
/* ----------------------------------------- */
/*  Reusable Type Definitions                */
/* ----------------------------------------- */

/**
 * A single point, expressed as an object {x, y}
 * @typedef {PIXI.Point|{x: number, y: number}} Point
 */

/**
 * A single point, expressed as an array [x,y]
 * @typedef {number[]} PointArray
 */

/**
 * A Ray intersection point
 * @typedef {{x: number, y: number, t0: number, t1: number}|null} RayIntersection
 * @property [wall] Wall
 */

/**
 * A standard rectangle interface.
 * @typedef {PIXI.Rectangle|{x: number, y: number, width: number, height: number}} Rectangle
 */
	/* ----------------------------------------- */
/*  Database Workflows                       */
/* ----------------------------------------- */

/**
 * The expected structure for a Data record
 * @typedef {{string, any}} Data
 * @property [_id] string
 */

/**
 * An object of optional keys and values which configure the behavior of a function
 * @typedef {{string, any}} Options
 */

const vtt = "Foundry VTT";
const VTT = "Foundry Virtual Tabletop";
const WEBSITE_URL = "https://foundryvtt.com";
const ASCII = `_______________________________________________________________
 _____ ___  _   _ _   _ ____  ______   __ __     _______ _____ 
|  ___/ _ \\| | | | \\ | |  _ \\|  _ \\ \\ / / \\ \\   / |_   _|_   _|
| |_ | | | | | | |  \\| | | | | |_) \\ V /   \\ \\ / /  | |   | |  
|  _|| |_| | |_| | |\\  | |_| |  _ < | |     \\ V /   | |   | |  
|_|   \\___/ \\___/|_| \\_|____/|_| \\_\\|_|      \\_/    |_|   |_|  
===============================================================`;

/* -------------------------------------------- */

/**
 * Define the allowed ActiveEffect application modes
 * @type {{string, number}}
 */
const ACTIVE_EFFECT_MODES = {
	CUSTOM: 0,
	MULTIPLY: 1,
	ADD: 2,
	DOWNGRADE: 3,
	UPGRADE: 4,
	OVERRIDE: 5
};
	/* -------------------------------------------- */
	/**
 * Define the string name used for the base entity type when specific sub-types are not defined by the system
 * @type {string}
 */
const BASE_ENTITY_TYPE = "base";

/**
 * Valid Chat Message types
 * @type {Object}
 */
const CHAT_MESSAGE_TYPES = {
	OTHER: 0,
	OOC: 1,
	IC: 2,
	EMOTE: 3,
	WHISPER: 4,
	ROLL: 5
};

/**
 * The allowed Entity types which may exist within a Compendium pack
 * This is a subset of ENTITY_TYPES
 * @type {Array}
 */
const COMPENDIUM_ENTITY_TYPES = ["Actor", "Item", "Scene", "JournalEntry", "Macro", "RollTable", "Playlist"];

/**
 * Define the set of languages which have built-in support in the core software
 * @type {string[]}
 */
const CORE_SUPPORTED_LANGUAGES = ["en"];

/**
 * The default artwork used for Token images if none is provided
 * @type {String}
 */
const DEFAULT_TOKEN = 'icons/svg/mystery-man.svg';

/**
 * The default artwork used for Note placeables if none is provided
 * @type {String}
 */
const DEFAULT_NOTE_ICON = 'icons/svg/book.svg';

/**
 * The supported dice roll visibility modes
 * @type {Object}
 */
const DICE_ROLL_MODES = {
	PUBLIC: "roll",
	PRIVATE: "gmroll",
	BLIND: "blindroll",
	SELF: "selfroll"
};
	/* -------------------------------------------- */
	/**
 * The allowed Drawing types which may be saved
 * @type {Object}
 */
const DRAWING_TYPES = {
	RECTANGLE: "r",
	ELLIPSE: "e",
	TEXT: "t",
	POLYGON: "p",
	FREEHAND: "f"
};

/**
 * The allowed fill types which a Drawing object may display
 * NONE: The drawing is not filled
 * SOLID: The drawing is filled with a solid color
 * PATTERN: The drawing is filled with a tiled image pattern
 * @type {Object}
 */
const DRAWING_FILL_TYPES = {
	NONE: 0,
	SOLID: 1,
	PATTERN: 2
};
	/**
 * The default configuration values used for Drawing objects
 * @type {Object}
 */
const DRAWING_DEFAULT_VALUES = {
	width: 0,
	height: 0,
	rotation: 0,
	z: 0,
	hidden: false,
	locked: false,
	fillType: DRAWING_FILL_TYPES.NONE,
	fillAlpha: 0.5,
	bezierFactor: 0.0,
	strokeAlpha: 1.0,
	strokeWidth: 8,
	fontSize: 48,
	textAlpha: 1.0,
	textColor: "#FFFFFF"
};

/* -------------------------------------------- */

/**
 * Define the allowed Entity class types
 * @type {Array}
 */
const ENTITY_TYPES = [
	"Actor",
	"ChatMessage",
	"Combat",
	"Item",
	"Folder",
	"JournalEntry",
	"Macro",
	"Playlist",
	"RollTable",
	"Scene",
	"User",
];

/**
 * Define the allowed Entity types which may be dynamically linked in chat
 * @type {Array}
 */
const ENTITY_LINK_TYPES = ["Actor", "Item", "Scene", "JournalEntry", "Macro", "RollTable"];

/**
 * Define the allowed permission levels for a non-user Entity.
 * Each level is assigned a value in ascending order. Higher levels grant more permissions.
 * @type {Object}
 */
const ENTITY_PERMISSIONS = {
	"NONE": 0,
	"LIMITED": 1,
	"OBSERVER": 2,
	"OWNER": 3
};

/**
 * EULA version number
 * @type {String}
 */
const EULA_VERSION = "0.6.1";

/**
 * Define the allowed Entity types which Folders may contain
 * @type {Array}
 */
const FOLDER_ENTITY_TYPES = ["Actor", "Item", "Scene", "JournalEntry", "RollTable"];

/**
 * The maximum allowed level of depth for Folder nesting
 * @type {Number}
 */
const FOLDER_MAX_DEPTH = 3;

/**
 * The minimum allowed grid size which is supported by the software
 * @type {Number}
 */
const GRID_MIN_SIZE = 50;

/**
 * The allowed Grid types which are supported by the software
 * @type {Object}
 */
const GRID_TYPES = {
	"GRIDLESS": 0,
	"SQUARE": 1,
	"HEXODDR": 2,
	"HEXEVENR": 3,
	"HEXODDQ": 4,
	"HEXEVENQ": 5
};
	/**
 * Enumerate the source types which can be used for an AmbientLight placeable object
 * @type {{UNIVERSAL: string, LOCAL: string, GLOBAL: string}}
 */
const SOURCE_TYPES = {
	LOCAL: "l",
	GLOBAL: "g",
	UNIVERSAL: "u"
};
	/**
 * An Array of valid MacroAction scope values
 * @type {Array.<string>}
 */
const MACRO_SCOPES = ["global", "actors", "actor"];
	/**
 * The allowed playback modes for an audio Playlist
 * DISABLED: The playlist does not play on its own, only individual Sound tracks played as a soundboard
 * SEQUENTIAL: The playlist plays sounds one at a time in sequence
 * SHUFFLE: The playlist plays sounds one at a time in randomized order
 * SIMULTANEOUS: The playlist plays all contained sounds at the same time
 * @type {Object}
 */
const PLAYLIST_MODES = {
	"DISABLED": -1,
	"SEQUENTIAL": 0,
	"SHUFFLE": 1,
	"SIMULTANEOUS": 2
};
	/**
 * Encode the reasons why a package may be available or unavailable for use
 * @type {Object}
 */
const PACKAGE_AVAILABILITY_CODES = {
	"UNKNOWN": -1,
	"AVAILABLE": 0,
	"REQUIRES_UPDATE": 1,
	"REQUIRES_SYSTEM": 2,
	"REQUIRES_DEPENDENCY": 3,
	"REQUIRES_CORE": 4
};

/**
 * A safe password string which can be displayed
 */
const PASSWORD_SAFE_STRING = "•".repeat(16);
	/**
 * The allowed software update channels
 * @type {Object}
 */
const SOFTWARE_UPDATE_CHANNELS = {
	"alpha": "SETUP.UpdateAlpha",
	"beta": "SETUP.UpdateBeta",
	"release": "SETUP.UpdateRelease"
};
	/**
 * The default sorting density for manually ordering child objects within a parent
 * @type {Number}
 */
const SORT_INTEGER_DENSITY = 100000;

/**
 * The allowed types of a TableResult document
 * @type {Object}
 */
const TABLE_RESULT_TYPES = {
	TEXT: 0,
	ENTITY: 1,
	COMPENDIUM: 2
};

/**
 * Define the valid anchor locations for a Tooltip displayed on a Placeable Object
 * @type {Object}
 */
const TEXT_ANCHOR_POINTS = {
	CENTER: 0,
	BOTTOM: 1,
	TOP: 2,
	LEFT: 3,
	RIGHT: 4
};

/**
 * Describe the various thresholds of token control upon which to show certain pieces of information
 * NONE - no information is displayed
 * CONTROL - displayed when the token is controlled
 * OWNER HOVER - displayed when hovered by a GM or a user who owns the actor
 * HOVER - displayed when hovered by any user
 * OWNER - always displayed for a GM or for a user who owns the actor
 * ALWAYS - always displayed for everyone
 * @type {Object}
 */
const TOKEN_DISPLAY_MODES = {
	"NONE": 0,
	"CONTROL": 10,
	"OWNER_HOVER": 20,
	"HOVER": 30,
	"OWNER": 40,
	"ALWAYS": 50
};

/**
 * The allowed Token disposition types
 * HOSTILE - Displayed as an enemy with a red border
 * NEUTRAL - Displayed as neutral with a yellow border
 * FRIENDLY - Displayed as an ally with a cyan border
 */
const TOKEN_DISPOSITIONS = {
	"HOSTILE": -1,
	"NEUTRAL": 0,
	"FRIENDLY": 1
};

/**
 * Define the allowed User permission levels.
 * Each level is assigned a value in ascending order. Higher levels grant more permissions.
 * @type {Object}
 */
const USER_ROLES = {
	"NONE": 0,
	"PLAYER": 1,
	"TRUSTED": 2,
	"ASSISTANT": 3,
	"GAMEMASTER": 4
};

/**
 * Invert the User Role mapping to recover role names from a role integer
 * @type {Object}
 */
const USER_ROLE_NAMES = Object.entries(USER_ROLES).reduce((obj, r) => {
	obj[r[1]] = r[0];
	return obj;
}, {});
	/**
 * A list of MIME types which are treated as uploaded "media", which are allowed to overwrite existing files.
 * Any non-media MIME type is not allowed to replace an existing file.
 * @type {string[]}
 */
const MEDIA_MIME_TYPES = [
	"image/apng", "image/bmp", "image/gif", "image/jpeg", "image/png", "image/svg+xml", "image/tiff", "image/webp",
	"audio/wave", "audio/wav", "audio/webm", "audio/ogg", "audio/midi", "audio/mpeg", "audio/opus", "audio/aac",
	"video/mpeg", "video/mp4", "video/ogg",
	"application/json", "application/ogg", "application/pdf",
];
	/**
 * Define the named actions which users or user roles can be permitted to do.
 * Each key of this Object denotes an action for which permission may be granted (true) or withheld (false)
 * @type {Object}
 */
const USER_PERMISSIONS = {
	"BROADCAST_AUDIO": {
		label: "PERMISSION.BroadcastAudio",
	hint: "PERMISSION.BroadcastAudioHint",
	disableGM: true,
		defaultRole: USER_ROLES.TRUSTED
	},
	"BROADCAST_VIDEO": {
		label: "PERMISSION.BroadcastVideo",
	hint: "PERMISSION.BroadcastVideoHint",
	disableGM: true,
		defaultRole: USER_ROLES.TRUSTED
	},
	"ACTOR_CREATE": {
		label: "PERMISSION.ActorCreate",
	hint: "PERMISSION.ActorCreateHint",
	disableGM: false,
		defaultRole: USER_ROLES.ASSISTANT
	},
	"DRAWING_CREATE": {
		label: "PERMISSION.DrawingCreate",
	hint: "PERMISSION.DrawingCreateHint",
	disableGM: false,
		defaultRole: USER_ROLES.TRUSTED
	},
	"ITEM_CREATE": {
		label: "PERMISSION.ItemCreate",
	hint: "PERMISSION.ItemCreateHint",
	disableGM: false,
		defaultRole: USER_ROLES.ASSISTANT
	},
	"FILES_BROWSE": {
		label: "PERMISSION.FilesBrowse",
	hint: "PERMISSION.FilesBrowseHint",
	disableGM: false,
		defaultRole: USER_ROLES.TRUSTED
	},
	"FILES_UPLOAD": {
		label: "PERMISSION.FilesUpload",
	hint: "PERMISSION.FilesUploadHint",
	disableGM: false,
		defaultRole: USER_ROLES.ASSISTANT
	},
	"JOURNAL_CREATE": {
			label: "PERMISSION.JournalCreate",
			hint: "PERMISSION.JournalCreateHint",
			disableGM: false,
			defaultRole: USER_ROLES.TRUSTED
	},
	"MACRO_SCRIPT": {
		label: "PERMISSION.MacroScript",
	hint: "PERMISSION.MacroScriptHint",
	disableGM: false,
		defaultRole: USER_ROLES.PLAYER
	},
	"MESSAGE_WHISPER": {
		label: "PERMISSION.MessageWhisper",
	hint: "PERMISSION.MessageWhisperHint",
	disableGM: false,
		defaultRole: USER_ROLES.PLAYER
	},
	"SETTINGS_MODIFY": {
		label: "PERMISSION.SettingsModify",
	hint: "PERMISSION.SettingsModifyHint",
	disableGM: false,
		defaultRole: USER_ROLES.ASSISTANT
	},
	"SHOW_CURSOR": {
		label: "PERMISSION.ShowCursor",
	hint: "PERMISSION.ShowCursorHint",
	disableGM: true,
		defaultRole: USER_ROLES.PLAYER
	},
	"SHOW_RULER": {
		label: "PERMISSION.ShowRuler",
		hint: "PERMISSION.ShowRulerHint",
		disableGM: true,
		defaultRole: USER_ROLES.PLAYER
	},
	"TEMPLATE_CREATE": {
		label: "PERMISSION.TemplateCreate",
	hint: "PERMISSION.TemplateCreateHint",
	disableGM: false,
		defaultRole: USER_ROLES.PLAYER
	},
	"TOKEN_CREATE": {
		label: "PERMISSION.TokenCreate",
	hint: "PERMISSION.TokenCreateHint",
	disableGM: false,
		defaultRole: USER_ROLES.ASSISTANT
	},
	"TOKEN_CONFIGURE": {
		label: "PERMISSION.TokenConfigure",
	hint: "PERMISSION.TokenConfigureHint",
	disableGM: false,
		defaultRole: USER_ROLES.TRUSTED
	},
	"WALL_DOORS": {
		label: "PERMISSION.WallDoors",
	hint: "PERMISSION.WallDoorsHint",
	disableGM: false,
		defaultRole: USER_ROLES.PLAYER
	}
};
	/**
 * The allowed directions of effect that a Wall can have
 * BOTH: The wall collides from both directions
 * LEFT: The wall collides only when a ray strikes its left side
 * RIGHT: The wall collides only when a ray strikes its right side
 * @type {Object}
 */
const WALL_DIRECTIONS = {
	BOTH: 0,
	LEFT: 1,
	RIGHT: 2
};

/**
 * The allowed door types which a Wall may contain
 * NONE: The wall does not contain a door
 * DOOR: The wall contains a regular door
 * SECRET: The wall contains a secret door
 * @type {Object}
 */
const WALL_DOOR_TYPES = {
	NONE: 0,
	DOOR: 1,
	SECRET: 2
};

/**
 * The allowed door states which may describe a Wall that contains a door
 * CLOSED: The door is closed
 * OPEN: The door is open
 * LOCKED: The door is closed and locked
 * @type {Object}
 */
const WALL_DOOR_STATES = {
	CLOSED: 0,
	OPEN: 1,
	LOCKED: 2
};

/**
 * The types of movement collision which a Wall may impose
 * NONE: Movement does not collide with this wall
 * NORMAL: Movement collides with this wall
 * @type {Object}
 */
const WALL_MOVEMENT_TYPES = {
	NONE: 0,
	NORMAL: 1
};

/**
 * The types of sensory collision which a Wall may impose
 * NONE: Senses do not collide with this wall
 * NORMAL: Senses collide with this wall
 * LIMITED: Senses collide with the second intersection, bypassing the first
 * @type {Object}
 */
const WALL_SENSE_TYPES = {
	NONE: 0,
	NORMAL: 1,
	LIMITED: 2
};

/**
 * The allowed set of HTML template extensions
 * @type {string[]}
 */
const HTML_FILE_EXTENSIONS = ["html", "hbs"];

/**
 * The supported file extensions for image-type files
 * @type {Array}
 */
const IMAGE_FILE_EXTENSIONS = ["jpg", "jpeg", "png", "svg", "webp"];

/**
 * The supported file extensions for video-type files
 * @type {Array}
 */
const VIDEO_FILE_EXTENSIONS = ["mp4", "ogg", "webm", "m4v"];

/**
 * The supported file extensions for audio-type files
 * @type {Array}
 */
const AUDIO_FILE_EXTENSIONS = ["flac", "mp3", "ogg", "wav", "webm"];

// Module Export
const CONST = {
	ASCII, vtt, VTT, WEBSITE_URL,
	ACTIVE_EFFECT_MODES, BASE_ENTITY_TYPE, CHAT_MESSAGE_TYPES, COMPENDIUM_ENTITY_TYPES, CORE_SUPPORTED_LANGUAGES,
	DEFAULT_TOKEN, DEFAULT_NOTE_ICON, DICE_ROLL_MODES,
	DRAWING_DEFAULT_VALUES, DRAWING_TYPES, DRAWING_FILL_TYPES,
	ENTITY_PERMISSIONS, ENTITY_TYPES, ENTITY_LINK_TYPES, EULA_VERSION,
	FOLDER_ENTITY_TYPES, FOLDER_MAX_DEPTH,
	GRID_MIN_SIZE, GRID_TYPES, MACRO_SCOPES, PLAYLIST_MODES, PACKAGE_AVAILABILITY_CODES, PASSWORD_SAFE_STRING,
	SOURCE_TYPES, MEDIA_MIME_TYPES, SOFTWARE_UPDATE_CHANNELS, SORT_INTEGER_DENSITY,
	TABLE_RESULT_TYPES, TEXT_ANCHOR_POINTS, TOKEN_DISPLAY_MODES, TOKEN_DISPOSITIONS,
	USER_PERMISSIONS, USER_ROLES, USER_ROLE_NAMES,
	WALL_SENSE_TYPES, WALL_MOVEMENT_TYPES, WALL_DOOR_STATES, WALL_DIRECTIONS, WALL_DOOR_TYPES,
	HTML_FILE_EXTENSIONS, IMAGE_FILE_EXTENSIONS, VIDEO_FILE_EXTENSIONS, AUDIO_FILE_EXTENSIONS
};
try {
	module.exports = CONST;
} catch(err) {
	window.CONST = CONST;
}
	/* -------------------------------------------- */
/*  Math Functions                              */
/* -------------------------------------------- */

/**
 * Bound a number between some minimum and maximum value, inclusively
 * @param {number} num    The current value
 * @param {number} min    The minimum allowed value
 * @param {number} max    The maximum allowed value
 * @return {number}       The clamped number
 */
function clampNumber(num, min, max) {
	return Math.min(max, Math.max(num, min));
}

/**
 * Round a floating point number to a certain number of decimal places
 * @param {number} number  A floating point number
 * @param {number} places  An integer number of decimal places
 */
function roundDecimals(number, places) {
	places = Math.min(Math.trunc(places), 0);
	let scl = Math.pow(10, places);
	return Math.round(number * scl) / scl;
}

/**
 * Transform an angle in radians to a number in degrees
 * @param {number} angle    An angle in radians
 * @return {number}         An angle in degrees
 */
function toDegrees(angle) {
	return angle * (180 / Math.PI);
}

/**
 * Transform an angle in degrees to be bounded within the domain [0, 360]
 * @param {number} degrees  An angle in degrees
 * @return {number}         The same angle on the range [0, 360]
 */
function normalizeDegrees(degrees) {
	let nd = (degrees + 360) % 360;
	return (nd > 180) ? nd - 360 : nd;
}

/**
 * Transform an angle in degrees to an angle in radians
 * @param {number} angle    An angle in degrees
 * @return {number}         An angle in radians
 */
function toRadians(angle) {
	return (angle % 360) * (Math.PI / 180);
}

/**
 * Transform an angle in radians to be bounded within the domain [-PI, PI]
 * @param {number} radians  An angle in degrees
 * @return {number}         The same angle on the range [-PI, PI]
 */
function normalizeRadians(radians) {
	let pi2 = 2 * Math.PI;
	let nr = (radians + pi2) % pi2;
	return (nr > Math.PI) ? nr - pi2 : nr;
}

// Assign helper functions to the Math environment
Object.assign(Math, {
	clamped: clampNumber,
	decimals: roundDecimals,
	toDegrees,
	normalizeDegrees,
	toRadians,
	normalizeRadians
});
	/* -------------------------------------------- */
/* String Methods                               */
/* -------------------------------------------- */
	String.prototype.capitalize = function() {
	if ( !this.length ) return this;
	return this.charAt(0).toUpperCase() + this.slice(1);
};
	String.prototype.titleCase = function() {
	if (!this.length) return this;
	return this.toLowerCase().split(' ').map(function (word) {
		return word.replace(word[0], word[0].toUpperCase());
	}).join(' ');
};
	/**
 * Strip any <script> tags which were included within a provided string
 * @return {String|*}
 */
String.prototype.stripScripts = function() {
	let el = document.createElement("div");
	el.innerHTML = this;
	for ( let s of el.getElementsByTagName("script") ) {
		s.parentNode.removeChild(s);
	}
	return el.innerHTML;
};
	/* -------------------------------------------- */
	/**
 * Transform any string into a url-viable slug string
 * @param {string} replacement    The replacement character to separate terms, default is '-'
 * @param {boolean} strict        Replace all non-alphanumeric characters, or allow them? Default false
 * @return {string}               The cleaned slug string
 */
String.prototype.slugify = function({replacement='-', strict=false}={}) {
	 // Map characters to lower case ASCII
	const charMap = JSON.parse('{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","¢":"cent","£":"pound","¤":"currency","¥":"yen","©":"(c)","ª":"a","®":"(r)","º":"o","À":"A","Á":"A","Â":"A","Ã":"A","Ä":"A","Å":"A","Æ":"AE","Ç":"C","È":"E","É":"E","Ê":"E","Ë":"E","Ì":"I","Í":"I","Î":"I","Ï":"I","Ð":"D","Ñ":"N","Ò":"O","Ó":"O","Ô":"O","Õ":"O","Ö":"O","Ø":"O","Ù":"U","Ú":"U","Û":"U","Ü":"U","Ý":"Y","Þ":"TH","ß":"ss","à":"a","á":"a","â":"a","ã":"a","ä":"a","å":"a","æ":"ae","ç":"c","è":"e","é":"e","ê":"e","ë":"e","ì":"i","í":"i","î":"i","ï":"i","ð":"d","ñ":"n","ò":"o","ó":"o","ô":"o","õ":"o","ö":"o","ø":"o","ù":"u","ú":"u","û":"u","ü":"u","ý":"y","þ":"th","ÿ":"y","Ā":"A","ā":"a","Ă":"A","ă":"a","Ą":"A","ą":"a","Ć":"C","ć":"c","Č":"C","č":"c","Ď":"D","ď":"d","Đ":"DJ","đ":"dj","Ē":"E","ē":"e","Ė":"E","ė":"e","Ę":"e","ę":"e","Ě":"E","ě":"e","Ğ":"G","ğ":"g","Ģ":"G","ģ":"g","Ĩ":"I","ĩ":"i","Ī":"i","ī":"i","Į":"I","į":"i","İ":"I","ı":"i","Ķ":"k","ķ":"k","Ļ":"L","ļ":"l","Ľ":"L","ľ":"l","Ł":"L","ł":"l","Ń":"N","ń":"n","Ņ":"N","ņ":"n","Ň":"N","ň":"n","Ő":"O","ő":"o","Œ":"OE","œ":"oe","Ŕ":"R","ŕ":"r","Ř":"R","ř":"r","Ś":"S","ś":"s","Ş":"S","ş":"s","Š":"S","š":"s","Ţ":"T","ţ":"t","Ť":"T","ť":"t","Ũ":"U","ũ":"u","Ū":"u","ū":"u","Ů":"U","ů":"u","Ű":"U","ű":"u","Ų":"U","ų":"u","Ŵ":"W","ŵ":"w","Ŷ":"Y","ŷ":"y","Ÿ":"Y","Ź":"Z","ź":"z","Ż":"Z","ż":"z","Ž":"Z","ž":"z","ƒ":"f","Ơ":"O","ơ":"o","Ư":"U","ư":"u","ǈ":"LJ","ǉ":"lj","ǋ":"NJ","ǌ":"nj","Ș":"S","ș":"s","Ț":"T","ț":"t","˚":"o","Ά":"A","Έ":"E","Ή":"H","Ί":"I","Ό":"O","Ύ":"Y","Ώ":"W","ΐ":"i","Α":"A","Β":"B","Γ":"G","Δ":"D","Ε":"E","Ζ":"Z","Η":"H","Θ":"8","Ι":"I","Κ":"K","Λ":"L","Μ":"M","Ν":"N","Ξ":"3","Ο":"O","Π":"P","Ρ":"R","Σ":"S","Τ":"T","Υ":"Y","Φ":"F","Χ":"X","Ψ":"PS","Ω":"W","Ϊ":"I","Ϋ":"Y","ά":"a","έ":"e","ή":"h","ί":"i","ΰ":"y","α":"a","β":"b","γ":"g","δ":"d","ε":"e","ζ":"z","η":"h","θ":"8","ι":"i","κ":"k","λ":"l","μ":"m","ν":"n","ξ":"3","ο":"o","π":"p","ρ":"r","ς":"s","σ":"s","τ":"t","υ":"y","φ":"f","χ":"x","ψ":"ps","ω":"w","ϊ":"i","ϋ":"y","ό":"o","ύ":"y","ώ":"w","Ё":"Yo","Ђ":"DJ","Є":"Ye","І":"I","Ї":"Yi","Ј":"J","Љ":"LJ","Њ":"NJ","Ћ":"C","Џ":"DZ","А":"A","Б":"B","В":"V","Г":"G","Д":"D","Е":"E","Ж":"Zh","З":"Z","И":"I","Й":"J","К":"K","Л":"L","М":"M","Н":"N","О":"O","П":"P","Р":"R","С":"S","Т":"T","У":"U","Ф":"F","Х":"H","Ц":"C","Ч":"Ch","Ш":"Sh","Щ":"Sh","Ъ":"U","Ы":"Y","Ь":"","Э":"E","Ю":"Yu","Я":"Ya","а":"a","б":"b","в":"v","г":"g","д":"d","е":"e","ж":"zh","з":"z","и":"i","й":"j","к":"k","л":"l","м":"m","н":"n","о":"o","п":"p","р":"r","с":"s","т":"t","у":"u","ф":"f","х":"h","ц":"c","ч":"ch","ш":"sh","щ":"sh","ъ":"u","ы":"y","ь":"","э":"e","ю":"yu","я":"ya","ё":"yo","ђ":"dj","є":"ye","і":"i","ї":"yi","ј":"j","љ":"lj","њ":"nj","ћ":"c","ѝ":"u","џ":"dz","Ґ":"G","ґ":"g","Ғ":"GH","ғ":"gh","Қ":"KH","қ":"kh","Ң":"NG","ң":"ng","Ү":"UE","ү":"ue","Ұ":"U","ұ":"u","Һ":"H","һ":"h","Ә":"AE","ә":"ae","Ө":"OE","ө":"oe","฿":"baht","ა":"a","ბ":"b","გ":"g","დ":"d","ე":"e","ვ":"v","ზ":"z","თ":"t","ი":"i","კ":"k","ლ":"l","მ":"m","ნ":"n","ო":"o","პ":"p","ჟ":"zh","რ":"r","ს":"s","ტ":"t","უ":"u","ფ":"f","ქ":"k","ღ":"gh","ყ":"q","შ":"sh","ჩ":"ch","ც":"ts","ძ":"dz","წ":"ts","ჭ":"ch","ხ":"kh","ჯ":"j","ჰ":"h","Ẁ":"W","ẁ":"w","Ẃ":"W","ẃ":"w","Ẅ":"W","ẅ":"w","ẞ":"SS","Ạ":"A","ạ":"a","Ả":"A","ả":"a","Ấ":"A","ấ":"a","Ầ":"A","ầ":"a","Ẩ":"A","ẩ":"a","Ẫ":"A","ẫ":"a","Ậ":"A","ậ":"a","Ắ":"A","ắ":"a","Ằ":"A","ằ":"a","Ẳ":"A","ẳ":"a","Ẵ":"A","ẵ":"a","Ặ":"A","ặ":"a","Ẹ":"E","ẹ":"e","Ẻ":"E","ẻ":"e","Ẽ":"E","ẽ":"e","Ế":"E","ế":"e","Ề":"E","ề":"e","Ể":"E","ể":"e","Ễ":"E","ễ":"e","Ệ":"E","ệ":"e","Ỉ":"I","ỉ":"i","Ị":"I","ị":"i","Ọ":"O","ọ":"o","Ỏ":"O","ỏ":"o","Ố":"O","ố":"o","Ồ":"O","ồ":"o","Ổ":"O","ổ":"o","Ỗ":"O","ỗ":"o","Ộ":"O","ộ":"o","Ớ":"O","ớ":"o","Ờ":"O","ờ":"o","Ở":"O","ở":"o","Ỡ":"O","ỡ":"o","Ợ":"O","ợ":"o","Ụ":"U","ụ":"u","Ủ":"U","ủ":"u","Ứ":"U","ứ":"u","Ừ":"U","ừ":"u","Ử":"U","ử":"u","Ữ":"U","ữ":"u","Ự":"U","ự":"u","Ỳ":"Y","ỳ":"y","Ỵ":"Y","ỵ":"y","Ỷ":"Y","ỷ":"y","Ỹ":"Y","ỹ":"y","‘":"\'","’":"\'","“":"\\\"","”":"\\\"","†":"+","•":"*","…":"...","₠":"ecu","₢":"cruzeiro","₣":"french franc","₤":"lira","₥":"mill","₦":"naira","₧":"peseta","₨":"rupee","₩":"won","₪":"new shequel","₫":"dong","€":"euro","₭":"kip","₮":"tugrik","₯":"drachma","₰":"penny","₱":"peso","₲":"guarani","₳":"austral","₴":"hryvnia","₵":"cedi","₸":"kazakhstani tenge","₹":"indian rupee","₽":"russian ruble","₿":"bitcoin","℠":"sm","™":"tm","∂":"d","∆":"delta","∑":"sum","∞":"infinity","♥":"love","元":"yuan","円":"yen","﷼":"rial"}');
	let slug = this.split("").reduce((result, char) => {
		return result + (charMap[char] || char);
	}, "").trim().toLowerCase();
	 // Convert any spaces to the replacement character and de-dupe
	slug = slug.replace(new RegExp('[\\s' + replacement + ']+', 'g'), replacement);
	 // If we're being strict, replace anything that is not alphanumeric
	if (strict) {
		slug = slug.replace(new RegExp('[^a-zA-Z0-9' + replacement + ']', 'g'), '');
	}
	return slug;
};
	/* -------------------------------------------- */
/* Number Methods                               */
/* -------------------------------------------- */
	Number.prototype.ordinalString = function() {
	let s=["th","st","nd","rd"],
		v=this%100;
	return this+(s[(v-20)%10]||s[v]||s[0]);
};
	Number.prototype.paddedString = function(digits) {
	let s = "000000000" + this;
	return s.substr(s.length-digits);
};
	Number.prototype.signedString = function() {
	return (( this < 0 ) ? "" : "+") + this;
};
	Number.prototype.between = function(a, b, inclusive=true) {
	let min = Math.min(a, b);
	let max = Math.max(a, b);
	return inclusive ? (this >= min) && (this <= max) : (this > min) && (this < max);
};

/**
 * Round a number to the nearest number which is a multiple of a given interval
 * @param {number} interval     The interval to round the number to the nearest multiple of
 * @returns {number}            The rounded number
 *
 * @example
 * let n = 17.18;
 * n.toNearest(5); // 15
 * n.toNearest(10); // 20
 * n.toNearest(0.25); // 17.25
 */
Number.prototype.toNearest = function(interval=1) {
	const q = 1 / interval;
	return Math.round(this  * q) / q;
};

/**
 * A faster numeric between check which avoids type coercion to the Number object
 * Since this avoids coercion, if non-numbers are passed in unpredictable results will occur. Use with caution.
 * @param {number} num
 * @param {number} a
 * @param {number} b
 * @param {boolean} inclusive
 * @return {boolean}
 */
Number.between = function(num, a, b, inclusive=true) {
	let min = Math.min(a, b);
	let max = Math.max(a, b);
	return inclusive ? (num >= min) && (num <= max) : (num > min) && (num < max);
};
	/**
 * Test whether a value is numeric
 * This is the highest performing algorithm currently available
 * https://jsperf.com/isnan-vs-typeof/5
 * @param {*} n       A value to test
 * @return {Boolean}  Is it a number?
 */
Number.isNumeric = function(n) {
	if ( n instanceof Array ) return false;
	else if ( [null, ""].includes(n) ) return false;
	return +n === +n;
};
	/* -------------------------------------------- */
/* Array Methods                                */
/* -------------------------------------------- */
	Array.fromRange = function(n) {
	return Array.from(new Array(parseInt(n)).keys());
};
	Array.prototype.deepFlatten = function() {
	return this.reduce((acc, val) => Array.isArray(val) ? acc.concat(val.deepFlatten()) : acc.concat(val), []);
};
	/**
 * Test equality of the values of this array against the values of some other Array
 * @param {Array} other
 */
Array.prototype.equals = function(other) {
	if ( !(other instanceof Array) || (other.length !== this.length) ) return false;
	return this.every((v, i) => other[i] === v);
};
	/**
 * Partition an original array into two children array based on a logical test
 * Elements which test as false go into the first result while elements testing as true appear in the second
 * @param rule {Function}
 * @return {Array}    An Array of length two whose elements are the partitioned pieces of the original
 */
Array.prototype.partition = function(rule) {
	return this.reduce((acc, val) => {
		let test = rule(val);
		acc[Number(test)].push(val);
		return acc;
	}, [[], []]);
};

/**
 * Join an Array using a string separator, first filtering out any parts which return a false-y value
 * @param {string} sep    The separator string
 * @return {string}       The joined string, filtered of any false values
 */
Array.prototype.filterJoin = function(sep) {
	return this.filter(p => !!p).join(sep);
};
	/**
 * Find an element within the Array and remove it from the array
 * @param {Function} find   A function to use as input to findIndex
 * @param {any} [replace]   A replacement for the spliced element
 * @return {any|null}       The replacement element, the removed element, or null if no element was found.
 */
Array.prototype.findSplice = function(find, replace) {
	const idx = this.findIndex(find);
	if ( idx === -1 ) return null;
	if ( replace !== undefined ) {
		this.splice(idx, 1, replace);
		return replace;
	} else {
		const item = this[idx];
		this.splice(idx, 1);
		return item;
	}
};

/* -------------------------------------------- */
/* Date Methods                                 */
/* -------------------------------------------- */

/**
 * Test whether a Date instance is valid.
 * A valid date returns a number for its timestamp, and NaN otherwise.
 * NaN is never equal to itself.
 * @returns {boolean}
 */
Date.prototype.isValid = function() {
	return this.getTime() === this.getTime();
}

/**
 * Return a standard YYYY-MM-DD string for the Date instance.
 * @returns {string}    The date in YYYY-MM-DD format
 */
Date.prototype.toDateInputString = function() {
	const yyyy = this.getFullYear();
	const mm = (this.getMonth() + 1).paddedString(2);
	const dd = this.getDate().paddedString(2);
	return `${yyyy}-${mm}-${dd}`;
}

/**
 * Return a standard H:M:S.Z string for the Date instance.
 * @returns {string}    The time in H:M:S format
 */
Date.prototype.toTimeInputString = function() {
	return this.toTimeString().split(" ")[0];
}

/* -------------------------------------------- */
/* Object Methods                               */
/* -------------------------------------------- */
	/**
 * Obtain references to the parent classes of a certain class.
 * @param {Function} cls      An ES6 Class definition
 * @return {Function[]}       An array of parent Classes which the provided class extends
 */
function getParentClasses(cls) {
	if ( typeof cls !== "function" ) {
		throw new Error("The provided class is not a type of Function");
	}
	const parents = [];
	while ( !!cls.name ) {
		cls = Object.getPrototypeOf(cls);
		if ( cls.name ) parents.push(cls);
	}
	return parents;
}
	/* -------------------------------------------- */
	/**
 * A cheap data duplication trick, surprisingly relatively performant
 * @param {Object} original   Some sort of data
 */
function duplicate(original) {
	return JSON.parse(JSON.stringify(original));
}

/* -------------------------------------------- */

/**
 * Learn the named type of a token - extending the functionality of typeof to recognize some core Object types
 * @param {*} token     Some passed token
 * @return {string}     The named type of the token
 */
function getType(token) {
	const tof = typeof token;
	if ( tof === "object" ) {
		if ( token === null ) return "null";
		let cn = token.constructor.name;
		if ( ["String", "Number", "Boolean", "Array", "Set"].includes(cn)) return cn;
		else if ( /^HTML/.test(cn) ) return "HTMLElement";
		else return "Object";
	}
	return tof;
}

/* -------------------------------------------- */
	/**
 * Filter the contents of some source object using the structure of a template object.
 * Only keys which exist in the template are preserved in the source object.
 *
 * @param {Object} source           An object which contains the data you wish to filter
 * @param {Object} template         An object which contains the structure you wish to preserve
 * @param {boolean} keepSpecial     Whether to keep special tokens like deletion keys
 * @param {boolean} templateValues  Instead of keeping values from the source, instead draw values from the template
 *
 * @example
 * const source = {foo: {number: 1, name: "Tim", topping: "olives"}, bar: "baz"};
 * const template = {foo: {number: 0, name: "Mit", style: "bold"}, other: 72};
 * filterObject(source, template); // {foo: {number: 1, name: "Tim"}};
 * filterObject(source, template, {templateValues: true}); // {foo: {number: 0, name: "Mit"}};
 */
function filterObject(source, template, {keepSpecial=false, templateValues=false}={}) {
	 // Validate input
	const ts = getType(source);
	const tt = getType(template);
	if ( (ts !== "Object") || (tt !== "Object")) throw new Error("One of source or template are not Objects!");
	 // Define recursive filtering function
	const _filter = function(s, t, filtered) {
		for ( let [k, v] of Object.entries(s) ) {
			let has = t.hasOwnProperty(k);
			let x = t[k];
			 // Case 1 - inner object
			if ( has && (getType(v) === "Object") && (getType(x) === "Object") ) {
				filtered[k] = _filter(v, x, {});
			}
			 // Case 2 - inner key
			else if ( has ) {
				filtered[k] = templateValues ? x : v;
			}
			 // Case 3 - special key
			else if ( keepSpecial && k.startsWith("-=") ) {
				filtered[k] = v;
			}
		}
		return filtered;
	};
	 // Begin filtering at the outer-most layer
	return _filter(source, template, {});
}
	/* -------------------------------------------- */
	/**
 * Flatten a possibly multi-dimensional object to a one-dimensional one by converting all nested keys to dot notation
 * @param {Object} obj  The object to flatten
 * @param {Number} _d   Recursion depth, to prevent overflow
 * @return {Object}     A flattened object
 */
function flattenObject(obj, _d=0) {
	const flat = {};
	if ( _d > 10 ) throw new Error("Maximum depth exceeded");
	for ( let [k, v] of Object.entries(obj) ) {
		let t = getType(v);
		 // Inner objects
		if ( t === "Object" ) {
			if ( isObjectEmpty(v) ) flat[k] = v;
			let inner = flattenObject(v, _d+1);
			for ( let [ik, iv] of Object.entries(inner) ) {
				flat[`${k}.${ik}`] = iv;
			}
		}
		 // Inner values
		else flat[k] = v;
	}
	return flat;
}
	/* -------------------------------------------- */
	/**
 * Expand a flattened object to be a standard multi-dimensional nested Object by converting all dot-notation keys to
 * inner objects.
 *
 * @param {Object} obj  The object to expand
 * @param {Number} _d   Recursion depth, to prevent overflow
 * @return {Object}     An expanded object
 */
function expandObject(obj, _d=0) {
	const expanded = {};
	if ( _d > 10 ) throw new Error("Maximum depth exceeded");
	for ( let [k, v] of Object.entries(obj) ) {
		if ( v instanceof Object && !Array.isArray(v) ) v = expandObject(v, _d+1);
		setProperty(expanded, k, v);
	}
	return expanded;
}
	/* -------------------------------------------- */

/**
 * A simple function to test whether or not an Object is empty
 * @param {Object} obj    The object to test
 * @return {Boolean}      Is the object empty?
 */
function isObjectEmpty(obj) {
	if ( getType(obj) !== "Object" ) throw new Error("The provided data is not an object!");
	return Object.keys(obj).length === 0;
}

/* -------------------------------------------- */

/**
 * Invert an object by assigning its values as keys and its keys as values.
 * @param {object} obj    The original object to invert
 * @returns {object}      The inverted object with keys and values swapped
 */
function invertObject(obj) {
	const inverted = {};
	for ( let [k, v] of Object.entries(obj) ) {
		if ( v in inverted ) throw new Error("The values of the provided object must be unique in order to invert it.");
		inverted[v] = k;
	}
	return inverted;
}

/* -------------------------------------------- */
	/**
 * Update a source object by replacing its keys and values with those from a target object.
 *
 * @param {Object} original     The initial object which should be updated with values from the target
 * @param {Object} other        A new object whose values should replace those in the source
 *
 * @param {boolean} [insertKeys]      Control whether to insert new top-level objects into the resulting structure
 *                                    which do not previously exist in the original object.
 * @param {boolean} [insertValues]    Control whether to insert new nested values into child objects in the resulting
 *                                    structure which did not previously exist in the original object.
 * @param {boolean} [overwrite]       Control whether to replace existing values in the source, or only merge values
 *                                    which do not already exist in the original object.
 * @param {boolean} [recursive]       Control whether to merge inner-objects recursively (if true), or whether to
 *                                    simply replace inner objects with a provided new value.
 * @param {boolean} [inplace]         Control whether to apply updates to the original object in-place (if true),
 *                                    otherwise the original object is duplicated and the copy is merged.
 * @param {boolean} [enforceTypes]    Control whether strict type checking requires that the value of a key in the
 *                                    other object must match the data type in the original data to be merged.
 * @param {number} [_d]               A privately used parameter to track recursion depth.
 *
 * @returns {Object}            The original source object including updated, inserted, or overwritten records.
 *
 * @example <caption>Control how new keys and values are added</caption>
 * mergeObject({k1: "v1"}, {k2: "v2"}, {insertKeys: false}); // {k1: "v1"}
 * mergeObject({k1: "v1"}, {k2: "v2"}, {insertKeys: true});  // {k1: "v1", k2: "v2"}
 * mergeObject({k1: {i1: "v1"}}, {k1: {i2: "v2"}}, {insertValues: false}); // {k1: {i1: "v1"}}
 * mergeObject({k1: {i1: "v1"}}, {k1: {i2: "v2"}}, {insertValues: true}); // {k1: {i1: "v1", i2: "v2"}}
 *
 * @example <caption>Control how existing data is overwritten</caption>
 * mergeObject({k1: "v1"}, {k1: "v2"}, {overwrite: true}); // {k1: "v2"}
 * mergeObject({k1: "v1"}, {k1: "v2"}, {overwrite: false}); // {k1: "v1"}
 *
 * @example <caption>Control whether merges are performed recursively</caption>
 * mergeObject({k1: {i1: "v1"}}, {k1: {i2: "v2"}}, {recursive: false}); // {k1: {i1: "v2"}}
 * mergeObject({k1: {i1: "v1"}}, {k1: {i2: "v2"}}, {recursive: true}); // {k1: {i1: "v1", i2: "v2"}}
 *
 * @example <caption>Deleting an existing object key</caption>
 * mergeObject({k1: "v1", k2: "v2"}, {"-=k1": null});   // {k2: "v2"}
 */
function mergeObject(original, other={}, {
		insertKeys=true,
		insertValues=true,
		overwrite=true,
		recursive=true,
		inplace=true,
		enforceTypes=false
	}={}, _d=0) {
	other = other || {};
	if (!(original instanceof Object) || !(other instanceof Object)) {
		throw new Error("One of original or other are not Objects!");
	}
	let depth = _d + 1;
	 // Maybe copy the original data at depth 0
	if ( !inplace && (_d === 0) ) original = duplicate(original);
	 // Enforce object expansion at depth 0
	if ( (_d === 0 ) && Object.keys(original).some(k => /\./.test(k)) ) original = expandObject(original);
	if ( (_d === 0 ) && Object.keys(other).some(k => /\./.test(k)) ) other = expandObject(other);
	 // Iterate over the other object
	for ( let [k, v] of Object.entries(other) ) {
		let tv = getType(v);
		 // Prepare to delete
		let toDelete = false;
		if ( k.startsWith("-=") ) {
			k = k.slice(2);
			toDelete = (v === null)
		}
		 // Get the existing object
		let x = original[k];
		let has = original.hasOwnProperty(k);
		let tx = getType(x);
		 // Ensure that inner objects exist
		if ( !has && (tv === "Object") ) {
			x = original[k] = {};
			has = true;
			tx = "Object";
		}
		 // Case 1 - Key exists
		if (has) {
			 // 1.1 - Recursively merge an inner object
			if ( (tv === "Object") && (tx === "Object") && recursive ) {
				mergeObject(x, v, {
					insertKeys: insertKeys,
					insertValues: insertValues,
					overwrite: overwrite,
					inplace: true,
					enforceTypes: enforceTypes
				}, depth);
			}
			 // 1.2 - Remove an existing key
			else if ( toDelete ) {
				delete original[k];
			}
			 // 1.3 - Overwrite existing value
			else if ( overwrite ) {
				if ( tx && (tv !== tx) && enforceTypes ) {
					throw new Error(`Mismatched data types encountered during object merge.`);
				}
				original[k] = v;
			}
			 // 1.4 - Insert new value
			else if ( (x === undefined) && insertValues ) {
				original[k] = v;
			}
		}
		 // Case 2 - Key does not exist
		else if ( !toDelete ) {
			let canInsert = (depth === 1 && insertKeys ) || ( depth > 1 && insertValues );
			if (canInsert) original[k] = v;
		}
	}
	 // Return the object for use
	return original;
}
	/* -------------------------------------------- */
	/**
 * Deeply difference an object against some other, returning the update keys and values
 * @param {object} original     An object comparing data against which to compare.
 * @param {object} other        An object containing potentially different data.
 * @param {boolean} [inner]     Only recognize differences in other for keys which also exist in original.
 * @return {object}             An object of the data in other which differs from that in original.
 */
function diffObject(original, other, {inner=false}={}) {
	function _difference(v0, v1) {
		let t0 = getType(v0);
		let t1 = getType(v1);
		if ( t0 !== t1 ) return [true, v1];
		if ( t0 === "Array" ) return [!v0.equals(v1), v1];
		if ( t0 === "Object" ) {
			if ( isObjectEmpty(v0) !== isObjectEmpty(v1) ) return [true, v1];
			let d = diffObject(v0, v1, {inner});
			return [!isObjectEmpty(d), d];
		}
		return [v0 !== v1, v1];
	}
	 // Recursively call the _difference function
	return Object.keys(other).reduce((obj, key) => {
		if ( inner && (original[key] === undefined) ) return obj;
		let [isDifferent, difference] = _difference(original[key], other[key]);
		if ( isDifferent ) obj[key] = difference;
		return obj;
	}, {});
}
	/* -------------------------------------------- */
	/**
 * A helper function which tests whether an object has a property or nested property given a string key.
 * The string key supports the notation a.b.c which would return true if object[a][b][c] exists
 * @param object {Object}   The object to traverse
 * @param key {String}      An object property with notation a.b.c
 *
 * @return {Boolean}        An indicator for whether the property exists
 */
function hasProperty(object, key) {
	if ( !key ) return false;
	let target = object;
	for ( let p of key.split('.') ) {
		target = target || {};
		if ( p in target ) target = target[p];
		else return false;
	}
	return true;
}
	/* -------------------------------------------- */
	/**
 * A helper function which searches through an object to retrieve a value by a string key.
 * The string key supports the notation a.b.c which would return object[a][b][c]
 * @param object {Object}   The object to traverse
 * @param key {String}      An object property with notation a.b.c
 *
 * @return {*}              The value of the found property
 */
function getProperty(object, key) {
	if ( !key ) return undefined;
	let target = object;
	for ( let p of key.split('.') ) {
		target = target || {};
		if ( p in target ) target = target[p];
		else return undefined;
	}
	return target;
}
	/* -------------------------------------------- */
	/**
 * A helper function which searches through an object to assign a value using a string key
 * This string key supports the notation a.b.c which would target object[a][b][c]
 *
 * @param object {Object}   The object to update
 * @param key {String}      The string key
 * @param value             The value to be assigned
 *
 * @return {Boolean}        A flag for whether or not the object was updated
 */
function setProperty(object, key, value) {
	let target = object;
	let changed = false;
	 // Convert the key to an object reference if it contains dot notation
	if ( key.indexOf('.') !== -1 ) {
		let parts = key.split('.');
		key = parts.pop();
		target = parts.reduce((o, i) => {
			if ( !o.hasOwnProperty(i) ) o[i] = {};
			return o[i];
		}, object);
	}
	 // Update the target
	if ( target[key] !== value ) {
		changed = true;
		target[key] = value;
	}
	 // Return changed status
	return changed;
}
	/* -------------------------------------------- */
/*  RegExp Helpers                              */
/* -------------------------------------------- */
	RegExp.escape= function(string) {
		return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
};
	/* -------------------------------------------- */
/*  URL Manipulation                            */
/* -------------------------------------------- */
	/**
 * Encode a url-like string by replacing any characters which need encoding
 * @param {string} path     A fully-qualified URL or url component (like a relative path)
 * @return {string}         An encoded URL string
 */
function encodeURL(path) {
	 // Determine whether the path is a well-formed URL
	let url = null;
	try {
		url = new URL(path);
	} catch(err) {}
	 // If URL, remove the initial protocol
	if ( url ) path = path.replace(url.protocol, "");
	 // Split and encode each URL part
	path = path.split("/").map(p => encodeURIComponent(p).replace(/\'/g, "%27")).join("/");
	 // Return the encoded URL
	return url ? url.protocol + path : path;
}
	/* -------------------------------------------- */
/*  Datetime Manipulation
/* -------------------------------------------- */
	/**
 * Express a timestamp as a relative string
 * @param timeStamp {Date}
 * @return {string}
 */
timeSince = function(timeStamp) {
	timeStamp = new Date(timeStamp);
	let now = new Date(),
			secondsPast = (now - timeStamp) / 1000,
			since = "";
	 // Format the time
	if (secondsPast < 60) {
		since = parseInt(secondsPast);
		if ( since <= 0 ) return "Now";
		else since = since + "s";
	}
	else if (secondsPast < 3600) since = parseInt(secondsPast/60) + 'm';
	else if (secondsPast <= 86400) since = parseInt(secondsPast/3600) + 'h';
	else {
		let hours = parseInt(secondsPast/3600),
				days = parseInt(hours/24);
		since = `${days}d ${hours % 24}h`;
	}
	 // Return the string
	return since + " ago";
};
	/**
 * Wrap a callback in a debounced timeout.
 * Delay execution of the callback function until the function has not been called for delay milliseconds
 * @param {Function} callback       A function to execute once the debounced threshold has been passed
 * @param {number} delay            An amount of time in milliseconds to delay
 * @return {Function}
 */
debounce = function(callback, delay) {
	let timeoutId;
	return function(...args) {
		clearTimeout(timeoutId);
		timeoutId = setTimeout(() => {
			callback.apply(this, args)
		}, delay);
	}
};
	/* -------------------------------------------- */
/*  Colors
/* -------------------------------------------- */

/**
 * Converts an RGB color value to HSV. Conversion formula adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes r, g, and b are contained in the set [0, 1] and returns h, s, and v in the set [0, 1].
 * @param {number} r       The red color value
 * @param {number} g       The green color value
 * @param {number} b       The blue color value
 * @return {number[]}      The HSV representation
 */
function rgbToHsv(r, g, b) {
	let max = Math.max(r, g, b), min = Math.min(r, g, b);
	let h, s, v = max;
	let d = max - min;
	s = max === 0 ? 0 : d / max;
	if (max === min) {
		h = 0; // achromatic
	} else {
		switch (max) {
			case r: h = (g - b) / d + (g < b ? 6 : 0); break;
			case g: h = (b - r) / d + 2; break;
			case b: h = (r - g) / d + 4; break;
		}
		h /= 6;
	}
	return [h, s, v];
}

/* -------------------------------------------- */

/**
 * Converts an HSV color value to RGB. Conversion formula adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes h, s, and v are contained in the set [0, 1] and returns r, g, and b in the set [0, 1].
 * @param {number} h    The hue
 * @param {number} s    The saturation
 * @param {number} v    The value
 * @return {number[]}   The RGB representation
 */
function hsvToRgb(h, s, v) {
	let r, g, b;
	let i = Math.floor(h * 6);
	let f = h * 6 - i;
	let p = v * (1 - s);
	let q = v * (1 - f * s);
	let t = v * (1 - (1 - f) * s);
	switch (i % 6) {
		case 0: r = v, g = t, b = p; break;
		case 1: r = q, g = v, b = p; break;
		case 2: r = p, g = v, b = t; break;
		case 3: r = p, g = q, b = v; break;
		case 4: r = t, g = p, b = v; break;
		case 5: r = v, g = p, b = q; break;
	}
	return [r, g, b];
}

/**
 * Converts a color as an [R, G, B] array of normalized floats to a hexadecimal number.
 * @param {Array.<Number>} rgb - Array of numbers where all values are normalized floats from 0.0 to 1.0.
 * @return {Number} Number in hexadecimal.
 */
function rgbToHex(rgb) {
	return (((rgb[0] * 255) << 16) + ((rgb[1] * 255) << 8) + (rgb[2] * 255 | 0));
}

/* ----------------------------------------- */

/**
 * Convert a hex color code to an RGB array
 * @param {number} hex    A hex color number
 * @return {Array}        An array of [r,g,b] colors normalized on the range of [0,1]
 */
function hexToRGB(hex) {
	return [
		((hex >> 16) & 0xFF) / 255,
		((hex >> 8) & 0xFF) / 255,
		(hex & 0xFF) / 255
	];
}

/* ----------------------------------------- */

/**
 * Convert a hex color code to an RGBA color string which can be used for CSS styling
 * @param {number} hex    A hex color number
 * @param {number} alpha  A level of transparency
 * @return {string}       An rgba style string
 */
function hexToRGBAString(hex, alpha=1.0) {
	const rgb = hexToRGB(hex).map(h => h * 255);
	rgb.push(alpha);
	return `rgba(${rgb.join(", ")})`;
}

/* ----------------------------------------- */

/**
 * Convert a string color to a hex integer
 * @param {String} color    The string color
 * @return {Number}         The hexidecimal color code
 */
function colorStringToHex(color) {
	if ( !color ) return null;
	color = color.startsWith("#") ? color.substr(1) : color;
	return parseInt(color, 16);
}
	/* -------------------------------------------- */
/*  Version Checking
/* -------------------------------------------- */

/**
 * Return whether or not a target version (v1) is more advanced than some other reference version (v0).
 * Supports either numeric or string version comparison with version parts separated by periods.
 * @param {number|string} v1    The target version
 * @param {number|string} v0    The reference version
 * @return {boolean}            Is v1 a more advanced version than v0?
 */
function isNewerVersion(v1, v0) {
	 // Handle numeric versions
	if ( (typeof v1 === "number") && (typeof v0 === "number") ) return v1 > v0;
	 // Handle string parts
	let v1Parts = String(v1).split(".");
	let v0Parts = String(v0).split(".");
	 // Iterate over version parts
	for ( let [i, p1] of v1Parts.entries() ) {
		let p0 = v0Parts[i];
		 // If the prior version doesn't have a part, v1 wins
		if ( p0 === undefined ) return true;
		 // If both parts are numbers, use numeric comparison to avoid cases like "12" < "5"
		if ( Number.isNumeric(p0) && Number.isNumeric(p1) ) {
			if ( Number(p1) !== Number(p0) ) return Number(p1) > Number(p0);
		}
		 // Otherwise, compare as strings
		else if ( p1 < p0 ) return false;
	}
	 // If there are additional parts to v0, it is not newer
	if ( v0Parts.length > v1Parts.length ) return false;
	 // If we have not returned false by now, its either newer or the same
	return !v1Parts.equals(v0Parts);
}

/* -------------------------------------------- */

/**
 * Generate a random ID
 * Generate random number and convert it to base 36 and remove the '0.' at the beginning
 * As long as the string is not long enough, generate more random data into it
 * Use substring in case we generated a string with a length higher than the requested length
 *
 * @param {number} length    The length of the random ID to generate
 * @return {string}          Return a string containing random letters and numbers
 */
function randomID(length=10) {
	const rnd = () => Math.random().toString(36).substr(2);
	let id = "";
	while (id.length < length)
		id += rnd();
	return id.substr(0, length);
}
	/* -------------------------------------------- */
	function benchmark(func, iterations) {
	const start = performance.now();
	for ( let i=0; i<iterations; i++ ) {
		func();
	}
	const end = performance.now();
	const t = Math.round((end - start) * 100) / 100;
	console.log(`Evaluated function ${iterations} times | ${t} ms | ${t / iterations} per`);
}
	/* -------------------------------------------- */
/*  URL Routing                                 */
/* -------------------------------------------- */

/**
 * Get the URL route for a certain path which includes a path prefix, if one is set
 * @param {string} path       The Foundry VTT URL path
 * @param {string|null} [prefix]   A path prefix to apply
 * @returns {string}          The absolute URL path
 */
function getRoute(path, {prefix=null}={}) {
	if ( !prefix ) {
		try {
			if ( ROUTE_PREFIX ) prefix = ROUTE_PREFIX;
		} catch(err) {}
	}
	path = path.replace(/(^[\/]+)|([\/]+$)/g, ""); // Strip leading and trailing slashes
	let paths = [""]
	if ( prefix ) paths.push(prefix);
	paths = paths.concat([path.replace(/(^\/)|(\/$)/g, "")]);
	return paths.join("/");
}

/* -------------------------------------------- */
	try {
	module.exports = {
		benchmark,
		debounce,
		duplicate,
		diffObject,
		filterObject,
		flattenObject,
		encodeURL,
		expandObject,
		getRoute,
		invertObject,
		isObjectEmpty,
		mergeObject,
		hasProperty,
		getProperty,
		setProperty,
		hsvToRgb,
		rgbToHsv,
		rgbToHex,
		colorStringToHex,
		isNewerVersion,
		randomID
	};
} catch(err) {}
	/* -------------------------------------------- */

/**
 * A helper class to provide common functionality for working with HTML5 audio and Howler instances
 * A singleton instance of this class is available as ``game.audio``
 *
 * Audio playback in Foundry VTT is managed by Howler.js (https://howlerjs.com/). Several methods and
 * attributes in this API return :class:`Howl` instances. See the Howler documentation for details
 * and example usage of the Howl API.
 */
class AudioHelper {
	constructor() {
		if ( game.audio instanceof this.constructor ) {
			throw new Error("You may not re-initialize the singleton AudioHelper. Use game.audio instead.");
		}
		 /**
		 * The set of Howl instances which have been created for different audio paths
		 * @type {Object}
		 */
		this.sounds = {};
		 /**
		 * A user gesture must be registered before audio can be played.
		 * This Array contains the Howl instances which are requested for playback prior to a gesture.
		 * Once a gesture is observed, we begin playing all elements of this Array.
		 * @type {Howl[]}
		 */
		this.pending = [];
		 /**
		 * A flag for whether video playback is currently locked by awaiting a user gesture
		 * @type {boolean}
		 */
		this.locked = true;
		 /**
		 * Audio Context singleton used for analysing audio levels of each stream
		 * Only created if necessary to listen to audio streams.
		 *
		 * @type {AudioContext}
		 */
		this._audioContext = null;
		 /**
		 * Map of all streams that we listen to for determining the decibel levels.
		 * Used for analyzing audio levels of each stream.
		 * Format of the object stored is :
		 * {id:
		 *   {
		 *     stream: MediaStream,
		 *     analyser: AudioAnalyser,
		 *     interval: Number,
		 *     callback: Function
		 *   }
		 * }
		 *
		 * @type {Object}
		 * @private
		 */
		this._analyserStreams = {};
		 /**
		 * Interval ID as returned by setInterval for analysing the volume of streams
		 * When set to 0, means no timer is set.
		 * @type {number}
		 * @private
		 */
		this._analyserInterval = 0;
		 /**
		 * Fast Fourrier Transform Array.
		 * Used for analysing the decibel level of streams. The array is allocated only once
		 * then filled by the analyser repeatedly. We only generate it when we need to listen to
		 * a stream's level, so we initialize it to null.
		 * @type {Float32Array}
		 * @private
		 */
		this._fftArray = null;
	}
	 /* -------------------------------------------- */
		/**
	 * Register client-level settings for global volume overrides
	 */
	static registerSettings() {
		 // Playlist Volume
		game.settings.register("core", "globalPlaylistVolume", {
			name: "Global Playlist Volume",
			hint: "Define a global playlist volume modifier",
			scope: "client",
			config: false,
			default: 1.0,
			type: Number,
			onChange: volume => {
				for ( let p of game.playlists.entities ) {
					p.sounds.filter(s => s.playing).forEach(s => p.playSound(s));
				}
			}
		});
		 // Ambient Volume
		game.settings.register("core", "globalAmbientVolume", {
			name: "Global Ambient Volume",
			hint: "Define a global ambient volume modifier",
			scope: "client",
			config: false,
			default: 1.0,
			type: Number,
			onChange: volume => {
				if ( canvas.ready ) {
					if ( canvas.background.isVideo ) canvas.background.source.volume = volume;
					canvas.sounds.update();
				}
			}
		});
		 // UI Volume
		game.settings.register("core", "globalInterfaceVolume", {
			name: "Global Interface Volume",
			hint: "Define a global interface volume modifier",
			scope: "client",
			config: false,
			default: 0.5,
			type: Number
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a Howl instance for a given audio source URL
	 * @param src
	 * @param preload
	 * @param autoplay
	 * @return {Howl}
	 */
	create({src, preload=false, autoplay=false, html5=false, volume=0.0, loop=false} = {}) {
		 // Return an existing howl if one already exists for the source
		if ( src in this.sounds ) {
			return this.sounds[src].howl;
		}
		 // Create the Howl instance
		let howl = new Howl({
			src: src,
			preload: preload,
			autoplay: autoplay,
			volume: volume,
			loop: loop,
			html5: html5,
			onload: () => this.sounds[src].loaded = true,
			onplay: id => this.sounds[src].ids.push(id)
		});
		 // Record the Howl instance for later use
		this.sounds[src] = {
			howl: howl,
			loaded: false,
			ids: []
		};
		return howl;
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether a source file has a supported audio extension type
	 * @param {string} src      A requested audio source path
	 * @return {boolean}        Does the filename end with a valid audio extension?
	 */
	static hasAudioExtension(src) {
		let rgx = new RegExp("(\\."+CONST.AUDIO_FILE_EXTENSIONS.join("|\\.")+")(\\?.*)?", "i");
		return rgx.test(src);
	}
	 /* -------------------------------------------- */
	 /**
	 * Play a single audio effect by it's source path and Howl ID
	 * @param {string} src
	 * @param {number} id
	 */
	play(src, id) {
		let howl = this.sounds[src];
		if ( !howl ) throw new Error("Howl instance does not exist for sound " + src);
		howl.play(id);
	}
	 /* -------------------------------------------- */
		/**
	 * Register an event listener to await the first mousemove gesture and begin playback once observed
	 */
	awaitFirstGesture() {
		if ( !this.locked ) return;
		const interactions = ['contextmenu', 'auxclick', 'mousedown', 'mouseup', 'keydown'];
		interactions.forEach(event => document.addEventListener(event, this._onFirstGesture.bind(this), {once: true}));
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the first observed user gesture
	 * @param {Event} event   The mouse-move event which enables playback
	 */
	_onFirstGesture(event) {
		if ( !this.pending.length ) return;
		console.log(`${vtt} | Activating pending audio playback with user gesture.`);
		this.locked = false;
		this.pending.forEach(fn => fn());
		this.pending = [];
	}
	 /* -------------------------------------------- */
	 preload(data) {
		game.socket.emit("preloadAudio", data);
		this.constructor.preload(data);
	}
		/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */
	 /**
	 * Open socket listeners which transact ChatMessage data
	 * @private
	 */
	static socketListeners(socket) {
		socket.on('playAudio', this.play);
		socket.on('preloadAudio', this.preload);
	}
	 /* -------------------------------------------- */
	 /**
	 * Play a one-off sound effect which is not part of a Playlist
	 *
	 * @param {Object} data           An object configuring the audio data to play
	 * @param {string} data.src       The audio source file path, either a public URL or a local path relative to the public directory
	 * @param {number} data.volume    The volume level at which to play the audio, between 0 and 1.
	 * @param {boolean} data.autoplay Begin playback of the audio effect immediately once it is loaded.
	 * @param {boolean} data.loop     Loop the audio effect and continue playing it until it is manually stopped.
	 * @param {boolean} [push]        Push the audio sound effect to other connected clients?
	 *
	 * @return {Howl}                 A Howl instance which controls audio playback.
	 *
	 * @example
	 * // Play the sound of a locked door for all players
	 * AudioHelper.play({src: "sounds/lock.wav", volume: 0.8, autoplay: true, loop: false}, true);
	 */
	static play(data, push=false) {
		let audioData = mergeObject({src: null, volume: 1.0, autoplay: true, loop: false}, data, {insertKeys: true});
		audioData.volume *= game.settings.get("core", "globalInterfaceVolume");
		if ( push ) game.socket.emit("playAudio", audioData);
		return new Howl(audioData);
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a Howl object and load it to be ready for later playback
	 * @param {Object} data         The audio data to preload
	 */
	static preload(data) {
		game.audio.create({
			src: data.path,
			autoplay: false,
			preload: true
		}).load();
	}
	 /* -------------------------------------------- */
	 /**
	 * Returns the volume value based on a range input volume control's position.
	 * This is using an exponential approximation of the logarithmic nature of audio level perception
	 * @param {number|string} value   Value between [0, 1] of the range input
	 * @param {number} order          [optional] the exponent of the curve (default: 2)
	 * @return {number}
	 */
	static inputToVolume(value, order=1.5) {
		return Math.pow(parseFloat(value), order);
	}
	 /* -------------------------------------------- */
	 /**
	 * Counterpart to inputToVolume()
	 * Returns the input range value based on a volume
	 * @param {number} volume     Value between [0, 1] of the volume level
	 * @param {number} order      [optional] the exponent of the curve (default: 2)
	 * @return {number}
	 */
	static volumeToInput(volume, order=1.5) {
		return Math.pow(volume, 1 / order);
	}
	 /* -------------------------------------------- */
	/*  Audio Stream Analysis                       */
	/* -------------------------------------------- */
	 /**
	 * Returns a singleton AudioContext if one can be created.
	 * An audio context may not be available due to limited resources or browser compatibility
	 * in which case null will be returned
	 *
	 * @return {AudioContext}   A singleton AudioContext or null if one is not available
	 */
	getAudioContext() {
		if ( this._audioContext )
			return this._audioContext;
		try {
			// Use one Audio Context for all the analysers.
			return new (AudioContext || webkitAudioContext)();
		} catch (err) {
			console.log("Could not create AudioContext. Will not be able to analyse stream volumes.");
		}
		return null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Registers a stream for periodic reports of audio levels.
	 * Once added, the callback will be called with the maximum decibel level of
	 * the audio tracks in that stream since the last time the event was fired.
	 * The interval needs to be a multiple of AudioHelper.levelAnalyserNativeInterval which defaults at 50ms
	 *
	 * @param {string} id             An id to assign to this report. Can be used to stop reports
	 * @param {MediaStream} stream    The MediaStream instance to report activity on.
	 * @param {Function} callback     The callback function to call with the decibel level. `callback(dbLevel)`
	 * @param {number} interval       (optional) The interval at which to produce reports.
	 * @param {number} smoothing      (optional) The smoothingTimeConstant to set on the audio analyser. Refer to AudioAnalyser API docs.
	 * @return {boolean}              Returns whether or not listening to the stream was successful
	 */
	startLevelReports(id, stream, callback, interval = 50, smoothing = 0.1) {
		if ( !stream || !id ) return;
		let audioContext = this.getAudioContext();
		if (audioContext === null) return false;
		 // Clean up any existing report with the same ID
		this.stopLevelReports(id);
		 // Make sure this stream has audio tracks, otherwise we can't connect the analyser to it
		if (stream.getAudioTracks().length === 0)
			return false;
		 // Create the analyser
		let analyser = audioContext.createAnalyser();
		analyser.fftSize = 512;
		analyser.smoothingTimeConstant = smoothing;
		 // Connect the analyser to the MediaStreamSource
		audioContext.createMediaStreamSource(stream).connect(analyser);
		this._analyserStreams[id] = {
			stream,
			analyser,
			interval,
			callback,
			// Used as a counter of 50ms increments in case the interval is more than 50
			_lastEmit: 0
		};
		 // Ensure the analyser timer is started as we have at least one valid stream to listen to
		this._ensureAnalyserTimer();
		return true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Stop sending audio level reports
	 * This stops listening to a stream and stops sending reports.
	 * If we aren't listening to any more streams, cancel the global analyser timer.
	 * @param {string} id      The id of the reports that passed to startLevelReports.
	 */
	stopLevelReports(id) {
		delete this._analyserStreams[id];
		if (isObjectEmpty(this._analyserStreams)) this._cancelAnalyserTimer();
	}
	 /* -------------------------------------------- */
	 /**
	 * Ensures the global analyser timer is started
	 * 
	 * We create only one timer that runs every 50ms and only create it if needed, this is meant to optimize things
	 * and avoid having multiple timers running if we want to analyse multiple streams at the same time.
	 * I don't know if it actually helps much with performance but it's expected that limiting the number of timers
	 * running at the same time is good practice and with JS itself, there's a potential for a timer congestion
	 * phenomenon if too many are created.
	 * @private
	 */
	_ensureAnalyserTimer() {
		if (this._analyserInterval === 0) {
			this._analyserInterval = setInterval(this._emitVolumes.bind(this), AudioHelper.levelAnalyserNativeInterval);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Cancel the global analyser timer
	 * If the timer is running and has become unnecessary, stops it.
	 * @private
	 */
	_cancelAnalyserTimer() {
		if (this._analyserInterval !== 0) {
			clearInterval(this._analyserInterval);
			this._analyserInterval = 0;
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Capture audio level for all speakers and emit a webrtcVolumes custom event with all the volume levels
	 * detected since the last emit.
	 * The event's detail is in the form of {userId: decibelLevel}
	 * @private
	 */
	_emitVolumes() {
		for (let id in this._analyserStreams) {
			const analyserStream = this._analyserStreams[id];
			if (++analyserStream._lastEmit < analyserStream.interval / AudioHelper.levelAnalyserNativeInterval)
				continue;
			 // Create the Fast Fourier Transform Array only once. Assume all analysers use the same fftSize
			if (this._fftArray === null) this._fftArray = new Float32Array(analyserStream.analyser.frequencyBinCount);
			 // Fill the array
			analyserStream.analyser.getFloatFrequencyData(this._fftArray);
			let maxDecibel = Math.max(...this._fftArray);
			analyserStream.callback(maxDecibel, this._fftArray);
			analyserStream._lastEmit = 0;
		}
	}
}

/**
 * The Native interval for the AudioHelper to analyse audio levels from streams
 * Any interval passed to startLevelReports() would need to be a multiple of this value.
 * Defaults to 50ms.
 * @type {number}
 */
AudioHelper.levelAnalyserNativeInterval = 50;
/**
 * A reusable storage concept which blends the functionality of an Array with the efficient key-based lookup of a Map.
 * This concept is reused throughout Foundry VTT where a collection of uniquely identified elements is required.
 * @extends {Map}
 */
class Collection extends Map {
	constructor(entries) {
		super(entries);
	}
	 /* -------------------------------------------- */
	 /**
	 * When iterating over a Collection, we should iterate over its values instead of over its entries
	 */
	[Symbol.iterator]() {
		return this.values();
	}
	 /* -------------------------------------------- */
	 /**
	 * Return an Array of all the entry values in the Collection
	 * @return {V[]}
	 */
	get entries() {
		return Array.from(this.values());
	}
	 /* -------------------------------------------- */
	 /**
	 * Find an entry in the Map using an functional condition.
	 * @see {Array#find}
	 *
	 * @param {Function} condition  The functional condition to test
	 * @return {V|null}             The value, if found, otherwise null
	 *
	 * @example
	 * let c = new Collection([["a", "A"], ["b", "B"], ["c", "C"]]);
	 * let a = c.find(entry => entry === "A");
	 */
	find(condition) {
		let entry = null;
		for ( let e of this.values() ) {
			if ( condition(e) ) {
				return entry = e;
			}
		}
		return null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Filter the Collection, returning an Array of entries which match a functional condition.
	 * @see {Array#filter}
	 * @param {Function} condition  The functional condition to test
	 * @return {V[]}                An Array of matched values
	 *
	 * @example
	 * let c = new Collection([["a", "AA"], ["b", "AB"], ["c", "CC"]]);
	 * let hasA = c.filters(entry => entry.slice(0) === "A");
	 */
	filter(condition) {
		const entries = [];
		for ( let e of this.values() ) {
			if ( condition(e) ) {
				entries.push(e);
			}
		}
		return entries;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get an element from the Collection by its key.
	 * @param {string} key      The key of the entry to retrieve
	 * @param {boolean} strict  Throw an Error if the requested id does not exist, otherwise return null. Default false
	 * @return {V|null}         The retrieved entry value, if the key exists, otherwise null
	 *
	 * @example
	 * let c = new Collection([["a", "A"], ["b", "B"], ["c", "C"]]);
	 * c.get("a"); // "A"
	 * c.get("d"); // null
	 * c.get("d", {strict: true}); // throws Error
	 */
	get(key, {strict=false}={}) {
		const entry = super.get(key);
		if ( strict && !entry ) {
			throw new Error(`The key ${key} does not exist in the ${this.constructor.name} Collection`);
		}
		return entry || null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get an entry from the Collection by name.
	 * Use of this method assumes that the objects stored in the collection have a "name" attribute.
	 * @param {string} name     The name of the entry to retrieve
	 * @param {boolean} strict  Throw an Error if the requested id does not exist, otherwise return null. Default false.
	 * @return {Entity|null}    The retrieved Entity, if one was found, otherwise null;
	 */
	getName(name, {strict = false} = {}) {
		const entry = this.find(e => e.name === name);
		if ( strict && (entry === undefined) ) {
			throw new Error(`An entry with name ${name} does not exist in the collection`);
		}
		return entry ?? null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Transform each element of the Collection into a new form, returning an Array of transformed values
	 * @param {Function} transformer  The transformation function to apply to each entry value
	 * @return {V[]}                  An Array of transformed values
	 */
	map(transformer) {
		const transformed = [];
		for ( let e of this.values() ) {
			transformed.push(transformer(e));
		}
		return transformed;
	}
	 /* -------------------------------------------- */
	 /**
	 * Reduce the Collection by applying an evaluator function and accumulating entries
	 * @see {Array#reduce}
	 * @param {Function} evaluator    A function which mutates the accumulator each iteration
	 * @param {any} initial           An initial value which accumulates with each iteration
	 * @return {any}                  The accumulated result
	 *
	 * @example
	 * let c = new Collection([["a", "A"], ["b", "B"], ["c", "C"]]);
	 * let letters = c.reduce((s, l) => {
	 *   return s + l;
	 * }, ""); // "ABC"
	 */
	reduce(evaluator, initial) {
		let accumulator = initial;
		for ( let e of this.values() ) {
			accumulator = evaluator(accumulator, e)
		}
		return accumulator;
	}
}

/**
 * A configuration of font families which are initialized when the page loads
 * @type {Object}
 */
const FONTS = {
	"Signika": {
		custom: {
			families: ['Signika'],
			urls: ['fonts/signika/signika.css']
		}
	},
	"FontAwesome": {
		custom: {
			families: ['FontAwesome'],
			urls: ['fonts/fontawesome/css/all.min.css']
		}
	},
	_loaded: []
};
	/**
 * Load font, and perform a callback once the font has been rendered
 * @deprecated since 0.6.4, to be removed in 0.8.x
 * @param fontName
 * @param callback
 */
function loadFont(fontName, callback) {
	console.warn(`The loadFont() utility method has been deprecated in favor of alternative methods for including font definitions. Please discontinue use of loadFont() which will be removed in 0.8.x`);
	 const font = $.extend(FONTS[fontName], {
		fontloading: function(fontFamily, fvd) {
			console.log("Foundry VTT | Loading Font: " + fontFamily);
			let temp = document.createElement('p');
			temp.id = fontFamily;
			temp.classList.add("font-preload");
			temp.style.fontFamily = fontFamily;
			temp.style.fontSize = "0px";
			temp.style.visibility = "hidden";
			temp.innerHTML = ".";
			document.body.appendChild(temp);
		},
		fontactive: () => {
			console.log(`${vtt} | Loaded font ${fontName}`);
			$( 'p#'+fontName ).remove();
			if ( callback ) callback();
		},
		fontinactive: () => {
			console.log("Something went wrong with " + fontName);
			$( 'p#'+fontName ).remove();
		}
	});
	 if (!FONTS._loaded.includes(fontName)) {
		WebFont.load(font);
		FONTS._loaded.push(fontName);
	}
}

/**
 * A simple event framework used throughout Foundry Virtual Tabletop.
 * When key actions or events occur, a "hook" is defined where user-defined callback functions can execute.
 * This class manages the registration and execution of hooked callback functions.
 */
class Hooks {
	 /**
	 * Register a callback handler which should be triggered when a hook is triggered.
	 *
	 * @param {string} hook   The unique name of the hooked event
	 * @param {Function} fn   The callback function which should be triggered when the hook event occurs
	 * @return {number}       An ID number of the hooked function which can be used to turn off the hook later
	 */
	static on(hook, fn) {
		console.debug(`${vtt} | Registered callback for ${hook} hook`);
		const id = this._id++;
		this._hooks[hook] = this._hooks[hook] || [];
		this._hooks[hook].push(fn);
		this._ids[id] = fn;
		return id;
	}
	 /* -------------------------------------------- */
	 /**
	 * Register a callback handler for an event which is only triggered once the first time the event occurs.
	 * After a "once" hook is triggered the hook is automatically removed.
	 *
	 * @param {string} hook   The unique name of the hooked event
	 * @param {Function} fn   The callback function which should be triggered when the hook event occurs
	 * @return {number}       An ID number of the hooked function which can be used to turn off the hook later
	 */
	static once(hook, fn) {
		this._once.push(fn);
		return this.on(hook, fn);
	}
	 /* -------------------------------------------- */
	 /**
	 * Unregister a callback handler for a particular hook event
	 *
	 * @param {string} hook           The unique name of the hooked event
	 * @param {Function|number} fn    The function, or ID number for the function, that should be turned off
	 */
	static off(hook, fn) {
		if ( typeof fn === "number" ) {
			let id = fn;
			fn = this._ids[fn];
			delete this._ids[id];
		}
		if ( !this._hooks.hasOwnProperty(hook) ) return;
		const fns = this._hooks[hook];
		let idx = fns.indexOf(fn);
		if ( idx !== -1 ) fns.splice(idx, 1);
		console.debug(`${vtt} | Unregistered callback for ${hook} hook`);
	}
	 /* -------------------------------------------- */
	 /**
	 * Call all hook listeners in the order in which they were registered
	 * Hooks called this way can not be handled by returning false and will always trigger every hook callback.
	 *
	 * @param {string} hook   The hook being triggered
	 * @param {...*} args     Arguments passed to the hook callback functions
	 */
	static callAll(hook, ...args) {
		if ( CONFIG.debug.hooks ) {
			console.log(`DEBUG | Calling ${hook} hook with args:`);
			console.log(args);
		}
		if ( !this._hooks.hasOwnProperty(hook) ) return;
		const fns = new Array(...this._hooks[hook]);
		for ( let fn of fns ) {
			this._call(hook, fn, args);
		}
		return true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Call hook listeners in the order in which they were registered.
	 * Continue calling hooks until either all have been called or one returns `false`.
	 *
	 * Hook listeners which return `false` denote that the original event has been adequately handled and no further
	 * hooks should be called.
	 *
	 * @param {string} hook   The hook being triggered
	 * @param {...*} args      Arguments passed to the hook callback functions
	 */
	static call(hook, ...args) {
		if ( CONFIG.debug.hooks ) {
			console.log(`DEBUG | Calling ${hook} hook with args:`);
			console.log(args);
		}
		if ( !this._hooks.hasOwnProperty(hook) ) return;
		const fns = new Array(...this._hooks[hook]);
		for ( let fn of fns ) {
			let callAdditional = this._call(hook, fn, args);
			if ( callAdditional === false ) return false;
		}
		return true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Call a hooked function using provided arguments and perhaps unregister it.
	 * @private
	 */
	static _call(hook, fn, args) {
		if ( this._once.includes(fn) ) this.off(hook, fn);
		try {
			return fn(...args);
		} catch(err) {
			console.warn(`${vtt} | Error thrown in hooked function ${fn.name}`);
			console.error(err);
		}
	}
}

// Static class attributes
Hooks._hooks = {};
Hooks._once = [];
Hooks._ids = {};
Hooks._id = 1;

/**
 * A helper class to provide common functionality for working with Image objects
 */
class ImageHelper {
	 /**
	 * Create thumbnail preview for a provided image path.
	 * @param {string|PIXI.DisplayObject} src   The URL or display object of the texture to render to a thumbnail
	 * @param {object} options    Additional named options passed to the compositeCanvasTexture function
	 * @return {Promise<object>}  The parsed and converted thumbnail data
	 */
	static async createThumbnail(src, options) {
		if ( !src ) return null;
		 // Load the texture and create a Sprite
		let object = src;
		if ( !(src instanceof PIXI.DisplayObject) ) {
			const texture = await loadTexture(src);
			object = PIXI.Sprite.from(texture);
		}
		 // Reduce to the smaller thumbnail texture
		const reduced = this.compositeCanvasTexture(object, options);
		const thumb = this.textureToImage(reduced);
		reduced.destroy(true);
		 // Return the image data
		return { src, texture: reduced, thumb, width: object.width, height: object.height };
	}
	 /* -------------------------------------------- */
	 /**
	 * Composite a canvas object by rendering it to a single texture
	 *
	 * @param {PIXI.DisplayObject} object   The object to render to a texture
	 * @param {number} [width]              The desired width of the output texture
	 * @param {number} [height]             The desired height of the output texture
	 * @param {number} [tx]                 A horizontal translation to apply to the object
	 * @param {number} [ty]                 A vertical translation to apply to the object
	 * @param {boolean} [center]            Center the texture in the rendered frame?
	 *
	 * @return {PIXI.Texture}               The composite Texture object
	 */
	static compositeCanvasTexture(object, {width, height, tx=0, ty=0, center=true}={}) {
		if ( !canvas?.app.renderer ) throw new Error("Unable to compose texture because there is no game canvas");
		width = width ?? object.width;
		height = height ?? object.height;
		 // Downscale the object to the desired thumbnail size
		const currentRatio = object.width / object.height;
		const targetRatio = width / height;
		const s = currentRatio > targetRatio ? (height / object.height) : (width / object.width);
		 // Define a transform matrix
		const transform = PIXI.Matrix.IDENTITY.clone();
		transform.scale(s, s);
		 // Translate position
		if ( center ) {
			tx = (width - (object.width * s)) / 2;
			ty = (height - (object.height * s)) / 2;
		} else {
			tx *= s;
			ty *= s;
		}
		transform.translate(tx, ty);
		 // Create and render a texture with the desired dimensions
		const texture = PIXI.RenderTexture.create({
			width: width,
			height: height,
			scaleMode: PIXI.SCALE_MODES.LINEAR,
			resolution: 2
		});
		canvas.app.renderer.render(object, texture, undefined, transform);
		return texture;
	}
	 /* -------------------------------------------- */
	 /**
	 * Extract a texture to a base64 PNG string
	 * @param {PIXI.Texture} texture      The texture object to extract
	 * @return {string}                   A base64 png string of the texture
	 */
	static textureToImage(texture) {
		const s = new PIXI.Sprite(texture);
		return canvas.app.renderer.extract.base64(s);
	}
}

/**
 * A set of helpers and management functions for dealing with user input from keyboard events.
 * {@link https://keycode.info/}
 */
class KeyboardManager {
	constructor() {
		 /**
		 * The set of key codes which are currently depressed (down)
		 * @type {Set}
		 */
		this._downKeys = null;
		 /**
		 * The set of key codes which have been already handled per workflow
		 * @type {Set}
		 */
		this._handled = null;
		 /**
		 * A mapping of movement keys which are pending
		 * @type {Set}
		 * @private
		 */
		this._moveKeys = null;
		 // Status handlers
		this._moveTime = null;
		this._tabState = 0;
		this._wheelTime = 0;
		 // Initial reset
		this._reset();
		 // Activate input listeners
		window.addEventListener('keydown', this._onKeyDown.bind(this));
		window.addEventListener('keyup', this._onKeyUp.bind(this));
		window.addEventListener("visibilitychange", this._reset.bind(this));
		window.addEventListener("wheel", this._onWheel.bind(this), {passive: false});
		window.addEventListener("compositionend", this._onCompositionEnd.bind(this));
	}
	 /* -------------------------------------------- */
	 /**
	 * Reset tracking for which keys are in the down and released states
	 * @private
	 */
	_reset() {
		this._downKeys = new Set();
		this._handled = new Set();
		this._moveKeys = new Set();
		this._tabState = 0;
	}
	 /* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /**
	 * Return whether the key code is currently in the DOWN state
	 * @param {string} code    The key code to test
	 * @type {boolean}
	 */
	isDown(code) {
		return this._downKeys.has(code);
	}
	 /* -------------------------------------------- */
	 /**
	 * A helper method to test whether, given an Event, the CTRL (or CMD) keys are pressed
	 * @param event
	 * @return {boolean}
	 */
	isCtrl(event) {
		if ( !event ) return false;
		event = "ctrlKey" in event ? event : event.data.originalEvent;
		return event.ctrlKey || event.metaKey;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get a standardized keyboard code for a given event
	 * @param {KeyboardEvent} event   The originating keypress event
	 * @return {string}               The standardized string code to use
	 */
	getKey(event) {
		 // Space bar gets a code because its key is misleading
		if ( event.code === "Space" ) return event.code;
		 // Digit keys are coerced to their number
		if ( /^Digit/.test(event.code) ) return event.code[5];
		 // Enforce that numpad keys are differentiated from digits
		if ( (event.location === 3) && ((event.code in this.moveKeys) || (event.code in this.zoomKeys)) ) {
			return event.code;
		}
		 // Otherwise always use the character key
		return event.key;
	}
	 /* -------------------------------------------- */
	 /**
	 * The key codes which represent a possible movement key
	 * @return {Object.<Array>}
	 */
	get moveKeys() {
		return this.constructor.MOVEMENT_KEYS;
	}
	 /* -------------------------------------------- */
	 /**
	 * The key codes which represent a digit key
	 * @return {Array.<string>}
	 */
	get digitKeys() {
		return this.constructor.DIGIT_KEYS;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the key codes used for zooming the canvas
	 * @return {Object.<string>}
	 */
	get zoomKeys() {
		return this.constructor.ZOOM_KEYS;
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether an input currently has focus
	 * @return {boolean}
	 */
	get hasFocus() {
		return $(":focus").length > 0;
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /**
	 * Handle a key press into the down position
	 * @param {KeyboardEvent} event   The originating keyboard event
	 * @private
	 */
	_onKeyDown(event) {
		if ( event.isComposing ) return; // Ignore IME composition
		const key = this.getKey(event);
		if ( this._handled.has(key) ) return;
		this._downKeys.add(key);
		this._handleKeys(event, key, false);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a key release into the up position
	 * @param {KeyboardEvent} event   The originating keyboard event
	 * @private
	 */
	_onKeyUp(event) {
		if ( event.isComposing ) return; // Ignore IME composition
		const key = this.getKey(event);
		this._downKeys.delete(key);
		this._handleKeys(event, key, true);
		if ( this._handled.has(key) ) {
			this._handled.clear();
			this._downKeys.clear();
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Delegate tracked key codes by dispatching to their various handlers
	 * @param {KeyboardEvent} event   The keydown or keyup event
	 * @param {string} key            The key being depressed
	 * @param {boolean} up            A flag for whether the key is down or up
	 * @private
	 */
	_handleKeys(event, key, up) {
		 // Collect meta modifiers
		const modifiers = {
			key: key,
			isShift: event.shiftKey,
			isCtrl: event.ctrlKey || event.metaKey,
			isAlt: event.altKey,
			hasFocus: this.hasFocus
		};
		 // Dispatch events to bound handlers
		if ( key === "Tab" ) this._onTab(event, up, modifiers);
		else if ( key === "Escape" ) this._onEscape(event, up, modifiers);
		else if ( key === "Space" ) this._onSpace(event, up, modifiers);
		else if ( key in this.moveKeys ) this._onMovement(event, up, modifiers);
		else if ( this.digitKeys.includes(key) ) this._onDigit(event, up, modifiers);
		else if ( ["Delete", "Backspace"].includes(key) ) this._onDelete(event, up, modifiers);
		else if ( key === "Alt" ) this._onAlt(event, up, modifiers);
		else if ( key.toLowerCase() === "z" ) this._onKeyZ(event, up, modifiers);
		else if ( key.toLowerCase() === "c" ) this._onKeyC(event, up, modifiers);
		else if ( key.toLowerCase() === "v" ) this._onKeyV(event, up, modifiers);
		else if ( key in this.zoomKeys ) this._onKeyZoom(event, up, modifiers);
	 }
	 /* -------------------------------------------- */
	 /**
	 * Input events do not fire with isComposing = false at the end of a composition event in Chrome
	 * See: https://github.com/w3c/uievents/issues/202
	 * @param {CompositionEvent} event
	 */
	_onCompositionEnd(event) {
		return this._onKeyDown(event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Master mouse-wheel event keyboard handler
	 * @private
	 */
	_onWheel(event) {
		 // Prevent zooming the entire browser window
		if ( event.ctrlKey ) event.preventDefault();
		 // Interpret shift+scroll as vertical scroll
		let dy = event.deltaY;
		if ( event.shiftKey && (dy === 0) ) dy = event.deltaX;
		if ( dy === 0 ) return;
		 // Take no actions if the canvas is not hovered
		if ( !canvas?.ready ) return;
		const hover = document.elementFromPoint(event.clientX, event.clientY);
		if ( !hover || (hover.id !== "board" )) return;
		event.preventDefault();
		 // Identify scroll modifiers
		const isCtrl = event.ctrlKey || event.metaKey;
		const isShift = event.shiftKey;
		const layer = canvas.activeLayer;
		 // Case 1 - rotate placeable objects
		if ( layer.options?.rotatableObjects && ( isCtrl || isShift ) ) {
			const hasTarget = layer.options?.controllableObjects ? layer.controlled.length : !!layer._hover;
			if (hasTarget) {
				const t = Date.now();
				if ((t - this._wheelTime) < this.constructor.MOUSE_WHEEL_RATE_LIMIT) return;
				this._wheelTime = t;
				return layer._onMouseWheel(event);
			}
		}
		 // Case 2 - zoom the canvas
		canvas._onMouseWheel(event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle TAB keypress events
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onTab(event, up, modifiers) {
		 // Always prevent tab actions if a form field is not in focus
		if ( !modifiers.hasFocus ) event.preventDefault();
		else return;
		if ( up || !canvas?.ready ) {
			this._tabState = 0;
			return;
		}
		if ( this._tabState > 0 ) return;
		 // Attempt to cycle tokens, otherwise re-center the canvas
		if ( canvas.tokens._active ) {
			let cycled = canvas.tokens.cycleTokens(!modifiers.isShift);
			if ( !cycled ) canvas.recenter();
		}
		this._tabState = 1;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle ESC keypress events
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onEscape(event, up, modifiers) {
		if ( up || modifiers.hasFocus ) return;
		 // Save fog of war if there are pending changes
		if ( canvas?.ready ) canvas.sight.saveFog();
		 // Case 1 - dismiss an open context menu
		if ( ui.context && ui.context.menu.length ) ui.context.close();
		 // Case 2 - close open UI windows
		else if ( Object.keys(ui.windows).length ) {
			Object.values(ui.windows).forEach(app => app.close());
		}
		 // Case 3 (GM) - release controlled objects
		else if ( canvas?.ready && game.user.isGM && Object.keys(canvas.activeLayer._controlled).length ) {
			event.preventDefault();
			canvas.activeLayer.releaseAll();
		}
		 // Case 4 - toggle the main menu
		else ui.menu.toggle();
		 // Flag the keydown workflow as handled
		this._handled.add(modifiers.key);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle SPACE keypress events
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onSpace(event, up, modifiers) {
		const ruler = canvas.controls.ruler;
		if ( up ) return;
		 // Move along a measured ruler
		if ( canvas?.ready && ruler.active ) {
			let moved = ruler.moveToken(event);
			if ( moved ) event.preventDefault();
		}
		 // Pause the game
		else if ( !modifiers.hasFocus && game.user.isGM ) {
			event.preventDefault();
			game.togglePause(null, true);
		}
		 // Flag the keydown workflow as handled
		this._handled.add(modifiers.key);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle ALT keypress events
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onAlt(event, up, modifiers) {
		if ( !canvas?.ready ) return;
		event.preventDefault();
		 // Highlight placeable objects on any layers which are visible
		for ( let layer of canvas.layers ) {
			if ( !layer.objects || !layer.interactiveChildren ) continue;
			for ( let o of layer.placeables ) {
				if ( !o.visible ) continue;
				if ( !o.can(game.user, "hover") ) return;
				if ( !up ) o._onHoverIn(event, {hoverOutOthers: false});
				else o._onHoverOut(event);
			}
		}
		 // Flag the keydown workflow as handled
		if ( !up ) this._handled.add(modifiers.key);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle movement keypress events
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onMovement(event, up, modifiers) {
		if ( !canvas?.ready || up || modifiers.hasFocus ) return;
		event.preventDefault();
		 // Handle CTRL+A
		if ( (modifiers.key === "a") && modifiers.isCtrl ) return this._onKeyA(event, up, modifiers);
		 // Reset move keys after a delay of 50ms or greater
		const now = Date.now();
		const delta = now - this._moveTime;
		if ( delta > 50 ) this._moveKeys.clear();
		 // Track the movement set
		const directions = this.moveKeys[modifiers.key];
		for ( let d of directions ) {
			this._moveKeys.add(d);
		}
		 // Handle canvas pan using CTRL
		if ( modifiers.isCtrl ) {
			if ( ["w", "a", "s", "d"].includes(modifiers.key) ) return;
			return this._handleCanvasPan();
		}
		 // Delay 50ms before shifting tokens in order to capture diagonal movements
		const layer = canvas.activeLayer;
		if ( layer instanceof TokenLayer || layer instanceof TilesLayer ) {
			if ( delta < 100 ) return; // Throttle keyboard movement once per 100ms
			setTimeout(() => this._handleMovement(event, layer), 50);
		}
		this._moveTime = now;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle keyboard movement once a small delay has elapsed to allow for multiple simultaneous key-presses.
	 * @private
	 */
	_handleMovement(event, layer) {
		if ( !this._moveKeys.size ) return;
		 // Get controlled objects
		let objects = layer.placeables.filter(o => o._controlled);
		if ( objects.length === 0 ) return;
		 // Define movement offsets and get moved directions
		const directions = this._moveKeys;
		let dx = 0;
		let dy = 0;
		 // Assign movement offsets
		if ( directions.has("left") ) dx -= 1;
		if ( directions.has("up") ) dy -= 1;
		if ( directions.has("right") ) dx += 1;
		if ( directions.has("down") ) dy += 1;
		this._moveKeys.clear();
		 // Perform the shift or rotation
		layer.moveMany({dx, dy, rotate: event.shiftKey});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle panning the canvas using CTRL + directional keys
	 */
	_handleCanvasPan() {
		 // Determine movement offsets
		let dx = 0;
		let dy = 0;
		if (this._moveKeys.has("left")) dx -= 1;
		if (this._moveKeys.has("up")) dy -= 1;
		if (this._moveKeys.has("right")) dx += 1;
		if (this._moveKeys.has("down")) dy += 1;
		 // Clear the pending set
		this._moveKeys.clear();
		 // Pan by the grid size
		const s = canvas.dimensions.size;
		return canvas.animatePan({
			x: canvas.stage.pivot.x + (dx * s),
			y: canvas.stage.pivot.y + (dy * s),
			duration: 100
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle number key presses
	 * @param {Event} event       The original digit key press
	 * @param {boolean} up        Is it a keyup?
	 * @param {Object}modifiers   What modifiers affect the keypress?
	 * @private
	 */
	_onDigit(event, up, modifiers) {
		if ( modifiers.hasFocus || up || modifiers.isCtrl || modifiers.isShift ) return;
		const num = parseInt(modifiers.key);
		if ( modifiers.isAlt ) ui.hotbar.changePage(num);
		else {
			const slot = ui.hotbar.macros.find(m => m.key === num);
			if ( slot.macro ) slot.macro.execute();
		}
		this._handled.add(modifiers.key);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle "A" keypress events (CTRL only) to select all objects
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onKeyA(event, up, modifiers) {
		if ( up || modifiers.hasFocus ) return;
		if ( !modifiers.isCtrl ) return;
		canvas.activeLayer.controlAll();
		this._handled.add(modifiers.key);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle "C" keypress events to copy data to clipboard
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onKeyC(event, up, modifiers) {
		if ( up || event.repeat || modifiers.hasFocus ) return;
		 // Case 1 - attempt a copy operation on the PlaceablesLayer
		if ( modifiers.isCtrl ) {
			if (window.getSelection().toString() !== "") return;
			if ( !canvas?.ready || !game.user.isGM ) return;
			let layer = canvas.activeLayer;
			if ( layer instanceof PlaceablesLayer ) layer.copyObjects();
		}
		 // Case 2 - Toggle character sheet
		else {
			const token = canvas?.ready && (canvas.tokens.controlled.length === 1) ? canvas.tokens.controlled[0] : null;
			const actor = token ? token.actor : game.user.character;
			if ( actor ) {
				const sheet = actor.sheet;
				if ( sheet.rendered ) {
					if ( sheet._minimized ) sheet.maximize();
					else sheet.close()
				}
				else sheet.render(true);
			}
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle "V" keypress events to paste data from clipboard
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onKeyV(event, up, modifiers ) {
		if ( up || event.repeat || !game.user.isGM || !canvas?.ready || modifiers.hasFocus || !modifiers.isCtrl ) return;
		let layer = canvas.activeLayer;
		if ( layer instanceof PlaceablesLayer ) {
			let pos = canvas.app.renderer.plugins.interaction.mouse.getLocalPosition(canvas.tokens);
			return layer.pasteObjects(pos, {hidden: modifiers.isAlt, snap: !modifiers.isShift});
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle Z Keypress Events to generally undo previous actions
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onKeyZ(event, up, modifiers) {
		if ( up || event.repeat || modifiers.hasFocus || !canvas?.ready ) return;
		 // Undo history for a PlaceablesLayer
		const layer = canvas.activeLayer;
		if ( !(layer instanceof PlaceablesLayer) ) return;
		if ( modifiers.isCtrl && layer.history.length ) {
			layer.undoHistory();
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle presses to keyboard zoom keys
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onKeyZoom(event, up, modifiers ) {
		if ( !canvas?.ready || this.hasFocus || up ) return;
		event.preventDefault();
		const direction = this.zoomKeys[modifiers.key];
		const delta = direction === "in" ? 1.05 : 0.95;
		return canvas.animatePan({scale: delta * canvas.stage.scale.x, duration: 100});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle DELETE Keypress Events
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onDelete(event, up, modifiers) {
		if ( this.hasFocus || up ) return;
		event.preventDefault();
		 // Remove hotbar Macro
		if ( ui.hotbar._hover ) game.user.assignHotbarMacro(null, ui.hotbar._hover);
		 // Delete placeables from Canvas layer
		else if ( canvas?.ready && ( canvas.activeLayer instanceof PlaceablesLayer ) ) {
			return canvas.activeLayer._onDeleteKey(event);
		}
	}
}

/**
 * Specify a rate limit for mouse wheel to gate repeated scrolling.
 * This is especially important for continuous scrolling mice which emit hundreds of events per second.
 * This designates a minimum number of milliseconds which must pass before another wheel event is handled
 * @type {number}
 */
KeyboardManager.MOUSE_WHEEL_RATE_LIMIT = 50;

/**
 * Enumerate the "digit keys"
 * @type {string[]}
 */
KeyboardManager.DIGIT_KEYS = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"];

/**
 * Map keys used for movement
 * @type {Object}
 */
KeyboardManager.MOVEMENT_KEYS = {
	w: ["up"],
	a: ["left"],
	s: ["down"],
	d: ["right"],
	W: ["up"],
	A: ["left"],
	S: ["down"],
	D: ["right"],
	ArrowUp: ["up"],
	ArrowRight: ["right"],
	ArrowDown: ["down"],
	ArrowLeft: ["left"],
	Numpad1: ["down", "left"],
	Numpad2: ["down"],
	Numpad3: ["down", "right"],
	Numpad4: ["left"],
	Numpad6: ["right"],
	Numpad7: ["up", "left"],
	Numpad8: ["up"],
	Numpad9: ["up", "right"],
};

/**
 * Map keys used for canvas zooming
 * @type {Object}
 */
KeyboardManager.ZOOM_KEYS = {
	"PageUp": "in",
	"PageDown": "out",
	"NumpadAdd": "in",
	"NumpadSubtract": "out"
};

/**
 * An abstract interface for managing defined game settings or settings menus for different packages.
 * Each setting is a string key/value pair belonging to a certain package and a certain store scope.
 *
 * When Foundry Virtual Tabletop is initialized, a singleton instance of this class is constructed within the global
 * Game object as as game.settings.
 *
 * @see {@link Game#settings}
 * @see {@link Settings}
 * @see {@link SettingsConfig}
 */
class ClientSettings {
	constructor(worldSettings) {
		 /**
		 * A object of registered game settings for this scope
		 * @type {Map}
		 */
		this.settings = new Map();
		 /**
		 * Registered settings menus which trigger secondary applications
		 * @type {Map}
		 */
		this.menus = new Map();
		 /**
		 * The storage interfaces used for persisting settings
		 * Each storage interface shares the same API as window.localStorage
		 */
		this.storage = new Map([
			["client", window.localStorage],
			["world", new WorldSettingsStorage(worldSettings)]
		]);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a singleton instance of the Game Settings Configuration app
	 * @return {SettingsConfig}
	 */
	get sheet() {
		if ( !this._sheet ) this._sheet = new SettingsConfig();
		return this._sheet;
	}
	 /* -------------------------------------------- */
	 /**
	 * Register a new game setting under this setting scope
	 *
	 * @param {string} module   The namespace under which the setting is registered
	 * @param {string} key      The key name for the setting under the namespace module
	 * @param {Object} data     Configuration for setting data
	 *
	 * @example
	 * // Register a client setting
	 * game.settings.register("myModule", "myClientSetting", {
	 *   name: "Register a Module Setting with Choices",
	 *   hint: "A description of the registered setting and its behavior.",
	 *   scope: "client",     // This specifies a client-stored setting
	 *   config: true,        // This specifies that the setting appears in the configuration view
	 *   type: String,
	 *   choices: {           // If choices are defined, the resulting setting will be a select menu
	 *     "a": "Option A",
	 *     "b": "Option B"
	 *   },
	 *   default: "a",        // The default value for the setting
	 *   onChange: value => { // A callback function which triggers when the setting is changed
	 *     console.log(value)
	 *   }
	 * });
	 *
	 * @example
	 * // Register a world setting
	 * game.settings.register("myModule", "myWorldSetting", {
	 *   name: "Register a Module Setting with a Range slider",
	 *   hint: "A description of the registered setting and its behavior.",
	 *   scope: "world",      // This specifies a world-level setting
	 *   config: true,        // This specifies that the setting appears in the configuration view
	 *   type: Number,
	 *   range: {             // If range is specified, the resulting setting will be a range slider
	 *     min: 0,
	 *     max: 100,
	 *     step: 10
	 *   }
	 *   default: 50,         // The default value for the setting
	 *   onChange: value => { // A callback function which triggers when the setting is changed
	 *     console.log(value)
	 *   }
	 * });
	 */
	register(module, key, data) {
		if ( !module || !key ) throw new Error("You must specify both module and key portions of the setting");
		data["key"] = key;
		data["module"] = module;
		data["scope"] = ["client", "world"].includes(data.scope) ? data.scope : "client";
		this.settings.set(`${module}.${key}`, data);
	}
	 /* -------------------------------------------- */
	 /**
	 * Register a new sub-settings menu
	 *
	 * @param {string} module   The namespace under which the menu is registered
	 * @param {string} key      The key name for the setting under the namespace module
	 * @param {Object} data     Configuration for setting data
	 *
	 * @example
	 * // Define a settings submenu which handles advanced configuration needs
	 * game.settings.registerMenu("myModule", "mySettingsMenu", {
	 *   name: "My Settings Submenu",
	 *   label: "Settings Menu Label",      // The text label used in the button
	 *   hint: "A description of what will occur in the submenu dialog.",
	 *   icon: "fas fa-bars",               // A Font Awesome icon used in the submenu button
	 *   type: MySubmenuApplicationClass,   // A FormApplication subclass which should be created
	 *   restricted: true                   // Restrict this submenu to gamemaster only?
	 * });
	 */
	registerMenu(module, key, data) {
		if ( !module || !key ) throw new Error("You must specify both module and key portions of the menu");
		data.key = `${module}.${key}`;
		data.module = module;
		if ( !data.type || !(data.type.prototype instanceof FormApplication) ) {
			throw new Error("You must provide a menu type that is FormApplication instance or subclass");
		}
		this.menus.set(data.key, data);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the value of a game setting for a certain module and setting key
	 *
	 * @param {string} module   The module namespace under which the setting is registered
	 * @param {string} key      The setting key to retrieve
	 *
	 * @example
	 * // Retrieve the current setting value
	 * game.settings.get("myModule", "myClientSetting");
	 */
	get(module, key) {
		if ( !module || !key ) throw new Error("You must specify both module and key portions of the setting");
		key = `${module}.${key}`;
		if ( !this.settings.has(key) ) throw new Error("This is not a registered game setting");
		 // Get the setting and the correct storage interface
		const setting = this.settings.get(key);
		const storage = this.storage.get(setting.scope);
		 // Get the setting value
		let value = storage.getItem(key);
		value = (value ?? false) ? JSON.parse(value) : setting.default;
		 // Cast the value to a requested type
		return setting.type ? setting.type(value) : value;
	}
	 /* -------------------------------------------- */
	 /**
	 * Set the value of a game setting for a certain module and setting key
	 *
	 * @param {string} module   The module namespace under which the setting is registered
	 * @param {string} key      The setting key to retrieve
	 * @param {any} value       The data to assign to the setting key
	 *
	 * @example
	 * // Update the current value of a setting
	 * game.settings.set("myModule", "myClientSetting", "b");
	 */
	async set(module, key, value) {
		if ( !module || !key ) throw new Error("You must specify both module and key portions of the setting");
		key = `${module}.${key}`;
		if ( !this.settings.has(key) ) throw new Error("This is not a registered game setting");
		 // Obtain the setting data and serialize the value
		const setting = this.settings.get(key);
		if ( value === undefined ) value = setting.default;
		const json = JSON.stringify(value);
		 // Broadcast the setting change to others
		if ( setting.scope === "world" ) {
			await SocketInterface.dispatch("modifyDocument", {
				type: "Setting",
				action: "update",
				data: {key, value: json}
			});
		}
		this._update(setting, key, json);
		 // Return the updated value
		return value;
	}
	 /* -------------------------------------------- */
	 /**
	 * Locally update a setting given a provided key and value
	 * @param {Object} setting
	 * @param {string} key
	 * @param {*} value
	 */
	_update(setting, key, value) {
		const storage = this.storage.get(setting.scope);
		storage.setItem(key, value);
		value = JSON.parse(value);
		if ( setting.onChange instanceof Function ) setting.onChange(value);
		return value;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle changes to a Setting document to apply them to the world setting storage
	 */
	static socketListeners(socket) {
		socket.on('modifyDocument', response => {
			const { request, result } = response;
			if (request.type !== "Setting") return;
			const {key, value} = result;
			const setting = game.settings.settings.get(key);
			switch ( request.action ) {
				case "create":
				case "update":
					game.settings._update(setting, key, value);
					break;
				case "delete":
					const storage = game.settings.storage.get(setting.scope);
					delete storage.data[key];
					break;
			}
		});
	}
}
	/* -------------------------------------------- */
	/**
 * A simple interface for World settings storage which imitates the API provided by localStorage
 */
class WorldSettingsStorage extends Map {
	constructor(settings) {
		super();
		for ( let s of settings ) {
			this.set(s.key, s.value);
		}
	}
	 getItem(key) {
		const value = this.get(key);
		return value !== undefined ? value : null;
	}
	 setItem(key, value) {
		this.set(key, value);
	}
}
	/* -------------------------------------------- */
/**
 * A library of package management commands which are used by various interfaces around the software.
 */
class SetupConfiguration {
	 /**
	 * A reference to the setup URL used under the current route prefix, if any
	 * @return {string}
	 */
	static get setupURL() {
		return getRoute("setup");
	}
	 /* -------------------------------------------- */
	/*  Package Management                          */
	/* -------------------------------------------- */
	 /**
	 * Check with the server whether a package of a certain type is able to be installed or updated.
	 * @param {string} type       The package type to check
	 * @param {string} name       The package name to check
	 * @param {string} manifest   The manifest URL to check
	 * @return {Promise<Object>}  The return manifest
	 */
	static async checkPackage({type="module", name=null, manifest=null}={}) {
		const request = await this.post({action: "checkPackage", type, name, manifest});
		return request.json();
	}
	 /* -------------------------------------------- */
	 /**
	 * Get an Array of available packages of a given type which may be installed
	 * @param {string} type
	 * @return {Promise<Object[]>}
	 */
	static async getPackages({type="system"}={}) {
		const request = await this.post({action: "getPackages", type: type});
		return request.json();
	}
	 /* -------------------------------------------- */
	 /**
	 * Install a Package
	 * @param {string} type       The type of package being installed, in ["module", "system", "world"]
	 * @param {string} name       The canonical package name
	 * @param {string} manifest   The package manifest URL
	 * @return {Promise<object>}  A Promise which resolves to the installed package manifest
	 */
	static async installPackage({type="module", name=null, manifest=null}={}) {
		const request = await this.post({action: "installPackage", type, name, manifest});
		const response = await request.json();
		 // Handle errors
		if ( response.error ) {
			const err = new Error(response.error);
			err.stack = response.stack;
			ui.notifications.error(game.i18n.format("SETUP.InstallFailure", {message: err.message}));
			console.error(err);
			return response;
		}
		 // Handle warnings
		if ( response.warning ) ui.notifications.warn(response.warning);
		ui.notifications.info(game.i18n.format("SETUP.InstallSuccess", {type: type.titleCase(), name: response.name}));
		 // Trigger dependency installation (asynchronously)
		if ( response.dependencies?.length ) {
			this.installDependencies(response);
		}
		 // Update application views
		if ( ui.setup ) await ui.setup.reload();
		return response
	}
	 /* -------------------------------------------- */
	 /**
	 * Install a set of dependency modules which are required by an installed package
	 * @param {object} pkg            The package which was installed that requested dependencies
	 * @return {Promise<void>}
	 */
	static async installDependencies(pkg) {
		const toInstall = [];
		const dependencies = pkg.dependencies || [];
		 // Obtain known package data for requested dependency types
		for ( let d of dependencies ) {
			if (!d.name) continue;
			d.type = d.type || "module";
			const installed = game.data[`${d.type}s`].find(p => p.id === d.name);
			if ( installed ) {
				console.debug(`Dependency ${d.type} ${d.name} is already installed.`);
				continue;
			}
			 // Manifest URL provided
			if (d.manifest) {
				toInstall.push(d);
				continue;
			}
			 // Discover from package listing
			const packages = await InstallPackage.getPackages(d.type);
			const dep = packages.find(p => p.name === d.name);
			if (!dep) {
				console.warn(`Requested dependency ${d.name} not found in ${d.type} directory.`);
				continue;
			}
			d.manifest = dep.version.manifest;
			d.version = dep.version.version;
			toInstall.push(d);
		}
		if ( !toInstall.length ) return;
		 // Prompt the user to confirm installation of dependency packages
		const html = await renderTemplate("templates/setup/install-dependencies.html", {
			dependencies: toInstall
		});
		let agree = false;
		await Dialog.confirm({
			title: game.i18n.localize("SETUP.PackageDependenciesTitle"),
			content: html,
			yes: () => agree = true
		});
		if ( !agree ) return ui.notifications.warn(game.i18n.format("SETUP.PackageDependenciesDecline", {
			title: pkg.title
		}));
		 // Install dependency packages
		for ( let d of toInstall ) {
			await this.installPackage(d);
		}
		return ui.notifications.info(game.i18n.format("SETUP.PackageDependenciesSuccess", {
			title: pkg.title,
			number: toInstall.length
		}));
	}
	 /* -------------------------------------------- */
	 /**
	 * Uninstall a single Package by name and type.
	 * @param {string} type       The type of package being installed, in ["module", "system", "world"]
	 * @param {string} name       The canonical package name
	 * @return {Promise<object>}  A Promise which resolves to the uninstalled package manifest
	 */
	static async uninstallPackage({type="module", name=null}={}) {
		const request = await this.post({action: "uninstallPackage", type, name});
		return request.json();
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the named scopes which can exist for packages.
	 * Scopes are returned in the prioritization order that their content is loaded.
	 * @return {Array<string>}    An array of string package scopes
	 */
	static getPackageScopes() {
		let scopes = ["core", game.system.id];
		scopes = scopes.concat(Array.from(game.modules.keys()));
		scopes.push("world");
		return scopes;
	}
	 /* -------------------------------------------- */
	/*  Helper Functions                            */
	/* -------------------------------------------- */
	 /**
	 * A helper method to submit a POST request to setup configuration with a certain body, returning the JSON response
	 * @param {Object} body         The request body to submit
	 * @return {Promise<Object>}    The response body
	 * @private
	 */
	static async post(body) {
		if (!((game.view === "setup") || (game.ready && game.user.isGM && body.shutdown))) {
			throw new Error("You may not submit POST requests to the setup page while a game world is currently active.");
		}
		const request = await fetch(this.setupURL, {
			method: "POST",
			headers: {'Content-Type': 'application/json'},
			body: JSON.stringify(body),
			redirect: "manual"
		});
		if ( request.status >= 400 ) throw new Error(request.statusText);
		return request;
	}
}
	class SocketInterface {
	 /**
	 * Standardize the way that socket messages are dispatched and their results are handled
	 * @param {string} eventName          The socket event name being handled
	 * @param {SocketRequest} request     Data provided to the Socket event
	 * @return {Promise<SocketResponse>}  A Promise which resolves to the SocketResponse
	 */
	static dispatch(eventName, request) {
		return new Promise((resolve, reject) => {
			game.socket.emit(eventName, request, response => {
				if ( response.error ) {
					const err = this._handleError(response.error);
					reject(err);
				}
				else resolve(response);
			})
		})
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle an error returned from the database, displaying it on screen and in the console
	 * @param {Error} err   The provided Error message
	 * @private
	 */
	static _handleError(err) {
		let error = err instanceof Error ? err : new Error(err.message);
		if ( err.stack ) error.stack = err.stack;
		ui.notifications.error(error.message);
		console.error(error);
		return error;
	}
}

/**
 * A collection of functions related to sorting objects within a parent container.
 */
class SortingHelpers {
	 /**
	 * Given a source object to sort, a target to sort relative to, and an Array of siblings in the container:
	 * Determine the updated sort keys for the source object, or all siblings if a reindex is required.
	 * Return an Array of updates to perform, it is up to the caller to dispatch these updates.
	 * Each update is structured as:
	 * {
	 *   target: object,
	 *   update: {sortKey: sortValue}
	 * }
	 *
	 * @param {*} source            The source object being sorted
	 * @param {*} target            The target object relative which to sort
	 * @param {object[]} siblings   The sorted Array of siblings which share the same sorted container
	 * @param {string} sortKey      The name of the data property within the source object which defines the sort key
	 * @param {boolean} sortBefore  Whether to sort before the target (if true) or after (if false)
	 *
	 * @returns {object[]}          An Array of updates for the caller of the helper function to perform
	 */
	static performIntegerSort(source, {target=null, siblings=[], sortKey="sort", sortBefore=true}={}) {
		 // Ensure the siblings are sorted
		siblings.sort((a, b) => a.data[sortKey] - b.data[sortKey]);
		 // Determine the index target for the sort
		let defaultIdx = sortBefore ? siblings.length : 0;
		let idx = target ? siblings.findIndex(sib => sib === target) : defaultIdx;
		 // Determine the indices to sort between
		let min, max;
		if ( sortBefore ) [min, max] = this._sortBefore(siblings, idx, sortKey);
		else [min, max] = this._sortAfter(siblings, idx, sortKey);
		 // Easiest case - no siblings
		if ( siblings.length === 0 ) {
			return [{
				target: source,
				update: {[sortKey]: CONST.SORT_INTEGER_DENSITY}
			}]
		}
		 // No minimum - sort to beginning
		else if ( Number.isFinite(max) && (min === null) ) {
			return [{
				target: source,
				update: {[sortKey]: max - CONST.SORT_INTEGER_DENSITY}
			}];
		}
		 // No maximum - sort to end
		else if ( Number.isFinite(min) && (max === null) ) {
			return [{
				target: source,
				update: {[sortKey]: min + CONST.SORT_INTEGER_DENSITY}
			}];
		}
		 // Sort between two
		else if ( Number.isFinite(min) && Number.isFinite(max) && (Math.abs(max - min) > 1) ) {
			return [{
				target: source,
				update: {[sortKey]: Math.round(0.5 * (min + max))}
			}];
		}
		 // Reindex all siblings
		else {
			siblings.splice(idx, 0, source);
			return siblings.map((sib, i) => {
				return {
					target: sib,
					update: {[sortKey]: (i+1) * CONST.SORT_INTEGER_DENSITY}
				}
			});
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Given an ordered Array of siblings and a target position, return the [min,max] indices to sort before the target
	 * @private
	 */
	static _sortBefore(siblings, idx, sortKey) {
		let max = siblings[idx] ? siblings[idx].data[sortKey] : null;
		let min = siblings[idx-1] ? siblings[idx-1].data[sortKey] : null;
		return [min, max];
	}
	 /* -------------------------------------------- */
	 /**
	 * Given an ordered Array of siblings and a target position, return the [min,max] indices to sort after the target
	 * @private
	 */
	static _sortAfter(siblings, idx, sortKey) {
		let min = siblings[idx] ? siblings[idx].data[sortKey] : null;
		let max = siblings[idx+1] ? siblings[idx+1].data[sortKey] : null;
		return [min, max];
	}
	 /* -------------------------------------------- */
}
/**
 * A singleton class {@link game#time} which keeps the official Server and World time stamps.
 * Uses a basic implementation of https://www.geeksforgeeks.org/cristians-algorithm/ for synchronization.
 */
class GameTime {
	constructor(socket) {
		 /**
		 * The most recently synchronized timestamps retrieved from the server.
		 * @type {{clientTime: number, serverTime: number, worldTime: number}}
		 */
		this._time = {};
		 /**
		 * The average one-way latency across the most recent 5 trips
		 * @type {number}
		 */
		this._dt = 0;
		 /**
		 * The most recent five synchronization durations
		 * @type {number[]}
		 */
		this._dts = [];
		 // Perform an initial sync
		if ( socket ) this.sync(socket);
	}
	 /* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /**
	 * The current server time based on the last synchronization point and the approximated one-way latency.
	 * @return {number}
	 */
	get serverTime() {
		const t1 = Date.now();
		const dt = t1 - this._time.clientTime;
		if ( dt > GameTime.SYNC_INTERVAL_MS ) this.sync();
		return this._time.serverTime + dt;
	}
	 /* -------------------------------------------- */
	 /**
	 * The current World time based on the last recorded value of the core.time setting
	 * @return {number}
	 */
	get worldTime() {
		return this._time.worldTime;
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /**
	 * Advance the game time by a certain number of seconds
	 * @param {number} seconds        The number of seconds to advance (or rewind if negative) by
	 * @return {Promise<number>}      The new game time
	 */
	async advance(seconds) {
		return game.settings.set("core", "time", this.worldTime + seconds);
	}
	 /* -------------------------------------------- */
	 /**
	 * Synchronize the local client game time with the official time kept by the server
	 * @return {Promise<GameTime>}
	 */
	async sync(socket) {
		socket = socket ?? game.socket;
		 // Get the official time from the server
		const t0 = Date.now();
		const time = await new Promise(resolve => socket.emit("time", resolve));
		const t1 = Date.now();
		 // Adjust for trip duration
		if ( this._dts.length >= 5 ) this._dts.unshift();
		this._dts.push(t1 - t0);
		 // Re-compute the average one-way duration
		this._dt = Math.round(this._dts.reduce((total, t) => total + t, 0) / (this._dts.length * 2));
		 // Adjust the server time and return the adjusted time
		time.clientTime = t1 - this._dt;
		this._time = time;
		console.log(`${vtt} | Synchronized official game time in ${this._dt}ms`);
		return this;
	}
	 /* -------------------------------------------- */
	/*  Event Handlers and Callbacks                */
	/* -------------------------------------------- */
	 /**
	 * Handle follow-up actions when the official World time is changed
	 * @param {number} worldTime  The new canonical World time.
	 */
	onUpdateWorldTime(worldTime) {
		const dt = worldTime - this._time.worldTime;
		this._time.worldTime = worldTime;
		Hooks.callAll("updateWorldTime", worldTime, dt);
		if ( CONFIG.debug.time ) console.log(`The world time advanced by ${dt} seconds, and is now ${worldTime}.`);
	}
}

/**
 * The amount of time to delay before re-syncing the official server time.
 * @type {number}
 */
GameTime.SYNC_INTERVAL_MS = 1000 * 60 * 5;

/**
 * Export data content to be saved to a local file
 * @param {string} data       Data content converted to a string
 * @param {string} type       The type of
 * @param {string} filename   The filename of the resulting download
 */
function saveDataToFile(data, type, filename) {
	const blob = new Blob([data], {type: type});
	 // Create an element to trigger the download
	let a = document.createElement('a');
	a.href = window.URL.createObjectURL(blob);
	a.download = filename;
	 // Dispatch a click event to the element
	a.dispatchEvent(new MouseEvent("click", {bubbles: true, cancelable: true, view: window}));
	setTimeout(() => window.URL.revokeObjectURL(a.href), 100);
}
	/* -------------------------------------------- */
	/**
 * Read text data from a user provided File object
 * @param {File} file           A File object
 * @return {Promise.<String>}   A Promise which resolves to the loaded text data
 */
function readTextFromFile(file) {
	const reader = new FileReader();
	return new Promise((resolve, reject) => {
		reader.onload = ev => {
			resolve(reader.result);
		};
		reader.onerror = ev => {
			reader.abort();
			reject();
		};
		reader.readAsText(file);
	});
}
	/* -------------------------------------------- */
	/**
 * Retrieve an Entity or Embedded Entity by its Universally Unique Identifier (uuid).
 * @param {string} uuid   The uuid of the Entity or Embedded Entity to retrieve
 * @return {Promise<Entity|Object|null>}
 */
async function fromUuid(uuid) {
	const parts = uuid.split(".");
	 // Compendium Entries
	if ( parts[0] === "Compendium" ) {
		if ( parts.length < 4 ) throw new Error(`Incorrect UUID format for Compendium entry: ${uuid}`);
		const [prefix, scope, packName, entryId] = parts;
		const pack = game.packs.get(`${scope}.${packName}`);
		return pack.getEntity(entryId);
	}
	 // World Entities
	const [entityName, entityId, embeddedName, embeddedId] = parts;
	const entity = CONFIG[entityName].entityClass.collection.get(entityId);
	if ( entity === null ) return null;
	 // Embedded Entities
	if ( parts.length === 4 ) {
		return entity.getEmbeddedEntity(embeddedName, embeddedId);
	}
	else return entity;
}

/**
 * A helper class to provide common functionality for working with HTML5 video objects
 * A singleton instance of this class is available as ``game.video``
 */
class VideoHelper {
	constructor() {
		if ( game.video instanceof this.constructor ) {
			throw new Error("You may not re-initialize the singleton VideoHelper. Use game.video instead.");
		}
		 /**
		 * A collection of HTML5 video objects which are currently active within the FVTT page
		 * @type {Object}
		 */
		this.videos = [];
		 /**
		 * A user gesture must be registered before video playback can begin.
		 * This Set records the video elements which await such a gesture.
		 * @type {Set}
		 */
		this.pending = new Set();
		 /**
		 * A mapping of base64 video thumbnail images
		 * @type {Map<string,string>}
		 */
		this.thumbs = new Map();
		 /**
		 * A flag for whether video playback is currently locked by awaiting a user gesture
		 * @type {boolean}
		 */
		 this.locked = true;
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 static hasVideoExtension(src) {
		let rgx = new RegExp("(\\."+CONST.VIDEO_FILE_EXTENSIONS.join("|\\.")+")(\\?.*)?", "i");
		return rgx.test(src);
	}
	 /* -------------------------------------------- */
	 /**
	 * Play a single video source
	 * If playback is not yet enabled, add the video to the pending queue
	 * @param {HTMLElement} video   The VIDEO element to play
	 */
	play(video) {
		video.play().catch(err => {
			if ( this.locked ) this.pending.add(video);
			else throw new Error(err.toString());
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Register an event listener to await the first mousemove gesture and begin playback once observed
	 * A user interaction must involve a mouse click or keypress.
	 * Listen for any of these events, and handle the first observed gesture.
	 */
	awaitFirstGesture() {
		if ( !this.locked ) return;
		const interactions = ['contextmenu', 'auxclick', 'mousedown', 'mouseup', 'keydown'];
		interactions.forEach(event => document.addEventListener(event, this._onFirstGesture.bind(this), {once: true}));
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the first observed user gesture
	 * We need a slight delay because unfortunately Chrome is stupid and doesn't always acknowledge the gesture fast enough.
	 * @param {Event} event   The mouse-move event which enables playback
	 */
	_onFirstGesture(event) {
		if ( !this.pending.size ) return;
		console.log(`${vtt} | Activating pending video playback with user gesture.`);
		this.locked = false;
		for ( let video of Array.from(this.pending) ) {
			this.play(video);
		}
		this.pending.clear();
	}
	 /* -------------------------------------------- */
	 /**
	 * Create and cache a static thumbnail to use for the video.
	 * The thumbnail is cached using the video file path or URL.
	 * @param {string} src        The source video URL
	 * @param {object} options    Thumbnail creation options, including width and height
	 * @return {Promise<string>}  The created and cached base64 thumbnail image
	 */
	async createThumbnail(src, options) {
		const t = await ImageHelper.createThumbnail(src, options);
		this.thumbs.set(src, t.thumb);
		return t.thumb;
	}
}

let _appId = 0;
let _maxZ = 100;

const MIN_WINDOW_WIDTH = 200;
const MIN_WINDOW_HEIGHT = 50;

/**
 * The standard application window that is rendered for a large variety of UI elements in Foundry VTT.
 * @interface
 *
 * @param {Object} options                      Configuration options which control how the application is rendered.
 *                                              Application subclasses may add additional supported options, but the
 *                                              following configurations are supported for all Applications. The values
 *                                              passed to the constructor are combined with the defaultOptions defined
 *                                              at the class level.
 * @param {string} options.baseApplication      A named "base application" which generates an additional hook
 * @param {number} options.width                The default pixel width for the rendered HTML
 * @param {number} options.height               The default pixel height for the rendered HTML
 * @param {number} options.top                  The default offset-top position for the rendered HTML
 * @param {number} options.left                 The default offset-left position for the rendered HTML
 * @param {boolean} options.popOut              Whether to display the application as a pop-out container
 * @param {boolean} options.minimizable         Whether the rendered application can be minimized (popOut only)
 * @param {boolean} options.resizable           Whether the rendered application can be drag-resized (popOut only)
 * @param {string} options.id                   The default CSS id to assign to the rendered HTML
 * @param {Array.<string>} options.classes      An array of CSS string classes to apply to the rendered HTML
 * @param {string} options.title                A default window title string (popOut only)
 * @param {string} options.template             The default HTML template path to render for this Application
 * @param {Array.<string>} options.scrollY      A list of unique CSS selectors which target containers that should
 *                                              have their vertical scroll positions preserved during a re-render.
 *
 * Hooks:
 *   renderApplication
 *   closeApplication
 *   getApplicationHeaderButtons
 */
class Application {
	constructor(options={}) {
		 /**
		 * The options provided to this application upon initialization
		 * @type {Object}
		 */
		this.options = mergeObject(this.constructor.defaultOptions, options, {
			insertKeys: true,
			insertValues: true,
			overwrite: true,
			inplace: false
		});
		 /**
		 * The application ID is a unique incrementing integer which is used to identify every application window
		 * drawn by the VTT
		 * @type {number}
		 */
		this.appId = _appId += 1;
		 /**
		 * An internal reference to the HTML element this application renders
		 * @type {jQuery}
		 */
		this._element = null;
		 /**
		 * Track the current position and dimensions of the Application UI
		 * @type {Object}
		 */
		this.position = {
			width: this.options.width,
			height: this.options.height,
			left: this.options.left,
			top: this.options.top,
			scale: this.options.scale
		};
		 /**
		 * DragDrop workflow handlers which are active for this Application
		 * @type {DragDrop[]}
		 */
		this._dragDrop = this._createDragDropHandlers();
		 /**
		 * Tab navigation handlers which are active for this Application
		 * @type {Tabs[]}
		 */
		this._tabs = this._createTabHandlers();
		 /**
		 * SearchFilter handlers which are active for this Application
		 * @type {SearchFilter[]}
		 */
		this._searchFilters = this._createSearchFilters();
		 /**
		 * Track whether the Application is currently minimized
		 * @type {boolean}
		 * @private
		 */
		this._minimized = false;
		 /**
		 * Track the render state of the Application
		 * @see {Application.RENDER_STATES}
		 * @type {number}
		 * @private
		 */
		this._state = Application.RENDER_STATES.NONE;
		 /**
		 * Track the most recent scroll positions for any vertically scrolling containers
		 * @type {Object|null}
		 */
		this._scrollPositions = null;
	}
	/* -------------------------------------------- */
	 /**
	 * Create drag-and-drop workflow handlers for this Application
	 * @return {DragDrop[]}     An array of DragDrop handlers
	 * @private
	 */
	_createDragDropHandlers() {
		return this.options.dragDrop.map(d => {
			d.permissions = {
				dragstart: this._canDragStart.bind(this),
				drop: this._canDragDrop.bind(this)
			};
			d.callbacks = {
				dragstart: this._onDragStart.bind(this),
				dragover: this._onDragOver.bind(this),
				drop: this._onDrop.bind(this)
			};
			return new DragDrop(d);
		});
	}
	/* -------------------------------------------- */
	 /**
	 * Create tabbed navigation handlers for this Application
	 * @return {Tabs[]}     An array of Tabs handlers
	 * @private
	 */
	_createTabHandlers() {
		return this.options.tabs.map(t => {
			t.callback = this._onChangeTab.bind(this);
			return new Tabs(t);
		});
	}
	/* -------------------------------------------- */
	 /**
	 * Create search filter handlers for this Application
	 * @return {SearchFilter[]}  An array of SearchFilter handlers
	 * @private
	 */
	_createSearchFilters() {
		return this.options.filters.map(f => {
			f.callback = this._onSearchFilter.bind(this);
			return new SearchFilter(f);
		})
	}
	/* -------------------------------------------- */
	 /**
	 * Assign the default options configuration which is used by this Application class. The options and values defined
	 * in this object are merged with any provided option values which are passed to the constructor upon initialization.
	 * Application subclasses may include additional options which are specific to their usage.
	 */
	static get defaultOptions() {
		return {
			baseApplication: null,
			width: null,
			height: null,
			top: null,
			left: null,
			popOut: true,
			minimizable: true,
			resizable: false,
			id: "",
			classes: [],
			dragDrop: [],
			tabs: [],
			filters: [],
			title: "",
			template: null,
			scrollY: []
		};
	};
	 /* -------------------------------------------- */
	 /**
	 * Return the CSS application ID which uniquely references this UI element
	 */
	get id() {
		return this.options.id ? this.options.id : `app-${this.appId}`;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the active application element, if it currently exists in the DOM
	 * @type {jQuery|HTMLElement}
	 */
	get element() {
		if ( this._element ) return this._element;
		let selector = "#"+this.id;
		return $(selector);
	}
	 /* -------------------------------------------- */
	 /**
	 * The path to the HTML template file which should be used to render the inner content of the app
	 * @type {string}
	 */
	get template() {
		return this.options.template;
	}
	 /* -------------------------------------------- */
	 /**
	 * Control the rendering style of the application. If popOut is true, the application is rendered in its own
	 * wrapper window, otherwise only the inner app content is rendered
	 * @type {boolean}
	 */
	get popOut() {
		return (this.options.popOut !== undefined) ? Boolean(this.options.popOut) : true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a flag for whether the Application instance is currently rendered
	 * @type {boolean}
	 */
	get rendered() {
		return this._state === Application.RENDER_STATES.RENDERED;
	}
	 /* -------------------------------------------- */
	 /**
	 * An Application window should define its own title definition logic which may be dynamic depending on its data
	 * @type {string}
	 */
	get title() {
		return game.i18n.localize(this.options.title);
	}
	 /* -------------------------------------------- */
	/* Application rendering
	/* -------------------------------------------- */
	 /**
	 * An application should define the data object used to render its template.
	 * This function may either return an Object directly, or a Promise which resolves to an Object
	 * If undefined, the default implementation will return an empty object allowing only for rendering of static HTML
	 *
	 * @return {Object|Promise}
	 */
	getData(options={}) {
		return {};
	}
	/* -------------------------------------------- */
	 /**
	 * Render the Application by evaluating it's HTML template against the object of data provided by the getData method
	 * If the Application is rendered as a pop-out window, wrap the contained HTML in an outer frame with window controls
	 *
	 * @param {boolean} force   Add the rendered application to the DOM if it is not already present. If false, the
	 *                          Application will only be re-rendered if it is already present.
	 * @param {Object} options  Additional rendering options which are applied to customize the way that the Application
	 *                          is rendered in the DOM.
	 *
	 * @param {number} options.left           The left positioning attribute
	 * @param {number} options.top            The top positioning attribute
	 * @param {number} options.width          The rendered width
	 * @param {number} options.height         The rendered height
	 * @param {number} options.scale          The rendered transformation scale
	 * @param {boolean} options.log           Whether to display a log message that the Application was rendered
	 * @param {string} options.renderContext  A context-providing string which suggests what event triggered the render
	 * @param {*} options.renderData          The data change which motivated the render request
	 *
	 */
	render(force=false, options={}) {
	 this._render(force, options).catch(err => {
		 err.message = `An error occurred while rendering ${this.constructor.name} ${this.appId}: ${err.message}`;
		 console.error(err);
		 this._state = Application.RENDER_STATES.ERROR;
		});
	 return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * An asynchronous inner function which handles the rendering of the Application
	 * @param {boolean} force     Render and display the application even if it is not currently displayed.
	 * @param {Object} options    Provided rendering options, see the render function for details
	 * @return {Promise<void>}    A Promise that resolves to the Application once rendering is complete
	 * @private
	 */
	async _render(force=false, options={}) {
		 // Do not render under certain conditions
		const states = Application.RENDER_STATES;
		if ( [states.CLOSING, states.RENDERING].includes(this._state) ) return;
		if ( !force && (this._state <= states.NONE) ) return;
		if ( [states.NONE, states.CLOSED, states.ERROR].includes(this._state) ) {
			console.log(`${vtt} | Rendering ${this.constructor.name}`);
		}
		this._state = states.RENDERING;
		 // Get the existing HTML element and application data used for rendering
		const element = this.element;
		const data = await this.getData(options);
		 // Store scroll positions
		const scrollY = this.options.scrollY;
		if ( element.length && scrollY ) this._saveScrollPositions(element, scrollY);
		 // Render the inner content
		const inner = await this._renderInner(data, options);
		let html = inner;
		 // If the application already exists in the DOM, replace the inner content
		if ( element.length ) this._replaceHTML(element, html, options);
		 // Otherwise render a new app
		else {
			 // Wrap a popOut application in an outer frame
			if ( this.popOut ) {
				html = await this._renderOuter(options);
				html.find('.window-content').append(inner);
				ui.windows[this.appId] = this;
			}
			 // Add the HTML to the DOM and record the element
			this._injectHTML(html, options);
		}
		 // Activate event listeners on the inner HTML
		this.activateListeners(inner);
		 // Set the application position (if it's not currently minimized)
		if ( !this._minimized ) this.setPosition(this.position);
		 // Restore scroll positions
		if ( scrollY ) this._restoreScrollPositions(html, scrollY);
		 // Dispatch Hooks for rendering the base and subclass applications
		for ( let cls of this.constructor._getInheritanceChain() ) {
			Hooks.call(`render${cls.name}`, this, html, data);
		}
		this._state = states.RENDERED;
	}
	/* -------------------------------------------- */
	 /**
	 * Return the inheritance chain for this Application class up to (and including) it's base Application class.
	 * @return {Application[]}
	 * @private
	 */
	static _getInheritanceChain() {
		const parents = getParentClasses(this);
		const base = this.defaultOptions.baseApplication;
		const chain = [this];
		for ( let cls of parents ) {
			chain.push(cls);
			if ( cls.name === base ) break;
		}
		return chain;
	}
	/* -------------------------------------------- */
	 /**
	 * Persist the scroll positions of containers within the app before re-rendering the content
	 * @param {jQuery} html           The HTML object being traversed
	 * @param {string[]} selectors    CSS selectors which designate elements to save
	 * @private
	 */
	_saveScrollPositions(html, selectors) {
		selectors = selectors || [];
		this._scrollPositions = selectors.reduce((pos, sel) => {
			const el = html.find(sel);
			if ( el.length === 1 ) pos[sel] = el[0].scrollTop;
			return pos;
		}, {});
	}
	/* -------------------------------------------- */
	 /**
	 * Restore the scroll positions of containers within the app after re-rendering the content
	 * @param {jQuery} html           The HTML object being traversed
	 * @param {string[]} selectors    CSS selectors which designate elements to restore
	 * @private
	 */
	_restoreScrollPositions(html, selectors) {
		const positions = this._scrollPositions || {};
		for ( let sel of selectors ) {
			const el = html.find(sel);
			if ( el.length === 1 ) el[0].scrollTop = positions[sel] || 0;
		}
	}
	/* -------------------------------------------- */
	 /**
	 * Render the outer application wrapper
	 * @return {Promise.<HTMLElement>}   A promise resolving to the constructed jQuery object
	 * @private
	 */
	async _renderOuter(options) {
		 // Gather basic application data
		const classes = options.classes || this.options.classes;
		const windowData = {
			id: this.id,
			classes: classes.join(" "),
			appId: this.appId,
			title: this.title,
			headerButtons: this._getHeaderButtons()
		};
		 // Render the template and return the promise
		let html = await renderTemplate("templates/app-window.html", windowData);
		html = $(html);
		 // Activate header button click listeners after a slight timeout to prevent immediate interaction
		setTimeout(() => {
			html.find(".header-button").click(event => {
				event.preventDefault();
				const button = windowData.headerButtons.find(b => event.currentTarget.classList.contains(b.class));
				button.onclick(event);
			});
		}, 500);
		 // Make the outer window draggable
		const header = html.find('header')[0];
		new Draggable(this, html, header, this.options.resizable);
		 // Make the outer window minimizable
		if ( this.options.minimizable ) {
			header.addEventListener('dblclick', this._onToggleMinimize.bind(this));
		}
		 // Set the outer frame z-index
		if ( Object.keys(ui.windows).length === 0 ) _maxZ = 100 - 1;
		html.css({zIndex: Math.min(++_maxZ, 9999)});
		 // Return the outer frame
		return html;
	}
	 /* -------------------------------------------- */
	 /**
	 * Render the inner application content
	 * @param {Object} data         The data used to render the inner template
	 * @return {Promise.<jQuery>}   A promise resolving to the constructed jQuery object
	 * @private
	 */
	async _renderInner(data, options) {
		let html = await renderTemplate(this.template, data);
		if ( html === "" ) throw new Error(`No data was returned from template ${this.template}`);
		return $(html);
	}
	/* -------------------------------------------- */
	 /**
	 * Customize how inner HTML is replaced when the application is refreshed
	 * @param {HTMLElement|jQuery} element  The original HTML element
	 * @param {HTMLElement|jQuery} html     New updated HTML
	 * @private
	 */
	_replaceHTML(element, html, options) {
	 if ( !element.length ) return;
		// For pop-out windows update the inner content and the window title
		if ( this.popOut ) {
			element.find('.window-content').html(html);
			element.find('.window-title').text(this.title);
		}
		 // For regular applications, replace the whole thing
		else {
			element.replaceWith(html);
			this._element = html;
		}
	}
	/* -------------------------------------------- */
	 /**
	 * Customize how a new HTML Application is added and first appears in the DOC
	 * @param html {jQuery}
	 * @private
	 */
	_injectHTML(html, options) {
		$('body').append(html);
		this._element = html;
		html.hide().fadeIn(200);
	}
	/* -------------------------------------------- */
	 /**
	 * Specify the set of config buttons which should appear in the Application header.
	 * Buttons should be returned as an Array of objects.
	 * The header buttons which are added to the application can be modified by the getApplicationHeaderButtons hook.
	 * @typedef {{label: string, class: string, icon: string, onclick: Function|null}} ApplicationHeaderButton
	 * @fires Application#hook:getApplicationHeaderButtons
	 * @return {ApplicationHeaderButton[]}
	 * @private
	 */
	_getHeaderButtons() {
		const buttons = [
			{
				label: "Close",
				class: "close",
				icon: "fas fa-times",
				onclick: () => this.close()
			}
		];
		for ( let cls of this.constructor._getInheritanceChain() ) {
			Hooks.call(`get${cls.name}HeaderButtons`, this, buttons);
		}
		return buttons;
	}
	/* -------------------------------------------- */
	/* Event Listeners and Handlers
	/* -------------------------------------------- */
	 /**
	 * Once the HTML for an Application has been rendered, activate event listeners which provide interactivity for
	 * the application
	 * @param html {jQuery}
	 */
	activateListeners(html) {
		const el = html[0];
		this._tabs.forEach(t => t.bind(el));
		this._dragDrop.forEach(d => d.bind(el));
		this._searchFilters.forEach(f => f.bind(el));
	}
	/* -------------------------------------------- */
	 /**
	 * Handle changes to the active tab in a configured Tabs controller
	 * @param {MouseEvent} event    A left click event
	 * @param {Tabs} tabs           The Tabs controller
	 * @param {string} active       The new active tab name
	 * @private
	 */
	_onChangeTab(event, tabs, active) {
		this.setPosition();
	}
	/* -------------------------------------------- */
	 /**
	 * Handle changes to search filtering controllers which are bound to the Application
	 * @param {KeyboardEvent} event   The key-up event from keyboard input
	 * @param {RegExp} query          The regular expression to test against
	 * @param {HTMLElement} html      The HTML element which should be filtered
	 * @private
	 */
	_onSearchFilter(event, query, html) {}
	/* -------------------------------------------- */
	 /**
	 * Define whether a user is able to begin a dragstart workflow for a given drag selector
	 * @param {string} selector       The candidate HTML selector for dragging
	 * @return {boolean}              Can the current user drag this selector?
	 * @private
	 */
	_canDragStart(selector) {
		return game.user.isGM;
	}
	/* -------------------------------------------- */
	 /**
	 * Define whether a user is able to conclude a drag-and-drop workflow for a given drop selector
	 * @param {string} selector       The candidate HTML selector for the drop target
	 * @return {boolean}              Can the current user drop on this selector?
	 * @private
	 */
	_canDragDrop(selector) {
		return game.user.isGM;
	}
	/* -------------------------------------------- */
	 /**
	 * Callback actions which occur at the beginning of a drag start workflow.
	 * @param {DragEvent} event       The originating DragEvent
	 * @private
	 */
	_onDragStart(event) {}
	/* -------------------------------------------- */
	 /**
	 * Callback actions which occur when a dragged element is over a drop target.
	 * @param {DragEvent} event       The originating DragEvent
	 * @private
	 */
	_onDragOver(event) {}
	/* -------------------------------------------- */
	 /**
	 * Callback actions which occur when a dragged element is dropped on a target.
	 * @param {DragEvent} event       The originating DragEvent
	 * @private
	 */
	_onDrop(event) {}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /**
	 * Bring the application to the top of the rendering stack
	 */
	bringToTop() {
		const element = this.element[0];
		const z = document.defaultView.getComputedStyle(element).zIndex;
		if ( z < _maxZ ) {
			element.style.zIndex = Math.min(++_maxZ, 99999);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Close the application and un-register references to it within UI mappings
	 * This function returns a Promise which resolves once the window closing animation concludes
	 * @return {Promise<void>}    A Promise which resolves once the application is closed
	 */
	async close(options={}) {
		const states = Application.RENDER_STATES;
		if ( !options.force && ![states.RENDERED, states.ERROR].includes(this._state) ) return;
		this._state = states.CLOSING;
		 // Get the element
		let el = this.element;
		if ( !el ) return this._state = states.CLOSED;
		el.css({minHeight: 0});
		 // Dispatch Hooks for closing the base and subclass applications
		for ( let cls of this.constructor._getInheritanceChain() ) {
			Hooks.call(`close${cls.name}`, this, el);
		}
		 // Animate closing the element
		return new Promise(resolve => {
			el.slideUp(200, () => {
				el.remove();
				 // Clean up data
				this._element = null;
				delete ui.windows[this.appId];
				this._minimized = false;
				this._scrollPositions = null;
				this._state = states.CLOSED;
				resolve();
			});
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Minimize the pop-out window, collapsing it to a small tab
	 * Take no action for applications which are not of the pop-out variety or apps which are already minimized
	 * @return {Promise<void>}  A Promise which resolves once the minimization action has completed
	 */
	async minimize() {
		if ( !this.popOut || [true, null].includes(this._minimized) ) return;
		this._minimized = null;
		 // Get content
		let window = this.element,
				header = window.find('.window-header'),
				content = window.find('.window-content');
		 // Remove minimum width and height styling rules
		window.css({minWidth: 100, minHeight: 30});
		 // Slide-up content
		content.slideUp(100);
		 // Slide up window height
		return new Promise((resolve) => {
			window.animate({height: `${header[0].offsetHeight+1}px`}, 100, () => {
				header.children().not(".window-title").not(".close").hide();
				window.animate({width: MIN_WINDOW_WIDTH}, 100, () => {
					window.addClass("minimized");
					this._minimized = true;
					resolve();
				});
			});
		})
	}
	 /* -------------------------------------------- */
	 /**
	 * Maximize the pop-out window, expanding it to its original size
	 * Take no action for applications which are not of the pop-out variety or are already maximized
	 * @return {Promise<void>}    A Promise which resolves once the maximization action has completed
	 */
	async maximize() {
		if ( !this.popOut || [false, null].includes(this._minimized) ) return;
		this._minimized = null;
		 // Get content
		let window = this.element,
				header = window.find('.window-header'),
				content = window.find('.window-content');
		 // Expand window
		return new Promise((resolve) => {
			window.animate({width: this.position.width, height: this.position.height}, 100, () => {
				header.children().show();
				content.slideDown(100, () => {
					window.removeClass("minimized");
					this._minimized = false;
					window.css({minWidth: '', minHeight: ''});
					this.setPosition(this.position);
					resolve();
				});
			});
		})
	}
	 /* -------------------------------------------- */
	 /**
	 * Set the application position and store it's new location.
	 *
	 * @param {number|null} left            The left offset position in pixels
	 * @param {number|null} top             The top offset position in pixels
	 * @param {number|null} width           The application width in pixels
	 * @param {number|string|null} height   The application height in pixels
	 * @param {number|null} scale           The application scale as a numeric factor where 1.0 is default
	 *
	 * @returns {{left: number, top: number, width: number, height: number, scale:number}}
	 * The updated position object for the application containing the new values
	 */
	setPosition({left, top, width, height, scale}={}) {
		if ( !this.popOut ) return; // Only configure position for popout apps
		const el = this.element[0];
		const p = this.position;
		const pop = this.popOut;
		const styles = window.getComputedStyle(el);
		 // If Height is "auto" unset current preference
		if ( (height === "auto") || (this.options.height === "auto") ) {
			el.style.height = "";
			height = null;
		}
		 // Update width if an explicit value is passed, or if no width value is set on the element
		if ( !el.style.width || width ) {
			const tarW = width || el.offsetWidth;
			const minW = parseInt(styles.minWidth) || (pop ? MIN_WINDOW_WIDTH : 0);
			const maxW = el.style.maxWidth || window.innerWidth;
			p.width = width = Math.clamped(tarW, minW, maxW);
			el.style.width = width+"px";
			if ( (width + p.left) > window.innerWidth ) left = p.left;
		}
		width = el.offsetWidth;
		 // Update height if an explicit value is passed, or if no height value is set on the element
		if ( !el.style.height || height ) {
			const tarH = height || (el.offsetHeight + 1);
			const minH = parseInt(styles.minHeight) || (pop ? MIN_WINDOW_HEIGHT : 0);
			const maxH = el.style.maxHeight || window.innerHeight;
			p.height = height = Math.clamped(tarH, minH, maxH);
			el.style.height = height+"px";
			if ( (height + p.top) > window.innerHeight ) top = p.top;
		}
		height = el.offsetHeight;
		 // Update Left
		if ( (pop && !el.style.left) || Number.isFinite(left) ) {
			const tarL = Number.isFinite(left) ? left : (window.innerWidth - width) / 2;
			const maxL = Math.max(window.innerWidth - width, 0);
			p.left = left = Math.clamped(tarL, 0, maxL);
			el.style.left = left+"px";
		}
		 // Update Top
		if ( (pop && !el.style.top) || Number.isFinite(top) ) {
			const tarT = Number.isFinite(top) ? top : (window.innerHeight - height) / 2;
			const maxT = Math.max(window.innerHeight - height, 0);
			p.top = top = Math.clamped(tarT, 0, maxT);
			el.style.top = p.top+"px";
		}
		 // Update Scale
		if ( scale ) {
			p.scale = Math.max(scale, 0);
			if ( scale === 1 ) el.style.transform = "";
			else el.style.transform = `scale(${scale})`;
		}
		 // Return the updated position object
		return p;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle application minimization behavior - collapsing content and reducing the size of the header
	 * @param {Event} ev
	 * @private
	 */
	_onToggleMinimize(ev) {
		ev.preventDefault();
		if ( this._minimized ) this.maximize(ev);
		else this.minimize(ev);
	}
	 /* -------------------------------------------- */
	 /**
	 * Additional actions to take when the application window is resized
	 * @param {Event} event
	 * @private
	 */
	_onResize(event) {}
}

/* -------------------------------------------- */

Application.RENDER_STATES = {
	CLOSING: -2,
	CLOSED: -1,
	NONE: 0,
	RENDERING: 1,
	RENDERED: 2,
	ERROR: 3
};
Object.freeze(Application.RENDER_STATES);

/**
 * An abstract pattern for defining an Application responsible for updating some object using an HTML form
 *
 * A few critical assumptions:
 * 1) This application is used to only edit one object at a time
 * 2) The template used contains one (and only one) HTML form as it's outer-most element
 * 3) This abstract layer has no knowledge of what is being updated, so the implementation must define _updateObject
 *
 * @extends {Application}
 * @abstract
 * @interface
 *
 * @param object {*}                    Some object or entity which is the target to be updated.
 * @param [options] {Object}            Additional options which modify the rendering of the sheet.
 */
class FormApplication extends Application {
	constructor(object={}, options={}) {
		super(options);
		 /**
		 * The object target which we are using this form to modify
		 * @type {*}
		 */
		this.object = object;
		 /**
		 * A convenience reference to the form HTMLElement
		 * @type {HTMLElement}
		 */
		this.form = null;
		 /**
		 * Keep track of any FilePicker instances which are associated with this form
		 * The values of this Array are inner-objects with references to the FilePicker instances and other metadata
		 * @type {FilePicker[]}
		 */
		this.filepickers = [];
		 /**
		 * Keep track of any mce editors which may be active as part of this form
		 * The values of this object are inner-objects with references to the MCE editor and other metadata
		 * @type {Object<string, object>}
		 */
		this.editors = {};
	}
	/* -------------------------------------------- */
	 /**
	 * Assign the default options which are supported by the entity edit sheet.
	 * In addition to the default options object supported by the parent Application class, the Form Application
	 * supports the following additional keys and values:
	 *
	 * @returns {Object} options                    The default options for this FormApplication class, see Application
	 * @returns {boolean} options.closeOnSubmit     Whether to automatically close the application when it's contained
	 *                                              form is submitted. Default is true.
	 * @returns {boolean} options.submitOnChange    Whether to automatically submit the contained HTML form when an input
	 *                                              or select element is changed. Default is false.
	 * @returns {boolean} options.submitOnClose     Whether to automatically submit the contained HTML form when the
	 *                                              application window is manually closed. Default is false.
	 * @returns {boolean} options.editable          Whether the application form is editable - if true, it's fields will
	 *                                              be unlocked and the form can be submitted. If false, all form fields
	 *                                              will be disabled and the form cannot be submitted. Default is true.
	 */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 classes: ["form"],
			closeOnSubmit: true,
			submitOnChange: false,
			submitOnClose: false,
			editable: true
		});
	}
	/* -------------------------------------------- */
	 /**
	 * Is the Form Application currently editable?
	 * @type {boolean}
	 */
	get isEditable() {
	 return this.options.editable;
	}
	/* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */
	 /** @override */
	getData(options={}) {
		return {
			object: duplicate(this.object),
			options: this.options,
			title: this.title
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _render(...args) {
		 // Identify the focused element
		let focus = this.element.find(":focus");
		focus = focus.length ? focus[0] : null;
		 // Render the application and restore focus
		await super._render(...args);
		if ( focus && focus.name ) {
			const input = this.form[focus.name];
			if ( input && (input.focus instanceof Function) ) input.focus();
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _renderInner(...args) {
		const html = await super._renderInner(...args);
		this.form = html[0] instanceof HTMLFormElement ? html[0] : html.find("form")[0];
		return html;
	}
	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /**
	 * Activate the default set of listeners for the Entity sheet
	 * These listeners handle basic stuff like form submission or updating images
	 *
	 * @param html {JQuery}     The rendered template ready to have listeners attached
	 */
	activateListeners(html) {
	 super.activateListeners(html);
		 // Disable input fields if the form is not editable
		if ( !this.isEditable ) {
			this._disableFields(this.form);
			return
		}
		 // Process form submission
		this.form.onsubmit = this._onSubmit.bind(this);
		 // Process changes to input fields
		html.on("change", "input,select,textarea", this._onChangeInput.bind(this));
		 // Detect and activate TinyMCE rich text editors
		html.find('.editor-content[data-edit]').each((i, div) => this._activateEditor(div));
		 // Detect and activate file-picker buttons
		html.find('button.file-picker').each((i, button) => this._activateFilePicker(button));
	}
	 /* -------------------------------------------- */
	 /**
	 * If the form is not editable, disable its input fields
	 * @param form {HTMLElement}
	 * @private
	 */
	_disableFields(form) {
		const inputs = ["INPUT", "SELECT", "TEXTAREA", "BUTTON"];
		for ( let i of inputs ) {
			for ( let el of form.getElementsByTagName(i) ) el.setAttribute("disabled", "");
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle standard form submission steps
	 * @param {Event} event               The submit event which triggered this handler
	 * @param {Object|null} [updateData]  Additional specific data keys/values which override or extend the contents of
	 *                                    the parsed form. This can be used to update other flags or data fields at the
	 *                                    same time as processing a form submission to avoid multiple database operations.
	 * @param {boolean} [preventClose]    Override the standard behavior of whether to close the form on submit
	 * @param {boolean} [preventRender]   Prevent the application from re-rendering as a result of form submission
	 * @returns {Promise}                 A promise which resolves to the validated update data
	 * @private
	 */
	async _onSubmit(event, {updateData=null, preventClose=false, preventRender=false}={}) {
		event.preventDefault();
		 // Prevent double submission
		const states = this.constructor.RENDER_STATES;
		if ( (this._state === states.NONE) || !this.options.editable || this._submitting ) return false;
		this._submitting = true;
		 // Process the form data
		const formData = this._getSubmitData(updateData);
		 // Handle the form state prior to submission
		let closeForm = this.options.closeOnSubmit && !preventClose;
		const priorState = this._state;
		if ( preventRender ) this._state = states.RENDERING;
		if ( closeForm ) this._state = states.CLOSING;
		 // Trigger the object update
		try {
			await this._updateObject(event, formData);
		} catch(err) {
			console.error(err);
			closeForm = false;
			this._state = priorState;
		}
		 // Restore flags and optionally close the form
		this._submitting = false;
		if ( preventRender ) this._state = priorState;
		if ( closeForm ) await this.close({submit: false, force: true});
		return formData;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get an object of update data used to update the form's target object
	 * @param {object} updateData     Additional data that should be merged with the form data
	 * @return {object}               The prepared update data
	 * @private
	 */
	_getSubmitData(updateData={}) {
		if ( !this.form ) throw new Error(`The FormApplication subclass has no registered form element`);
		const fd = new FormDataExtended(this.form, {editors: this.editors});
		let data = fd.toObject();
		if ( updateData ) data = flattenObject(mergeObject(data, updateData));
		return data;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle changes to an input element, submitting the form if options.submitOnChange is true.
	 * Do not preventDefault in this handler as other interactions on the form may also be occurring.
	 * @param {Event} event  The initial change event
	 * @private
	 */
	_onChangeInput(event) {
		const el = event.target;
		 // Handle changes to specific input types
		if ( (el.type === "color") && el.dataset.edit ) {
			this._onChangeColorPicker(event);
		}
		 if ( el.type === "range" ) {
			this._onChangeRange(event);
		}
		 // Maybe submit the form
		if ( this.options.submitOnChange ) {
			return this._onSubmit(event);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the change of a color picker input which enters it's chosen value into a related input field
	 * @private
	 */
	_onChangeColorPicker(event) {
		const input = event.target;
		const form = input.form;
		form[input.dataset.edit].value = input.value;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle changes to a range type input by propagating those changes to the sibling range-value element
	 * @param {Event} event  The initial change event
	 * @private
	 */
	_onChangeRange(event) {
	 const field = event.target.parentElement.querySelector(".range-value");
	 if ( field ) {
		 if ( field.tagName === "INPUT" ) field.value = event.target.value;
		 else field.innerHTML = event.target.value;
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * This method is called upon form submission after form data is validated
	 * @param event {Event}       The initial triggering submission event
	 * @param formData {Object}   The object of validated form data with which to update the object
	 * @returns {Promise}         A Promise which resolves once the update operation has completed 
	 * @abstract
	 */
	async _updateObject(event, formData) {
		throw new Error("A subclass of the FormApplication must implement the _updateObject method.");
	}
	 /* -------------------------------------------- */
	/*  TinyMCE Editor                              */
	/* -------------------------------------------- */
	 /**
	 * Activate a named TinyMCE text editor
	 * @param {string} name             The named data field which the editor modifies.
	 * @param {object} options          TinyMCE initialization options passed to TextEditor.create
	 * @param {string} initialContent   Initial text content for the editor area.
	 */
	activateEditor(name, options={}, initialContent="") {
		const editor = this.editors[name];
		if ( !editor ) throw new Error(`${name} is not a registered editor name!`);
		options = mergeObject(editor.options, options);
		options.height = options.target.offsetHeight;
		TextEditor.create(options, initialContent || editor.initial).then(mce => {
			editor.mce = mce;
			editor.changed = false;
			editor.active = true;
			mce.focus();
			mce.on('change', ev => editor.changed = true);
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle saving the content of a specific editor by name
	 * @param {string} name           The named editor to save
	 * @param {boolean} [remove]      Remove the editor after saving its content
	 * @return {Promise<void>}
	 */
	async saveEditor(name, {remove=true}={}) {
		const editor = this.editors[name];
		if ( !editor || !editor.mce ) throw new Error(`${name} is not an active editor name!`);
		editor.active = false;
		const mce = editor.mce;
		 // Submit the containing form
		const unchanged = mce.getContent() === editor.initial;
		const submit = this._onSubmit(new Event("mcesave"));
		 // Remove the editor and reset the button
		if ( remove ) mce.remove();
		if ( editor.hasButton ) editor.button.style.display = "block";
		return submit.then(() => {
			if ( remove ) {
				mce.destroy();
				editor.mce = null;
				if ( unchanged ) this.render();
			}
			editor.changed = false;
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Activate a TinyMCE editor instance present within the form
	 * @param div {HTMLElement}
	 * @private
	 */
	_activateEditor(div) {
		 // Get the editor content div
		const name = div.getAttribute("data-edit");
		const button = div.nextElementSibling;
		const hasButton = button && button.classList.contains("editor-edit");
		const wrap = div.parentElement.parentElement;
		const wc = $(div).parents(".window-content")[0];
		 // Determine the preferred editor height
		const heights = [wrap.offsetHeight, wc ? wc.offsetHeight : null];
		if ( div.offsetHeight > 0 ) heights.push(div.offsetHeight);
		let height = Math.min(...heights.filter(h => Number.isFinite(h)));
		 // Get initial content
		const data = this.object instanceof Entity ? this.object.data : this.object;
		const initialContent = getProperty(data, name);
		const editorOptions = {
			target: div,
			height: height,
			save_onsavecallback: mce => this.saveEditor(name)
		};
		 // Add record to editors registry
		this.editors[name] = {
			target: name,
			button: button,
			hasButton: hasButton,
			mce: null,
			active: !hasButton,
			changed: false,
			options: editorOptions,
			initial: initialContent
		};
		 // If we are using a toggle button, delay activation until it is clicked
		if (hasButton) button.onclick = event => {
			button.style.display = "none";
			this.activateEditor(name, editorOptions, initialContent);
		};
		 // Otherwise activate immediately
		else this.activateEditor(name, editorOptions, initialContent);
	}
	 /* -------------------------------------------- */
	/*  FilePicker UI
	/* -------------------------------------------- */
	 /**
	 * Activate a FilePicker instance present within the form
	 * @param button {HTMLElement}
	 * @private
	 */
	_activateFilePicker(button) {
		button.onclick = event => {
			event.preventDefault();
			let target = button.getAttribute("data-target");
			let fp = FilePicker.fromButton(button);
			this.filepickers.push({
				target: target,
				app: fp
			});
			fp.browse();
		}
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /** @override */
	async close(options={}) {
		const states = Application.RENDER_STATES;
		if ( !options.force && ![states.RENDERED, states.ERROR].includes(this._state) ) return;
		 // Trigger saving of the form
		const submit = options.submit ?? this.options.submitOnClose;
		if ( submit ) await this.submit({preventClose: true, preventRender: true});
		 // Close any open FilePicker instances
		for ( let fp of this.filepickers ) {
			if ( fp.app ) fp.app.close();
		}
		this.filepickers = [];
		 // Close any open MCE editors
		for ( let ed of Object.values(this.editors) ) {
			if ( ed.mce ) ed.mce.destroy();
		}
		this.editors = {};
		 // Close the application itself
		return super.close(options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Submit the contents of a Form Application, processing its content as defined by the Application
	 * @param {object} [options]        Options passed to the _onSubmit event handler
	 * @returns {FormApplication}       Return a self-reference for convenient method chaining
	 */
	async submit(options={}) {
		if ( this._submitting ) return; 
		const submitEvent = new Event("submit");
		await this._onSubmit(submitEvent, options);
		return this;
	}
	 /* -------------------------------------------- */
	/*  Deprecated Methods                          */
	/* -------------------------------------------- */
	 /**
	 * @deprecated since 0.7.2
	 * @see {@link FormDataExtended}
	 */
	static processForm(formElement) {
		console.warn(`You are using FormData.processForm(form) which has been deprecated in favor of the FormDataExtended helper class`);
		return FormDataExtended(formElement);
	};
	 /* -------------------------------------------- */
	 /**
	 * @deprecated since 0.7.3
	 * @see {@link FormApplication#activateEditor}
	 */
	_createEditor(...args) {
		console.warn("You are using the FormApplication#_createEditor method which has been deprecated in favor of FormApplication#activateEditor")
		return this.activateEditor(...args)
	}
}
	/**
 * @deprecated since 0.7.0
 * @see {@link FormApplication.processForm}
 */
validateForm = function(formElement) {
	console.warn(`You are using the validateForm(formData) function which has been deprecated in favor of the FormApplication.processForm static method`);
	return new FormDataExtended(formElement);
};
	/* -------------------------------------------- */
	/**
 * Extend the FormApplication pattern to incorporate specific logic for viewing or editing Entity instances.
 * See the FormApplication documentation for more complete description of this interface.
 *
 * @extends {FormApplication}
 * @abstract
 * @interface
 *
 * @param {Entity} object                           An Entity which should be managed by this form sheet.
 * @param {Object} [options]                        Optional configuration parameters for how the form behaves.
 */
class BaseEntitySheet extends FormApplication {
	constructor(object, options) {
		super(object, options);
		this.entity.apps[this.appId] = this;
	}
	/* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 classes: ["sheet"],
			template: `templates/sheets/${this.name.toLowerCase()}.html`,
			viewPermission: ENTITY_PERMISSIONS.LIMITED
		});
	}
	/* -------------------------------------------- */
	 /**
	 * A convenience accessor for the object property, which in the case of a BaseEntitySheet is an Entity instance.
	 * @type {Entity}
	 */
	get entity() {
	 return this.object;
	}
	/* -------------------------------------------- */
	 /** @override */
	get isEditable() {
	 return this.options.editable && this.entity.owner;
	}
		/* -------------------------------------------- */
	 /** @override */
	get title() {
		return this.entity.name;
	}
	/* -------------------------------------------- */
	 /** @override */
	render(force, options) {
		if ( !this.object.compendium && !this.object.hasPerm(game.user, this.options.viewPermission) ) {
			if ( !force ) return; // If rendering is not being forced, fail silently
			const err = game.i18n.localize("SHEETS.EntitySheetPrivate");
			ui.notifications.warn(err);
			return console.warn(err);
		}
		return super.render(force, options);
	}
	/* -------------------------------------------- */
	 /** @override */
	getData(options) {
		let isOwner = this.entity.owner;
		return {
			cssClass: isOwner ? "editable" : "locked",
			editable: this.isEditable,
			entity: duplicate(this.entity.data),
			limited: this.entity.limited,
			options: this.options,
			owner: isOwner,
			title: this.title
		}
	}
	/* -------------------------------------------- */
	 /** @override */
	_getHeaderButtons() {
		let buttons = super._getHeaderButtons();
		if ( this.entity.compendium ) {
			buttons.unshift({
				label: "Import",
				class: "import",
				icon: "fas fa-download",
				onclick: async ev => {
					await this.close();
					const packName = this.entity.compendium.collection;
					this.entity.collection.importFromCollection(packName, this.entity._id);
				}
			});
		}
		return buttons
	}
	/* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		formData["_id"] = this.object._id;
		return this.entity.update(formData);
	}
}

/* -------------------------------------------- */

/**
 * Support mousewheel control for range type input elements
 * @param {WheelEvent} event    A Mouse Wheel scroll event
 */
function _handleMouseWheelInputChange(event) {
	const r = event.target;
	if ( (r.tagName !== "INPUT") || (r.type !== "range")) return;
	event.preventDefault();
	event.stopPropagation();
	 // Adjust the range slider by the step size
	const step = (parseFloat(r.step) || 1.0) * Math.sign(-1 * event.deltaY);
	r.value = Math.clamped(parseFloat(r.value) + step, parseFloat(r.min), parseFloat(r.max));
	 // Dispatch a change event that can bubble upwards to the parent form
	const ev = new Event("change", {bubbles: true});
	ev.target = ev.currentTarget = r;
	r.dispatchEvent(ev);
}
	/**
 * A helper class which assists with localization and string translation
 */
class Localization {
	constructor(language) {
		 // Obtain the default language from application settings
		const [defaultLanguage, defaultModule] = (language || "en.core").split(".");
		 /**
		 * The target language for localization
		 * @type {string}
		 */
		this.lang = defaultLanguage;
		 /**
		 * The package authorized to provide default language configurations
		 * @type {string}
		 */
		this.defaultModule = defaultModule;
		 /**
		 * The translation dictionary for the target language
		 * @type {Object}
		 */
		this.translations = {};
		 /**
		 * Fallback translations if the target keys are not found
		 * @type {Object}
		 */
		this._fallback = {};
	}
	/* -------------------------------------------- */
	 /**
	 * Initialize the Localization module
	 * Discover available language translations and apply the current language setting
	 * @return {Promise<void>}      A Promise which resolves once languages are initialized
	 */
	async initialize() {
		const clientLanguage = await game.settings.get("core", "language");
		 // Discover which modules available to the client
		this._discoverSupportedLanguages();
		 // Activate the configured language
		await this.setLanguage(clientLanguage || this.lang);
		 // Define type labels
		if ( game.system && isObjectEmpty(CONFIG.Actor.typeLabels) ) {
			CONFIG.Actor.typeLabels = game.system.entityTypes.Actor.reduce((obj, t) => {
				obj[t] = `ACTOR.Type${t.titleCase()}`;
				return obj;
			}, {});
		}
		if ( game.system && isObjectEmpty(CONFIG.Item.typeLabels) ) {
			CONFIG.Item.typeLabels = game.system.entityTypes.Item.reduce((obj, t) => {
				obj[t] = `ITEM.Type${t.titleCase()}`;
				return obj;
			}, {});
		}
	}
	/* -------------------------------------------- */
	 /**
	 * Set a language as the active translation source for the session
	 * @param {string} lang       A language string in CONFIG.supportedLanguages
	 * @returns {Promise<void>}   A Promise which resolves once the translations for the requested language are ready
	 */
	async setLanguage(lang) {
		if ( !Object.keys(CONFIG.supportedLanguages).includes(lang) ) {
			console.error(`Cannot set language ${lang}, as it is not in the supported set. Falling back to English`);
			lang = "en";
		}
		this.lang = lang;
		 // Load translations and English fallback strings
		this.translations = await this._getTranslations(lang);
		if ( lang !== "en" ) this._fallback = await this._getTranslations("en");
	}
	/* -------------------------------------------- */
	 /**
	 * Discover the available supported languages from the set of packages which are provided
	 * @private
	 */
	_discoverSupportedLanguages() {
		const sl = CONFIG.supportedLanguages;
		if ( game.view === "join" ) return;
		 // Define packages
		const systems = game.data.systems || [game.data.system.data];
		const modules = game.data.modules;
		const worlds =  game.data.worlds || [game.data.world];
		const packages = systems.concat(modules).concat(worlds);
		 // Discover and register languages
		packages.filter(p => p.languages.length).forEach(p => {
			for ( let l of p.languages ) {
				if ( !sl.hasOwnProperty(l.lang) ) {
					sl[l.lang] = l.name;
				}
			}
		});
	}
	/* -------------------------------------------- */
	 /**
	 * Prepare the dictionary of translation strings for the requested language
	 * @param {string} lang         The language for which to load translations
	 * @return {Promise<object>}    The retrieved translations object
	 * @private
	 */
	async _getTranslations(lang) {
		const translations = {};
		const promises = [];
		 // Include core supported languages
		if ( CONST.CORE_SUPPORTED_LANGUAGES.includes(lang) ) {
			promises.push(this._loadTranslationFile(`lang/${lang}.json`));
		}
		 // Add game system translations
		if ( game.system ) {
			let sl = game.system.languages.find(l => l.lang === lang);
			if ( sl ) promises.push(this._loadTranslationFile(sl.path));
		}
		 // Add module translations
		if ( game.modules ) {
			for ( let module of game.modules.values() ) {
				if ( !module.active && (module.id !== this.defaultModule) ) continue;
				let mls = module.languages.filter(l => {
					if ( l.lang !== lang ) return false;
					let checkSystem = !l.system || (game.system && (l.system === game.system.id));
					let checkModule = !l.module || game.modules.has(l.module);
					return checkSystem && checkModule;
				});
				for ( let ml of mls ) {
					promises.push(this._loadTranslationFile(ml.path));
				}
			}
		}
		 // Merge translations in load order and return the prepared dictionary
		await Promise.all(promises);
		for ( let p of promises ) {
			let json = await p;
			mergeObject(translations, json, {inplace: true});
		}
		return translations;
	}
	/* -------------------------------------------- */
	 /**
	 * Load a single translation file and return its contents as processed JSON
	 * @param {string} src    The translation file path to load
	 * @private
	 */
	async _loadTranslationFile(src) {
		const resp = await fetch(src).catch(err => { return {} });
		if ( resp.status !== 200 ) {
			console.error(`${vtt} | Unable to load requested localization file ${src}`);
			return {};
		}
		return resp.json().then(json => {
			console.log(`${vtt} | Loaded localization file ${src}`);
			return json;
		}).catch(err => {
			console.error(`Unable to parse localization file ${src}: ${err}`);
			return {};
		});
	}
	/* -------------------------------------------- */
	/*  Localization API                            */
	/* -------------------------------------------- */
	 /**
	 * Return whether a certain string has a known translation defined.
	 * @param {string} stringId     The string key being translated
	 * @param {boolean} [fallback]  Allow fallback translations to count?
	 * @return {boolean}
	 */
	has(stringId, fallback=true) {
		return hasProperty(this.translations, stringId) || hasProperty(this._fallback, stringId);
	}
	/* -------------------------------------------- */
	 /**
	 * Localize a string by drawing a translation from the available translations dictionary, if available
	 * If a translation is not available, the original string is returned
	 * @param {String} stringId     The string ID to translate
	 * @return {String}             The translated string
	 *
	 * @example
	 * {
	 *   "MYMODULE.MYSTRING": "Hello, this is my module!"
	 * }
	 * game.i18n.localize("MYMODULE.MYSTRING"); // Hello, this is my module!
	 */
	localize(stringId) {
		return getProperty(this.translations, stringId) || getProperty(this._fallback, stringId) || stringId;
	}
	/* -------------------------------------------- */
	 /**
	 * Localize a string including variable formatting for input arguments.
	 * Provide a string ID which defines the localized template.
	 * Variables can be included in the template enclosed in braces and will be substituted using those named keys.
	 *
	 * @param {string} stringId     The string ID to translate
	 * @param {Object} data         Provided input data
	 * @return {string}             The translated and formatted string
	 *
	 * @example
	 * {
	 *   "MYMODULE.GREETING": "Hello {name}, this is my module!"
	 * }
	 * game.i18n.format("MYMODULE.GREETING", {name: "Andrew"}); // Hello Andrew, this is my module!
	 */
	format(stringId, data={}) {
		let str = this.localize(stringId);
		const fmt = /\{[^\}]+\}/g;
		str = str.replace(fmt, k => {
			return data[k.slice(1, -1)];
		});
		return str;
	}
}
	// Register Handlebars Extensions
HandlebarsIntl.registerWith(Handlebars);

// Global template cache
_templateCache = {};
	/* -------------------------------------------- */
/*  HTML Template Loading                       */
/* -------------------------------------------- */

/**
 * Get a template from the server by fetch request and caching the retrieved result
 * @param {string} path           The web-accessible HTML template URL
 * @returns {Promise<Function>}	  A Promise which resolves to the compiled Handlebars template
 */
async function getTemplate(path) {
	if ( !_templateCache.hasOwnProperty(path) ) {
		await new Promise((resolve, reject) => {
			game.socket.emit('template', path, resp => {
			 if ( resp.error ) return reject(new Error(resp.error));
			 const compiled = Handlebars.compile(resp.html);
			 Handlebars.registerPartial(path, compiled);
			 _templateCache[path] = compiled;
			 console.log(`Foundry VTT | Retrieved and compiled template ${path}`);
			 resolve(compiled);
		 });
		});
	} 
	return _templateCache[path];
}

/* -------------------------------------------- */

/**
 * Load and cache a set of templates by providing an Array of paths
 * @param {string[]} paths    An array of template file paths to load
 * @return {Promise<string[]>}
 */
async function loadTemplates(paths) {
	return Promise.all(paths.map(p => getTemplate(p)));
}

/* -------------------------------------------- */
	/**
 * Get and render a template using provided data and handle the returned HTML
 * Support asynchronous file template file loading with a client-side caching layer
 *
 * Allow resolution of prototype methods and properties since this all occurs within the safety of the client.
 * @see {@link https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access}
 *
 * @param {string} path             The file path to the target HTML template
 * @param {Object} data             A data object against which to compile the template
 *
 * @return {Promise.<HTMLElement>}  Returns the rendered HTML
 */
function renderTemplate(path, data) {
	return getTemplate(path).then(template => {
		return template(data || {}, {
			allowProtoMethodsByDefault: true,
			allowProtoPropertiesByDefault: true
		});
	});
}
	/* -------------------------------------------- */
/*  Handlebars Template Helpers                 */
/* -------------------------------------------- */
	/**
 * A collection of Handlebars template helpers which can be used within HTML templates.
 */
class HandlebarsHelpers {
	 /**
	 * For checkboxes, if the value of the checkbox is true, add the "checked" property, otherwise add nothing.
	 * @return {string}
	 */
	static checked(value) {
		return Boolean(value) ? "checked" : "";
	}
	 /* -------------------------------------------- */
	 /**
	 * Construct an editor element for rich text editing with TinyMCE
	 * @return {Handlebars.SafeString}
	 */
	static editor(options) {
		const target = options.hash['target'];
		if ( !target ) throw new Error("You must define the name of a target field.");
		 // Enrich the content
		const owner = Boolean(options.hash['owner']);
		const content = TextEditor.enrichHTML(options.hash['content'] || "", {secrets: owner, entities: true});
		 // Construct the HTML
		let editor = $(`<div class="editor"><div class="editor-content" data-edit="${target}">${content}</div></div>`);
		 // Append edit button
		const button = Boolean(options.hash['button']);
		const editable = Boolean(options.hash['editable']);
		if ( button && editable ) editor.append($('<a class="editor-edit"><i class="fas fa-edit"></i></a>'));
		return new Handlebars.SafeString(editor[0].outerHTML);
	}
	 /* -------------------------------------------- */
	 /**
	 * Render a file-picker button linked to an <input> field
	 * @return {Handlebars.SafeString|string}
	 */
	static filePicker(options) {
		const type = options.hash['type'];
		const target = options.hash['target'];
		if ( !target ) throw new Error("You must define the name of the target field.");
		 // Do not display the button for users who do not have browse permission
		if ( game.world && !game.user.can("FILES_BROWSE" ) ) return "";
		 // Construct the HTML
		const tooltip = game.i18n.localize("FILES.BrowseTooltip");
		return new Handlebars.SafeString(`
		<button type="button" class="file-picker" data-type="${type}" data-target="${target}" title="${tooltip}" tabindex="-1">
				<i class="fas fa-file-import fa-fw"></i>
		</button>`);
	}
	 /* -------------------------------------------- */
	 /**
	 * Translate a provided string key by using the loaded dictionary of localization strings.
	 * @return {string}
	 *
	 * @example <caption>Translate a provided localization string, optionally including formatting parameters</caption>
	 * <label>{{localize "ACTOR.Create"}}</label> <!-- "Create Actor" -->
	 * <label>{{localize "CHAT.InvalidCommand", command=foo}}</label> <!-- "foo is not a valid chat message command." -->
	 */
	static localize(value, options) {
		const data = options.hash;
		return isObjectEmpty(data) ? game.i18n.localize(value) : game.i18n.format(value, data);
	}
	 /* -------------------------------------------- */
	 /**
	 * A string formatting helper to display a number with a certain fixed number of decimals and an explicit sign.
	 * @return {string}
	 */
	static numberFormat(value, options) {
		const dec = options.hash['decimals'] ?? 0;
		const sign = options.hash['sign'] || false;
		value = parseFloat(value).toFixed(dec);
		if (sign ) return ( value >= 0 ) ? "+"+value : value;
		return value;
	}
	 /* -------------------------------------------- */
	 /**
	 * A helper to create a set of radio checkbox input elements in a named set.
	 * The provided keys are the possible radio values while the provided values are human readable labels.
	 *
	 * @param {string} name         The radio checkbox field name
	 * @param {object} choices      A mapping of radio checkbox values to human readable labels
	 * @param {string} options.checked    Which key is currently checked?
	 * @param {boolean} options.localize  Pass each label through string localization?
	 * @return {Handlebars.SafeString}
	 *
	 * @example <caption>The provided input data</caption>
	 * let groupName = "importantChoice";
	 * let choices = {a: "Choice A", b: "Choice B"};
	 * let chosen = "a";
	 *
	 * @example <caption>The template HTML structure</caption>
	 * <div class="form-group">
	 *   <label>Radio Group Label</label>
	 *   <div class="form-fields">
	 *     {{radioBoxes groupName choices checked=chosen localize=true}}
	 *   </div>
	 * </div>
	 */
	static radioBoxes(name, choices, options) {
		const checked = options.hash['checked'] || null;
		const localize = options.hash['localize'] || false;
		let html = "";
		for ( let [key, label] of Object.entries(choices) ) {
			if ( localize ) label = game.i18n.localize(label);
			const isChecked = checked === key;
			html += `<label class="checkbox"><input type="radio" name="${name}" value="${key}" ${isChecked ? "checked" : ""}> ${label}</label>`;
		}
		return new Handlebars.SafeString(html);
	}
	 /* -------------------------------------------- */
	 /**
	* A helper to assign an <option> within a <select> block as selected based on its value
	* Escape the string as handlebars would, then escape any regexp characters in it
	* @return {Handlebars.SafeString}
	*/
	static select(selected, options) {
		const escapedValue = RegExp.escape(Handlebars.escapeExpression(selected));
		const rgx = new RegExp(' value=[\"\']' + escapedValue + '[\"\']');
		const html = options.fn(this);
		return html.replace(rgx, "$& selected");
	}
	 /* -------------------------------------------- */
	 /**
	 * A helper to create a set of <option> elements in a <select> block based on a provided dictionary.
	 * The provided keys are the option values while the provided values are human readable labels.
	 * This helper supports both single-select as well as multi-select input fields.
	 *
	 * @param {object} choices      A mapping of radio checkbox values to human readable labels
	 * @param {string|string[]} options.selected    Which key or array of keys that are currently selected?
	 * @param {boolean} options.localize  Pass each label through string localization?
	 * @return {Handlebars.SafeString}
	 *
	 * @example <caption>The provided input data</caption>
	 * let choices = {a: "Choice A", b: "Choice B"};
	 * let value = "a";
	 *
	 * @example <caption>The template HTML structure</caption>
	 * <select name="importantChoice">
	 *   {{selectOptions choices selected=value localize=true}}
	 * </select>
	 */
	static selectOptions(choices, options) {
		const localize = options.hash['localize'] ?? false;
		let selected = options.hash['selected'] ?? null;
		let blank = options.hash['blank'] || null;
		selected = selected instanceof Array ? selected.map(String) : [String(selected)];
		 // Create an option
		const option = (key, label) => {
			if ( localize ) label = game.i18n.localize(label);
			let isSelected = selected.includes(key);
			html += `<option value="${key}" ${isSelected ? "selected" : ""}>${label}</option>`
		};
		 // Create the options
		let html = "";
		if ( blank ) option("", blank);
		Object.entries(choices).forEach(e => option(...e));
		return new Handlebars.SafeString(html);
	}
}

/**
 * Register all handlebars helpers
 */
Handlebars.registerHelper({
	checked: HandlebarsHelpers.checked,
	editor: HandlebarsHelpers.editor,
	filePicker: HandlebarsHelpers.filePicker,
	numberFormat: HandlebarsHelpers.numberFormat,
	localize: HandlebarsHelpers.localize,
	radioBoxes: HandlebarsHelpers.radioBoxes,
	select: HandlebarsHelpers.select,
	selectOptions: HandlebarsHelpers.selectOptions,
	timeSince: timeSince,
	eq: (v1, v2) => v1 === v2,
	ne: (v1, v2) => v1 !== v2,
	lt: (v1, v2) => v1 < v2,
	gt: (v1, v2) => v1 > v2,
	lte: (v1, v2) => v1 <= v2,
	gte: (v1, v2) => v1 >= v2,
	and() { return Array.prototype.every.call(arguments, Boolean) },
	or() { return Array.prototype.slice.call(arguments, 0, -1).some(Boolean) }
});

/* Global Variables */
let canvas = null;
let game = {};
let keyboard = null;
let socket = null;
const ui = {
	windows: {}
};

/**
 * The core Game instance which encapsulates the data, settings, and states relevant for managing the game experience.
 * The singleton instance of the Game class is available as the global variable game.
 *
 * @param {string} view         The named view which is active for this game instance.
 * @param {Object} data         An object of all the World data vended by the server when the client first connects
 * @param {string} sessionId    The ID of the currently active client session retrieved from the browser cookie
 * @param {Socket} socket       The open web-socket which should be used to transact game-state data
 */
class Game {
	constructor(view, data, sessionId, socket) {
		 /**
		 * The named view which is currently active.
		 * Game views include: join, setup, players, license, game, stream
		 * @type {string}
		 */
		this.view = view;
		 /**
		 * The object of world data passed from the server
		 * @type {Object}
		 */
		this.data = data;
		 /**
		 * Localization support
		 * @type {Localization}
		 */
		this.i18n = new Localization(data?.options?.language);
		 /**
		 * The Keyboard Manager
		 * @type {KeyboardManager}
		 */
		this.keyboard = null;
		 /**
		 * A mapping of installed modules
		 * @type {Map}
		 */
		this.modules = new Map((data.modules || []).map(m => [m.id, m]));
		 /**
		 * The user role permissions setting
		 * @type {Object}
		 */
		this.permissions = null;
		 /**
		 * The client session id which is currently active
		 * @type {string}
		 */
		this.sessionId = sessionId;
		 /**
		 * Client settings which are used to configure application behavior
		 * @type {ClientSettings}
		 */
		this.settings = new ClientSettings(data.settings || []);
		 /**
		 * A reference to the open Socket.io connection
		 * @type {WebSocket|null}
		 */
		this.socket = socket;
		 /**
		 * A singleton GameTime instance which manages the progression of time within the game world.
		 * @type {GameTime}
		 */
		this.time = new GameTime(socket);
		 /**
		 * The id of the active World user, if any
		 * @type {string}
		 */
		this.userId = data.userId || null;
		 /**
		 * A singleton instance of the Audio Helper class
		 * @type {AudioHelper}
		 */
		this.audio = new AudioHelper();
		 /**
		 * A singleton instance of the Video Helper class
		 * @type {VideoHelper}
		 */
		this.video = new VideoHelper();
		 /**
		 * Whether the Game is running in debug mode
		 * @type {boolean}
		 */
		this.debug = false;
		 /**
		 * A flag for whether texture assets for the game canvas are currently loading
		 * @type {boolean}
		 */
		this.loading = false;
		 /**
		 * A flag for whether the Game has successfully reached the "ready" hook
		 * @type {boolean}
		 */
		this.ready = false;
	}
	 /* -------------------------------------------- */
	 /**
	 * Fetch World data and return a Game instance
	 * @return {Promise<Game>}  A Promise which resolves to the created Game instance
	 */
	static async create() {
		 // Display ASCII welcome
		console.log(CONST.ASCII);
		let socket = null;
		 // Get the current URL
		const url = new URL(window.location.href);
		const view = url.pathname.split("/").pop();
		 // Retrieve an existing client session from cookies
		const cookies = Game.getCookies();
		let sessionId = view !== "join" ? cookies.session : null;
		if ( sessionId ) {
			console.log(`${vtt} | Reestablishing existing session ${sessionId}`);
			socket = await this.connect(sessionId);
		} else if ( view !== "join" ) {
			console.error(`No client session ID available, redirecting to login`);
			window.location.href = getRoute("join");
		}
		 // Obtain necessary world data
		let gameData = {};
		if ( socket ) {
			const worldActive = await this.getWorldStatus(socket);
			gameData = worldActive ? await this.getWorldData(socket) : await this.getSetupData(socket);
		}
		 // Create the Game instance
		return new Game(view, gameData, sessionId, socket);
	}
	 /* -------------------------------------------- */
	 /**
	 * Establish a live connection to the game server through the socket.io URL
	 * @param {string} sessionId  The client session ID with which to establish the connection
	 * @return {Promise<object>}  A promise which resolves to the connected socket, if successful
	 */
	static async connect(sessionId) {
		return new Promise((resolve, reject) => {
			const socket = io.connect({
				path: getRoute("socket.io"),
				transports: ["websocket"],    // Require websocket transport instead of XHR polling
				upgrade: false,               // Prevent "upgrading" to websocket since it is enforced
				reconnection: true,           // Automatically reconnect
				reconnectionDelay: 1000,
				reconnectionAttempts: 3,
				reconnectionDelayMax: 5000,
				query: { session: sessionId } // Pass session info
			});
			socket.on("connect", () => {
				console.log(`${vtt} | Connected to server socket using session ${sessionId}`);
				resolve(socket)
			});
			socket.on("connectTimeout", timeout => {
				reject(new Error("Failed to establish a socket connection within allowed timeout."))
			});
			socket.on("connectError", err => reject(err));
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Retrieve the cookies which are attached to the client session
	 * @return {Object}   The session cookies
	 */
	static getCookies() {
		const cookies = {};
		for (let cookie of document.cookie.split('; ')) {
			let [name, value] = cookie.split("=");
			cookies[name] = decodeURIComponent(value);
		}
		return cookies;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the current World status upon initial connection.
	 * @return {Promise<boolean>}
	 */
	static async getWorldStatus(socket) {
		const status = await new Promise(resolve => {
			socket.emit("getWorldStatus", resolve);
		});
		console.log(`${vtt} | The game World is currently ${status ? "active" : "not active"}`);
		return status;
	}
	 /* -------------------------------------------- */
	 /**
	 * Request World data from server and return it
	 * @return {Promise<object>}
	 */
	static async getWorldData(socket) {
		return new Promise(resolve => {
			socket.emit("world", resolve);
		})
	}
	 /* -------------------------------------------- */
	 /**
	 * Request setup data from server and return it
	 * @return {Promise<object>}
	 */
	static async getSetupData(socket) {
		return new Promise(resolve => {
			socket.emit("getSetupData", resolve);
		})
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize the Game for the current window location
	 */
	async initialize() {
		console.log(`${vtt} | Initializing Game instance`);
		this.ready = false;
		Hooks.callAll('init');
		 // Register game settings
		this.registerSettings();
		 // Initialize language translations
		await this.i18n.initialize();
		 // Activate event listeners
		this.activateListeners();
		 // Initialize client view
		const url = window.location.pathname;
		if (/\/license/.test(url)) await this._initializeLicenseView();
		if (/\/game/.test(url)) await this._initializeGameView();
		else if (/\/setup/.test(url)) await this._initializeSetupView();
		else if (/\/stream/.test(url)) await this._initializeStreamView();
		else if (/\/players/.test(url)) await this._initializePlayersView();
		else if (/\/join/.test(url)) await this._initializeJoinView();
		 // Display usability warnings or errors
		this._displayUsabilityErrors();
	}
	 /* -------------------------------------------- */
	 /**
	 * Display certain usability error messages which are likely to result in the player having a bad experience.
	 * @private
	 */
	_displayUsabilityErrors() {
		 // Validate required resolution
		const MIN_WIDTH = 1024;
		const MIN_HEIGHT = 700;
		if ( window.innerHeight < MIN_HEIGHT || window.innerWidth < MIN_WIDTH ) {
			if ( ui.notifications && !game.data.options.debug ) {
				ui.notifications.error(game.i18n.format("ERROR.LowResolution", {
					width: window.innerWidth,
					reqWidth: MIN_WIDTH,
					height: window.innerHeight,
					reqHeight: MIN_HEIGHT
				}), {permanent: true});
			}
		}
		 // Unsupported Chromium version
		const MIN_CHROMIUM_VERSION = 80;
		const chromium = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
		if ( chromium && (parseInt(chromium[2]) < MIN_CHROMIUM_VERSION) ) {
			if ( ui.notifications ) {
				ui.notifications.error(game.i18n.format("ERROR.ChromiumVersion", {
					version: chromium[2],
					minimum: MIN_CHROMIUM_VERSION
				}), {permanent: true});
			}
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Shut down the currently active Game. Requires GameMaster user permission.
	 * @return {Promise<Object>}    A Promise which resolves to the response object from the server
	 */
	async shutDown() {
		const resp = await SetupConfiguration.post({shutdown: true});
		if ( resp.status < 400 ) setTimeout(() => window.location.href = getRoute("setup"), 1000);
	}
	 /* -------------------------------------------- */
	/*  Primary Game Initialization
	/* -------------------------------------------- */
	 /**
	 * Fully set up the game state, initializing Entities, UI applications, and the Canvas
	 * @returns {Promise<void>}
	 */
	async setupGame() {
		Hooks.callAll('setup');
		 // Store permission settings
		this.permissions = await this.settings.get("core", "permissions");
		 // Initialization Steps
		this.initializeEntities();
		await this.initializePacks();
		this.initializeRTC();
		this.initializeUI();
		await this.initializeCanvas();
		this.initializeKeyboard();
		this.openSockets();
		 // Register sheet preferences
		EntitySheetConfig.initializeSheets();
		 // If the player is not a GM and does not have an impersonated character, prompt for selection
		if (!this.user.isGM && !this.user.character) {
			new PlayerConfig(this.user).render(true);
		}
		 // Call all game ready hooks
		this.ready = true;
		Hooks.callAll('ready');
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize game state data by creating EntityCollection instances for every Entity types
	 */
	initializeEntities() {
		this.users = new Users(this.data.users);
		this.messages = new Messages(this.data.messages);
		this.scenes = new Scenes(this.data.scenes);
		this.actors = new Actors(this.data.actors);
		this.items = new Items(this.data.items);
		this.journal = new Journal(this.data.journal);
		this.macros = new Macros(this.data.macros);
		this.playlists = new Playlists(this.data.playlists);
		this.combats = new CombatEncounters(this.data.combat);
		this.tables = new RollTables(this.data.tables);
		this.folders = new Folders(this.data.folders);
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize the Compendium packs which are present within this Game
	 * Create a Collection which maps each Compendium pack using it's collection ID
	 * @returns {Collection<string,Compendium>}
	 */
	async initializePacks(config) {
		config = config || await game.settings.get("core", Compendium.CONFIG_SETTING);
		const prior = this.packs;
		const packs = new Collection();
		for ( let metadata of this.data.packs ) {
			const collection = `${metadata.package}.${metadata.name}`;
			 // Get or create the pack
			let pack = null;
			if ( prior && prior.has(collection) ) pack = prior.get(collection);
			else pack = new Compendium(metadata);
			 // Update the pack configuration and re-render
			const conf = config[collection];
			if ( conf ) {
				pack.private = !!conf.private;
				pack.locked = !!conf.locked;
			}
			pack.render(false);
			 // Add to the new collection
			packs.set(collection, pack);
		}
		return this.packs = packs;
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize the WebRTC implementation
	 */
	initializeRTC() {
		this.webrtc = new AVMaster();
		return this.webrtc.connect()
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize core UI elements
	 */
	initializeUI() {
		 // Initialize all applications
		for ( let [k, cls] of Object.entries(CONFIG.ui) ) {
			ui[k] = new cls();
		}
		 // Render some applications
		ui.nav.render(true);
		ui.notifications.render(true);
		ui.sidebar.render(true);
		ui.players.render(true);
		ui.hotbar.render(true);
		ui.webrtc.render(true);
		ui.pause.render(true);
		ui.controls.render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize the game Canvas
	 */
	async initializeCanvas() {
		if (document.getElementById("board")) {
			 // Ensure that necessary fonts have loaded
			await this._checkFontsReady(3000);
			 // Render the canvas
			try {
				canvas = new Canvas();
				const scene = game.scenes.viewed;
				if ( scene ) await scene.view();
				else await canvas.draw();
			} catch(err) {
				console.error(`Failed to render WebGL canvas! Be sure to read the following error carefully.`);
				console.error(err);
			}
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Ensure that necessary fonts have loaded and are ready for use
	 * Enforce a maximum timeout in milliseconds.
	 * Proceed with rendering after that point even if fonts are not yet available.
	 * @param {number} ms   The timeout to delay
	 * @return {Promise<void>}
	 * @private
	 */
	async _checkFontsReady(ms) {
		for ( let f of CONFIG.fontFamilies ) {
			document.fonts.load(`1rem ${f}`);
		}
		const timeout = new Promise(resolve => setTimeout(resolve, ms));
		return Promise.race([document.fonts.ready, timeout]).then(() => {
			console.log(`${vtt} | Document fonts loaded and ready`);
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize Keyboard and Mouse controls
	 */
	initializeKeyboard() {
		keyboard = this.keyboard = new KeyboardManager();
	}
	 /* -------------------------------------------- */
	 /**
	 * Register core game settings
	 */
	registerSettings() {
		 // Permissions Control Menu
		game.settings.registerMenu("core", "permissions", {
			name: "PERMISSION.Configure",
			label: "PERMISSION.ConfigureLabel",
			hint: "PERMISSION.ConfigureHint",
			icon: "fas fa-user-lock",
			type: PermissionConfig,
			restricted: true
		});
		 // User Role Permissions
		game.settings.register("core", "permissions", {
			name: "Permissions",
			scope: "world",
			default: {},
			type: Object,
			config: false,
			onChange: permissions => {
				game.permissions = permissions;
				if ( ui.controls ) ui.controls.initialize();
				if ( ui.sidebar ) ui.sidebar.render();
			}
		});
		 // WebRTC Control Menu
		game.settings.registerMenu("core", "webrtc", {
			name: "WEBRTC.Title",
			label: "WEBRTC.MenuLabel",
			hint: "WEBRTC.MenuHint",
			icon: "fas fa-headset",
			type: AVConfig,
			restricted: false
		});
		 // RTC World Settings
		game.settings.register("core", "rtcWorldSettings", {
			name: "WebRTC (Audio/Video Conferencing) World Settings",
			scope: "world",
			default: AVSettings.DEFAULT_WORLD_SETTINGS,
			type: Object,
			onChange: () => game.webrtc.settings.changed()
		});
		 // RTC Client Settings
		game.settings.register("core", "rtcClientSettings", {
			name: "WebRTC (Audio/Video Conferencing) Client specific Configuration",
			scope: "client",
			default: AVSettings.DEFAULT_CLIENT_SETTINGS,
			type: Object,
			onChange: () => game.webrtc.settings.changed()
		});
		 // Language preference
		game.settings.register("core", "language", {
			name: "SETTINGS.LangN",
			hint: "SETTINGS.LangL",
			scope: "client",
			config: true,
			default: game.i18n.lang,
			type: String,
			choices: CONFIG.supportedLanguages,
			onChange: lang => window.location.reload()
		});
		 // Chat message roll mode
		game.settings.register("core", "rollMode", {
			name: "Default Roll Mode",
			scope: "client",
			config: false,
			default: "roll",
			type: String,
			choices: CONFIG.Dice.rollModes
		});
		 // World time
		game.settings.register("core", "time", {
			name: "World Time",
			scope: "world",
			config: false,
			default: 0,
			type: Number,
			onChange: time => this.time.onUpdateWorldTime(time)
		});
		 // Register module configuration settings
		game.settings.register("core", ModuleManagement.CONFIG_SETTING, {
			name: "Module Configuration Settings",
			scope: "world",
			config: false,
			default: {},
			type: Object,
			onChange: settings => window.location.reload()
		});
		 // Register compendium visibility setting
		game.settings.register("core", Compendium.CONFIG_SETTING, {
			name: "Compendium Configuration",
			scope: "world",
			config: false,
			default: {},
			type: Object,
			onChange: async config => {
				await this.initializePacks(config);
				ui.compendium.render();
			}
		});
		 // Combat Tracker Configuration
		game.settings.register("core", Combat.CONFIG_SETTING, {
			name: "Combat Tracker Configuration",
			scope: "world",
			config: false,
			default: {},
			type: Object,
			onChange: () => {
				if (game.combat) {
					game.combat.setupTurns();
					game.combats.render();
				}
			}
		});
		 // Entity Sheet Class Configuration
		game.settings.register("core", "sheetClasses", {
			name: "Sheet Class Configuration",
			scope: "world",
			config: false,
			default: {},
			type: Object,
			onChange: setting => EntitySheetConfig._updateDefaultSheets(setting)
		});
		 // Are Chat Bubbles Enabled?
		game.settings.register("core", "chatBubbles", {
			name: "SETTINGS.CBubN",
			hint: "SETTINGS.CBubL",
			scope: "world",
			config: true,
			default: true,
			type: Boolean
		});
		 // Pan to Token Speaker
		game.settings.register("core", "chatBubblesPan", {
			name: "SETTINGS.CBubPN",
			hint: "SETTINGS.CBubPL",
			scope: "world",
			config: true,
			default: true,
			type: Boolean
		});
		 // Disable Resolution Scaling
		game.settings.register("core", "disableResolutionScaling", {
			name: "SETTINGS.ResScaleN",
			hint: "SETTINGS.ResScaleL",
			scope: "client",
			config: window.devicePixelRatio !== 1,
			default: false,
			type: Boolean,
			onChange: () => window.location.reload()
		});
		 // TODO - legacy setting, remove in 0.8.x
		game.settings.register("core", "devicePixelRatio", {
			name: "DEPRECATED DEVICE PIXEL RATIO SETTING",
			hint: "DEPRECATED DEVICE PIXEL RATIO SETTING",
			scope: "client",
			config: false,
			default: false,
			type: Boolean
		});
		 // Left-Click Deselection
		game.settings.register("core", "leftClickRelease", {
			name: "SETTINGS.LClickReleaseN",
			hint: "SETTINGS.LClickReleaseL",
			scope: "client",
			config: true,
			default: false,
			type: Boolean
		});
		 // Maximum Framerate
		game.settings.register("core", "maxFPS", {
			name: "SETTINGS.MaxFPSN",
			hint: "SETTINGS.MaxFPSL",
			scope: "client",
			config: true,
			type: Number,
			range: {min: 10, max: 60, step: 10},
			default: 60,
			onChange: () => canvas ? canvas.draw() : null
		});
		 // Live Token Drag Preview
		game.settings.register("core", "tokenDragPreview", {
			name: "SETTINGS.TokenDragPreviewN",
			hint: "SETTINGS.TokenDragPreviewL",
			scope: "world",
			config: true,
			default: false,
			type: Boolean
		});
		 // Soft Shadows
		game.settings.register("core", "softShadows", {
			name: "SETTINGS.SoftSN",
			hint: "SETTINGS.SoftSL",
			config: true,
			type: Boolean,
			default: true,
			onChange: () => canvas ? canvas.draw() : null
		});
		 // Animated Token Vision
		game.settings.register("core", "visionAnimation", {
			name: "SETTINGS.AnimVisionN",
			hint: "SETTINGS.AnimVisionL",
			config: true,
			type: Boolean,
			default: true
		});
		 // Light Source Flicker
		game.settings.register("core", "lightAnimation", {
			name: "SETTINGS.AnimLightN",
			hint: "SETTINGS.AnimLightL",
			config: true,
			type: Boolean,
			default: true,
			onChange: () => canvas.lighting.activateAnimation()
		});
		 // Mipmap Antialiasing
		game.settings.register("core", "mipmap", {
			name: "SETTINGS.MipMapN",
			hint: "SETTINGS.MipMapL",
			config: true,
			type: Boolean,
			default: true,
			onChange: () => canvas ? canvas.draw() : null
		});
		 // Default Drawing Configuration
		game.settings.register("core", DrawingsLayer.DEFAULT_CONFIG_SETTING, {
			name: "Default Drawing Configuration",
			scope: "client",
			config: false,
			default: {},
			type: Object
		});
		 // Entity-specific settings
		RollTables.registerSettings();
		 // Audio playback settings
		AudioHelper.registerSettings();
		 // Register CanvasLayer settings
		NotesLayer.registerSettings();
		TemplateLayer.registerSettings();
	}
	 /* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /**
	 * Is the current session user authenticated as an application administrator?
	 * @type {boolean}
	 */
	get isAdmin() {
		return this.data.isAdmin;
	}
	 /* -------------------------------------------- */
	 /**
	 * The currently connected User entity, or null if Users is not yet initialized
	 * @type {User|null}
	 */
	get user() {
		return this.users ? this.users.current : null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Metadata regarding the current game World
	 * @type {Object}
	 */
	get world() {
		return this.data.world;
	}
	 /* -------------------------------------------- */
	 /**
	 * Metadata regarding the game System which powers this World
	 * @type {Object}
	 */
	get system() {
		return this.data.system;
	}
	 /* -------------------------------------------- */
	 /**
	 * A convenience accessor for the currently viewed Combat encounter
	 * @type {Combat}
	 */
	get combat() {
		return this.combats.viewed;
	}
	 /* -------------------------------------------- */
	 /**
	 * A state variable which tracks whether or not the game session is currently paused
	 * @type {boolean}
	 */
	get paused() {
		return this.data.paused;
	}
	 /* -------------------------------------------- */
	 /**
	 * A convenient reference to the currently active canvas tool
	 * @type {string}
	 */
	get activeTool() {
		return ui.controls.activeTool;
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /**
	 * Toggle the pause state of the game
	 * Trigger the `pauseGame` Hook when the paused state changes
	 * @param {boolean} pause     The new pause state
	 * @param {boolean} [push]    Push the pause state change to other connected clients?
	 */
	togglePause(pause, push = false) {
		this.data.paused = pause || !this.data.paused;
		if (push && game.user.isGM) game.socket.emit("pause", this.data.paused);
		 // Render the paused UI
		ui.pause.render();
		 // Call API hooks
		Hooks.callAll("pauseGame", this.data.paused);
	}
	 /* -------------------------------------------- */
	 /**
	 * Log out of the game session by returning to the Join screen
	 */
	logOut() {
		if ( this.socket ) this.socket.disconnect();
		window.location.href = getRoute("join");
	}
	 /* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */
	 /**
	 * Open socket listeners which transact game state data
	 */
	openSockets() {
		 // Helper Listeners
		Game.socketListeners(this.socket);
		AudioHelper.socketListeners(this.socket);
		ClientSettings.socketListeners(this.socket);
		 // Database Listeners
		Entity.activateSocketListeners(this.socket);
		Users.socketListeners(this.socket);
		Scenes.socketListeners(this.socket);
		Journal.socketListeners(this.socket);
	}
	 /* -------------------------------------------- */
	 /**
	 * General game-state socket listeners and event handlers
	 * @param socket
	 */
	static socketListeners(socket) {
		 // Disconnection and reconnection attempts
		socket.on('disconnect', (reason) => {
			ui.notifications.error("You have lost connection to the server, attempting to re-establish.");
		});
		 // Reconnect failed
		socket.on('reconnect_failed', () => {
			ui.notifications.error("Server connection lost.");
			window.location.href = getRoute("no");
		});
		 // Reconnect succeeded
		socket.on('reconnect', (attemptNumber) => {
			ui.notifications.info("Server connection re-established.");
		});
		 // Game pause
		socket.on('pause', pause => {
			game.togglePause(pause, false);
		});
		 // Game shutdown
		socket.on("shutdown", data => {
			ui.notifications.info("The game world is shutting down and you will be returned to the server homepage.", {
				permanent: true
			});
			setTimeout(() => window.location.href = getRoute("/"), 1000);
		});
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /**
	 * Activate Event Listeners which apply to every Game View
	 */
	activateListeners() {
		 // Disable touch zoom
		document.addEventListener("touchmove", ev => {
			if (ev.scale !== 1) ev.preventDefault();
		});
		 // Disable right-click
		document.addEventListener("contextmenu", ev => ev.preventDefault());
		 // Disable mouse 3, 4, and 5
		document.addEventListener("mousedown", this._onLeftClick);
		 // Prevent dragging and dropping unless a more specific handler allows it
		document.addEventListener("dragstart", this._onPreventDragstart);
		document.addEventListener("dragover", this._onPreventDragover);
		document.addEventListener("drop", this._onPreventDrop);
		 // Support mousewheel interaction for range input elements
		window.addEventListener("wheel", _handleMouseWheelInputChange, {passive: false});
		 // Entity links
		TextEditor.activateListeners();
			// Await gestures to begin audio and video playback
		game.audio.awaitFirstGesture();
		game.video.awaitFirstGesture();
		 // Handle changes to the state of the browser window
		window.addEventListener("beforeunload", this._onWindowBeforeUnload);
		window.addEventListener("blur", this._onWindowBlur);
		window.addEventListener("resize", this._onWindowResize);
		if ( this.view === "game" ) {
			history.pushState(null, null, location.href);
			window.addEventListener("popstate", this._onWindowPopState);
		}
		 // Force hyperlinks to a separate window/tab
		document.addEventListener("click", this._onClickHyperlink);
	}
	 /* -------------------------------------------- */
	 /**
	 * On left mouse clicks, check if the element is contained in a valid hyperlink and open it in a new tab.
	 * @param {MouseEvent} event
	 * @private
	 */
	_onClickHyperlink(event) {
		const a = event.target.closest("a[href]");
		if ( !a || (a.href === "javascript:void(0)") ) return;
		event.preventDefault();
		window.open(a.href, "_blank");
	}
	 /* -------------------------------------------- */
	 /**
	 * Prevent starting a drag and drop workflow on elements within the document unless the element has the draggable
	 * attribute explicitly defined or overrides the dragstart handler.
	 * @param {DragEvent} event   The initiating drag start event
	 * @private
	 */
	_onPreventDragstart(event) {
		if ( event.target.getAttribute("draggable") === "true" ) return;
		event.preventDefault();
		return false;
	}
	 /* -------------------------------------------- */
	 /**
	 * Disallow dragging of external content onto anything but a file input element
	 * @param {DragEvent} event   The requested drag event
	 * @private
	 */
	_onPreventDragover(event) {
		const target = event.target;
		if ( (target.tagName === "INPUT") && (target.type === "file") ) return;
		else event.preventDefault();
	}
	 /* -------------------------------------------- */
	 /**
	 * Disallow dropping of external content onto anything but a file input element
	 * @param {DragEvent} event   The requested drag event
	 * @private
	 */
	_onPreventDrop(event) {
		const target = event.target;
		if ( (target.tagName === "INPUT") && (target.type === "file") ) return;
		else event.preventDefault();
	}
	 /* -------------------------------------------- */
	 /**
	 * On a left-click event, remove any currently displayed inline roll tooltip
	 * @param {MouseEvent} event    The originating left-click event
	 * @private
	 */
	_onLeftClick(event) {
		if ([3, 4, 5].includes(event.button)) event.preventDefault();
		const inlineRoll = document.querySelector(".inline-roll.expanded");
		if ( inlineRoll && !event.target.closest(".inline-roll") ) {
			return Roll._collapseInlineResult(inlineRoll);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle resizing of the game window
	 * Reposition any active UI windows
	 * @private
	 */
	_onWindowResize(event) {
		Object.values(ui.windows).forEach(app => app.setPosition());
		if (canvas && canvas.ready) canvas._onResize(event)
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle window unload operations to clean up any data which may be pending a final save
	 * @param {Event} event     The window unload event which is about to occur
	 * @private
	 */
	_onWindowBeforeUnload(event) {
		if ( canvas?.ready ) canvas.sight.saveFog();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle cases where the browser window loses focus to reset detection of currently pressed keys
	 * @param {Event} event   The originating window.blur event
	 * @private
	 */
	_onWindowBlur(event) {
		if ( !game.keyboard ) return;
		const dk = game.keyboard._downKeys;
		if (dk.has("Alt")) game.keyboard._onAlt(event, true, {});
		dk.clear();
		game.keyboard._handled.clear();
	}
	 /* -------------------------------------------- */
	 _onWindowPopState(event) {
		if ( game._goingBack ) return;
		history.pushState(null, null, location.href);
		if ( confirm(game.i18n.localize("APP.NavigateBackConfirm")) ) {
			game._goingBack = true;
			history.back();
			history.back();
		}
	}
	 /* -------------------------------------------- */
	/*  View Initialization Functions
	/* -------------------------------------------- */
	 /**
	 * Initialization steps for the primary Game view
	 * @private
	 */
	async _initializeGameView() {
		 // Require a valid user cookie and EULA acceptance
		if ( !SIGNED_EULA ) window.location.href = getRoute("license");
		if (!this.userId) {
			console.error("Invalid user session provided - returning to login screen.");
			this.logOut();
		}
		 // Setup the game
		await this.setupGame();
		 // Set a timeout of 10 minutes before kicking the user off
		setTimeout(() => {
			if (this.user.isGM || !this.data.demo) return;
			console.log(`${vtt} | Ending demo session after 10 minutes. Thanks for testing!`);
			this.logOut();
		}, 1000 * 60 * 10);
		 // Context menu listeners
		ContextMenu.eventListeners();
	};
	 /* -------------------------------------------- */
	 /**
	 * Initialization steps for the game setup view
	 * @private
	 */
	async _initializeLicenseView() {
		ui.notifications = new Notifications().render(true);
		const setup = document.getElementById("setup");
		if ( setup.dataset.step === "eula" ) new EULA().render(true);
	};
	 /* -------------------------------------------- */
	 /**
	 * Initialization steps for the game setup view
	 * @private
	 */
	async _initializeSetupView() {
		if ( !SIGNED_EULA ) window.location.href = getRoute("license");
		ui.notifications = new Notifications().render(true);
		if ( document.body.classList.contains("auth") ) return;
		ui.setup = new SetupConfigurationForm(game.data).render(true);
	};
	 /* -------------------------------------------- */
	 /**
	 * Initialization steps for the Stream helper view
	 * @private
	 */
	async _initializeStreamView() {
		canvas = {ready: false};
		if ( !SIGNED_EULA ) window.location.href = getRoute("license");
		this.initializeEntities();
		ui.chat = new ChatLog({stream: true}).render(true);
		Entity.activateSocketListeners(this.socket);
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize the Player Management View
	 * @private
	 */
	async _initializePlayersView() {
		if ( !SIGNED_EULA ) window.location.href = getRoute("license");
		this.users = new Users(this.data.users);
		this.players = new UserManagement(this.users);
		this.players.render(true);
		ui.notifications = new Notifications().render(true);
		Users.socketListeners(this.socket);
	};
	 /* -------------------------------------------- */
	 /**
	 * Initialization steps specifically for the game setup view
	 * This view is unique because a Game object does not exist for a non-authenticated player
	 * @private
	 */
	async _initializeJoinView() {
		if ( !SIGNED_EULA ) window.location.href = getRoute("license");
		ui.notifications = new Notifications().render(true);
		 // Populate the next session time
		const nextDate = new Date(document.getElementById("nextDatetime")?.value);
		if ( nextDate.isValid() && document.getElementById("next-date") ) {
			document.getElementById("next-date").value = nextDate.toDateInputString();
			document.getElementById("next-time").value = nextDate.toTimeInputString();
			const fmt = new Intl.DateTimeFormat(undefined, {timeZoneName: "short"});
			const tz = fmt.formatToParts().find(p => p.type === "timeZoneName");
			if (tz) document.getElementById("next-tz").innerText = ` (${tz.value})`;
		}
		 // Handle the join form submission
		const forms = document.querySelectorAll("form");
		for ( let form of forms ) {
			form.submit.disabled = false;
			form.addEventListener("submit", async event => {
				event.preventDefault();
				 // Disable the button and collect form data
				const form = event.target;
				form.submit.disabled = true;
				const formData = new FormData(form);
				formData.set("action", form.submit.dataset.action);
				 // Submit a POST request to the server
				const response = await fetch(window.location.pathname, {
					method: "POST",
					body: formData
				}).then(r => r.json());
				 // Redirect on success
				if ( response.status === "success" ) {
					ui.notifications.info(game.i18n.localize(response.message));
					setTimeout(() => window.location.href = response.redirect, 500 );
				}
				 // Notify on failure
				else if ( response.status === "failed" ) {
					ui.notifications.error(game.i18n.localize(response.error ?? response.message));
					form.submit.disabled = false;
				}
			});
		}
	}
}

/* -------------------------------------------- */

/**
 * Once the Window has loaded, created and initialize the Game object
 */
window.addEventListener("DOMContentLoaded", async function() {
	game = window.game = await Game.create();
	game.initialize();
}, {once: true, passive: true});

/**
 * This class provides an interface and API for conducting dice rolls.
 * The basic structure for a dice roll is a string formula and an object of data against which to parse it.
 *
 * @param formula {String}    The string formula to parse
 * @param data {Object}       The data object against which to parse attributes within the formula
 *
 * @see {@link Die}
 * @see {@link DicePool}
 *
 * @example
 * // Attack with advantage!
 * let r = new Roll("2d20kh + @prof + @strMod", {prof: 2, strMod: 4});
 *
 * // The parsed terms of the roll formula
 * console.log(r.terms);    // [Die, +, 2, +, 4]
 *
 * // Execute the roll
 * r.evaluate();
 *
 * // The resulting equation after it was rolled
 * console.log(r.result);   // 16 + 2 + 4
 *
 * // The total resulting from the roll
 * console.log(r.total);    // 22
 */
class Roll {
	constructor(formula, data={}) {
		 /**
		 * The original provided data
		 * @type {Object}
		 */
		this.data = this._prepareData(data);
		 /**
		 * An array of inner terms which were rolled parenthetically
		 * @type {DiceTerm[]}
		 */
		this._dice = [];
		 /**
		 * The evaluated results of the Roll
		 * @type {Array<number|string>}
		 */
		this.results = [];
		 /**
		 * The identified terms of the Roll
		 * @type {Array<Roll|DicePool|DiceTerm|number|string>}
		 */
		this.terms = this._identifyTerms(formula, {step: 0});
		 /**
		 * The original formula before evaluation
		 * @type {string}
		 */
		this._formula = this.constructor.cleanFormula(this.terms);
		 /**
		 * An internal flag for whether the Roll object has been rolled
		 * @type {boolean}
		 * @private
		 */
		this._rolled = false;
		 /**
		 * Cache the evaluated total to avoid re-evaluating it
		 * @type {number|null}
		 * @private
		 */
		this._total = null;
	}
	 /* -------------------------------------------- */
	 /**
	 * A factory method which constructs a Roll instance using the default configured Roll class.
	 * @param {any[]} args      Arguments passed to the Roll instance constructor
	 * @return {Roll}           The constructed Roll instance
	 */
	static create(...args) {
		const cls = CONFIG.Dice.rolls[0];
		return new cls(...args);
	}
	 /* -------------------------------------------- */
	 /**
	 * Replace referenced data attributes in the roll formula with values from the provided data.
	 * Data references in the formula use the @attr syntax and would reference the corresponding attr key.
	 *
	 * @param {string} formula          The original formula within which to replace
	 * @param {object} data             The data object which provides replacements
	 * @param {string} [missing]        The value that should be assigned to any unmatched keys.
	 *                                  If null, the unmatched key is left as-is.
	 * @param {boolean} [warn]          Display a warning notification when encountering an un-matched key.
	 * @static
	 */
	static replaceFormulaData(formula, data, {missing, warn=false}={}) {
		let dataRgx = new RegExp(/@([a-z.0-9_\-]+)/gi);
		return formula.replace(dataRgx, (match, term) => {
			let value = getProperty(data, term);
			if ( value === undefined ) {
				if ( warn ) ui.notifications.warn(game.i18n.format("DICE.WarnMissingData", {match}));
				return (missing !== undefined) ? String(missing) : match;
			}
			return String(value).trim();
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Return an Array of the individual DiceTerm instances contained within this Roll.
	 * @return {DiceTerm[]}
	 */
	get dice() {
		return this._dice.concat(this.terms.reduce((dice, t) => {
			if ( t instanceof DiceTerm ) dice.push(t);
			else if ( t instanceof DicePool ) dice = dice.concat(t.dice);
			return dice;
		}, []));
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a standardized representation for the displayed formula associated with this Roll.
	 * @return {string}
	 */
	get formula() {
		return this.constructor.cleanFormula(this.terms);
	}
	 /* -------------------------------------------- */
	 /**
	 * The resulting arithmetic expression after rolls have been evaluated
	 * @return {string|null}
	 */
	get result() {
		if ( !this._rolled ) return null;
		return this.results.join(" ");
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the total result of the Roll expression if it has been evaluated, otherwise null
	 * @type {number|null}
	 */
	get total() {
		if ( !this._rolled ) return null;
		return this._total;
	}
	 /* -------------------------------------------- */
	 /**
	 * Alter the Roll expression by adding or multiplying the number of dice which are rolled
	 * @param {number} multiply   A factor to multiply. Dice are multiplied before any additions.
	 * @param {number} add        A number of dice to add. Dice are added after multiplication.
	 * @param {boolean} [multiplyNumeric]  Apply multiplication factor to numeric scalar terms
	 * @return {Roll}             The altered Roll expression
	 */
	alter(multiply, add, {multiplyNumeric=false}={}) {
		if ( this._rolled ) throw new Error("You may not alter a Roll which has already been rolled");
		this.terms = this.terms.map(t => {
			if ( t.alter ) return t.alter(multiply, add, {multiplyNumeric});
			else if ( (typeof t === "number") && multiplyNumeric ) return Math.round(t * multiply);
			return t;
		});
		 // Update the altered formula and return the altered Roll
		this._formula = this.formula;
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Execute the Roll, replacing dice and evaluating the total result
	 *
	 * @param {boolean} [minimize]    Produce the minimum possible result from the Roll instead of a random result.
	 * @param {boolean} [maximize]    Produce the maximum possible result from the Roll instead of a random result.
	 *
	 * @returns {Roll}    The rolled Roll object, able to be chained into other methods
	 *
	 * @example
	 * let r = new Roll("2d6 + 4 + 1d4");
	 * r.evaluate();
	 * console.log(r.result); // 5 + 4 + 2
	 * console.log(r.total);  // 11
	 */
	evaluate({minimize=false, maximize=false}={}) {
		if ( this._rolled ) throw new Error("This Roll object has already been rolled.");
		 // Step 1 - evaluate any inner Rolls and recompile the formula
		let hasInner = false;
		this.terms = this.terms.map((t, i, terms) => {
			if ( t instanceof Roll ) {
				hasInner = true;
				t.evaluate({minimize, maximize});
				this._dice = this._dice.concat(t.dice);
				const priorMath = (i > 0) && (terms[i-1].split(" ").pop() in Math);
				return priorMath ? `(${t.total})` : String(t.total);
			}
			return t;
		});
		 // Step 2 - re-compile the formula and re-identify terms
		const formula = this.constructor.cleanFormula(this.terms);
		this.terms = this._identifyTerms(formula, {step: 1});
		 // Step 3 - evaluate remaining terms
		this.results = this.terms.map(term => {
			if ( term.evaluate ) return term.evaluate({minimize, maximize}).total;
			else return term;
		});
		 // Step 4 - safely evaluate the final total
		let total = this._safeEval(this.results.join(" "));
		if ( total === null ) total = 0;
		if ( !Number.isNumeric(total) ) {
			throw new Error(game.i18n.format("DICE.ErrorNonNumeric", {formula: this.formula}));
		}
		 // Store final outputs
		this._total = total;
		this._rolled = true;
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Clone the Roll instance, returning a new Roll instance that has not yet been evaluated
	 * @return {Roll}
	 */
	clone() {
		return new this.constructor(this._formula, this.data);
	}
	 /* -------------------------------------------- */
	 /**
	 * Evaluate and return the Roll expression.
	 * This function simply calls the evaluate() method but is maintained for backwards compatibility.
	 * @return {Roll}   The Roll instance, containing evaluated results and the rolled total.
	 */
	roll() {
		return this.evaluate();
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a new Roll object using the original provided formula and data
	 * Each roll is immutable, so this method returns a new Roll instance using the same data.
	 *
	 * @return {Roll}    A new Roll object, rolled using the same formula and data
	 */
	reroll() {
		let r = new this.constructor(this.formula, this.data);
		return r.roll();
	}
	 /* -------------------------------------------- */
	 /**
	 * Simulate a roll and evaluate the distribution of returned results
	 * @param {string} formula    The Roll expression to simulate
	 * @param {number} n          The number of simulations
	 * @return {number[]}         The rolled totals
	 */
	static simulate(formula, n=10000) {
		const results = [...Array(n)].map(i => {
			let r = new this(formula);
			return r.evaluate().total;
		}, []);
		const summary = results.reduce((sum, v) => {
			sum.total = sum.total + v;
			if ( (sum.min === null) || (v < sum.min) ) sum.min = v;
			if ( (sum.max === null) || (v > sum.max) ) sum.max = v;
			return sum;
		}, {total: 0, min: null, max: null});
		summary.mean = summary.total / n;
		console.log(`Formula: ${formula} | Iterations: ${n} | Mean: ${summary.mean} | Min: ${summary.min} | Max: ${summary.max}`);
		return results;
	}
	 /* -------------------------------------------- */
	 /**
	 * Validate that a provided roll formula can represent a valid
	 * @param {string} formula    A candidate formula to validate
	 * @return {boolean}          Is the provided input a valid dice formula?
	 */
	static validate(formula) {
		 // Replace all data references with an arbitrary number
		formula = formula.replace(/@([a-z.0-9_\-]+)/gi, "1");
		 // Attempt to evaluate the roll
		try {
			const r = new this(formula);
			r.evaluate();
			return true;
		}
		 // If we weren't able to evaluate, the formula is invalid
		catch(err) {
			return false;
		}
	}
	 /* -------------------------------------------- */
	/*  Internal Helper Functions                   */
	/* -------------------------------------------- */
	 /**
	 * Create a formula string from an array of Dice terms.
	 * @return {string}
	 */
	static cleanFormula(terms) {
		terms = this.cleanTerms(terms).map(t => {
			if ( t instanceof Roll ) return `(${t.formula})`;
			return t.formula || String(t);
		}).join("");
		let formula = terms.replace(/ /g, "");
		return formula.replace(new RegExp(this.ARITHMETIC.map(o => "\\"+o).join("|"), "g"), " $& ");
	}
	 /* -------------------------------------------- */
	 /**
	 * Clean the terms of a Roll equation, removing empty space and de-duping arithmetic operators
	 * @param {Array<DiceTerm|string|number>} terms  The input array of terms
	 * @return {Array<DiceTerm|string|number>}       The cleaned array of terms
	 */
	static cleanTerms(terms) {
		return terms.reduce((cleaned, t, i, terms) => {
			if ( typeof t === "string" ) t = t.trim();
			if ( t === "" ) return cleaned;
			let prior = terms[i-1];
			 // De-dupe addition and multiplication
			if ( ["+", "*"].includes(t) && prior === t ) return cleaned;
			 // Negate double subtraction
			if ( (t === "-") && (prior === "-" ) ) {
				cleaned[i-1] = "+";
				return cleaned;
			}
			 // Negate double division
			if ( (t === "/") && (prior === "/") ) {
				cleaned[i-1] = "*";
				return cleaned;
			}
			 // Subtraction and negative values
			if ( ["-+", "+-"].includes(t+prior) ) {
				cleaned[i-1] = "-";
				return cleaned;
			}
			 // Return the clean array
			cleaned.push(t);
			return cleaned;
		}, []);
	}
	 /* -------------------------------------------- */
	 /**
	 * Split a provided Roll formula to identify it's component terms.
	 * Some terms are very granular, like a Number of an arithmetic operator
	 * Other terms are very coarse like an entire inner Roll from a parenthetical expression.
	 * As a general rule, this function should return an Array of terms which are ready to be evaluated immediately.
	 * Some terms may require recursive evaluation.
	 * @private
	 *
	 * @param {string} formula  The formula to parse
	 * @param {number} [step]   The numbered step in the Roll evaluation process.
	 * @return {Array<Roll|DicePool|DiceTerm|number|string>}       An array of identified terms
	 */
	_identifyTerms(formula, {step=0}={}) {
		if ( typeof formula !== "string" ) throw new Error("The formula provided to a Roll instance must be a string");
		 // Step 1 - Update the Roll formula using provided data
		formula = this.constructor.replaceFormulaData(formula, this.data, {missing: "0", warn: true});
		 // Step 2 - identify separate parenthetical terms
		let terms = this._splitParentheticalTerms(formula);
		 // Step 3 - expand pooled terms
		terms = this._splitPooledTerms(terms);
		 // Step 4 - expand remaining arithmetic terms
		terms = this._splitDiceTerms(terms, step);
		 // Step 5 - clean and de-dupe terms
		terms = this.constructor.cleanTerms(terms);
		return terms;
	}
	 /* -------------------------------------------- */
	 /**
	 * Prepare the data structure used for the Roll.
	 * This is factored out to allow for custom Roll classes to do special data preparation using provided input.
	 * @param {object} data   Provided roll data
	 * @private
	 */
	_prepareData(data) {
		return data;
	}
	 /* -------------------------------------------- */
	 /**
	 * Identify and split a formula into separate terms by arithmetic terms
	 * @private
	 */
	_splitDiceTerms(terms, step) {
		 // Split on arithmetic terms and operators
		const operators = this.constructor.ARITHMETIC.concat(["(", ")"]);
		const arith = new RegExp(operators.map(o => "\\"+o).join("|"), "g");
		 // Expand remaining string terms by splitting on arithmetic operators
		terms = terms.reduce((arr, term) => {
			if ( typeof term === "string" ) {
				const split = term.replace(arith, ";$&;").split(";");
				for ( let s of split ) {
					s = s.trim();
					if ( s !== "" ) arr.push(s);
				}
			}
			else arr.push(term);
			return arr;
		}, []);
		 // Iterate over all terms, identifying numeric and dice terms
		terms = terms.reduce((arr, term, i, terms) => {
			 // Preserve existing object types
			if ( getType(term) === "Object" ) {
				arr.push(term);
				return arr;
			}
			 // Handle arithmetic terms
			if ( this.constructor.ARITHMETIC.includes(term) ) {
				if ( !arr.length && (term !== "-") ) return arr; // Ignore leading arithmetic except negatives
				else if ( i === (terms.length - 1) ) return arr; // Ignore trailing arithmetic
				arr.push(term);
				return arr;
			}
			 // Handle numeric terms
			if ( Number.isNumeric(term) ) {
				arr.push(Number(term));
				return arr;
			}
			 // Identify Dice terms
			if ( DiceTerm.matchTerm(term, {imputeNumber: step > 0}) ) {
				const die = DiceTerm.fromExpression(term);
				arr.push(die);
				return arr;
			}
			 // Remaining string terms
			arr.push(term);
			return arr;
		}, []);
		 // Return the set of final terms
		return terms;
	}
	 /* -------------------------------------------- */
	 /**
	 * Identify and split a formula into separate terms by parenthetical expressions
	 * @private
	 */
	_splitParentheticalTerms(formula) {
		 // Augment parentheses with semicolons and split into terms
		const split = formula.replace(/\(/g, ";(;").replace(/\)/g, ";);");
		 // Match outer-parenthetical groups
		let nOpen = 0;
		const terms = split.split(";").reduce((arr, t, i, terms) => {
			if ( t === "" ) return arr;
			 // Identify whether the left-parentheses opens a math function
			let mathFn = false;
			if ( t === "(" ) {
				const fn = terms[i-1].match(/(?:\s)?([A-z0-9]+)$/);
				mathFn = fn && !!Roll.MATH_PROXY[fn[1]];
			}
			 // Combine terms using open parentheses and math expressions
			if ( (nOpen > 0) || mathFn ) arr[arr.length - 1] += t;
			else arr.push(t);
			 // Increment the count
			if ( (t === "(") ) nOpen++;
			else if ( (t === ")") && ( nOpen > 0 ) ) nOpen--;
			return arr;
		}, []);
		 // Close any un-closed parentheses
		for ( let i=0; i<nOpen; i++ ) terms[terms.length - 1] += ")";
		 // Substitute parenthetical dice rolls groups to inner Roll objects
		return terms.reduce((terms, term) => {
			const prior = terms.length ? terms[terms.length-1] : null;
			if ( term[0] === "(" ) {
				 // Handle inner Roll parenthetical groups
				if ( /[dD]/.test(term) ) {
					terms.push(Roll.fromTerm(term, this.data));
					return terms;
				}
				 // Evaluate arithmetic-only parenthetical groups
				term = this._safeEval(term);
				term = Number.isInteger(term) ? term : term.toFixed(2);
				 // Continue wrapping math functions
				const priorMath = prior && (prior.split(" ").pop() in Math);
				if ( priorMath ) term = `(${term})`;
			}
			 // Append terms to to non-Rolls
			if ((prior !== null) && !(prior instanceof Roll)) terms[terms.length-1] += term;
			else terms.push(term);
			return terms;
		}, []);
	}
	 /* -------------------------------------------- */
	 /**
	 * Identify and split a formula into separate terms by curly braces which represent pooled expressions
	 * @private
	 */
	_splitPooledTerms(terms) {
		 // First re-organize the terms by splitting on curly braces
		let nOpen = 0;
		terms = terms.reduce((terms, term) => {
			 // Force immediate processing of inner objects which are encountered within an open outer pool
			if ( (term instanceof Roll) || (term instanceof DicePool) ) {
				if ( nOpen > 0 ) {
					term.evaluate();
					this._dice = this._dice.concat(term.dice);
					term = term.total;
				}
				else {
					terms.push(term);
					return terms;
				}
			}
			term = String(term);
			 // Match outer-bracketed groups
			const parts = term.replace(/{/g, ';{;').replace(/}([A-z0-9<=>]+)?/g, '$&;').split(";");
			for ( let t of parts ) {
				if ( t === "" ) continue;
				if ( nOpen > 0 ) terms[terms.length - 1] += t;
				else terms.push(t);
				if ( t === "{" ) nOpen = Math.max(1, nOpen + 1);
				if ( /}/.test(t) ) nOpen = Math.max(0, nOpen - 1);
			}
			return terms;
		}, []);
		 // Close any un-closed pools
		for ( let i=0; i<nOpen; i++ ) terms[terms.length - 1] += "}";
		 // Convert term groups to DicePool objects
		return terms.reduce((terms, term) => {
			if ( term === "" ) return terms;
			const isClosedPool = (term[0] === "{") && (term.indexOf("}") !== -1);
			if ( isClosedPool ) terms.push(DicePool.fromExpression(term, {}, this.data));
			else terms.push(term);
			return terms;
		}, []);
	}
	 /* -------------------------------------------- */
	 /**
	 * Safely evaluate a formulaic expression using a Proxy environment which is allowed access to Math commands
	 * @param {string} expression     The formula expression to evaluate
	 * @return {number|null}          The returned numeric result, or null if the outcome is not numeric
	 * @private
	 */
	_safeEval(expression) {
		return Roll.MATH_PROXY.safeEval(expression);
	}
	 /* -------------------------------------------- */
	/*  Chat Messages                               */
	/* -------------------------------------------- */
	 /**
	 * Render the tooltip HTML for a Roll instance
	 * @return {Promise<HTMLElement>}
	 */
	getTooltip() {
		const parts = this.dice.map(d => {
			const cls = d.constructor;
			return {
				formula: d.expression,
				total: d.total,
				faces: d.faces,
				flavor: d.flavor,
				rolls: d.results.map(r => {
					const hasSuccess = r.success !== undefined;
					const hasFailure = r.failure !== undefined;
					const isMax = r.result === d.faces;
					const isMin = r.result === 1;
					return {
						result: cls.getResultLabel(r.result),
						classes: [
							cls.name.toLowerCase(),
							"d" + d.faces,
							r.success ? "success" : null,
							r.failure ? "failure" : null,
							r.rerolled ? "rerolled" : null,
							r.exploded ? "exploded" : null,
							r.discarded ? "discarded" : null,
							!(hasSuccess || hasFailure) && isMin ? "min" : null,
							!(hasSuccess || hasFailure) && isMax ? "max" : null
						].filter(c => c).join(" ")
					}
				})
			};
		});
		return renderTemplate(this.constructor.TOOLTIP_TEMPLATE, { parts });
	}
	 /* -------------------------------------------- */
	 /**
	 * Render a Roll instance to HTML
	 * @param chatOptions {Object}      An object configuring the behavior of the resulting chat message.
	 * @return {Promise.<HTMLElement>}  A Promise which resolves to the rendered HTML
	 */
	async render(chatOptions = {}) {
		chatOptions = mergeObject({
			user: game.user._id,
			flavor: null,
			template: this.constructor.CHAT_TEMPLATE,
			blind: false
		}, chatOptions);
		const isPrivate = chatOptions.isPrivate;
		 // Execute the roll, if needed
		if (!this._rolled) this.roll();
		 // Define chat data
		const chatData = {
			formula: isPrivate ? "???" : this._formula,
			flavor: isPrivate ? null : chatOptions.flavor,
			user: chatOptions.user,
			tooltip: isPrivate ? "" : await this.getTooltip(),
			total: isPrivate ? "?" : Math.round(this.total * 100) / 100
		};
		 // Render the roll display template
		return renderTemplate(chatOptions.template, chatData);
	}
	 /* -------------------------------------------- */
	 /**
	 * Transform a Roll instance into a ChatMessage, displaying the roll result.
	 * This function can either create the ChatMessage directly, or return the data object that will be used to create.
	 *
	 * @param {object} messageData          The data object to use when creating the message
	 * @param {options} [options]           Additional options which modify the created message.
	 * @param {string|null} [options.rollMode]  The template roll mode to use for the message from CONFIG.Dice.rollModes
	 * @param {boolean} [options.create=true]   Whether to automatically create the chat message, or only return the
	 *                                          prepared chatData object.
	 * @return {Promise|Object}             A promise which resolves to the created ChatMessage entity, if create is true
	 *                                      or the Object of prepared chatData otherwise.
	 */
	toMessage(messageData={}, {rollMode=null, create=true}={}) {
		 // Perform the roll, if it has not yet been rolled
		if (!this._rolled) this.evaluate();
		 // Prepare chat data
		messageData = mergeObject({
			user: game.user._id,
			type: CONST.CHAT_MESSAGE_TYPES.ROLL,
			content: this.total,
			sound: CONFIG.sounds.dice,
		}, messageData);
		messageData.roll = this;
		 // Apply message options
		if ( rollMode ) ChatMessage.applyRollMode(messageData, rollMode);
		 // Either create the message or just return the chat data
		return create ? CONFIG.ChatMessage.entityClass.create(messageData) : messageData;
	}
	 /* -------------------------------------------- */
	/*  Saving and Loading                          */
	/* -------------------------------------------- */
	 /**
	 * Represent the data of the Roll as an object suitable for JSON serialization.
	 * @return {Object}     Structured data which can be serialized into JSON
	 */
	toJSON() {
		if ( !this._rolled ) throw new Error(`You cannot serialize an un-rolled Roll object`);
		return {
			class: this.constructor.name,
			dice: this._dice,
			formula: this._formula,
			terms: this.terms,
			results: this.results,
			total: this._total
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Recreate a Roll instance using a provided data object
	 * @param {object} data   Unpacked data representing the Roll
	 * @return {Roll}         A reconstructed Roll instance
	 */
	static fromData(data) {
		if (!("terms" in data)) {
			data = this._backwardsCompatibleRoll(data);
		}
		 // Create the Roll instance
		const roll = new this(data.formula);
		roll.results = data.results;
		roll._total = data.total;
		roll._dice = data.dice.map(t => DiceTerm.fromData(t));
		 // Expand terms
		roll.terms = data.terms.map(t => {
			if ( t.class ) {
				if ( t.class === "DicePool" ) return DicePool.fromData(t);
				else return DiceTerm.fromData(t);
			}
			return t;
		});
		 // Return the reconstructed roll
		roll._rolled = true;
		return roll;
	}
	 /* -------------------------------------------- */
	 /**
	 * Recreate a Roll instance using a provided JSON string
	 * @param {string} json   Serialized JSON data representing the Roll
	 * @return {Roll}         A reconstructed Roll instance
	 */
	static fromJSON(json) {
		const data = JSON.parse(json);
		const cls = CONFIG.Dice.rolls.find(cls => cls.name === data.class);
		if ( !cls ) throw new Error(`Unable to recreate ${data.class} instance from provided data`);
		return cls.fromData(data);
	}
	 /* -------------------------------------------- */
	 /**
	 * Construct a new Roll object from a parenthetical term of an outer Roll.
	 * @param {string} term     The isolated parenthetical term, for example (4d6)
	 * @param {object} data     The Roll data object, provided by the outer Roll
	 * @return {Roll}           An inner Roll object constructed from the term
	 */
	static fromTerm(term, data) {
		const match = term.match(this.PARENTHETICAL_RGX);
		return new this(match ? match[1] : term, data);
	}
	 /* -------------------------------------------- */
	/*  Interface Helpers                           */
	/* -------------------------------------------- */
	 /**
	 * Expand an inline roll element to display it's contained dice result as a tooltip
	 * @param {HTMLAnchorElement} a     The inline-roll button
	 * @return {Promise<void>}
	 * @private
	 */
	static async _expandInlineResult(a) {
		if ( !a.classList.contains("inline-roll") ) return;
		if ( a.classList.contains("expanded") ) return;
		 // Create a new tooltip
		const roll = Roll.fromJSON(unescape(a.dataset.roll));
		const tip = document.createElement("div");
		tip.innerHTML = await roll.getTooltip();
		 // Add the tooltip
		const tooltip = tip.children[0];
		a.appendChild(tooltip);
		a.classList.add("expanded");
		 // Set the position
		const pa = a.getBoundingClientRect();
		const pt = tooltip.getBoundingClientRect();
		tooltip.style.left = `${Math.min(pa.x, window.innerWidth - (pt.width + 3))}px`;
		tooltip.style.top = `${Math.min(pa.y + pa.height + 3, window.innerHeight - (pt.height + 3))}px`;
		const zi = getComputedStyle(a).zIndex;
		tooltip.style.zIndex = Number.isNumeric(zi) ? zi + 1 : 100;
	}
	 /* -------------------------------------------- */
	 /**
	 * Collapse an expanded inline roll to conceal it's tooltip
	 * @param {HTMLAnchorElement} a     The inline-roll button
	 * @private
	 */
	static _collapseInlineResult(a) {
		if ( !a.classList.contains("inline-roll") ) return;
		if ( !a.classList.contains("expanded") ) return;
		const tooltip = a.querySelector(".dice-tooltip");
		if ( tooltip ) tooltip.remove();
		return a.classList.remove("expanded");
	}
	 /* -------------------------------------------- */
	/*  Deprecations                                */
	/* -------------------------------------------- */
	 /**
	 * Provide backwards compatibility for Roll data prior to 0.7.0
	 * @deprecated since 0.7.0
	 * @private
	 */
	static _backwardsCompatibleRoll(data) {
		data.terms = data.parts.map(p => {
			if ( /_d[0-9]+/.test(p) ) {
				let i = parseInt(p.replace("_d", ""));
				return data.dice[i];
			}
			return p;
		});
		delete data.parts;
		data.dice = [];
		data.results = data.result.split(" + ").map(Number);
		delete data.result;
		return data;
	}
	 /* -------------------------------------------- */
	 /**
	 * @deprecated since 0.7.0
	 * @see {@link Roll#terms}
	 */
	get parts() {
		console.warn(`You are referencing Roll#parts which is now deprecated in favor of Roll#terms`);
		return this.terms;
	}
	 /* -------------------------------------------- */
	 /**
	 * @deprecated since 0.7.0
	 * @see {@link Roll#evaluate}
	 */
	static minimize(formula) {
		console.warn(`The Roll.minimize(formula) function is deprecated in favor of Roll#evaluate({minimize: true})`);
		return new this(formula).evaluate({minimize: true});
	}
	 /* -------------------------------------------- */
	 /**
	 * @deprecated since 0.7.0
	 * @see {@link Roll#evaluate}
	 */
	static maximize(formula) {
		console.warn(`The Roll.maximize(formula) function is deprecated in favor of Roll#evaluate({maximize: true})`);
		return new this(formula).evaluate({maximize: true});
	}
}

/**
 * Allowed arithmetic operators which can join together terms in a Roll expression
 * @type {string[]}
 */
Roll.ARITHMETIC = ["+", "-", "*", "/"];

/**
 * A Proxy environment for safely evaluating a string using only available Math functions
 * @type {Math}
 */
Roll.MATH_PROXY = new Proxy(Math, {has: () => true, get: (t, k) => k === Symbol.unscopables ? undefined : t[k]});
Roll.MATH_PROXY.safeEval = function(expression) {
	const src = 'with (sandbox) { return ' + expression + '}';
	const evl = new Function('sandbox', src);
	return evl(this);
}

/**
 * A regular expression used to identify the Roll formula for parenthetical terms
 * @type {RegExp}
 */
Roll.PARENTHETICAL_RGX = /^\((.*)\)$/;
Roll.CHAT_TEMPLATE = "templates/dice/roll.html";
Roll.TOOLTIP_TEMPLATE = "templates/dice/tooltip.html";
/**
 * An abstract base class for any term which appears in a dice roll formula
 * @abstract
 *
 * @param {object} termData                 Data used to create the Dice Term, including the following:
 * @param {number} termData.number          The number of dice of this term to roll, before modifiers are applied
 * @param {number} termData.faces           The number of faces on each die of this type
 * @param {string[]} termData.modifiers     An array of modifiers applied to the results
 * @param {object} termData.options         Additional options that modify the term
 */
class DiceTerm {
	constructor({number=1, faces=6, modifiers=[], options={}}={}) {
		 /**
		 * The number of dice of this term to roll, before modifiers are applied
		 * @type {number}
		 */
		this.number = number;
		 /**
		 * The number of faces on the die
		 * @type {number}
		 */
		this.faces = faces;
		 /**
		 * An Array of dice term modifiers which are applied
		 * @type {string[]}
		 */
		this.modifiers = modifiers;
		 /**
		 * An object of additional options which modify the dice term
		 * @type {object}
		 */
		this.options = options;
		 /**
		 * The array of dice term results which have been rolled
		 * @type {object[]}
		 */
		this.results = [];
		 /**
		 * An internal flag for whether the dice term has been evaluated
		 * @type {boolean}
		 * @private
		 */
		this._evaluated = false;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the dice expression portion of the full term formula, excluding any flavor text.
	 * @type {string}
	 */
	get expression() {
		const x = this.constructor.DENOMINATION === "d" ? this.faces : this.constructor.DENOMINATION;
		return `${this.number}d${x}${this.modifiers.join("")}`;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a standardized representation for the displayed formula associated with this DiceTerm
	 * @type {string}
	 */
	get formula() {
		let f = this.expression;
		if ( this.flavor ) f += `[${this.flavor}]`;
		return f;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the flavor text associated with a particular DiceTerm, possibly an empty string if the term is flavorless.
	 * @type {string}
	 */
	get flavor() {
		return this.options.flavor || "";
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the total result of the DiceTerm if it has been evaluated
	 * @type {number|null}
	 */
	get total() {
		if ( !this._evaluated ) return null;
		return this.results.reduce((t, r) => {
			if ( !r.active ) return t;
			if ( r.count !== undefined ) return t + r.count;
			else return t + r.result;
		}, 0);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return an array of rolled values which are still active within this term
	 * @type {number[]}
	 */
	get values() {
		return this.results.reduce((arr, r) => {
			if ( !r.active ) return arr;
			arr.push(r.result);
			return arr;
		}, []);
	}
	 /* -------------------------------------------- */
	 /**
	 * Alter the DiceTerm by adding or multiplying the number of dice which are rolled
	 * @param {number} multiply   A factor to multiply. Dice are multiplied before any additions.
	 * @param {number} add        A number of dice to add. Dice are added after multiplication.
	 * @return {DiceTerm}         The altered term
	 */
	alter(multiply, add) {
		if ( this._evaluated ) throw new Error(`You may not alter a DiceTerm after it has already been evaluated`);
		multiply = Number.isFinite(multiply) && (multiply >= 0) ? multiply : 1;
		add = Number.isInteger(add) ? add : 0;
		if ( multiply >= 0 ) this.number = Math.round(this.number * multiply);
		if ( add ) this.number += add;
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Evaluate the roll term, populating the results Array.
	 * @param {boolean} [minimize]    Apply the minimum possible result for each roll.
	 * @param {boolean} [maximize]    Apply the maximum possible result for each roll.
	 * @returns {DiceTerm}    The evaluated dice term
	 */
	evaluate({minimize=false, maximize=false}={}) {
		if ( this._evaluated ) {
			throw new Error(`This ${this.constructor.name} has already been evaluated and is immutable`);
		}
		 // Roll the initial number of dice
		for ( let n=1; n <= this.number; n++ ) {
			this.roll({minimize, maximize});
		}
		 // Apply modifiers
		this._evaluateModifiers();
		 // Return the evaluated term
		this._evaluated = true;
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Roll the DiceTerm by mapping a random uniform draw against the faces of the dice term.
	 * @param {boolean} [minimize]    Apply the minimum possible result instead of a random result.
	 * @param {boolean} [maximize]    Apply the maximum possible result instead of a random result.
	 * @return {object}
	 */
	roll({minimize=false, maximize=false}={}) {
		const rand = CONFIG.Dice.randomUniform();
		let result = Math.ceil(rand * this.faces);
		if ( minimize ) result = Math.min(1, this.faces);
		if ( maximize ) result = this.faces;
		const roll = {result, active: true};
		this.results.push(roll);
		return roll;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a string used as the label for each rolled result
	 * @param {string} result     The numeric result
	 * @return {string}           The result label
	 */
	static getResultLabel(result) {
		return String(result);
	}
	 /* -------------------------------------------- */
	/*  Modifier Helpers                            */
	/* -------------------------------------------- */
	 /**
	 * Sequentially evaluate each dice roll modifier by passing the term to its evaluation function
	 * Augment or modify the results array.
	 * @private
	 */
	_evaluateModifiers() {
		const cls = this.constructor;
		for ( let m of this.modifiers ) {
			const command = m.match(/[A-z]+/)[0].toLowerCase();
			let fn = cls.MODIFIERS[command];
			if ( typeof fn === "string" ) fn = this[fn];
			if ( fn instanceof Function ) {
				fn.call(this, m);
			}
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * A helper comparison function.
	 * Returns a boolean depending on whether the result compares favorably against the target.
	 * @param {number} result         The result being compared
	 * @param {string} comparison     The comparison operator in [=,<,<=,>,>=]
	 * @param {number} target         The target value
	 * @return {boolean}              Is the comparison true?
	 */
	static compareResult(result, comparison, target) {
		switch ( comparison ) {
			case "=":
				return result === target;
			case "<":
				return result < target;
			case "<=":
				return result <= target;
			case ">":
				return result > target;
			case ">=":
				return result >= target;
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * A helper method to modify the results array of a dice term by flagging certain results are kept or dropped.
	 * @param {object[]} results      The results array
	 * @param {number} number         The number to keep or drop
	 * @param {boolean} [keep]        Keep results?
	 * @param {boolean} [highest]     Keep the highest?
	 * @return {object[]}             The modified results array
	 */
	static _keepOrDrop(results, number, {keep=true, highest=true}={}) {
		 // Sort remaining active results in ascending (keep) or descending (drop) order
		const ascending = keep === highest;
		const values = results.reduce((arr, r) => {
			if ( r.active ) arr.push(r.result);
			return arr;
		}, []).sort((a, b) => ascending ? a - b : b - a);
		 // Determine the cut point, beyond which to discard
		number = Math.clamped(keep ? values.length - number : number, 0, values.length);
		const cut = values[number];
		 // Track progress
		let discarded = 0;
		const ties = [];
		let comp = ascending ? "<" : ">";
		 // First mark results on the wrong side of the cut as discarded
		results.forEach(r => {
			if ( !r.active ) return;  // Skip results which have already been discarded
			let discard = this.compareResult(r.result, comp, cut);
			if ( discard ) {
				r.discarded = true;
				r.active = false;
				discarded++;
			}
			else if ( r.result === cut ) ties.push(r);
		});
		 // Next discard ties until we have reached the target
		ties.forEach(r => {
			if ( discarded < number ) {
				r.discarded = true;
				r.active = false;
				discarded++;
			}
		});
		return results;
	}
	 /* -------------------------------------------- */
	 /**
	 * A reusable helper function to handle the identification and deduction of failures
	 */
	static _applyCount(results, comparison, target, {flagSuccess=false, flagFailure=false}={}) {
		for ( let r of results ) {
			let success = this.compareResult(r.result, comparison, target);
			if (flagSuccess) {
				r.success = success;
				if (success) delete r.failure;
			}
			else if (flagFailure ) {
				r.failure = success;
				if (success) delete r.success;
			}
			r.count = success ? 1 : 0;
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * A reusable helper function to handle the identification and deduction of failures
	 */
	static _applyDeduct(results, comparison, target, {deductFailure=false, invertFailure=false}={}) {
		for ( let r of results ) {
			 // Flag failures if a comparison was provided
			if (comparison) {
				const fail = this.compareResult(r.result, comparison, target);
				if ( fail ) {
					r.failure = true;
					delete r.success;
				}
			}
			 // Otherwise treat successes as failures
			else {
				if ( r.success === false ) {
					r.failure = true;
					delete r.success;
				}
			}
			 // Deduct failures
			if ( deductFailure ) {
				if ( r.failure ) r.count = -1;
			}
			else if ( invertFailure ) {
				if ( r.failure ) r.count = -1 * r.result;
			}
		}
	}
	 /* -------------------------------------------- */
	/*  Factory Methods                             */
	/* -------------------------------------------- */
	 /**
	 * Construct a DiceTerm from a provided data object
	 * @param {object} data         Provided data from an un-serialized term
	 * @return {DiceTerm}           The constructed DiceTerm
	 */
	static fromData(data) {
		// TODO: Backwards compatibility for pre-0.7.0 dice
		if (!("number" in data)) data = this._backwardsCompatibleTerm(data);
		const cls = Object.values(CONFIG.Dice.terms).find(c => c.name === data.class) || Die;
		return cls.fromResults(data, data.results);
	}
	 /* -------------------------------------------- */
	 /**
	 * Parse a provided roll term expression, identifying whether it matches this type of term.
	 * @param {string} expression
	 * @param {object} options            Additional term options
	 * @return {DiceTerm|null}            The constructed DiceTerm instance
	 */
	static fromExpression(expression, options={}) {
		const match = this.matchTerm(expression);
		if ( !match ) return null;
		let [number, denomination, modifiers, flavor] = match.slice(1);
		 // Get the denomination of DiceTerm
		denomination = denomination.toLowerCase();
		const term = denomination in CONFIG.Dice.terms ? CONFIG.Dice.terms[denomination] : Die;
		if ( !term ) throw new Error(`Die denomination ${denomination} not registered in CONFIG.Dice.terms`);
		 // Get the term arguments
		number = Number.isNumeric(number) ? parseInt(number) : 1;
		const faces = Number.isNumeric(denomination) ? parseInt(denomination) : null;
		modifiers = Array.from((modifiers || "").matchAll(DiceTerm.MODIFIER_REGEX)).map(m => m[0]);
		if ( flavor ) options.flavor = flavor;
		 // Construct a term of the appropriate denomination
		return new term({number, faces, modifiers, options});
	}
	 /* -------------------------------------------- */
	 /**
	 * Check if the expression matches this type of term
	 * @param {string} expression               The expression to parse
	 * @param {boolean} [imputeNumber=true]     Allow the number of dice to be optional, i.e. "d6"
	 * @return {RegExpMatchArray|null}
	 */
	static matchTerm(expression, {imputeNumber=true}={}) {
		const rgx = new RegExp(`^([0-9]+)${imputeNumber ? "?" : ""}[dD]([A-z]|[0-9]+)${DiceTerm.MODIFIERS_REGEX}${DiceTerm.FLAVOR_TEXT_REGEX}`);
		const match = expression.match(rgx);
		return match || null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a "fake" dice term from a pre-defined array of results
	 * @param {object} options        Arguments used to initialize the term
	 * @param {object[]} results      An array of pre-defined results
	 * @return {DiceTerm}
	 *
	 * @example
	 * let d = new Die({faces: 6, number: 4, modifiers: ["r<3"]});
	 * d.evaluate();
	 * let d2 = Die.fromResults({faces: 6, number: 4, modifiers: ["r<3"]}, d.results);
	 */
	static fromResults(options, results) {
		const term = new this(options);
		term.results = results;
		term._evaluated = true;
		return term;
	}
	 /* -------------------------------------------- */
	 /**
	 * Serialize the DiceTerm to a JSON string which allows it to be saved in the database or embedded in text.
	 * This method should return an object suitable for passing to the JSON.stringify function.
	 * @return {object}
	 */
	toJSON() {
		return {
			class: this.constructor.name,
			number: this.number,
			faces: this.faces,
			modifiers: this.modifiers,
			options: this.options,
			results: this.results
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Reconstruct a DiceTerm instance from a provided JSON string
	 * @param {string} json   A serialized JSON representation of a DiceTerm
	 * @return {DiceTerm}     A reconstructed DiceTerm from the provided JSON
	 */
	static fromJSON(json) {
		let data;
		try {
			data = JSON.parse(json);
		} catch(err) {
			throw new Error("You must pass a valid JSON string");
		}
		return this.fromData(data);
	}
	 /* -------------------------------------------- */
	 /**
	 * Provide backwards compatibility for Die syntax prior to 0.7.0
	 * @private
	 */
	static _backwardsCompatibleTerm(data) {
		const match = this.matchTerm(data.formula);
		data.number = parseInt(match[1]);
		data.results = data.rolls.map(r => {
			r.result = r.roll;
			delete r.roll;
			r.active = r.active !== false;
			return r;
		});
		delete data.rolls;
		delete data.formula;
		return data;
	}
}

/**
 * Define the denomination string used to register this Dice type in CONFIG.Dice.terms
 * @return {string}
 * @public
 */
DiceTerm.DENOMINATION = "";

/**
 * Define the modifiers that can be used for this particular DiceTerm type.
 * @type {{string: (string|Function)}}
 * @public
 */
DiceTerm.MODIFIERS = {};

/**
 * A regular expression pattern which identifies a potential DiceTerm modifier
 * @type {RegExp}
 * @public
 */
DiceTerm.MODIFIER_REGEX = /([A-z]+)([^A-z\s()+\-*\/]+)?/g;

/**
 * A regular expression pattern which indicates the end of a DiceTerm
 * @type {string}
 * @public
 */
DiceTerm.MODIFIERS_REGEX = "([^ ()+\\-/*\\[]+)?";

/**
 * A regular expression pattern which identifies part-specific flavor text
 * @type {string}
 * @public
 */
DiceTerm.FLAVOR_TEXT_REGEX = "(?:\\[(.*)\\])?";

/**
 * A standalone, pure JavaScript implementation of the Mersenne Twister pseudo random number generator.
 *
 * @author Raphael Pigulla <pigulla@four66.com>
 * @version 0.2.3
 * @license
 * Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. The names of its contributors may not be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
class MersenneTwister {
	/**
	 * Instantiates a new Mersenne Twister.
	 * @param {number} [seed]   The initial seed value, if not provided the current timestamp will be used.
	 * @constructor
	 */
	constructor(seed) {
		 // Initial values
		this.MAX_INT = 4294967296.0;
		this.N = 624;
		this.M = 397;
		this.UPPER_MASK = 0x80000000;
		this.LOWER_MASK = 0x7fffffff;
		this.MATRIX_A = 0x9908b0df;
		 // Initialize sequences
		this.mt = new Array(this.N);
		this.mti = this.N + 1;
		this.SEED = this.seed(seed ?? new Date().getTime());
	};
	 /**
	 * Initializes the state vector by using one unsigned 32-bit integer "seed", which may be zero.
	 *
	 * @since 0.1.0
	 * @param {number} seed The seed value.
	 */
	seed(seed) {
		this.SEED = seed;
		let s;
		this.mt[0] = seed >>> 0;
		 for (this.mti = 1; this.mti < this.N; this.mti++) {
			s = this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >>> 30);
			this.mt[this.mti] =
				(((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253) + this.mti;
			this.mt[this.mti] >>>= 0;
		}
		return seed;
	};
	 /**
	 * Initializes the state vector by using an array key[] of unsigned 32-bit integers of the specified length. If
	 * length is smaller than 624, then each array of 32-bit integers gives distinct initial state vector. This is
	 * useful if you want a larger seed space than 32-bit word.
	 *
	 * @since 0.1.0
	 * @param {array} vector The seed vector.
	 */
	seedArray(vector) {
		let i = 1, j = 0, k = this.N > vector.length ? this.N : vector.length, s;
		this.seed(19650218);
		for (; k > 0; k--) {
			s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);
			 this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525))) +
				vector[j] + j;
			this.mt[i] >>>= 0;
			i++;
			j++;
			if (i >= this.N) {
				this.mt[0] = this.mt[this.N-1];
				i = 1;
			}
			if (j >= vector.length) {
				j = 0;
			}
		}
		 for (k = this.N-1; k; k--) {
			s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);
			this.mt[i] =
				(this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941)) - i;
			this.mt[i] >>>= 0;
			i++;
			if (i >= this.N) {
				this.mt[0] = this.mt[this.N - 1];
				i = 1;
			}
		}
		this.mt[0] = 0x80000000;
	};
	 /**
	 * Generates a random unsigned 32-bit integer.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	int() {
		let y, kk, mag01 = [0, this.MATRIX_A];
		 if (this.mti >= this.N) {
			if (this.mti === this.N+1) {
				this.seed(5489);
			}
			 for (kk = 0; kk < this.N - this.M; kk++) {
				y = (this.mt[kk] & this.UPPER_MASK) | (this.mt[kk + 1] & this.LOWER_MASK);
				this.mt[kk] = this.mt[kk + this.M] ^ (y >>> 1) ^ mag01[y & 1];
			}
			 for (; kk < this.N - 1; kk++) {
				y = (this.mt[kk] & this.UPPER_MASK) | (this.mt[kk + 1] & this.LOWER_MASK);
				this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ (y >>> 1) ^ mag01[y & 1];
			}
			 y = (this.mt[this.N - 1] & this.UPPER_MASK) | (this.mt[0] & this.LOWER_MASK);
			this.mt[this.N - 1] = this.mt[this.M - 1] ^ (y >>> 1) ^ mag01[y & 1];
			this.mti = 0;
		}
		 y = this.mt[this.mti++];
		 y ^= (y >>> 11);
		y ^= (y << 7) & 0x9d2c5680;
		y ^= (y << 15) & 0xefc60000;
		y ^= (y >>> 18);
		 return y >>> 0;
	};
	 /**
	 * Generates a random unsigned 31-bit integer.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	int31() {
		return this.int() >>> 1;
	};
	 /**
	 * Generates a random real in the interval [0;1] with 32-bit resolution.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	real() {
		return this.int() * (1.0 / (this.MAX_INT - 1));
	};
	 /**
	 * Generates a random real in the interval ]0;1[ with 32-bit resolution.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	realx() {
		return (this.int() + 0.5) * (1.0 / this.MAX_INT);
	};
	 /**
	 * Generates a random real in the interval [0;1[ with 32-bit resolution.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	rnd() {
		return this.int() * (1.0 / this.MAX_INT);
	};
	 /**
	 * Generates a random real in the interval [0;1[ with 32-bit resolution.
	 *
	 * Same as .rnd() method - for consistency with Math.random() interface.
	 *
	 * @since 0.2.0
	 * @returns {number}
	 */
	random() {
		return this.rnd();
	};
	 /**
	 * Generates a random real in the interval [0;1[ with 53-bit resolution.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	rndHiRes() {
		const a = this.int() >>> 5;
		const b = this.int() >>> 6;
		return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);
	};
	 /**
	 * A pseudo-normal distribution using the Box-Muller transform.
	 * @param {number} mu     The normal distribution mean
	 * @param {number} sigma  The normal distribution standard deviation
	 * @returns {number}
	 */
	normal(mu, sigma) {
		let u = 0;
		while(u === 0) u = this.random(); //Converting [0,1) to (0,1)
		let v = 0;
		while(v === 0) v = this.random(); //Converting [0,1) to (0,1)
		let n = Math.sqrt( -2.0 * Math.log(u) ) * Math.cos(2.0 * Math.PI * v);
		return (n * sigma) + mu
	}
	 /**
	 * A factory method for generating random uniform rolls
	 * @return {number}
	 */
	static random() {
		return twist.random();
	}
	 /**
	 * A factory method for generating random normal rolls
	 * @return {number}
	 */
	static normal(...args) {
		return twist.normal(...args);
	}
}

// Global singleton
const twist = new MersenneTwister(Date.now());

/**
 * Define a two-sided coin term that can be used as part of a Roll formula
 * @implements {DiceTerm}
 */
class Coin extends DiceTerm {
	constructor(termData) {
		super(termData);
		this.faces = 2;
	}
	 /* -------------------------------------------- */
	 /** @override */
	roll(options) {
		const roll = super.roll(options);
		roll.result -= 1;
		this.results[this.results.length - 1].result = roll.result;
		return roll;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static getResultLabel(result) {
		return {
			"0": "T",
			"1": "H"
		}[result];
	}
	 /* -------------------------------------------- */
	/*  Term Modifiers                              */
	/* -------------------------------------------- */
	 /**
	 * Call the result of the coin flip, marking any coins that matched the called target as a success
	 *
	 * 3dcc1      Flip 3 coins and treat "heads" as successes
	 * 2dcc0      Flip 2 coins and treat "tails" as successes
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	call(modifier) {
		 // Match the modifier
		const rgx = /[cC]([01])/
		const match = modifier.match(rgx);
		let [_, target] = match;
		target = parseInt(target);
		 // Treat each result which matched the call as a success
		for ( let r of this.results ) {
			r.count = r.result === target ? 1 : 0;
		}
	}
}
Coin.DENOMINATION = "c";
Coin.MODIFIERS = {
	"c": "call"
};

/**
 * Define a fair n-sided die term that can be used as part of a Roll formula
 * @implements {DiceTerm}
 *
 * @example
 * // Roll 4 six-sided dice
 * let die = new Die({faces: 6, number: 4}).evaluate();
 */
class Die extends DiceTerm {
	constructor(termData) {
		super(termData);
		if ( typeof this.faces !== "number" ) {
			throw new Error("A Die term must have a numeric number of faces.");
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	get total() {
		const total = super.total;
		if ( this.options.marginSuccess ) return total - parseInt(this.options.marginSuccess);
		else if ( this.options.marginFailure ) return parseInt(this.options.marginFailure) - total;
		else return total;
	}
	 /* -------------------------------------------- */
	/*  Term Modifiers                              */
	/* -------------------------------------------- */
	 /**
	 * Re-roll the Die, rolling additional results for any values which fall within a target set.
	 * If no target number is specified, re-roll the lowest possible result.
	 *
	 * 20d20r         reroll all 1s
	 * 20d20r1        reroll all 1s
	 * 20d20r=1       reroll all 1s
	 * 20d20r1=1      reroll a single 1
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	reroll(modifier) {
		 // Match the re-roll modifier
		const rgx = /[rR]([0-9]+)?([<>=]+)?([0-9]+)?/;
		const match = modifier.match(rgx);
		if ( !match ) return this;
		let [max, comparison, target] = match.slice(1);
		 // If no comparison was set, treat the max as the target
		if ( !comparison ) {
			target = max;
			max = null;
		}
		 // Determine threshold values
		max = parseInt(max) || this.results.length;
		target = parseInt(target) || 1;
		comparison = comparison || "=";
		 // Re-roll results from the initial set to a maximum number of times
		const n = this.results.length;
		for ( let i=0; i<n; i++ ) {
			let r = this.results[i];
			if (!r.active) continue;
			 // Maybe we have run out of re-rolls
			if (max <= 0) break;
			 // Determine whether to re-roll the result
			if ( DiceTerm.compareResult(r.result, comparison, target) ) {
				r.rerolled = true;
				r.active = false;
				this.roll();
				max -= 1;
			}
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Explode the Die, rolling additional results for any values which match the target set.
	 * If no target number is specified, explode the highest possible result.
	 * Explosion can be a "small explode" using a lower-case x or a "big explode" using an upper-case "X"
	 *
	 * @param {string} modifier     The matched modifier query
	 * @param {boolean} recursive   Explode recursively, such that new rolls can also explode?
	 */
	explode(modifier, {recursive=true}={}) {
		 // Match the explode or "explode once" modifier
		const rgx = /[xX][oO]?([0-9]+)?([<>=]+)?([0-9]+)?/;
		const match = modifier.match(rgx);
		if ( !match ) return this;
		let [max, comparison, target] = match.slice(1);
		 // If no comparison was set, treat the max as the target
		if ( !comparison ) {
			target = max;
			max = null;
		}
		 // Determine threshold values
		max = parseInt(max) || null;
		target = parseInt(target) || this.faces;
		comparison = comparison || "=";
		 // Recursively explode until there are no remaining results to explode
		let checked = 0;
		let initial = this.results.length;
		while ( checked < this.results.length ) {
			let r = this.results[checked];
			checked++;
			if (!r.active) continue;
			 // Maybe we have run out of explosions
			if ( (max !== null) && (max <= 0) ) break;
			 // Determine whether to explode the result and roll again!
			if ( DiceTerm.compareResult(r.result, comparison, target) ) {
				r.exploded = true;
				this.roll();
				if ( max !== null ) max -= 1;
			}
			 // Limit recursion if it's a "small explode"
			if ( !recursive && (checked >= initial) ) checked = this.results.length;
			if ( checked > 1000 ) throw new Error("Maximum recursion depth for exploding dice roll exceeded");
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * @see {@link Die#explode}
	 */
	explodeOnce(modifier) {
		return this.explode(modifier, {recursive: false});
	}
	 /* -------------------------------------------- */
	 /**
	 * Keep a certain number of highest or lowest dice rolls from the result set.
	 *
	 * 20d20k       Keep the 1 highest die
	 * 20d20kh      Keep the 1 highest die
	 * 20d20kh10    Keep the 10 highest die
	 * 20d20kl      Keep the 1 lowest die
	 * 20d20kl10    Keep the 10 lowest die
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	keep(modifier) {
		const rgx = /[kK]([hHlL])?([0-9]+)?/;
		const match = modifier.match(rgx);
		if ( !match ) return this;
		let [direction, number] = match.slice(1);
		direction = direction ? direction.toLowerCase() : "h";
		number = parseInt(number) || 1;
		DiceTerm._keepOrDrop(this.results, number, {keep: true, highest: direction === "h"});
	}
	 /* -------------------------------------------- */
	 /**
	 * Drop a certain number of highest or lowest dice rolls from the result set.
	 *
	 * 20d20d       Drop the 1 lowest die
	 * 20d20dh      Drop the 1 highest die
	 * 20d20dl      Drop the 1 lowest die
	 * 20d20dh10    Drop the 10 highest die
	 * 20d20dl10    Drop the 10 lowest die
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	drop(modifier) {
		const rgx = /[dD]([hHlL])?([0-9]+)?/;
		const match = modifier.match(rgx);
		if ( !match ) return this;
		let [direction, number] = match.slice(1);
		direction = direction ? direction.toLowerCase() : "l";
		number = parseInt(number) || 1;
		DiceTerm._keepOrDrop(this.results, number, {keep: false, highest: direction !== "l"});
	}
	 /* -------------------------------------------- */
	 /**
	 * Count the number of successful results which occurred in a given result set.
	 * Successes are counted relative to some target, or relative to the maximum possible value if no target is given.
	 * Applying a count-success modifier to the results re-casts all results to 1 (success) or 0 (failure)
	 *
	 * 20d20cs      Count the number of dice which rolled a 20
	 * 20d20cs>10   Count the number of dice which rolled higher than 10
	 * 20d20cs<10   Count the number of dice which rolled less than 10
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	countSuccess(modifier) {
		const rgx = /(?:cs|CS)([<>=]+)?([0-9]+)?/;
		const match = modifier.match(rgx);
		if ( !match ) return this;
		let [comparison, target] = match.slice(1);
		comparison = comparison || "=";
		target = parseInt(target) || this.faces;
		DiceTerm._applyCount(this.results, comparison, target, {flagSuccess: true});
	}
	 /* -------------------------------------------- */
	 /**
	 * Count the number of failed results which occurred in a given result set.
	 * Failures are counted relative to some target, or relative to the lowest possible value if no target is given.
	 * Applying a count-failures modifier to the results re-casts all results to 1 (failure) or 0 (non-failure)
	 *
	 * 6d6cf      Count the number of dice which rolled a 1 as failures
	 * 6d6cf<=3   Count the number of dice which rolled less than 3 as failures
	 * 6d6cf>4    Count the number of dice which rolled greater than 4 as failures
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	countFailures(modifier) {
		const rgx = /(?:cf|CF)([<>=]+)?([0-9]+)?/;
		const match = modifier.match(rgx);
		if ( !match ) return this;
		let [comparison, target] = match.slice(1);
		comparison = comparison || "=";
		target = parseInt(target) || 1;
		DiceTerm._applyCount(this.results, comparison, target, {flagFailure: true});
	}
	 /* -------------------------------------------- */
	 /**
	 * Deduct the number of failures from the dice result, counting each failure as -1
	 * Failures are identified relative to some target, or relative to the lowest possible value if no target is given.
	 * Applying a deduct-failures modifier to the results counts all failed results as -1.
	 *
	 * 6d6df      Subtract the number of dice which rolled a 1 from the non-failed total.
	 * 6d6cs>3df  Subtract the number of dice which rolled a 3 or less from the non-failed count.
	 * 6d6cf<3df  Subtract the number of dice which rolled less than 3 from the non-failed count.
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	deductFailures(modifier) {
		const rgx = /(?:df|DF)([<>=]+)?([0-9]+)?/;
		const match = modifier.match(rgx);
		if ( !match ) return this;
		let [comparison, target] = match.slice(1);
		if ( comparison || target ) {
			comparison = comparison || "=";
			target = parseInt(target) || 1;
		}
		DiceTerm._applyDeduct(this.results, comparison, target, {deductFailure: true});
	}
	 /* -------------------------------------------- */
	 /**
	 * Subtract the value of failed dice from the non-failed total, where each failure counts as its negative value.
	 * Failures are identified relative to some target, or relative to the lowest possible value if no target is given.
	 * Applying a deduct-failures modifier to the results counts all failed results as -1.
	 *
	 * 6d6df<3    Subtract the value of results which rolled less than 3 from the non-failed total.
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	subtractFailures(modifier) {
		const rgx = /(?:sf|SF)([<>=]+)?([0-9]+)?/;
		const match = modifier.match(rgx);
		if ( !match ) return this;
		let [comparison, target] = match.slice(1);
		if ( comparison || target ) {
			comparison = comparison || "=";
			target = parseInt(target) || 1;
		}
		DiceTerm._applyDeduct(this.results, comparison, target, {invertFailure: true});
	}
	 /* -------------------------------------------- */
	 /**
	 * Subtract the total value of the DiceTerm from a target value, treating the difference as the final total.
	 * Example: 6d6ms>12    Roll 6d6 and subtract 12 from the resulting total.
	 * @param {string} modifier     The matched modifier query
	 */
	marginSuccess(modifier) {
		const rgx = /(?:ms|MS)([<>=]+)?([0-9]+)?/;
		const match = modifier.match(rgx);
		if ( !match ) return this;
		let [comparison, target] = match.slice(1);
		target = parseInt(target);
		if ( [">", ">=", "=", undefined].includes(comparison) ) this.options["marginSuccess"] = target;
		else if ( ["<", "<="].includes(comparison) ) this.options["marginFailure"] = target;
	}
	 /* -------------------------------------------- */
	 /**
	 * @deprecated since 0.7.0
	 * TODO: Remove in 0.8.x
	 * @see {@link Die#results}
	 */
	get rolls() {
		console.warn(`You are using the Die#rolls attribute which is deprecated in favor of Die#results.`);
		return this.results;
	}
}

/** @override */
Die.DENOMINATION = "d";

/** @override */
Die.MODIFIERS = {
	"r": "reroll",
	"x": "explode",
	"xo": "explodeOnce",
	"k": "keep",
	"kh": "keep",
	"kl": "keep",
	"d": "drop",
	"dh": "drop",
	"dl": "drop",
	"cs": "countSuccess",
	"cf": "countFailures",
	"df": "deductFailures",
	"sf": "subtractFailures",
	"ms": "marginSuccess",
};

/**
 * Define a three-sided Fate/Fudge dice term that can be used as part of a Roll formula
 * Mathematically behaves like 1d3-2
 * @extends {DiceTerm}
 */
class FateDie extends DiceTerm {
	constructor(termData) {
		super(termData);
		this.faces = 3;
	}
	 /* -------------------------------------------- */
	 /** @override */
	roll(options) {
		const roll = super.roll(options);
		roll.result = roll.result - 2;
		this.results[this.results.length - 1].result = roll.result;
		return roll;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static getResultLabel(result) {
		return {
			"-1": "-",
			"0": "&nbsp;",
			"1": "+"
		}[result];
	}
}
FateDie.DENOMINATION = "f";

/**
 * A dice pool represents a set of Roll expressions which are collectively modified to compute an effective total
 * across all Rolls in the pool. The final total for the pool is defined as the sum over kept rolls, relative to any
 * success count or margin.
 *
 * @example
 * // Consider 3 rolls
 * let r1 = new Roll("4d6");
 * let r2 = new Roll("3d8");
 * let r3 = new Roll("2d10");
 *
 * // Keep the highest of the 3 roll expressions
 * let pool = new DicePool({
 *   rolls: [r1,r2,r3],
 *   modifiers: ["kh"]
 * });
 * pool.evaluate();
 *
 * @example
 * // Construct a DicePool from a string formula
 * let pool = DicePool.fromExpression("{4d6,3d8,2d10}kh");
 */
class DicePool {
	constructor({rolls=[], modifiers=[], options={}}={}) {
		 /**
		 * The elements of a Dice Pool must be Roll objects or numbers
		 * @type {Array<Roll|number>}
		 */
		this.rolls = rolls;
		 /**
		 * The string modifiers applied to resolve the pool
		 * @type {string[]}
		 */
		this.modifiers = modifiers;
		 /**
		 * An object of additional options which modify the pool
		 * @type {object}
		 */
		this.options = options;
		 /**
		 * The array of dice pool results which have been rolled
		 * @type {Array<{result: number, active: boolean}>}
		 */
		this.results = [];
		 /**
		 * An internal flag for whether the dice term has been evaluated
		 * @type {boolean}
		 * @private
		 */
		this._evaluated = false;
		 /**
		 * Cache the evaluated total to avoid re-evaluating it
		 * @type {number|null}
		 * @private
		 */
		this._total = null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Define the modifiers that can be used for this particular DiceTerm type.
	 * @type {Object<string, Function>}
	 * @public
	 */
	static MODIFIERS = {
		"k": "keep",
		"kh": "keep",
		"kl": "keep",
		"d": "drop",
		"dh": "drop",
		"dl": "drop",
		"cs": "countSuccess",
		"cf": "countFailures"
	};
	 /* -------------------------------------------- */
	 /**
	 * A regular expression pattern which identifies a potential DicePool modifier
	 * @type {RegExp}
	 */
	static MODIFIER_REGEX = /([A-z]+)([^A-z\s()+\-*\/]+)?/g;
	 /* -------------------------------------------- */
	 /**
	 * A regular expression used to identify a valid Dice Pool
	 * @type {RegExp}
	 */
	static POOL_REGEX = /^{([^}]+)}([A-z][A-z0-9<=>]+)?$/;
	 /* -------------------------------------------- */
	 /**
	 * Return an Array of each individual DiceTerm instances contained within the DicePool.
	 * @return {DiceTerm[]}
	 */
	get dice() {
		return this.rolls.reduce((dice, r) => dice.concat(r.dice), []);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a standardized representation for the displayed formula associated with this DicePool.
	 * @return {string}
	 */
	get formula() {
		const pool = this.rolls.map(r => {
			return r.terms.some(t => t instanceof DicePool) ? `(${r.formula})` : r.formula;
		});
		return `{${pool.join(",")}}${this.modifiers.join("")}`;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the total result of the DicePool if it has been evaluated
	 * @type {number|null}
	 */
	get total() {
		if ( !this._evaluated ) return null;
		return this.results.reduce((t, r) => {
			if ( !r.active ) return t;
			if ( r.count !== undefined ) return t + r.count;
			else return t + r.result;
		}, 0);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return an array of rolled values which are still active within the DicePool
	 * @type {number[]}
	 */
	get values() {
		return this.results.reduce((arr, r) => {
			if ( !r.active ) return arr;
			arr.push(r.result);
			return arr;
		}, []);
	}
	 /* -------------------------------------------- */
	 /**
	 * Alter the DiceTerm by adding or multiplying the number of dice which are rolled
	 * @param {any[]} args        Arguments passed to each contained Roll#alter method.
	 * @return {DicePool}         The altered pool
	 */
	alter(...args) {
		if ( this._evaluated ) throw new Error(`You may not alter a DicePool after it has already been evaluated`);
		this.rolls.forEach(r => r.alter(...args));
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Evaluate the DicePool, populating the results Array.
	 * @param {boolean} [minimize]    Apply the minimum possible result for each roll.
	 * @param {boolean} [maximize]    Apply the maximum possible result for each roll.
	 * @returns {DiceTerm}    The evaluated dice term
	 */
	evaluate({minimize=false, maximize=false}={}) {
		if ( this._evaluated ) {
			throw new Error(`This ${this.constructor.name} has already been evaluated and is immutable`);
		}
		 // Evaluate the members of the pool
		this.results = this.rolls.map(r => {
			let result = null;
			if ( r instanceof Roll ) {
				if ( !r._rolled ) r.evaluate();
				result = r.total;
			}
			else result = Number(r);
			return {
				result: result,
				active: true
			};
		});
		 // Apply modifiers
		this._evaluateModifiers();
		 // Return the evaluated term
		this._evaluated = true;
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Sequentially evaluate each dice roll modifier by passing the term to its evaluation function
	 * Augment or modify the results array.
	 * @private
	 */
	_evaluateModifiers() {
		const cls = this.constructor;
		for ( let m of this.modifiers ) {
			const command = m.match(/[A-z]+/)[0].toLowerCase();
			let fn = cls.MODIFIERS[command];
			if ( typeof fn === "string" ) fn = this[fn];
			if ( fn instanceof Function ) {
				fn.call(this, m);
			}
		}
	}
	 /* -------------------------------------------- */
	/*  Saving and Loading                          */
	/* -------------------------------------------- */
	 /**
	 * Reconstruct a DicePool instance from a provided data Object
	 * @param {Object} data   The provided data
	 * @return {DicePool}     The constructed Dice Pool
	 */
	static fromData(data) {
		const rolls = data.rolls.map(r => Roll.fromData(r));
		const pool = new this({rolls, modifiers: data.modifiers, options: data.options});
		pool.results = data.results;
		pool._evaluated = true;
		return pool;
	}
	 /* -------------------------------------------- */
	 /**
	 * Given a string formula, create and return an evaluated DicePool object
	 * @param {string} formula    The string formula to parse
	 * @param {object} [options]  Additional options applied to the DicePool
	 * @param {object} [data]     A data object which defines data substitutions for Rolls in the DicePool
	 *
	 * @return {DicePool|null}    The evaluated DicePool object or null if the formula is invalid
	 */
	static fromExpression(formula, options={}, data={}) {
		const rgx = formula.trim().match(this.POOL_REGEX);
		if ( !rgx ) return null;
		let [terms, modifiers] = rgx.slice(1);
		 // Transform each term of the pool into a Roll instance
		const rolls = terms.split(',').reduce((arr, t) => {
			arr.push(Roll.create(t.trim(), data));
			return arr;
		}, []);
		 // Identify modifiers
		modifiers = Array.from((modifiers || "").matchAll(DiceTerm.MODIFIER_REGEX)).map(m => m[0]);
		 // Construct and return the Dice Pool
		return new this({rolls, modifiers, options});
	}
	 /* -------------------------------------------- */
	 /**
	 * Reconstruct a DicePool instance from a provided data Object
	 * @param {string} json   The serialized JSON string
	 * @return {DicePool}     The constructed Dice Pool
	 */
	static fromJSON(json) {
		let data;
		try {
			data = JSON.parse(json);
		} catch(err) {
			throw new Error("You must pass a valid JSON string");
		}
		return this.fromData(data);
	}
	 /* -------------------------------------------- */
	 /**
	 * Convert the DicePool instance into an Object which can be serialized to JSON
	 * @return {Object}     The converted data
	 */
	toJSON() {
		return {
			class: this.constructor.name,
			rolls: this.rolls,
			modifiers: this.modifiers,
			options: this.options,
			results: this.results
		}
	}
	 /* -------------------------------------------- */
	/*  Modifiers                                   */
	/* -------------------------------------------- */
	 /**
	 * Keep a certain number of highest or lowest dice rolls from the result set.
	 *
	 * {1d6,1d8,1d10,1d12}kh2       Keep the 2 best rolls from the pool
	 * {1d12,6}kl                   Keep the lowest result in the pool
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	keep(modifier) {
		return Die.prototype.keep.call(this, modifier);
	}
	 /* -------------------------------------------- */
	 /**
	 * Keep a certain number of highest or lowest dice rolls from the result set.
	 *
	 * {1d6,1d8,1d10,1d12}dl3       Drop the 3 worst results in the pool
	 * {1d12,6}dh                   Drop the highest result in the pool
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	drop(modifier) {
		return Die.prototype.drop.call(this, modifier);
	}
	 /* -------------------------------------------- */
	 /**
	 * Count the number of successful results which occurred in the pool.
	 * Successes are counted relative to some target, or relative to the maximum possible value if no target is given.
	 * Applying a count-success modifier to the results re-casts all results to 1 (success) or 0 (failure)
	 *
	 * 20d20cs      Count the number of dice which rolled a 20
	 * 20d20cs>10   Count the number of dice which rolled higher than 10
	 * 20d20cs<10   Count the number of dice which rolled less than 10
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	countSuccess(modifier) {
		return Die.prototype.countSuccess.call(this, modifier);
	}
	 /* -------------------------------------------- */
	 /**
	 * Count the number of failed results which occurred in a given result set.
	 * Failures are counted relative to some target, or relative to the lowest possible value if no target is given.
	 * Applying a count-failures modifier to the results re-casts all results to 1 (failure) or 0 (non-failure)
	 *
	 * 6d6cf      Count the number of dice which rolled a 1 as failures
	 * 6d6cf<=3   Count the number of dice which rolled less than 3 as failures
	 * 6d6cf>4    Count the number of dice which rolled greater than 4 as failures
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	countFailures(modifier) {
		return Die.prototype.countFailures.call(this, modifier);
	}
}

/**
 * The virtual tabletop environment is implemented using a WebGL powered HTML 5 canvas using the powerful PIXI.js
 * library. The canvas is comprised of an ordered sequence of layers which define rendering groups and collections of
 * objects that are drawn on the canvas itself.
 *
 * @see {@link CanvasLayer} An abstract class for all Canvas layers.
 * @see {@link PlaceablesLayer} An abstract class for Canvas Layers which contain Placeable Objects.
 * @see {@link PlaceableObject} An abstract class for objects which are placed into the Scene and drawn on the canvas.
 *
 * @example <caption>Example Canvas commands</caption>
 * canvas.ready; // Is the canvas ready for use?
 * canvas.scene; // The currently viewed Scene entity.
 * canvas.dimensions; // The dimensions of the current Scene.
 * canvas.draw(); // Completely re-draw the game canvas (this is usually unnecessary).
 * canvas.pan(x, y, zoom); // Pan the canvas to new coordinates and scale.
 * canvas.recenter(); // Re-center the canvas on the currently controlled Token.
 */
class Canvas {
	constructor() {
		 // Verify that WebGL is available
		if ( !PIXI.utils.isWebGLSupported() ) {
			const err = new Error(game.i18n.localize("ERROR.NoWebGL"));
			ui.notifications.error(err.message, {permanent: true});
			throw err;
		}
		 // Create the canvas element and attach it to the DOM
		const canvas = document.createElement("canvas");
		canvas.id = "board";
		$("#board").replaceWith(canvas);
		 // Activate drop handling
		this._dragDrop = new DragDrop({ callbacks: { drop: this._onDrop.bind(this) } }).bind(canvas);
		 // Create PIXI Application
		const resolution = game.settings.get("core", "disableResolutionScaling") ? 1 : window.devicePixelRatio;
		this.app = new PIXI.Application({
			view: canvas,
			width: window.innerWidth,
			height: window.innerHeight,
			antialias: true,
			transparent: false,
			resolution: resolution,
			backgroundColor: null
		});
		this.app.renderer.plugins.interaction.moveWhenInside = true;
		 // Register custom blend modes
		for ( let [k,v] of Object.entries(BLEND_MODES) ) {
			PIXI.BLEND_MODES[k] = this.app.renderer.state.blendModes.push(v) - 1;
		}
		 // Define the Stage
		this.stage = this.app.stage;
		Object.defineProperty(this.stage.constructor, 'name', {value: `CanvasStage`, writable: false});
		 // Create Canvas layers and the HUD
		this.hud = new HeadsUpDisplay();
		this._createLayers(this.stage);
		 // Record the active scene and its dimensions
		this.id = null;
		this.scene = null;
		this.dimensions = null;
		 /**
		 * Track the timestamp of the last stage zoom operation
		 * @type {number}
		 * @private
		 */
		this._zoomTime = 0;
		 /**
		 * Track the last automatic pan time to throttle
		 * @type {number}
		 * @private
		 */
		this._panTime = 0;
		 /**
		 * An object of data which is temporarily cached to be reloaded after the canvas is drawn
		 * @type {Object}
		 * @private
		 */
		this._reload = { layer: "TokenLayer" };
		 /**
		 * The singleton interaction manager instance which handles mouse workflows on the Canvas
		 * @type {MouseInteractionManager}
		 */
		this.mouseInteractionManager = null;
		 /**
		 * A flag for whether the game Canvas is ready to be used. False if the canvas is not yet drawn, true otherwise.
		 * @type {boolean}
		 */
		this.ready = false;
		 /**
		 * An Array of pending canvas operations which should trigger on the next re-paint
		 * @type {object[]}
		 */
		this.pendingOperations = [];
		 /**
		 * A Set of unique pending operation names to ensure operations are only performed once
		 * @type {Set.<string>}
		 */
		this._pendingOperationNames = new Set();
	}
	 /* -------------------------------------------- */
	 /**
	 * Create the layers of the game Canvas.
	 * @param {PIXI.Container} stage    The primary canvas stage
	 * @private
	 */
	_createLayers(stage) {
		for ( let [k, v] of Object.entries(this.constructor.layers) ) {
			const layer = new v();
			this[k] = this.stage.addChild(layer);
		}
	}
	 /* -------------------------------------------- */
	/*  Properties and Attributes
	/* -------------------------------------------- */
	 /**
	 * A mapping of named CanvasLayers.
	 * This mapping is defined in the order that layers must be drawn.
	 * @type {Object<string, CanvasLayer>}
	 */
	static get layers() {
		return {
			background: BackgroundLayer,  // 0
			tiles: TilesLayer,            // 10
			drawings: DrawingsLayer,      // 20
			grid: GridLayer,              // 30
			walls: WallsLayer,            // 40
			templates: TemplateLayer,     // 50
			notes: NotesLayer,            // 60
			tokens: TokenLayer,           // 100
			lighting: LightingLayer,      // 200
			sounds: SoundsLayer,          // 200
			sight: SightLayer,            // 210
			effects: EffectsLayer,        // 300
			controls: ControlsLayer       // 400
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * An Array of all CanvasLayer instances which are active on the Canvas board
	 * @type {CanvasLayer[]}
	 */
	get layers() {
		return Object.keys(this.constructor.layers).map(k => this[k]);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a reference to the active Canvas Layer
	 * @type {CanvasLayer}
	 */
	get activeLayer() {
		for ( let k of Object.keys(this.constructor.layers) ) {
			if ( this[k]._active ) return this[k];
		}
		return null;
	}
	 /* -------------------------------------------- */
	/*  Rendering
	/* -------------------------------------------- */
	 /**
	 * When re-drawing the canvas, first tear down or discontinue some existing processes
	 * @return {Promise<void>}
	 */
	async tearDown() {
		this.stage.visible = false;
		const layer = this.activeLayer;
		 // Track current data which should be restored on draw
		this._reload = {
			scene: this.scene._id,
			layer: layer.name,
			controlledTokens: Object.keys(this.tokens._controlled),
			targetedTokens: Array.from(game.user.targets).map(t => t.id)
		};
		 // Perform layer-specific tear-down actions
		for ( let l of this.layers.reverse() ) {
			await l.tearDown();
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the game canvas.
	 * @return {Promise<Canvas>}    A Promise which resolves once the Canvas is fully drawn
	 */
	async draw(scene) {
		scene = (scene === undefined ? game.scenes.viewed : scene) || null;
		const wasReady = this.ready;
		this.ready = false;
		 // Tear down any existing scene
		if ( wasReady ) await this.tearDown();
		 // Confirm there is an active scene
		this.scene = scene;
		this.id = scene?.id || null;
		if ( this.scene === null ) {
			console.log(`${vtt} | Skipping game canvas - no active scene.`);
			canvas.app.view.style.display = "none";
			ui.controls.render()
			return this;
		}
		else if ( !(scene instanceof Scene) ) {
			throw new Error("You must provide a Scene entity to draw the VTT canvas.")
		}
		 // Configure Scene to draw
		this.dimensions = this.constructor.getDimensions(scene.data);
		canvas.app.view.style.display = "block";
		document.documentElement.style.setProperty("--gridSize", this.dimensions.size+"px");
		 // Configure rendering settings
		PIXI.settings.MIPMAP_TEXTURES = PIXI.MIPMAP_MODES[game.settings.get("core", "mipmap") ? "ON" : "OFF"];
		const maxFPS = game.settings.get("core", "maxFPS");
		this.app.ticker.maxFPS = maxFPS.between(0, 60) ? maxFPS : 0;
		 // Call initialization hooks
		console.log(`${vtt} | Drawing game canvas for scene ${this.scene.name}`);
		Hooks.callAll('canvasInit', this);
		 // Configure primary canvas stage
		this.stage.visible = false;
		this.stage.position.set(window.innerWidth/2, window.innerHeight/2);
		this.stage.hitArea = new PIXI.Rectangle(0, 0, this.dimensions.width, this.dimensions.height);
		this.stage.interactive = true;
		this.stage.sortableChildren = true;
		 // Scene background color
		this.backgroundColor = scene.data.backgroundColor ? colorStringToHex(scene.data.backgroundColor) : 0x666666;
		this.app.renderer.backgroundColor = this.backgroundColor;
		 // Load required textures
		await TextureLoader.loadSceneTextures(this.scene);
		 // Draw layers
		for ( let l of this.layers ) {
			try {
				await l.draw();
			} catch(err) {
				ui.notifications.error(`Canvas drawing failed for the ${l.name}, see the console for more details.`);
				console.error(err);
			}
		}
		 // Initialize starting conditions
		await this._initialize();
		 // Add interactivity
		this._addListeners();
		 // Mark the canvas as ready and call hooks
		this.stage.visible = this.ready = true;
		Hooks.call("canvasReady", this);
		this._reload = {};
		 // Perform a final resize to ensure the rendered dimensions are correct
		this._onResize();
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the canvas active dimensions based on the size of the scene's map.
	 * We expand the image size by a factor of 1.5 and round to the nearest 2x grid size.
	 * The rounding accomplishes that the padding buffer around the map always contains whole grid spaces.
	 *
	 * @param {Object} data     The scene dimensions data being established
	 */
	static getDimensions({width, height, grid, gridDistance, padding, shiftX, shiftY}={}) {
		const w = width || (grid * 30);
		const h = height || (grid * 20);
		const d = {
			sceneWidth: w,
			sceneHeight: h,
			size: parseInt(grid),
			distance: parseFloat(gridDistance),
			shiftX: parseInt(shiftX),
			shiftY: parseInt(shiftY),
			ratio: w / h
		};
		 // Define padding and final dimensions
		d.paddingX = Math.ceil((padding * w) / grid) * grid;
		d.width = w + (2 * d.paddingX);
		d.paddingY = Math.ceil((padding * h) / grid) * grid;
		d.height = h + (2 * d.paddingY);
		 // Define helper rectangles
		d.rect = new PIXI.Rectangle(0, 0, d.width, d.height);
		d.sceneRect = new PIXI.Rectangle(d.paddingX-d.shiftX, d.paddingY-d.shiftY, d.sceneWidth, d.sceneHeight);
		return d;
	}
	 /* -------------------------------------------- */
	 /**
	 * Once the canvas is drawn, initialize control, visibility, and audio states
	 * @return {Promise<void>}
	 */
	async _initialize() {
		 // Clear the set of targeted Tokens for the current user
		game.user.targets.clear();
		 // Render the HUD layer
		this.hud.render(true);
		 // Initialize canvas conditions
		this._initializeCanvasPosition();
		this._initializeCanvasLayer();
		 // Initialize Token control
		this._initializeTokenControl();
		 // Initialize starting layer conditions
		this.initializeSources();
		await this.sight.initialize();
		// this.sounds.initialize();  TODO
		 // Broadcast user presence in the Scene
		game.user.broadcastActivity({sceneId: this.scene.id});
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize all lighting, vision, and sound sources for the Scene.
	 */
	initializeSources() {
		 // Clear sources
		this.lighting.sources.clear();
		this.sight.sources.clear();
		 // Initialize data
		this.lighting.darknessLevel = this.scene.data.darkness;
		 // Update sources
		this.tokens.placeables.forEach(token => token.updateSource({defer: true}));
		this.lighting.placeables.forEach(light => light.updateSource({defer: true}));
		this.sounds.initialize();
		 // Refresh layer displays
		this.lighting.refresh();
		this.sight.refresh({forceUpdateFog: true});
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize the starting view of the canvas stage
	 * If we are re-drawing a scene which was previously rendered, restore the prior view position
	 * Otherwise set the view to the top-left corner of the scene at standard scale
	 * @private
	 */
	_initializeCanvasPosition() {
		 // If we are re-drawing a Scene that was already visited, use it's cached view position
		const position = this.scene._viewPosition;
		if ( !isObjectEmpty(position) ) return this.pan(position);
		 // Otherwise use a saved initial position
		const initial = this.scene.data.initial;
		if ( initial ) return this.pan({
			x: initial.x,
			y: initial.y,
			scale: initial.scale
		});
		 // Otherwise determine a starting default based on the scene size
		this.pan({
			x: this.dimensions.paddingX + this.stage.position.x,
			y: this.dimensions.paddingY + this.stage.position.y,
			scale: 1
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize a CanvasLayer in the activation state
	 * @private
	 */
	_initializeCanvasLayer() {
		this.layers.forEach(l => l.deactivate());
		let activeLayer = this._reload.layer || ui.controls.control.layer || "TokenLayer";
		this.getLayer(activeLayer).activate();
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize a token or set of tokens which should be controlled.
	 * Restore controlled and targeted tokens from before the re-draw.
	 * @private
	 */
	_initializeTokenControl() {
		let isReload = this._reload.scene === this.scene._id;
		 // Determine controlled token set (if any)
		const controlledTokens = isReload ? this._reload.controlledTokens : [];
		if ( !isReload && !game.user.isGM ) {
			let token = game.user.character ? game.user.character.getActiveTokens().shift() : null;
			if ( !token ) {
				token = canvas.tokens.placeables.filter(t => t.actor && t.actor.hasPerm(game.user, "OBSERVER")).shift();
			}
			if ( token ) controlledTokens.push(token.id);
		}
		const targetedTokens = isReload ? this._reload.targetedTokens : [];
		 // Iterate over tokens
		let panToken = null;
		for ( let t of canvas.tokens.placeables ) {
			if ( controlledTokens.includes(t.id) ) {
				if ( !panToken ) panToken = t;
				t.control({updateSight: false, releaseOthers: false});
			}
			if ( targetedTokens.includes(t.id) ) t.setTarget(true, {releaseOthers: false, groupSelection: true});
		}
		 // Pan camera to controlled token
		if ( panToken && !isReload ) this.pan({x: panToken.x, y: panToken.y, duration: 250});
	}
	 /* -------------------------------------------- */
	 /**
	 * Get a reference to the a specific CanvasLayer by it's name
	 * @param {string} layerName    The name of the canvas layer to get
	 * @return {CanvasLayer}
	 */
	getLayer(layerName) {
		return this.stage.getChildByName(layerName);
	}
	 /* -------------------------------------------- */
	 /**
	 * Given an embedded object name, get the canvas layer for that object
	 * @param {string} embeddedName
	 * @returns {PlaceablesLayer|null}
	 * @private
	 */
	getLayerByEmbeddedName(embeddedName) {
		return {
			AmbientLight: this.lighting,
			AmbientSound: this.sounds,
			Drawing: this.drawings,
			Note: this.notes,
			MeasuredTemplate: this.templates,
			Tile: this.tiles,
			Token: this.tokens,
			Wall: this.walls
		}[embeddedName] || null;
	}
	 /* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */
	 /**
	 * Pan the canvas to a certain {x,y} coordinate and a certain zoom level
	 * @param {number|null} x      The x-coordinate of the pan destination
	 * @param {number|null} y      The y-coordinate of the pan destination
	 * @param {number|null} scale  The zoom level (max of CONFIG.Canvas.maxZoom) of the action
	 */
	pan({x=null, y=null, scale=null}={}) {
		 // Constrain the resulting canvas view
		const constrained = this._constrainView({x, y, scale});
		 // Set the pivot point
		this.stage.pivot.set(constrained.x, constrained.y);
		 // Set the zoom level
		this.stage.scale.set(constrained.scale, constrained.scale);
		 // Decrease blur as we zoom
		this._updateBlur(constrained.scale);
		 // Update the scene tracked position
		canvas.scene._viewPosition = constrained;
		 // Call canvasPan Hook
		Hooks.callAll("canvasPan", this, constrained);
		 // Align the HUD
		this.hud.align();
	}
	 /* -------------------------------------------- */
	 /**
	 * Animate panning the canvas to a certain destination coordinate and zoom scale
	 * Customize the animation speed with additional options
	 * Returns a Promise which is resolved once the animation has completed
	 *
	 * @param {number} x            The destination x-coordinate
	 * @param {number} y            The destination y-coordinate
	 * @param {number} scale        The destination zoom scale
	 * @param {number} duration     The total duration of the animation in milliseconds; used if speed is not set
	 * @param {number} speed        The speed of animation in pixels per second; overrides duration if set
	 * @returns {Promise<void>}     A Promise which resolves once the animation has been completed
	 */
	async animatePan({x, y, scale, duration=250, speed}={}) {
		 // Determine the animation duration to reach the target
		if ( speed ) {
			let ray = new Ray(this.stage.pivot, {x, y});
			duration = Math.round(ray.distance * 1000 / speed);
		}
		 // Constrain the resulting dimensions and construct animation attributes
		const constrained = this._constrainView({x, y, scale});
		const attributes = [
			{ parent: this.stage.pivot, attribute: 'x', to: constrained.x },
			{ parent: this.stage.pivot, attribute: 'y', to: constrained.y },
			{ parent: this.stage.scale, attribute: 'x', to: constrained.scale },
			{ parent: this.stage.scale, attribute: 'y', to: constrained.scale },
		].filter(a => a.to !== undefined);
		 // Trigger the animation function
		await CanvasAnimation.animateLinear(attributes, {
			name: "canvas.animatePan",
			duration: duration,
			ontick: (dt, attributes) => {
				this.hud.align();
				const stage = this.stage;
				Hooks.callAll("canvasPan", this, {x: stage.pivot.x, y: stage.pivot.y, scale: stage.scale.x});
			}
		});
		 // Decrease blur as we zoom
		this._updateBlur(constrained.scale);
		 // Update the scene tracked position
		canvas.scene._viewPosition = constrained;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the constrained zoom scale parameter which is allowed by the maxZoom parameter
	 * @param {number} x              The requested x-coordinate
	 * @param {number} y              The requested y-coordinate
	 * @param {number} scale          The requested scale
	 * @return {{x, y, scale}}        The allowed scale
	 * @private
	 */
	_constrainView({x, y, scale}) {
		const d = canvas.dimensions;
		 // Constrain the maximum zoom level
		if ( Number.isNumeric(scale) && (scale !== this.stage.scale.x) ) {
			const max = CONFIG.Canvas.maxZoom;
			const ratio = Math.max(d.width / window.innerWidth, d.height / window.innerHeight, max);
			scale = Math.round(Math.clamped(scale, 1 / ratio, max) * 100) / 100;
		} else {
			scale = this.stage.scale.x;
		}
		 // Constrain the pivot point using the new scale
		if ( Number.isNumeric(x) && x !== this.stage.pivot.x ) {
			const padw = 0.4 * (window.innerWidth / scale);
			x = Math.clamped(x, -padw, d.width + padw);
		}
		else x = this.stage.pivot.x;
		if ( Number.isNumeric(y) && x !== this.stage.pivot.y ) {
			const padh = 0.4 * (window.innerHeight / scale);
			y = Math.clamped(y, -padh, d.height + padh);
		}
		else y = this.stage.pivot.y;
		 // Return the constrained view dimensions
		return {x, y, scale};
	}
	 /* -------------------------------------------- */
	 /**
	 * Update the blur strength depending on the scale of the canvas stage
	 * @param {number} scale
	 * @private
	 */
	_updateBlur(scale) {
		const blur = Math.ceil(Math.clamped(scale * CONFIG.Canvas.blurStrength, 0, CONFIG.Canvas.blurStrength));
		canvas.lighting.illumination.filter.blur = blur;
		canvas.sight.filter.blur = blur;
	}
	 /* -------------------------------------------- */
	 /**
	 * Recenter the canvas
	 * Otherwise, pan the stage to put the top-left corner of the map in the top-left corner of the window
	 */
	recenter(coordinates) {
		if ( coordinates ) this.pan(coordinates);
		this.animatePan({
			x: this.dimensions.paddingX + (window.innerWidth / 2),
			y: this.dimensions.paddingY + (window.innerHeight / 2),
			duration: 250
		});
	}
	 /* -------------------------------------------- */
	/* Event Handlers
	/* -------------------------------------------- */
	 /**
	 * Attach event listeners to the game canvas to handle click and interaction events
	 * @private
	 */
	_addListeners() {
		 // Remove all existing listeners
		this.stage.removeAllListeners();
		 // Define callback functions for mouse interaction events
		const callbacks = {
			clickLeft: this._onClickLeft.bind(this),
			clickLeft2: this._onClickLeft2.bind(this),
			clickRight: this._onClickRight.bind(this),
			clickRight2: null,
			dragLeftStart: this._onDragLeftStart.bind(this),
			dragLeftMove: this._onDragLeftMove.bind(this),
			dragLeftDrop: this._onDragLeftDrop.bind(this),
			dragLeftCancel: this._onDragLeftCancel.bind(this),
			dragRightStart: null,
			dragRightMove: this._onDragRightMove.bind(this),
			dragRightDrop: this._onDragRightDrop.bind(this),
			dragRightCancel: null
		};
		 // Create and activate the interaction manager
		const permissions = { clickRight2: false };
		const mgr = new MouseInteractionManager(this.stage, this.stage, permissions, callbacks);
		this.mouseInteractionManager = mgr.activate();
		 // Add a listener for cursor movement
		this.stage.on("mousemove", event => canvas.controls._onMoveCursor(event));
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle left mouse-click events occurring on the Canvas stage or its active Layer.
	 * @see {MouseInteractionManager#_handleClickLeft}
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onClickLeft(event) {
		 // Extract event data
		const layer = this.activeLayer;
		const tool = game.activeTool;
		 // Place Ruler waypoints
		const isRuler = tool === "ruler";
		const isCtrlRuler = game.keyboard.isCtrl(event) && (layer.name === "TokenLayer");
		if ( isRuler || isCtrlRuler ) return this.controls.ruler._onClickLeft(event);
		 // Begin select events
		const isSelect = ["select", "target"].includes(tool);
		const release = game.settings.get("core", "leftClickRelease");
		if ( isSelect && !release ) return;
		 // Dispatch the event to the active layer
		if ( layer instanceof PlaceablesLayer ) layer._onClickLeft(event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle double left-click events occurring on the Canvas stage.
	 * @see {MouseInteractionManager#_handleClickLeft2}
	 * @param {PIXI.interaction.InteractionEvent} event
	 */
	_onClickLeft2(event) {
		const layer = this.activeLayer;
		if ( layer instanceof PlaceablesLayer ) layer._onClickLeft2(event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the beginning of a left-mouse drag workflow on the Canvas stage or its active Layer.
	 * @see {MouseInteractionManager#_handleDragStart}
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onDragLeftStart(event) {
		 // Extract event data
		const layer = this.activeLayer;
		const isRuler = game.activeTool === "ruler";
		const isCtrlRuler = game.keyboard.isCtrl(event) && (layer.name === "TokenLayer");
		 // Begin ruler measurement
		if ( isRuler || isCtrlRuler ) return this.controls.ruler._onDragStart(event);
		 // Activate select rectangle
		const isSelect = ["select", "target"].includes(game.activeTool);
		if ( isSelect ) {
			canvas.controls.select.active = true;
			return;
		}
		 // Dispatch the event to the active layer
		if ( layer instanceof PlaceablesLayer ) layer._onDragLeftStart(event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mouse movement events occurring on the Canvas stage or it's active layer
	 * @see {MouseInteractionManager#_handleDragMove}
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onDragLeftMove(event) {
		const layer = this.activeLayer;
		 // Pan the canvas if the drag event approaches the edge
		this._onDragCanvasPan(event.data.originalEvent);
		 // Continue a Ruler measurement
		const ruler = this.controls.ruler;
		if ( ruler._state > 0 ) return ruler._onMouseMove(event);
		 // Continue a select event
		const isSelect = ["select", "target"].includes(game.activeTool);
		if ( isSelect && canvas.controls.select.active ) return this._onDragSelect(event);
		 // Dispatch the event to the active layer
		if ( layer instanceof PlaceablesLayer ) layer._onDragLeftMove(event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the conclusion of a left-mouse drag workflow when the mouse button is released.
	 * @see {MouseInteractionManager#_handleDragDrop}
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onDragLeftDrop(event) {
		 // Extract event data
		const {coords, originalEvent} = event.data;
		const tool = game.activeTool;
		const layer = canvas.activeLayer;
		const isCtrl = game.keyboard.isCtrl(event);
		 // Conclude a measurement event if we aren't holding the CTRL key
		const ruler = canvas.controls.ruler;
		if ( ruler.active ) {
			if ( isCtrl ) originalEvent.preventDefault();
			return ruler._onMouseUp(event);
		}
		 // Conclude a select event
		const isSelect = ["select", "target"].includes(tool);
		if ( isSelect && canvas.controls.select.active ) {
			canvas.controls.select.clear();
			canvas.controls.select.active = false;
			if ( tool === "select" ) return layer.selectObjects(coords);
			if ( tool === "target" ) return layer.targetObjects(coords, {releaseOthers: !originalEvent.shiftKey});
		}
		 // Dispatch the event to the active layer
		if ( layer instanceof PlaceablesLayer ) layer._onDragLeftDrop(event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the cancellation of a left-mouse drag workflow
	 * @see {MouseInteractionManager#_handleDragCancel}
	 * @param {PointerEvent} event
	 * @private
	 */
	_onDragLeftCancel(event) {
		const layer = canvas.activeLayer;
		const tool = game.activeTool;
		 // Don't cancel ruler measurement
		const ruler = canvas.controls.ruler;
		if ( ruler.active ) return event.preventDefault();
		 // Clear selection
		const isSelect = ["select", "target"].includes(tool);
		if ( isSelect ) return canvas.controls.select.clear();
		 // Dispatch the event to the active layer
		if ( layer instanceof PlaceablesLayer ) layer._onDragLeftCancel(event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle right mouse-click events occurring on the Canvas stage or it's active layer
	 * @see {MouseInteractionManager#_handleClickRight}
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onClickRight(event) {
		const ruler = canvas.controls.ruler;
		if ( ruler.active ) return ruler._onClickRight(event);
		 // Dispatch to the active layer
		const layer = this.activeLayer;
		if ( layer instanceof PlaceablesLayer ) layer._onClickRight(event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle right-mouse drag events occuring on the Canvas stage or an active Layer
	 * @see {MouseInteractionManager#_handleDragMove}
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onDragRightMove(event) {
		 // Extract event data
		const DRAG_SPEED_MODIFIER = 0.8;
		const {cursorTime, origin, destination} = event.data;
		const dx = destination.x - origin.x;
		const dy = destination.y - origin.y;
		 // Update the client's cursor position every 100ms
		const now = Date.now();
		if ( (now - (cursorTime || 0)) > 100 ) {
			if ( this.controls ) this.controls._onMoveCursor(event, destination);
			event.data.cursorTime = now;
		}
		 // Pan the canvas
		this.pan({
			x: canvas.stage.pivot.x - (dx * DRAG_SPEED_MODIFIER),
			y: canvas.stage.pivot.y - (dy * DRAG_SPEED_MODIFIER)
		});
		 // Reset Token tab cycling
		this.tokens._tabIndex = null;
	}
		/* -------------------------------------------- */
	 /**
	 * Handle the conclusion of a right-mouse drag workflow the Canvas stage.
	 * @see {MouseInteractionManager#_handleDragDrop}
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onDragRightDrop(event) {}
	 /* -------------------------------------------- */
	 /**
	 * Determine selection coordinate rectangle during a mouse-drag workflow
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onDragSelect(event) {
		 // Extract event data
		const {origin, destination} = event.data;
		 // Determine rectangle coordinates
		let coords = {
			x: Math.min(origin.x, destination.x),
			y: Math.min(origin.y, destination.y),
			width: Math.abs(destination.x - origin.x),
			height: Math.abs(destination.y - origin.y)
		};
		 // Draw the select rectangle
		canvas.controls.drawSelect(coords);
		event.data.coords = coords;
	}
	 /* -------------------------------------------- */
	 /**
	 * Pan the canvas view when the cursor position gets close to the edge of the frame
	 * @param {MouseEvent} event    The originating mouse movement event
	 * @private
	 */
	_onDragCanvasPan(event) {
		 // Throttle panning by 200ms
		const now = Date.now();
		if ( now - (this._panTime || 0) <= 200 ) return;
		this._panTime = now;
		 // Shift by 3 grid spaces at a time
		const {x, y} = event;
		const pad = 50;
		const shift = (this.dimensions.size * 3) / this.stage.scale.x;
		 // Shift horizontally
		let dx = 0;
		if ( x < pad ) dx = -shift;
		else if ( x > window.innerWidth - pad ) dx = shift;
		 // Shift vertically
		let dy = 0;
		if ( y < pad ) dy = -shift;
		else if ( y > window.innerHeight - pad ) dy = shift;
		 // Enact panning
		if ( dx || dy ) return this.animatePan({x: this.stage.pivot.x + dx, y: this.stage.pivot.y + dy, duration: 200});
	}
	 /* -------------------------------------------- */
	/*  Other Event Handlers                        */
	/* -------------------------------------------- */
	 /**
	 * Handle window resizing with the dimensions of the window viewport change
	 * @param {Event} event     The Window resize event
	 * @private
	 */
	_onResize(event=null) {
		if ( !this.ready ) return false;
		 // Record the original width
		const w = window.innerWidth;
		const h = window.innerHeight;
		 // Resize the renderer
		this.app.renderer.view.style.width = w + "px";
		this.app.renderer.view.style.height = h + "px";
		this.app.renderer.resize(w, h);
		 // Adjust the stage position and pivot
		this.stage.position.set(w/2, h/2);
		const dx = (window.innerWidth - w) / 2;
		const dy = (window.innerHeight - h) / 2;
		this.pan({x: this.stage.pivot.x + dx, y: this.stage.pivot.y + dy});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mousewheel events which adjust the scale of the canvas
	 * @param {WheelEvent} event    The mousewheel event that zooms the canvas
	 * @private
	 */
	_onMouseWheel(event) {
		let dz = ( event.deltaY < 0 ) ? 1.05 : 0.95;
		this.pan({scale: dz * canvas.stage.scale.x});
	}
	 /* -------------------------------------------- */
	 /**
	 * Event handler for the drop portion of a drag-and-drop event.
	 * @private
	 */
	_onDrop(event) {
		event.preventDefault();
		 // Try to extract the data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData('text/plain'));
		}
		catch (err) {
			return false;
		}
		 // Acquire the cursor position transformed to Canvas coordinates
		const [x, y] = [event.clientX, event.clientY];
		const t = this.stage.worldTransform;
		data.x = (x - t.tx) / canvas.stage.scale.x;
		data.y = (y - t.ty) / canvas.stage.scale.y;
		 // Handle the drop with a Hooked function
		const allowed = Hooks.call("dropCanvasData", this, data);
		if ( allowed === false ) return;
		 // Handle different data types
		switch ( data.type ) {
			case "Actor":
				return canvas.tokens._onDropActorData(event, data);
			case "JournalEntry":
				return canvas.notes._onDropData(event, data);
			case "Macro":
				return game.user.assignHotbarMacro(null, data.slot);
			case "Tile":
				return canvas.tiles._onDropTileData(event, data);
		}
	}
	 /* -------------------------------------------- */
	/*  Pending Operations                          */
	/* -------------------------------------------- */
	 /**
	 * Add a pending canvas operation that should fire once the socket handling workflow concludes.
	 * This registers operations by a unique string name into a queue - avoiding repeating the same work multiple times.
	 * This is especially helpful for multi-object updates to avoid costly and redundant refresh operations.
	 * @param {string} name     A unique name for the pending operation, conventionally Class.method
	 * @param {Function} fn     The unbound function to execute later
	 * @param {*} scope         The scope to which the method should be bound when called
	 * @param {...*} args       Arbitrary arguments to pass to the method when called
	 */
	addPendingOperation(name, fn, scope, args) {
		if ( this._pendingOperationNames.has(name) ) return;
		this._pendingOperationNames.add(name);
		this.pendingOperations.push([fn, scope, args]);
	}
	 /* -------------------------------------------- */
	 /**
	 * Fire all pending functions that are registered in the pending operations queue and empty it.
	 */
	triggerPendingOperations() {
		for ( let [fn, scope, args] of this.pendingOperations ) {
			if ( !fn ) continue;
			args = args || [];
			fn = fn.call(scope, ...args);
		}
		this.pendingOperations = [];
		this._pendingOperationNames.clear();
	}
}

/**
 * An abstract pattern for primary layers of the game canvas to implement
 * @type {PIXI.Container}
 * @abstract
 * @interface
 */
class CanvasLayer extends PIXI.Container {
	constructor() {
		super();
		 /**
		 * Track whether the canvas layer is currently active for interaction
		 * @type {boolean}
		 */
		this._active = false;
		 // Set initial state
		this.interactive = false;
		this.interactiveChildren = false;
	}
	 /* -------------------------------------------- */
	/*  Properties and Attributes
	/* -------------------------------------------- */
	 /**
	 * Customize behaviors of this CanvasLayer by modifying some behaviors at a class level.
	 * @static
	 * @type {Object}
	 * @property {number} zIndex            The zIndex sorting of this layer relative to other layers
	 * @property {boolean} sortActiveTop    Should this layer be sorted to the top when it is active?
	 */
	static get layerOptions() {
		return {
			zIndex: 0,
			sortActiveTop: false
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a reference to the active instance of this canvas layer
	 * @static
	 * @type {CanvasLayer}
	 */
	static get instance() {
		return canvas.stage.children.find(l => l.constructor.name === this.name);
	}
	 /* -------------------------------------------- */
	 /**
	 * The canonical name of the CanvasLayer
	 * @type {string}
	 */
	get name() {
		return this.constructor.name;
	}
	 /* -------------------------------------------- */
	/*  Rendering
	/* -------------------------------------------- */
	 /**
	 * Deconstruct data used in the current layer in preparation to re-draw the canvas
	 */
	tearDown() {
		this.renderable = false;
		this.removeChildren().forEach(c => {
			c.destroy({children: true, texture: true, baseTexture: false});
		});
		this.renderable = true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the canvas layer, rendering its internal components and returning a Promise
	 * The Promise resolves to the drawn layer once its contents are successfully rendered.
	 * @return {Promise<CanvasLayer>}
	 */
	async draw() {
		const d = canvas.dimensions;
		this.width = d.width;
		this.height = d.height;
		this.hitArea = d.rect;
		this.zIndex = this.constructor.layerOptions.zIndex;
		return this;
	}
	 /* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */
	 /**
	 * Activate the CanvasLayer, deactivating other layers and marking this layer's children as interactive.
	 * @return {CanvasLayer}    The layer instance, now activated
	 */
	activate() {
		if ( this._active ) return;
		const options = this.constructor.layerOptions;
		this._active = true;
		 // Deactivate other layers
		let maxZ = 0;
		for ( let l of canvas.layers ) {
			if ( l === this ) continue;
			if ( l._active ) l.deactivate();
			if ( l.zIndex > maxZ ) maxZ = l.zIndex;
		}
		 // Set interactivity for the active layer
		this.zIndex = options.sortActiveTop ? maxZ + 1 : options.zIndex;
		this.interactive = false;
		this.interactiveChildren = true;
		 // Activate the control palette for the layer
		if ( ui.controls ) ui.controls.initialize({layer: this.constructor.name});
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Deactivate the CanvasLayer, removing interactivity from its children.
	 * @return {CanvasLayer}    The layer instance, now inactive
	 */
	deactivate() {
		const options = this.constructor.layerOptions;
		this._active = false;
		this.interactive = false;
		this.interactiveChildren = false;
		this.zIndex = options.zIndex;
	}
}
/**
 * An Abstract Base Class which defines a Placeable Object which represents an Entity placed on the Canvas
 * @extends {PIXI.Container}
 * @abstract
 * @interface
 *
 * @param {object} data     The underlying embedded document data for the placeable type
 * @param {Scene} [scene]   The parent scene that this object belongs to (if any)
 */
class PlaceableObject extends PIXI.Container {
	constructor(data={}, scene) {
		super();
		 /**
		 * The underlying data object which provides the basis for this placeable object
		 * @type {Object}
		 */
		this.data = data;
		 /**
		 * Retain a reference to the Scene within which this Placeable Object resides
		 * @type {Scene}
		 */
		this.scene = scene;
		 /**
		 * Track the field of vision for the placeable object.
		 * This is necessary to determine whether a player has line-of-sight towards a placeable object or vice-versa
		 * @type {{fov: PIXI.Polygon|null, los: PIXI.Polygon|null}}
		 */
		this.vision = {fov: null, los: null};
		 /**
		 * A control icon for interacting with the object
		 * @type {ControlIcon}
		 */
		this.controlIcon = null;
		 /**
		 * A mouse interaction manager instance which handles mouse workflows related to this object.
		 * @type {MouseInteractionManager}
		 */
		this.mouseInteractionManager = null;
		 /**
		 * An indicator for whether the object is currently controlled
		 * @type {boolean}
		 * @private
		 */
		this._controlled = false;
		 /**
		 * An indicator for whether the object is currently a hover target
		 * @type {boolean}
		 * @private
		 */
		this._hover = false;
		 /**
		 * A singleton reference to the FormApplication class which configures this object
		 * @type {FormApplication|null}
		 * @private
		 */
		this._sheet = null;
	}
	 /* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /**
	 * The bounding box for this PlaceableObject.
	 * This is required if the layer uses a Quadtree, otherwise it is optional
	 * @return {NormalizedRectangle}
	 */
	get bounds() {
		throw new Error("Each PlaceableObject implementation must define it's own bounding box.");
	}
	 /* -------------------------------------------- */
	 /**
	 * The central coordinate pair of the placeable object based on it's own width and height
	 * @type {PIXI.Point}
	 */
	get center() {
		if ( "width" in this.data && "height" in this.data ) {
			return new PIXI.Point(this.data.x + (this.data.width / 2), this.data.y + (this.data.height / 2));
		}
		return new PIXI.Point(this.data.x, this.data.y);
	}
	 /* -------------------------------------------- */
	 /**
	 * The _id of the underlying EmbeddedEntity
	 * @type {string}
	 */
	get id() {
		return this.data._id;
	}
	 /* -------------------------------------------- */
	 /**
	 * The field-of-vision polygon for the object, if it has been computed
	 * @type {PIXI.Polygon|null}
	 */
	get fov() {
		return this.vision.fov;
	}
	 /* -------------------------------------------- */
	 /**
	 * Identify the official EmbeddedEntity name for this PlaceableObject class
	 * @type {string}
	 */
	static get embeddedName() {
		throw new Error("Each PlaceableObject subclass should define it's canonical embeddedName");
	}
	 /* -------------------------------------------- */
	 /**
	 * Provide a reference to the canvas layer which contains placeable objects of this type
	 * @type {PlaceablesLayer}
	 */
	static get layer() {
		return canvas.getLayerByEmbeddedName(this.embeddedName);
	}
	 /** @alias {PlaceableObject.layer} */
	get layer() {
		return this.constructor.layer;
	}
	 /* -------------------------------------------- */
	 /**
	 * The line-of-sight polygon for the object, if it has been computed
	 * @type {PIXI.Polygon|null}
	 */
	get los() {
		return this.vision.los;
	}
	 /* -------------------------------------------- */
	 /**
	 * A Form Application which is used to configure the properties of this Placeable Object or the EmbeddedEntity
	 * it represents.
	 * @type {FormApplication}
	 */
	get sheet() {
		if ( !this._sheet ) {
			const cls = this.layer.options.sheetClass;
			this._sheet = new cls(this);
		}
		return this._sheet;
	}
	 /* -------------------------------------------- */
	 /**
	 * A Universally Unique Identifier (uuid) for this EmbeddedEntity
	 * @type {string}
	 */
	get uuid() {
		return `${this.scene.uuid}.${this.constructor.name}.${this.id}`;
	}
	 /* -------------------------------------------- */
	/*  Permission Controls                         */
	/* -------------------------------------------- */
	 /**
	 * Test whether a user can perform a certain interaction with regards to a Placeable Object
	 * @param {User} user       The User performing the action
	 * @param {string} action   The named action being attempted
	 * @return {boolean}        Does the User have rights to perform the action?
	 */
	can(user, action) {
		const fn = this[`_can${action.titleCase()}`];
		return fn ? fn.call(this, user) : false;
	}
	 /**
	 * Can the User access the HUD for this Placeable Object?
	 * @private
	 */
	_canHUD(user, event) {
		return false;
	}
	 /**
	 * Does the User have permission to configure the Placeable Object?
	 * @private
	 */
	_canConfigure(user, event) {
		return user.isGM;
	}
	 /**
	 * Does the User have permission to control the Placeable Object?
	 * @private
	 */
	_canControl(user, event) {
		return user.isGM;
	}
	 /**
	 * Does the User have permission to view details of the Placeable Object?
	 * @private
	 */
	_canView(user, event) {
		return user.isGM;
	}
	 /**
	 * Does the User have permission to create the underlying Embedded Entity?
	 * @private
	 */
	_canCreate(user, event) {
		return user.isGM;
	}
	 /**
	 * Does the User have permission to drag this Placeable Object?
	 * @private
	 */
	_canDrag(user, event) {
		return this._canControl(user);
	}
	 /**
	 * Does the User have permission to hover on this Placeable Object?
	 * @private
	 */
	_canHover(user, event) {
		return this._canControl(user);
	}
	 /**
	 * Does the User have permission to update the underlying Embedded Entity?
	 * @private
	 */
	_canUpdate(user, event) {
		return this._canControl(user);
	}
	 /**
	 * Does the User have permission to delete the underlying Embedded Entity?
	 * @private
	 */
	_canDelete(user, event) {
		return this._canControl(user);
	}
	 /* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */
	 /**
	 * Clear the display of the existing object
	 * @return {PlaceableObject}    The cleared object
	 */
	clear() {
		this.removeChildren().forEach(c => c.destroy({children: true}));
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Clone the placeable object, returning a new object with identical attributes
	 * The returned object is non-interactive, and has no assigned ID
	 * If you plan to use it permanently you should call the create method
	 *
	 * @return {PlaceableObject}  A new object with identical data
	 */
	clone() {
		let data = duplicate(this.data);
		data._id = null;
		let clone = new this.constructor(data);
		clone.interactive = false;
		clone._original = this;
		clone._controlled = this._controlled;
		return clone;
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the placeable object into its parent container
	 * @return {PlaceableObject}    The drawn object
	 */
	async draw() {
		throw new Error("A PlaceableObject subclass must define initial drawing procedure.");
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the primary Sprite for the PlaceableObject
	 * @return {PIXI.Sprite|null}
	 * @private
	 */
	_drawPrimarySprite(texture) {
		if ( !texture || !texture.valid ) return null;
		const s = new PIXI.Sprite(texture);
		const source = getProperty(texture, "baseTexture.resource.source");
		if ( source && (source.tagName === "VIDEO") ) {
			source.loop = true;
			source.muted = true;
			game.video.play(source);
		}
		return s;
	}
	 /* -------------------------------------------- */
	 /**
	 * Refresh the current display state of the Placeable Object
	 * @return {PlaceableObject}    The refreshed object
	 */
	refresh() {
		throw new Error("A PlaceableObject subclass must define an refresh drawing procedure.");
	}
	 /* -------------------------------------------- */
	/*  Database Management                         */
	/* -------------------------------------------- */
	 /** @extends {Entity.createEmbeddedEntity} */
	static async create(data, options) {
		const created = await canvas.scene.createEmbeddedEntity(this.embeddedName, data, options);
		if ( !created ) return;
		if ( created instanceof Array ) {
			return created.map(c => this.layer.get(c._id));
		} else {
			return this.layer.get(created._id);
		}
	}
	 /* -------------------------------------------- */
	 /** @extends {Entity.updateEmbeddedEntity} */
	async update(data, options) {
		data["_id"] = this.id;
		await this.scene.updateEmbeddedEntity(this.constructor.embeddedName, data, options);
		return this;
	}
	 /* -------------------------------------------- */
	 /** @extends {Entity.deleteEmbeddedEntity} */
	async delete(options) {
		await this.scene.deleteEmbeddedEntity(this.constructor.embeddedName, this.id, options);
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the value of a "flag" for this PlaceableObject
	 * See the setFlag method for more details on flags
	 *
	 * @param {string} scope    The flag scope which namespaces the key
	 * @param {string} key      The flag key
	 * @return {*}              The flag value
	 */
	getFlag(scope, key) {
		const scopes = SetupConfiguration.getPackageScopes();
		if ( !scopes.includes(scope) ) throw new Error(`Invalid scope for flag ${key}`);
		key = `${scope}.${key}`;
		return getProperty(this.data.flags, key);
	}
	 /* -------------------------------------------- */
	 /**
	 * Assign a "flag" to this Entity.
	 * Flags represent key-value type data which can be used to store flexible or arbitrary data required by either
	 * the core software, game systems, or user-created modules.
	 *
	 * Each flag should be set using a scope which provides a namespace for the flag to help prevent collisions.
	 *
	 * Flags set by the core software use the "core" scope.
	 * Flags set by game systems or modules should use the canonical name attribute for the module
	 * Flags set by an individual world should "world" as the scope.
	 *
	 * Flag values can assume almost any data type. Setting a flag value to null will delete that flag.
	 *
	 * @param {string} scope    The flag scope which namespaces the key
	 * @param {string} key      The flag key
	 * @param {*} value         The flag value
	 *
	 * @return {Promise}        A Promise resolving to the updated PlaceableObject
	 */
	async setFlag(scope, key, value) {
		const scopes = SetupConfiguration.getPackageScopes();
		if ( !scopes.includes(scope) ) throw new Error(`Invalid scope for flag ${key}`);
		key = `flags.${scope}.${key}`;
		return this.update({[key]: value});
	}
	 /* -------------------------------------------- */
	 /**
	 * Remove a flag assigned to the Entity
	 * @param {string} scope    The flag scope which namespaces the key
	 * @param {string} key      The flag key
	 * @return {Promise}        A Promise resolving to the updated Entity
	 */
	async unsetFlag(scope, key) {
		const scopes = SetupConfiguration.getPackageScopes();
		if ( !scopes.includes(scope) ) throw new Error(`Invalid scope for flag ${key}`);
		key = `flags.${scope}.-=${key}`;
		return this.update({[key]: null});
	}
	 /* -------------------------------------------- */
	 /**
	 * Register pending canvas operations which should occur after a new PlaceableObject of this type is created
	 * @private
	 */
	_onCreate() {
		this.draw();
	}
	 /* -------------------------------------------- */
	 /**
	 * Define additional steps taken when an existing placeable object of this type is updated with new data
	 * @private
	 */
	_onUpdate(data) {
		const layer = this.layer;
		 // Z-index sorting
		if ( Object.keys(data).includes("z") ) {
			this.zIndex = parseInt(data.z) || 0;
		}
		 // Quadtree location update
		if ( layer.quadtree ) {
			layer.quadtree.remove(this).insert({r: this.bounds, t: this});
		}
		 // Refresh display
		this.refresh();
		 // Refresh connected apps
		this.sheet.render(false);
	}
	 /* -------------------------------------------- */
	 /**
	 * Define additional steps taken when an existing placeable object of this type is deleted
	 * @private
	 */
	_onDelete() {
		this.release({trigger: false});
		const layer = this.layer;
		if ( layer._hover === this ) layer._hover = null;
		if ( layer.quadtree ) layer.quadtree.remove(this);
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /**
	 * Assume control over a PlaceableObject, flagging it as controlled and enabling downstream behaviors
	 * @param {Object} options                  Additional options which modify the control request
	 * @param {boolean} options.releaseOthers   Release any other controlled objects first
	 * @return {boolean}                        A flag denoting whether or not control was successful
	 */
	control(options={}) {
		if ( !this.layer.options.controllableObjects ) return false;
		 // Release other controlled objects
		const wasControlled = this._controlled;
		this._controlled = false;
		if ( options.releaseOthers !== false ) {
			for ( let o of Object.values(this.layer._controlled) ) {
				if ( o !== this ) o.release();
			}
		}
		this._controlled = wasControlled;
		 // Bail out if this object is already controlled, or not controllable
		if (this._controlled) return true;
		if (!this.can(game.user, "control")) return false;
		 // Toggle control status
		this._controlled = true;
		this.layer._controlled[this.id] = this;
		 // Trigger follow-up events and fire an on-control Hook
		this._onControl(options);
		Hooks.callAll("control"+this.constructor.name, this, this._controlled);
		canvas.triggerPendingOperations();
		return true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Additional events which trigger once control of the object is established
	 * @param {Object} options    Optional parameters which apply for specific implementations
	 * @private
	 */
	_onControl(options) {
		this.refresh();
	}
	 /* -------------------------------------------- */
	 /**
	 * Release control over a PlaceableObject, removing it from the controlled set
	 * @param {Object} options          Options which modify the releasing workflow
	 * @return {boolean}                A Boolean flag confirming the object was released.
	 */
	release(options={}) {
		delete this.layer._controlled[this.id];
		if (!this._controlled) return true;
		this._controlled = false;
		 // Trigger follow-up events
		this._onRelease(options);
		 // Fire an on-release Hook
		Hooks.callAll("control"+this.constructor.name, this, this._controlled);
		if ( options.trigger !== false ) canvas.triggerPendingOperations();
		return true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Additional events which trigger once control of the object is released
	 * @param {Object} options          Options which modify the releasing workflow
	 * @private
	 */
	_onRelease(options) {
		const layer = this.layer;
		if ( layer.hud && (layer.hud.object === this) ) layer.hud.clear();
		this.refresh();
	}
	 /* -------------------------------------------- */
	 /**
	 * Rotate the PlaceableObject to a certain angle of facing
	 * @param {number} angle    The desired angle of rotation
	 * @param {number} snap     Snap the angle of rotation to a certain target degree increment
	 * @return {Promise<PlaceableObject>} A Promise which resolves once the rotation has completed
	 */
	async rotate(angle, snap) {
		if ( this.data.rotation === undefined ) return this;
		const rotation = this._updateRotation({angle, snap});
		 // Conceal any active hud
		const hud = this.layer.hud;
		if ( hud ) hud.clear();
		 // Update the object
		return this.update({rotation});
	}
	 /* -------------------------------------------- */
	 /**
	 * Determine a new angle of rotation for a PlaceableObject either from an explicit angle or from a delta offset.
	 * @param {number} [angle]    An explicit angle, either this or delta must be provided
	 * @param {number} [delta]    A relative angle delta, either this or the angle must be provided
	 * @param {number} [snap]     A precision (in degrees) to which the resulting angle should snap. Default is 0.
	 * @return {number}           The new rotation angle for the object
	 */
	_updateRotation({angle=null, delta=0, snap=0}={}) {
		let degrees = Number.isNumeric(angle) ? angle : this.data.rotation + delta;
		 // Determine an offset for certain grid orientations
		let isHexRow = [CONST.GRID_TYPES.HEXODDR, CONST.GRID_TYPES.HEXEVENR].includes(canvas.grid.type);
		const offset = isHexRow ? 30 : 0;
		 // Standardize degrees
		degrees = (degrees + offset) % 360;
		while ( degrees <= 0 ) degrees += 360;
		 // Snap to the desired precision
		if ( snap > 0 ) {
			degrees = Math.round(degrees / snap) * snap;
		}
		return degrees - offset;
	}
	 /* -------------------------------------------- */
	 /**
	 * Obtain a shifted position for the Placeable Object
	 * @param {number} dx         The number of grid units to shift along the X-axis
	 * @param {number} dy         The number of grid units to shift along the Y-axis
	 * @return {{x, y}}           The shifted target coordinates
	 * @private
	 */
	_getShiftedPosition(dx, dy) {
		let [x, y] = canvas.grid.grid.shiftPosition(this.data.x, this.data.y, dx, dy);
		return {x, y};
	}
	 /* -------------------------------------------- */
	/*  Interactivity                               */
	/* -------------------------------------------- */
	 /**
	 * Activate interactivity for the Placeable Object
	 */
	activateListeners() {
		const mgr = this._createInteractionManager();
		this.mouseInteractionManager = mgr.activate();
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a standard MouseInteractionManager for the PlaceableObject
	 * @private
	 */
	_createInteractionManager() {
		 // Handle permissions to perform various actions
		const permissions = {
			hoverIn: this._canHover,
			hoverOut: this._canHover,
			clickLeft: this._canControl,
			clickLeft2: this._canView,
			clickRight: this._canHUD,
			clickRight2: this._canConfigure,
			dragStart: this._canDrag
		};
		 // Define callback functions for each workflow step
		const callbacks = {
			hoverIn: this._onHoverIn,
			hoverOut: this._onHoverOut,
			clickLeft: this._onClickLeft,
			clickLeft2: this._onClickLeft2,
			clickRight: this._onClickRight,
			clickRight2: this._onClickRight2,
			dragLeftStart: this._onDragLeftStart,
			dragLeftMove: this._onDragLeftMove,
			dragLeftDrop: this._onDragLeftDrop,
			dragLeftCancel: this._onDragLeftCancel,
			dragRightStart: null,
			dragRightMove: null,
			dragRightDrop: null,
			dragRightCancel: null
		};
		 // Define options
		const options = {
			target: this.controlIcon ? "controlIcon" : null
		};
		 // Create the interaction manager
		return new MouseInteractionManager(this, canvas.stage, permissions, callbacks, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Actions that should be taken for this Placeable Object when a mouseover event occurs
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @param {boolean} hoverOutOthers
	 * @private
	 */
	_onHoverIn(event, {hoverOutOthers=true}={}) {
		if ( this._hover === true ) return false;
		if ( this.data.locked ) return false;
		const layer = this.layer;
		 // Update the hover state of all objects in the layer
		if ( hoverOutOthers ) {
			layer.placeables.forEach(o => {
				if ( o !== this ) o._onHoverOut(event);
			});
		}
		this._hover = true;
		layer._hover = this;
		 // Refresh the object display
		this.refresh();
		Hooks.callAll("hover"+this.constructor.name, this, this._hover);
	}
	 /* -------------------------------------------- */
	 /**
	 * Actions that should be taken for this Placeable Object when a mouseout event occurs
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onHoverOut(event) {
		if ( this._hover !== true ) return false;
		if ( this.data.locked ) return false;
		const layer = this.layer;
		this._hover = false;
		layer._hover = null;
		this.refresh();
		Hooks.callAll("hover"+this.constructor.name, this, this._hover);
	}
	 /* -------------------------------------------- */
	 /**
	 * Callback actions which occur on a single left-click event to assume control of the object
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onClickLeft(event) {
		const hud = this.layer.hud;
		if ( hud ) hud.clear();
		 // Add or remove the Placeable Object from the currently controlled set
		const oe = event.data.originalEvent;
		if ( this._controlled ) {
			if ( oe.shiftKey ) return this.release();
		} else {
			return this.control({releaseOthers: !oe.shiftKey});
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Callback actions which occur on a double left-click event to activate
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onClickLeft2(event) {
		const sheet = this.sheet;
		if ( sheet ) sheet.render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Callback actions which occur on a single right-click event to configure properties of the object
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onClickRight(event) {
		const hud = this.layer.hud;
		if ( hud ) {
			const releaseOthers = !this._controlled && !event.data.originalEvent.shiftKey;
			this.control({releaseOthers});
			if ( hud.object === this) hud.clear();
			else hud.bind(this);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Callback actions which occur on a double right-click event to configure properties of the object
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onClickRight2(event) {
		const sheet = this.sheet;
		if ( sheet ) sheet.render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Callback actions which occur when a mouse-drag action is first begun.
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onDragLeftStart(event) {
		 // Identify and clone every drag target
		const targets = this.layer.options.controllableObjects ? this.layer.controlled : [this];
		const clones = [];
		for ( let o of targets ) {
			if ( o.data.locked ) continue;
			o.data.locked = true;
			 // Clone the object
			const c = o.clone();
			clones.push(c);
			 // Draw the clone
			c.draw().then(c => {
				o.alpha = 0.4;
				c.alpha = 0.8;
				c.visible = true;
				this.layer.preview.addChild(c);
			});
		}
		event.data.clones = clones;
	}
	 /* -------------------------------------------- */
	 /**
	 * Callback actions which occur on a mouse-move operation.
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onDragLeftMove(event) {
		const {clones, destination, origin, originalEvent} = event.data;
		 // Pan the canvas if the drag event approaches the edge
		canvas._onDragCanvasPan(originalEvent);
		 // Determine dragged distance
		const dx = destination.x - origin.x;
		const dy = destination.y - origin.y;
		 // Update the position of each clone
		for ( let c of clones || [] ) {
			c.data.x = c._original.data.x + dx;
			c.data.y = c._original.data.y + dy;
			c.refresh();
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Callback actions which occur on a mouse-move operation.
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onDragLeftDrop(event) {
		const clones = event.data.clones || [];
		 // Ensure the destination is within bounds
		const dest = event.data.destination;
		if ( !canvas.grid.hitArea.contains(dest.x, dest.y) ) return false;
		 // Compute the final dropped positions
		const updates = clones.map(c => {
			let dest = {x: c.data.x, y: c.data.y};
			if ( !event.data.originalEvent.shiftKey ) {
				dest = canvas.grid.getSnappedPosition(c.data.x, c.data.y, this.layer.options.gridPrecision);
			}
			return {_id: c._original.id, x: dest.x, y: dest.y, rotation: c.data.rotation};
		});
		return canvas.scene.updateEmbeddedEntity(this.constructor.name, updates);
	}
	 /* -------------------------------------------- */
	 /**
	 * Callback actions which occur on a mouse-move operation.
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onDragLeftCancel(event) {
		for ( let c of this.layer.preview.children ) {
			c.visible = false;
			const o = c._original;
			if ( o ) {
				o.data.locked = false;
				o.alpha = 1.0;
			}
		}
		this.layer.preview.removeChildren();
	}
}

/**
 * The base PlaceablesLayer subclass of CanvasLayer
 * @type {CanvasLayer}
 * @abstract
 * @interface
 */
class PlaceablesLayer extends CanvasLayer {
	constructor() {
		super();
		 /**
		 * Placeable Layer Objects
		 * @type {PIXI.Container}
		 */
		this.objects = null;
		 /**
		 * Preview Object Placement
		 */
		this.preview = null;
		 /**
		 * Keep track of history so that CTRL+Z can undo changes
		 * @type {object[]}
		 */
		this.history = [];
		 /**
		 * Track the PlaceableObject on this layer which is currently being hovered upon
		 * @type {PlaceableObject}
		 */
		this._hover = null;
		 /**
		 * Track the set of PlaceableObjects on this layer which are currently controlled by their id
		 * @type {Object}
		 */
		this._controlled = {};
		 /**
		 * Keep track of an object copied with CTRL+C which can be pasted later
		 * @type {object[]}
		 */
		this._copy = [];
		 /**
		 * PlaceableObject layer options
		 * @type {Object}
		 */
		this.options = this.constructor.layerOptions;
		 /**
		 * A Quadtree which partitions and organizes Walls into quadrants for efficient target identification.
		 * @type {Quadtree|null}
		 */
		this.quadtree = null;
	}
	 /* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /**
	 * @inheritDoc
	 * @property {boolean} canDragCreate        Does this layer support a mouse-drag workflow to create new objects?
	 * @property {boolean} canDelete            Can objects be deleted from this layer?
	 * @property {boolean} controllableObjects  Can placeable objects in this layer be controlled?
	 * @property {boolean} rotatableObjects     Can placeable objects in this layer be rotated?
	 * @property {boolean} snapToGrid           Do objects in this layer snap to the grid
	 * @property {number} gridPrecision         At what numeric grid precision do objects snap?
	 * @property {PlaceableObject} objectClass  The class used to represent an object on this layer.
	 * @property {boolean} quadtree             Does this layer use a quadtree to track object positions?
	 * @property {FormApplication} sheetClass   The FormApplication class used to configure objects on this layer.
	 */
	static get layerOptions() {
		return mergeObject(super.layerOptions, {
			canDragCreate: game.user.isGM,
			canDelete: game.user.isGM,
			controllableObjects: false,
			rotatableObjects: false,
			snapToGrid: true,
			gridPrecision: 2,
			objectClass: null,
			quadtree: false,
			sheetClass: null
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Define the named Array within Scene.data containing the placeable objects displayed in this layer
	 * @static
	 * @type {string}
	 */
	static get dataArray() {
		return Scene.config.embeddedEntities[this.placeableClass.name];
	}
	 /* -------------------------------------------- */
	 /**
	 * Define a Container implementation used to render placeable objects contained in this layer
	 * @static
	 * @type {PIXI.Container}
	 */
	static get placeableClass() {
		return this.layerOptions.objectClass;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the precision relative to the Scene grid with which Placeable objects should be snapped
	 * @return {number}
	 */
	get gridPrecision() {
		return this.constructor.layerOptions.gridPrecision;
	}
	 /* -------------------------------------------- */
	 /**
	 * If objects on this PlaceableLayer have a HUD UI, provide a reference to its instance
	 * @type {BasePlaceableHUD|null}
	 */
	get hud() {
		return null;
	}
	 /* -------------------------------------------- */
	 /**
	 * A convenience method for accessing the placeable object instances contained in this layer
	 * @type {PlaceableObject[]}
	 */
	get placeables() {
		if ( !this.objects ) return [];
		return this.objects.children;
	}
	 /* -------------------------------------------- */
	 /**
	 * An Array of placeable objects in this layer which have the _controlled attribute
	 * @return {Array.<PlaceableObject>}
	 */
	get controlled() {
		return Object.values(this._controlled);
	}
	 /* -------------------------------------------- */
	/*  Rendering
	/* -------------------------------------------- */
	 /** @override */
	async draw() {
		await super.draw();
		 // Create objects container which can be sorted
		this.objects = this.addChild(new PIXI.Container());
		this.objects.sortableChildren = true;
		this.objects.visible = false;
		 // Create a Quadtree container if the layer uses it
		if ( this.options.quadtree ) {
			const d = canvas.dimensions;
			this.quadtree = new Quadtree({x: 0, y: 0, width: d.width, height: d.height});
		} else this.quadtree = null;
		 // Create preview container which is always above objects
		this.preview = this.addChild(new PIXI.Container());
		 // Create and draw objects
		const promises = canvas.scene.data[this.constructor.dataArray].map(data => {
			const obj = this.createObject(data);
			return obj.draw();
		});
		 // Wait for all objects to draw
		this.visible = true;
		return Promise.all(promises);
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw a single placeable object
	 * @return {PlaceableObject}
	 */
	createObject(data) {
		const obj = new this.constructor.placeableClass(data, canvas.scene);
		obj.zIndex = data.z || 0;
		this.objects.addChild(obj);
		if ( this.quadtree ) this.quadtree.insert({r: obj.bounds, t: obj});
		return obj;
	}
	 /* -------------------------------------------- */
	 /** @override */
	async tearDown() {
		 // Reset layer history
		this.history = [];
		 // Release all controlled objects
		if ( this.options.controllableObjects ) {
			this._controlled = {};
		}
		 // Clear the HUD
		if ( this.hud ) this.hud.clear();
		 // Destroy the layer children
		return super.tearDown();
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /** @override */
	activate() {
		super.activate();
		this.objects.visible = true;
		this.placeables.forEach(l => l.refresh());
		return this;
	}
	 /* -------------------------------------------- */
	 /** @override */
	deactivate() {
		super.deactivate();
		this.objects.visible = false;
		this.releaseAll();
		this.placeables.forEach(l => l.refresh());
		if ( this.preview ) this.preview.removeChildren();
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get a PlaceableObject contained in this layer by it's ID
	 * @param {string} objectId   The ID of the contained object to retrieve
	 * @return {PlaceableObject}  The object instance, or undefined
	 */
	get(objectId) {
		return this.placeables.find(t => t.id === objectId);
	}
	 /* -------------------------------------------- */
	 /**
	 * Acquire control over all PlaceableObject instances which are visible and controllable within the layer.
	 * @param {object} options      Options passed to the control method of each object
	 * @return {PlaceableObject[]}  An array of objects that were controlled
	 */
	controlAll(options={}) {
		if ( !this.options.controllableObjects ) return;
		options.releaseOthers = false;
		for ( let o of this.placeables ) {
			if (!o.visible || !o.can(game.user, "control")) continue;
			o.control(options);
		}
		return this.controlled;
	}
	 /* -------------------------------------------- */
	 /**
	 * Release all controlled PlaceableObject instance from this layer.
	 * @param {object} options   Options passed to the release method of each object
	 * @returns {number}         The number of PlaceableObject instances which were released
	 */
	releaseAll(options={}) {
		let released = 0;
		for ( let o of this.placeables ) {
			if ( !o._controlled ) continue;
			o.release(options);
			released++;
		}
		return released;
	}
	 /* -------------------------------------------- */
	 /**
	 * Simultaneously rotate multiple PlaceableObjects using a provided angle or incremental.
	 * This executes a single database operation using Scene.update.
	 * If rotating only a single object, it is better to use the PlaceableObject.rotate instance method.
		* @param {number} angle      A target angle of rotation (in degrees) where zero faces "south"
	 * @param {number} delta      An incremental angle of rotation (in degrees)
	 * @param {number} snap       Snap the resulting angle to a multiple of some increment (in degrees)
	 * @param {Array|Set} ids     An Array or Set of object IDs to target for rotation
		* @return {Promise<Scene>}   The resulting Promise from the Scene.update operation
	 */
	async rotateMany({angle=null, delta=null, snap=null, ids=null}={}) {
		if ((!this.constructor.layerOptions.rotatableObjects ) || (game.paused && !game.user.isGM)) return;
		if ( (angle === null) && (delta === null) ) {
			throw new Error("Either a target angle or incremental delta must be provided.");
		}
		 // Determine the set of rotatable objects
		const rotatable = this.controlled.filter(o => !o.data.locked);
		if ( !rotatable.length ) return;
		 // Conceal any active HUD
		const hud = this.hud;
		if ( hud ) hud.clear();
		 // Update the objects with a single operation
		const updateData = rotatable.map(o => {
			return {_id: o.id, rotation: o._updateRotation({angle, delta, snap})}
		});
		return this.updateMany(updateData);
	}
	 /* -------------------------------------------- */
	 /**
	 * Simultaneously move multiple PlaceableObjects via keyboard movement offsets.
	 * This executes a single database operation using Scene.update.
	 * If moving only a single object, this will delegate to PlaceableObject.update for performance reasons.
	 * 
	 * @param {number} dx         The number of incremental grid units in the horizontal direction
	 * @param {number} dy         The number of incremental grid units in the vertical direction
	 * @param {boolean} rotate    Rotate the token to the keyboard direction instead of moving
	 * @param {Array|Set} ids     An Array or Set of object IDs to target for rotation
	 *
	 * @return {Promise<Scene>}   The resulting Promise from the Scene.update operation
	 */
	async moveMany({dx=0, dy=0, rotate=false, ids=null}={}) {
		if ( !dx && !dy ) return;
		if ( game.paused && !game.user.isGM ) {
			return ui.notifications.warn(game.i18n.localize("GAME.PausedWarning"));
		}
		 // Determine the set of movable object IDs unless some were explicitly provided
		ids = ids !== null ? Array.from(ids) : this.controlled.filter(o => !o.data.locked).map(o => o.id);
		if ( !ids.length ) return;
		 // Define rotation angles
		const rotationAngles = {
			square: [45, 135, 225, 315],
			hexR: [30, 150, 210, 330],
			hexQ: [60, 120, 240, 300]
		};
		 // Determine the rotation angle
		let offsets = [dx, dy];
		let angle = 0;
		if ( rotate ) {
			let angles = rotationAngles.square;
			if ( canvas.grid.type >= CONST.GRID_TYPES.HEXODDQ ) angles = rotationAngles.hexQ;
			else if ( canvas.grid.type >= CONST.GRID_TYPES.HEXODDR ) angles = rotationAngles.hexR;
			if (offsets.equals([0, 1])) angle = 0;
			else if (offsets.equals([-1, 1])) angle = angles[0];
			else if (offsets.equals([-1, 0])) angle = 90;
			else if (offsets.equals([-1, -1])) angle = angles[1];
			else if (offsets.equals([0, -1])) angle = 180;
			else if (offsets.equals([1, -1])) angle = angles[2];
			else if (offsets.equals([1, 0])) angle = 270;
			else if (offsets.equals([1, 1])) angle = angles[3];
		}
		 // Conceal any active HUD
		const hud = this.hud;
		if ( hud ) hud.clear();
		 // Construct the update Array
		const updateData = ids.map(id => {
			let update = {_id: id};
			if ( rotate ) update.rotation = angle;
			else {
				let obj = this.get(id);
				mergeObject(update, obj._getShiftedPosition(...offsets));
			}
			return update;
		});
		 // Call the updateMany method
		return this.updateMany(updateData);
	}
	 /* -------------------------------------------- */
	 /**
	 * Undo a change to the objects in this layer
	 * This method is typically activated using CTRL+Z while the layer is active
	 * @return {Promise<Scene>}
	 */
	async undoHistory() {
		if ( !this.history.length ) return Promise.reject("No more tracked history to undo!");
		let event = this.history.pop();
		const cls = this.constructor.placeableClass;
		 // Undo creation with deletion
		if ( event.type === "create" ) {
			return this.deleteMany(event.data.map(d => d._id), {isUndo: true});
		}
		 // Undo updates with update
		else if ( event.type === "update" ) {
			return this.updateMany(event.data, {isUndo: true});
		}
		 // Undo deletion with creation
		else if ( event.type === "delete" ) {
			return cls.create(event.data, {isUndo: true});
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Create multiple embedded entities in a parent Entity collection using an Array of provided data
	 *
	 * @param {object[]} data       An Array of update data Objects which provide incremental data
	 * @param {object} options      Additional options which customize the update workflow
	 *
	 * @return {Promise<object[]>}  A Promise which resolves to the returned socket response (if successful)
	 */
	async createMany(data, options={}) {
		const embeddedName = this.constructor.placeableClass.name;
		return canvas.scene.createEmbeddedEntity(embeddedName, data, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Update multiple embedded entities in a parent Entity collection using an Array of provided data
	 *
	 * @param {object[]} data       An Array of update data Objects which provide incremental data
	 * @param {object} options      Additional options which customize the update workflow
	 *
	 * @return {Promise<object[]>}  A Promise which resolves to the returned socket response (if successful)
	 */
	async updateMany(data, options={}) {
		const embeddedName = this.constructor.placeableClass.name;
		return canvas.scene.updateEmbeddedEntity(embeddedName, data, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Simultaneously delete multiple PlaceableObjects.
	 * This executes a single database operation using Scene.update.
	 * If deleting only a single object, this will delegate to PlaceableObject.delete for performance reasons.
	 *
	 * @param {string[]} ids        An Array of object IDs to target for deletion
	 * @param {object} options      Additional options which customize the update workflow
	 *
	 * @return {Promise<string[]>}  A Promise which resolves to the returned socket response (if successful)
	 */
	async deleteMany(ids, options={}) {
		const embeddedName = this.constructor.placeableClass.name;
		return canvas.scene.deleteEmbeddedEntity(embeddedName, ids, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Update all objects in this layer with a provided transformation.
	 * Conditionally filter to only apply to objects which match a certain condition.
	 * @param {Function|object} transformation    An object of data or function to apply to all matched objects
	 * @param {Function|null}  condition          A function which tests whether to target each object
	 * @param {object} [options]                  Additional options passed to Entity.update
	 * @return {Promise<Data[]>}                  An array of updated data once the operation is complete
	 */
	async updateAll(transformation, condition=null, options={}) {
		const hasTransformer = transformation instanceof Function;
		if ( !hasTransformer && (getType(transformation) !== "Object") ) {
			throw new Error("You must provide a data object or transformation function");
		}
		const hasCondition = condition instanceof Function;
		const updates = this.placeables.reduce((arr, obj) => {
			if ( hasCondition && !condition(obj) ) return arr;
			const update = hasTransformer ? transformation(obj) : duplicate(transformation);
			update._id = obj.id;
			arr.push(update);
			return arr;
		},[]);
		return this.updateMany(updates, options);
	}
	 /* -------------------------------------------- */
		/**
	 * A helper method to prompt for deletion of all PlaceableObject instances within the Scene
	 * Renders a confirmation dialogue to confirm with the requester that all objects will be deleted
	 */
	deleteAll() {
		const cls = this.constructor.placeableClass;
		if ( !game.user.isGM ) {
			throw new Error(`You do not have permission to delete ${cls.name} objects from the Scene.`);
		}
		return Dialog.confirm({
			title: game.i18n.localize("CONTROLS.ClearAll"),
			content: `<p>${game.i18n.format("CONTROLS.ClearAllHint", {type: cls.name})}</p>`,
			yes: () => this.deleteMany(this.placeables.map(o => o.id), {}),
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Record a new CRUD event in the history log so that it can be undone later
	 * @param {string} type   The event type (create, update, delete)
	 * @param {Object} data   The object data
	 */
	storeHistory(type, data) {
		if ( this.history.length >= 10 ) this.history.shift();
		this.history.push({type, data});
	}
	 /* -------------------------------------------- */
	 /**
	 * Copy currently controlled PlaceableObjects to a temporary Array, ready to paste back into the scene later
	 * @returns {PlaceableObject[]}             The Array of copied PlaceableObject instances
	 */
	copyObjects() {
		if ( this.options.controllableObjects ) this._copy = Array.from(this.controlled);
		else if ( this._hover) this._copy = [this._hover];
		else this._copy = [];
		const cn = this.constructor.placeableClass.name;
		ui.notifications.info(`Copied data for ${this._copy.length} ${cn} objects.`);
		return this._copy;
	}
	 /* -------------------------------------------- */
	 /**
	 * Paste currently copied PlaceableObjects back to the layer by creating new copies
	 * @param {Point} position      The destination position for the copied data.
	 * @param {boolean} [hidden]    Paste data in a hidden state, if applicable. Default is false.
	 * @param {boolean} [snap]      Snap the resulting objects to the grid. Default is true.
	 * @return {Promise.<PlaceableObject[]>}    An Array of created PlaceableObject instances
	 */
	async pasteObjects(position, {hidden=false, snap=true}={}) {
		if ( !this._copy.length ) return [];
		const cls = this.constructor.placeableClass;
		 // Adjust the pasted position for half a grid space
		if ( snap ) {
			position.x -= canvas.dimensions.size / 2;
			position.y -= canvas.dimensions.size / 2;
		}
		 // Get the left-most object in the set
		this._copy.sort((a, b) => a.data.x - b.data.x);
		let {x, y} = this._copy[0].data;
		 // Iterate over objects
		const toCreate = [];
		for ( let c of this._copy ) {
			let data = duplicate(c.data);
			let dest = {x: position.x + (data.x - x), y: position.y + (data.y - y)};
			if ( snap ) dest = canvas.grid.getSnappedPosition(dest.x, dest.y);
			delete data._id;
			toCreate.push(mergeObject(data, {
				x: dest.x,
				y: dest.y,
				hidden: data.hidden || hidden
			}));
		}
		 // Call paste hooks
		Hooks.call(`paste${cls.name}`, this._copy, toCreate);
		 // Create all objects
		let created = await canvas.scene.createEmbeddedEntity(cls.name, toCreate);
		ui.notifications.info(`Pasted data for ${toCreate.length} ${cls.name} objects.`);
		created = created instanceof Array ? created : [created];
		return created.map(c => this.get(c._id));
	}
	 /* -------------------------------------------- */
	 /**
	 * Select all PlaceableObject instances which fall within a coordinate rectangle.
	 *
	 * @param {number} x      The top-left x-coordinate of the selection rectangle
	 * @param {number} y      The top-left y-coordinate of the selection rectangle
	 * @param {number} width  The width of the selection rectangle
	 * @param {number} height The height of the selection rectangle
	 * @param {Object} releaseOptions   Optional arguments provided to any called release() method
	 * @param {Object} controlOptions   Optional arguments provided to any called control() method
	 * @return {boolean}       A boolean for whether the controlled set was changed in the operation
	 */
	selectObjects({x, y, width, height, releaseOptions={}, controlOptions={}}={}) {
		if ( !this.options.controllableObjects ) return false;
		const oldSet = Object.values(this._controlled);
		 // Identify controllable objects
		const controllable = this.placeables.filter(obj => obj.visible && (obj.control instanceof Function));
		const newSet = controllable.filter(obj => {
			let c = obj.center;
			return Number.between(c.x, x, x+width) && Number.between(c.y, y, y+height);
		});
		 // Release objects no longer controlled
		const toRelease = oldSet.filter(obj => !newSet.includes(obj));
		toRelease.forEach(obj => obj.release(releaseOptions));
		 // Control new objects
		if ( isObjectEmpty(controlOptions) ) controlOptions.releaseOthers = false;
		const toControl = newSet.filter(obj => !oldSet.includes(obj));
		toControl.forEach(obj => obj.control(controlOptions));
		 // Return a boolean for whether the control set was changed
		return (toRelease.length > 0) || (toControl.length > 0);
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /**
	 * Handle left mouse-click events which originate from the Canvas stage and are dispatched to this Layer.
	 * @see {Canvas#_onClickLeft}
	 */
	_onClickLeft(event) {
		if ( this.hud ) this.hud.clear();
		this.releaseAll();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle double left-click events which originate from the Canvas stage and are dispatched to this Layer.
	 * @see {Canvas#_onClickLeft2}
	 */
	_onClickLeft2(event) {}
	 /* -------------------------------------------- */
	 /**
	 * Start a left-click drag workflow originating from the Canvas stage.
	 * @see {Canvas#_onDragLeftStart}
	 */
	_onDragLeftStart(event) {
		if ( !this.options.canDragCreate ) {
			delete event.data.createState;
			return;
		}
		event.data.createState = 0;
		 // Clear any existing preview
		if ( this.preview ) this.preview.removeChildren();
		event.data.preview = null;
		 // Snap the origin to the grid
		const {origin, originalEvent} = event.data;
		if ( this.options.snapToGrid && !originalEvent.isShift ) {
			event.data.origin = canvas.grid.getSnappedPosition(origin.x, origin.y, this.gridPrecision);
		}
		 // Register the ongoing creation
		event.data.createState = 1;
	}
	 /* -------------------------------------------- */
	 /**
	 * Continue a left-click drag workflow originating from the Canvas stage.
	 * @see {Canvas#_onDragLeftMove}
	 */
	_onDragLeftMove(event) {
		const preview = event.data.preview;
		if ( !preview ) return;
		if ( preview.parent === null ) { // In theory this should never happen, but rarely does
			this.preview.addChild(preview);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Conclude a left-click drag workflow originating from the Canvas stage.
	 * @see {Canvas#_onDragLeftDrop}
	 */
	_onDragLeftDrop(event) {
		const object = event.data.preview;
		if ( object ) {
			this.constructor.placeableClass.create(object.data);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Cancel a left-click drag workflow originating from the Canvas stage.
	 * @see {Canvas#_onDragLeftDrop}
	 */
	_onDragLeftCancel(event) {
		if ( this.preview ) {
			for ( let c of this.preview.children ) {
				if ( c._original ) {
					if ( "locked" in c._original.data ) c._original.data.locked = false;
					c._original.alpha = 1.0;
				}
			}
			this.preview.removeChildren();
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle right mouse-click events which originate from the Canvas stage and are dispatched to this Layer.
	 * @see {Canvas#_onClickRight}
	 */
	_onClickRight(event) {
		if ( this.hud ) this.hud.clear();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mouse-wheel events at the PlaceableObjects layer level to rotate multiple objects at once.
	 * This handler will rotate all controlled objects by some incremental angle.
	 * @param {MouseWheelEvent} event   The mousewheel event which originated the request
	 */
	_onMouseWheel(event) {
		 // Prevent wheel rotation for non-GM users if the game is paused
		if ( game.paused && !game.user.isGM ) return;
		 // Determine the incremental angle of rotation from event data
		const dBig = canvas.grid.type > CONST.GRID_TYPES.SQUARE ? 60 : 45;
		let snap = event.shiftKey ? dBig : 15;
		let delta = snap * Math.sign(event.deltaY);
		 // Case 1 - rotate preview objects
		if ( this.preview.children.length ) {
			for ( let p of this.preview.children ) {
				p.data.rotation = p._updateRotation({delta, snap});
				p.refresh();
			}
		}
		 // Case 2 - Update multiple objects
		else return this.rotateMany({delta, snap});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a DELETE keypress while a placeable object is hovered
	 * @param {Event} event    The delete key press event which triggered the request
	 * @private
	 */
	async _onDeleteKey(event) {
		if ( !this.options.canDelete ) return;
		let ids = null;
		 // Delete all controlled objects which are not currently locked
		if ( this.options.controllableObjects ) {
			ids = this.controlled.reduce((ids, o) => {
				if ( o.data.locked ) return ids;
				ids.push(o.id);
				return ids;
			}, []);
		}
		 // Otherwise delete the hovered object
		else ids = this._hover ? [this._hover.id] : [];
		 // Execute delete operations
		if ( !ids.length ) return;
		return canvas.activeLayer.deleteMany(ids);
	}
}

jQuery.fn.shake = function(shakes, distance, duration) {
	if (shakes > 0) {
		this.each(function () {
			let $el = $(this);
			let left = $el.css('left');
			$el.animate({left: "-=" + distance}, duration, function () {
				$el.animate({left: "+=" + distance * 2}, duration, function () {
					$el.animate({left: left}, duration, function () {
						$el.shake(shakes - 1, distance, duration);
					});
				});
			});
		});
	}
	return this;
};

/**
 * Display a right-click activated Context Menu which provides a dropdown menu of options
 * A ContextMenu is constructed by designating a parent HTML container and a target selector
 * An Array of menuItems defines the entries of the menu which is displayed
 * 
 * @param {HTMLElement|jQuery} element    The containing HTML element within which the menu is positioned
 * @param {string} selector               A CSS selector which activates the context menu.
 * @param {object[]} menuItems            An Array of entries to display in the menu
 * @param {string} eventName              Optionally override the triggering event which can spawn the menu
 *
 * @param {Object} menuItem               Menu items in the array can have the following properties
 * @param {string} menuItem.name          The displayed item name
 * @param {string} menuItem.icon          An icon glyph HTML string
 * @param {Function} menuItem.condition   A function which returns a Boolean for whether or not to display the item
 * @param {Function} menuItem.callback    A callback function to trigger when the entry of the menu is clicked
 */
class ContextMenu {
	constructor(element, selector, menuItems, {eventName="contextmenu"}={}) {
		 /**
		 * The target HTMLElement being selected
		 * @type {HTMLElement}
		 */
		this.element = element;
		 /**
		 * The target CSS selector which activates the menu
		 * @type {string}
		 */
		this.selector = selector || element.attr("id");
		 /**
		 * An interaction event name which activates the menu
		 * @type {string}
		 */
		this.eventName = eventName;
		 /**
		 * The array of menu items being rendered
		 * @type {object[]}
		 */
		this.menuItems = menuItems;
		 /**
		 * Track which direction the menu is expanded in
		 * @type {boolean}
		 */
		this._expandUp = false;
		 // Bind to the current element
		this.bind();
	}
	 /* -------------------------------------------- */
	 /**
	 * A convenience accessor to the context menu HTML object
	 * @return {*|jQuery.fn.init|jQuery|HTMLElement}
	 */
	get menu() {
		return $("#context-menu");
	}
	 /* -------------------------------------------- */
	 /**
	 * Attach a ContextMenu instance to an HTML selector
	 */
	bind() {
		this.element.on(this.eventName, this.selector, event => {
			event.preventDefault();
			let parent = $(event.currentTarget),
					menu = this.menu;
			 // Remove existing context UI
			$('.context').removeClass("context");
			 // Close the current context
			if ( $.contains(parent[0], menu[0]) ) this.close();
			 // If the new target element is different
			else {
				this.render(parent);
				ui.context = this;
			}
		})
	}
	 /* -------------------------------------------- */
	 /**
	 * Animate closing the menu by sliding up and removing from the DOM
	 */
	async close() {
		let menu = this.menu;
		await this._animateClose(menu);
		menu.remove();
		$('.context').removeClass("context");
		delete ui.context;
	}
	 /* -------------------------------------------- */
	 async _animateOpen(menu) {
		menu.hide();
		return new Promise(resolve => menu.slideDown(200, resolve));
	}
	 /* -------------------------------------------- */
	 async _animateClose(menu) {
		return new Promise(resolve => menu.slideUp(200, resolve));
	}
	 /* -------------------------------------------- */
	 /**
	 * Render the Context Menu by iterating over the menuItems it contains
	 * Check the visibility of each menu item, and only render ones which are allowed by the item's logical condition
	 * Attach a click handler to each item which is rendered
	 * @param target
	 */
	render(target) {
		let html = $("#context-menu").length ? $("#context-menu") : $('<nav id="context-menu"></nav>');
		let ol = $('<ol class="context-items"></ol>');
		html.html(ol);
		 // Build menu items
		for (let item of this.menuItems) {
			 // Determine menu item visibility (display unless false)
			let display = true;
			if ( item.condition !== undefined ) {
				display = ( item.condition instanceof Function ) ? item.condition(target) : item.condition;
			}
			if ( !display ) continue;
			 // Construct and add the menu item
			let name = game.i18n.localize(item.name);
			let li = $(`<li class="context-item">${item.icon}${name}</li>`);
			li.children("i").addClass("fa-fw");
			li.click(e => {
				e.preventDefault();
				e.stopPropagation();
				item.callback(target);
				this.close();
			});
			ol.append(li);
		}
		 // Bail out if there are no children
		if ( ol.children().length === 0 ) return;
		 // Append to target
		this._setPosition(html, target);
		 // Animate open the menu
		return this._animateOpen(html);
	}
	 /* -------------------------------------------- */
	 /**
	 * Set the position of the context menu, taking into consideration whether the menu should expand upward or downward
	 * @private
	 */
	_setPosition(html, target) {
		const container = target[0].parentElement;
		 // Append to target and get the context bounds
		target.css('position', 'relative');
		html.css("visibility", "hidden");
		target.append(html);
		const contextRect = html[0].getBoundingClientRect();
		const parentRect = target[0].getBoundingClientRect();
		const containerRect = container.getBoundingClientRect();
		 // Determine whether to expand upwards
		const contextTop = parentRect.top - contextRect.height;
		const contextBottom = parentRect.bottom + contextRect.height;
		const canOverflowUp = (contextTop > containerRect.top) || (getComputedStyle(container).overflowY === "visible");
		 // If it overflows the container bottom, but not the container top
		const containerUp = ( contextBottom > containerRect.bottom ) && ( contextTop >= containerRect.top );
		const windowUp = ( contextBottom > window.innerHeight ) && ( contextTop > 0 ) && canOverflowUp;
		this._expandUp = containerUp || windowUp;
		 // Display the menu
		html.addClass(this._expandUp ? "expand-up" : "expand-down");
		html.css("visibility", "");
		target.addClass("context");
	}
	 /* -------------------------------------------- */
	 static eventListeners() {
		document.addEventListener("click", ev => {
			if ( ui.context ) ui.context.close();
		});
	};
}

/* -------------------------------------------- */

/**
 * @typedef {Object} DialogButton
 * @property {string} icon            A Font Awesome icon for the button
 * @property {string} label           The label for the button
 * @property {Function} [callback]    A callback function that fires when the button is clicked
 */

/**
 * Create a dialog window displaying a title, a message, and a set of buttons which trigger callback functions.
 * @implements {Application}
 *
 * @param {Object} data               An object of dialog data which configures how the modal window is rendered
 * @param {string} data.title         The window title
 * @param {string} data.content       HTML content
 * @param {Function} [data.render]    A callback function invoked when the dialog is rendered
 * @param {Function} [data.close]     Common callback operations to perform when the dialog is closed
 * @param {Object<string, DialogButton>} data.buttons The buttons which are displayed as action choices for the dialog
 *
 * @param {Object} options            Dialog rendering options, see :class:`Application`
 * @param {string} options.default    The name of the default button which should be triggered on Enter
 * @param {boolean} options.jQuery    Whether to provide jQuery objects to callback functions (if true) or plain
 *                                    HTMLElement instances (if false). This is currently true by default but in the
 *                                    future will become false by default.
 *
 * @example <caption>Constructing a custom dialog instance</caption>
 * let d = new Dialog({
 *  title: "Test Dialog",
 *  content: "<p>You must choose either Option 1, or Option 2</p>",
 *  buttons: {
 *   one: {
 *    icon: '<i class="fas fa-check"></i>',
 *    label: "Option One",
 *    callback: () => console.log("Chose One")
 *   },
 *   two: {
 *    icon: '<i class="fas fa-times"></i>',
 *    label: "Option Two",
 *    callback: () => console.log("Chose Two")
 *   }
 *  },
 *  default: "two",
 *  render: html => console.log("Register interactivity in the rendered dialog"),
 *  close: html => console.log("This always is logged no matter which option is chosen")
 * });
 * d.render(true);
 */
class Dialog extends Application {
	constructor(data, options) {
		super(options);
		this.data = data;
	}
	/* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 template: "templates/hud/dialog.html",
			classes: ["dialog"],
			width: 400,
			jQuery: true
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	get title() {
		return this.data.title || "Dialog";
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		let buttons = Object.keys(this.data.buttons).reduce((obj, key) => {
			let b = this.data.buttons[key];
			b.cssClass = [key, this.data.default === key ? "default" : ""].filterJoin(" ");
			if ( b.condition !== false ) obj[key] = b;
			return obj;
		}, {});
		return {
			content: this.data.content,
			buttons: buttons
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		html.find(".dialog-button").click(this._onClickButton.bind(this));
		$(document).on('keydown.chooseDefault', this._onKeyDown.bind(this));
		if ( this.data.render instanceof Function ) this.data.render(this.options.jQuery ? html : html[0]);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a left-mouse click on one of the dialog choice buttons
	 * @param {MouseEvent} event    The left-mouse click event
	 * @private
	 */
	_onClickButton(event) {
		const id = event.currentTarget.dataset.button;
		const button = this.data.buttons[id];
		this.submit(button);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a keydown event while the dialog is active
	 * @param {KeyboardEvent} event   The keydown event
	 * @private
	 */
	_onKeyDown(event) {
		 // Close dialog
		if ( event.key === "Escape" ) {
			event.preventDefault();
			event.stopPropagation();
			return this.close();
		}
		 // Confirm default choice
		if ( (event.key === "Enter") && this.data.default ) {
			event.preventDefault();
			event.stopPropagation();
			const defaultChoice = this.data.buttons[this.data.default];
			return this.submit(defaultChoice);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Submit the Dialog by selecting one of its buttons
	 * @param {Object} button     The configuration of the chosen button
	 * @private
	 */
	submit(button) {
		try {
			if (button.callback) button.callback(this.options.jQuery ? this.element : this.element[0]);
			this.close();
		} catch(err) {
			ui.notifications.error(err);
			throw new Error(err);
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	async close(options) {
		if ( this.data.close ) this.data.close(this.options.jQuery ? this.element : this.element[0]);
		$(document).off('keydown.chooseDefault');
		return super.close(options);
	}
	 /* -------------------------------------------- */
	/*  Factory Methods                             */
	/* -------------------------------------------- */
	 /**
	 * A helper factory method to create simple confirmation dialog windows which consist of simple yes/no prompts.
	 * If you require more flexibility, a custom Dialog instance is preferred.
	 *
	 * @param {string} title          The confirmation window title
	 * @param {string} content        The confirmation message
	 * @param {Function} yes          Callback function upon yes
	 * @param {Function} no           Callback function upon no
	 * @param {Function} render       A function to call when the dialog is rendered
	 * @param {boolean} defaultYes    Make "yes" the default choice?
	 * @param {boolean} rejectClose   Reject the Promise if the Dialog is closed without making a choice.
	 * @param {Object} options        Additional rendering options passed to the Dialog
	 *
	 * @return {Promise<*>}           A promise which resolves once the user makes a choice or closes the window
	 *
	 * @example
	 * let d = Dialog.confirm({
	 *  title: "A Yes or No Question",
	 *  content: "<p>Choose wisely.</p>",
	 *  yes: () => console.log("You chose ... wisely"),
	 *  no: () => console.log("You chose ... poorly"),
	 *  defaultYes: false
	 * });
	 */
	static async confirm({title, content, yes, no, render, defaultYes=true, rejectClose=false, options={}}={}, old) {
		 // TODO: Support the old second-paramter options until 0.8.x release
		if ( old ) {
			console.warn("You are passing an options object as a second parameter to Dialog.confirm. This should now be passed in as the options key of the first parameter.")
			options = old;
		}
		return new Promise((resolve, reject) => {
			const dialog = new this({
				title: title,
				content: content,
				buttons: {
					yes: {
						icon: '<i class="fas fa-check"></i>',
						label: game.i18n.localize("Yes"),
						callback: html => {
							const result = yes ? yes(html) : true;
							resolve(result);
						}
					},
					no: {
						icon: '<i class="fas fa-times"></i>',
						label: game.i18n.localize("No"),
						callback: html => {
							const result = no ? no(html) : false;
							resolve(result);
						}
					}
				},
				default: defaultYes ? "yes" : "no",
				render: render,
				close: () => {
					if ( rejectClose ) reject("The confirmation Dialog was closed without a choice being made");
					else resolve(null);
				},
			}, options);
			dialog.render(true);
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * A helper factory method to display a basic "prompt" style Dialog with a single button
	 * @param {string} title          The confirmation window title
	 * @param {string} content        The confirmation message
	 * @param {string} label          The confirmation button text
	 * @param {Function} callback     A callback function to fire when the button is clicked
	 * @param {Function} render       A function that fires after the dialog is rendered
	 * @param {object} options        Additional rendering options
	 * @return {Promise<*>}           A promise which resolves when clicked, or rejects if closed
	 */
	static async prompt({title, content, label, callback, render, options={}}={}) {
		return new Promise((resolve, reject) => {
			const dialog = new this({
				title: title,
				content: content,
				buttons: {
					ok: {
						icon: '<i class="fas fa-check"></i>',
						label: label,
						callback: html => {
							const result = callback(html);
							resolve(result);
						}
					},
				},
				default: "ok",
				render: render,
				close: () => reject,
			}, options);
			dialog.render(true);
		});
	}
}

/**
 * A UI utility to make an element draggable.
 */
class Draggable {
	constructor(app, element, handle, resizable) {
		 // Setup element data
		this.app = app;
		this.element = element[0];
		this.handle = handle || this.element;
		this.resizable = resizable || false;
		 /**
		 * Duplicate the application's starting position to track differences
		 * @type {Object}
		 */
		this.position = null;
		 /**
		 * Remember event handlers associated with this Draggable class so they may be later unregistered
		 * @type {Object}
		 */
		this.handlers = {};
		 /**
		 * Throttle mousemove event handling to 60fps
		 * @type {number}
		 */
		this._moveTime = 0;
		 // Activate interactivity
		this.activateListeners();
	}
	 /* ----------------------------------------- */
	 /**
	 * Activate event handling for a Draggable application
	 * Attach handlers for floating, dragging, and resizing
	 */
	activateListeners() {
		 // Float to top
		this.handlers["click"] = ["mousedown", ev => this.app.bringToTop(), {capture: true, passive: true}];
		this.element.addEventListener(...this.handlers.click);
		 // Drag handlers
		this.handlers["dragDown"] = ["mousedown", e => this._onDragMouseDown(e), false];
		this.handlers["dragMove"] = ["mousemove", e => this._onDragMouseMove(e), false];
		this.handlers["dragUp"] = ["mouseup", e => this._onDragMouseUp(e), false];
		this.handle.addEventListener(...this.handlers.dragDown);
		this.handle.classList.add("draggable");
		 // Resize handlers
		if ( !this.resizable ) return;
		let handle = $('<div class="window-resizable-handle"><i class="fas fa-arrows-alt-h"></i></div>')[0];
		this.element.appendChild(handle);
		 // Register handlers
		this.handlers["resizeDown"] = ["mousedown", e => this._onResizeMouseDown(e), false];
		this.handlers["resizeMove"] = ["mousemove", e => this._onResizeMouseMove(e), false];
		this.handlers["resizeUp"] = ["mouseup", e => this._onResizeMouseUp(e), false];
		 // Attach the click handler and CSS class
		handle.addEventListener(...this.handlers.resizeDown);
		this.handle.classList.add("resizable");
	}
	 /* ----------------------------------------- */
	 /**
	 * Handle the initial mouse click which activates dragging behavior for the application
	 * @private
	 */
	_onDragMouseDown(event) {
		event.preventDefault();
		 // Record initial position
		this.position = duplicate(this.app.position);
		this._initial = {x: event.clientX, y: event.clientY};
		 // Add temporary handlers
		window.addEventListener(...this.handlers.dragMove);
		window.addEventListener(...this.handlers.dragUp);
	}
	 /* ----------------------------------------- */
	 /**
	 * Move the window with the mouse, bounding the movement to ensure the window stays within bounds of the viewport
	 * @private
	 */
	_onDragMouseMove(event) {
		event.preventDefault();
		 // Limit dragging to 60 updates per second
		const now = Date.now();
		if ( (now - this._moveTime) < (1000/60) ) return;
		this._moveTime = now;
		 // Update application position
		this.app.setPosition({
			left: this.position.left + (event.clientX - this._initial.x),
			top: this.position.top + (event.clientY - this._initial.y)
		});
	}
	 /* ----------------------------------------- */
	 /**
	 * Conclude the dragging behavior when the mouse is release, setting the final position and removing listeners
	 * @private
	 */
	_onDragMouseUp(event) {
		event.preventDefault();
		window.removeEventListener(...this.handlers.dragMove);
		window.removeEventListener(...this.handlers.dragUp);
	}
	 /* ----------------------------------------- */
	 /**
	 * Handle the initial mouse click which activates dragging behavior for the application
	 * @private
	 */
	_onResizeMouseDown(event) {
		event.preventDefault();
		 // Limit dragging to 60 updates per second
		const now = Date.now();
		if ( (now - this._moveTime) < (1000/60) ) return;
		this._moveTime = now;
		 // Record initial position
		this.position = duplicate(this.app.position);
		if ( this.position.height === "auto" ) this.position.height = this.element.clientHeight;
		if ( this.position.width === "auto" ) this.position.width = this.element.clientWidth;
		this._initial = {x: event.clientX, y: event.clientY};
		 // Add temporary handlers
		window.addEventListener(...this.handlers.resizeMove);
		window.addEventListener(...this.handlers.resizeUp);
	}
	 /* ----------------------------------------- */
	 /**
	 * Move the window with the mouse, bounding the movement to ensure the window stays within bounds of the viewport
	 * @private
	 */
	_onResizeMouseMove(event) {
		event.preventDefault();
		this.app.setPosition({
			width: this.position.width + (event.clientX - this._initial.x),
			height: this.position.height + (event.clientY - this._initial.y)
		});
	}
	 /* ----------------------------------------- */
	 /**
	 * Conclude the dragging behavior when the mouse is release, setting the final position and removing listeners
	 * @private
	 */
	_onResizeMouseUp(event) {
		event.preventDefault();
		window.removeEventListener(...this.handlers.resizeMove);
		window.removeEventListener(...this.handlers.resizeUp);
		this.app._onResize(event);
	}
}
/**
 * A controller class for managing drag and drop workflows within an Application instance.
 * The controller manages the following actions: dragstart, dragover, drop
 * @see {@link Application}
 *
 * @param {string} dragSelector     The CSS selector used to target draggable elements.
 * @param {string} dropSelector     The CSS selector used to target viable drop targets.
 * @param {Object<string,Function>} permissions    An object of permission test functions for each action
 * @param {Object<string,Function>} callbacks      An object of callback functions for each action
 *
 * @example
 * const dragDrop = new DragDrop({
 *   dragSelector: ".item",
 *   dropSelector: ".items",
 *   permissions: { dragstart: this._canDragStart.bind(this), drop: this._canDragDrop.bind(this) }
 *   callbacks: { dragstart: this._onDragStart.bind(this), drop: this._onDragDrop.bind(this) }
 * });
 * dragDrop.bind(html);
 */
class DragDrop {
	constructor({dragSelector=null, dropSelector=null, permissions={}, callbacks={}} = {}) {
		 /**
		 * The HTML selector which identifies draggable elements
		 * @type {string}
		 */
		this.dragSelector = dragSelector;
		 /**
		 * The HTML selector which identifies drop targets
		 * @type {string}
		 */
		this.dropSelector = dropSelector;
		 /**
		 * A set of permission checking functions for each action of the Drag and Drop workflow
		 * @type {Object}
		 */
		this.permissions = permissions;
		 /**
		 * A set of callback functions for each action of the Drag and Drop workflow
		 * @type {Object}
		 */
		this.callbacks = callbacks;
	}
	 /* -------------------------------------------- */
	 /**
	 * Bind the DragDrop controller to an HTML application
	 * @param {HTMLElement} html    The HTML element to which the handler is bound
	 */
	bind(html) {
		 // Identify and activate draggable targets
		if ( this.can("dragstart", this.dragSelector) ) {
			const draggables = html.querySelectorAll(this.dragSelector);
			for (let el of draggables) {
				el.setAttribute("draggable", true);
				el.ondragstart = this._handleDragStart.bind(this);
			}
		}
		 // Identify and activate drop targets
		if ( this.can("dragdrop", this.dropSelector) ) {
			const droppables = this.dropSelector ? html.querySelectorAll(this.dropSelector) : [html];
			for ( let el of droppables ) {
				el.ondragover = this._handleDragOver.bind(this);
				el.ondrop = this._handleDrop.bind(this);
			}
		}
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Execute a callback function associated with a certain action in the workflow
	 * @param {DragEvent} event   The drag event being handled
	 * @param {string} action     The action being attempted
	 */
	callback(event, action) {
		const fn = this.callbacks[action];
		if ( fn instanceof Function ) return fn(event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether the current user has permission to perform a step of the workflow
	 * @param {string} action     The action being attempted
	 * @param {string} selector   The selector being targeted
	 * @return {boolean}          Can the action be performed?
	 */
	can(action, selector) {
		const fn = this.permissions[action];
		if ( fn instanceof Function ) return fn(selector);
		return true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the start of a drag workflow
	 * @param {DragEvent} event   The drag event being handled
	 * @private
	 */
	_handleDragStart(event) {
		this.callback(event, "dragstart");
		if ( event.dataTransfer.items.length ) event.stopPropagation();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a dragged element over a droppable target
	 * @param {DragEvent} event   The drag event being handled
	 * @private
	 */
	_handleDragOver(event) {
		event.preventDefault();
		this.callback(event, "dragover");
		return false;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a dragged element dropped on a droppable target
	 * @param {DragEvent} event   The drag event being handled
	 * @private
	 */
	_handleDrop(event) {
		event.preventDefault();
		return this.callback(event, "drop");
	}
	 /* -------------------------------------------- */
	 static createDragImage(img, width, height) {
		let div = document.getElementById("drag-preview");
		 // Create the drag preview div
		if ( !div ) {
			div = document.createElement("div");
			div.setAttribute("id", "drag-preview");
			const img = document.createElement("img");
			img.classList.add("noborder");
			div.appendChild(img);
			document.body.appendChild(div);
		}
		 // Add the preview image
		const i = div.children[0];
		i.src = img.src;
		i.width = width;
		i.height = height;
		return div;
	}
}
/**
 * A collection of helper functions and utility methods related to the rich text editor
 */
class TextEditor {
	 /**
	 * Create a Rich Text Editor. The current implementation uses TinyMCE
	 * @param {Object} options          Configuration options provided to the Editor init
	 * @param {string} content          Initial HTML or text content to populate the editor with
	 * @return {tinyMCE.Editor}         The editor instance.
	 */
	static async create(options={}, content="") {
		const mceConfig = mergeObject(CONFIG.TinyMCE, options, {inplace: false});
		mceConfig.target = options.target;
		if ( mceConfig.content_css instanceof Array ) {
			mceConfig.content_css = mceConfig.content_css.map(c => getRoute(c)).join(",");
		}
		mceConfig.init_instance_callback = editor => {
			const window = editor.getWin();
			if ( content ) editor.setContent(content);
			window.addEventListener("wheel", event => {
				if ( event.ctrlKey ) event.preventDefault();
			}, {passive: false});
			window.addEventListener("drop", ev => this._onDropEditorData(ev, editor))
		};
		const editors = await tinyMCE.init(mceConfig);
		return editors[0];
	}
	 /* -------------------------------------------- */
	/*  HTML Manipulation Helpers
	/* -------------------------------------------- */
	 /**
	 * Safely decode an HTML string, removing invalid tags and converting entities back to unicode characters.
	 * @param {string} html     The original encoded HTML string
	 * @return {string}         The decoded unicode string
	 */
	static decodeHTML(html) {
		const txt = this._decoder;
		txt.innerHTML = html;
		return txt.value;
	}
	 /* -------------------------------------------- */
	 /**
	 * Enrich HTML content by replacing or augmenting components of it
	 * @param {string} content        The original HTML content (as a string)
	 * @param {boolean} secrets       Include secret tags in the final HTML? If false secret blocks will be removed.
	 * @param {boolean} entities      Replace dynamic entity links?
	 * @param {boolean} links         Replace hyperlink content?
	 * @param {boolean} rolls         Replace inline dice rolls?
	 * @param {Object} rollData       The data object providing context for inline rolls
	 * @return {string}               The enriched HTML content
	 */
	static enrichHTML(content, {secrets=false, entities=true, links=true, rolls=true, rollData=null}={}) {
		 // Create the HTML element
		const html = document.createElement("div");
		html.innerHTML = String(content);
		 // Remove secret blocks
		if ( !secrets ) {
			let elements = html.querySelectorAll("section.secret");
			elements.forEach(e => e.parentNode.removeChild(e));
		}
		 // Plan text content replacements
		let updateTextArray = true;
		let text = [];
		 // Replace entity links
		if ( entities ) {
			if ( updateTextArray ) text = this._getTextNodes(html);
			const entityTypes = CONST.ENTITY_LINK_TYPES.concat("Compendium");
			const rgx = new RegExp(`@(${entityTypes.join("|")})\\[([^\\]]+)\\](?:{([^}]+)})?`, 'g');
			updateTextArray = this._replaceTextContent(text, rgx, this._createEntityLink);
		}
		 // Replace hyperlinks
		if ( links ) {
			if ( updateTextArray ) text = this._getTextNodes(html);
			const rgx = /(https?:\/\/)(www\.)?([^\s<]+)/gi;
			updateTextArray = this._replaceTextContent(text, rgx, this._createHyperlink);
		}
		 // Replace inline rolls
		if ( rolls ) {
			if (updateTextArray) text = this._getTextNodes(html);
			const rgx = /\[\[(\/[a-zA-Z]+\s)?(.*?)([\]]{2,3})/gi;
			updateTextArray = this._replaceTextContent(text, rgx, (...args) => this._createInlineRoll(...args, rollData));
		}
		 // Return the enriched HTML
		return html.innerHTML;
	};
	 /* -------------------------------------------- */
	 /**
	 * Preview an HTML fragment by constructing a substring of a given length from its inner text.
	 * @param {string} content    The raw HTML to preview
	 * @param {number} length     The desired length
	 * @return {string}           The previewed HTML
	 */
	static previewHTML(content, length=250) {
		const div = document.createElement("div");
		div.innerHTML = content;
		div.innerText = this.truncateText(div.innerText, {maxLength: length});
		return div.innerHTML;
	}
	 /* -------------------------------------------- */
	 /**
	 * Truncate a fragment of text to a maximum number of characters.
	 * @param {string} text           The original text fragment that should be truncated to a maximum length
	 * @param {number} [maxLength]    The maximum allowed length of the truncated string.
	 * @param {boolean} [splitWords]  Whether to truncate by splitting on white space (if true) or breaking words.
	 * @param {string|null} [suffix]  A suffix string to append to denote that the text was truncated.
	 * @return {*}
	 */
	static truncateText(text, {maxLength=50, splitWords=true, suffix="…"}={}) {
		if ( text.length <= maxLength ) return text;
		 // Split the string (on words if desired)
		let short = "";
		if ( splitWords ) {
			short = text.slice(0, maxLength + 10);
			while ( short.length > maxLength ) {
				if ( /\s/.test(short) ) short = short.replace(/[\s]+([\S]+)?$/, "");
				else short = short.slice(0, maxLength);
			}
		} else {
			short = text.slice(0, maxLength);
		}
		 // Add a suffix and return
		suffix = suffix ?? "";
		return short + suffix;
	}
	 /* -------------------------------------------- */
	/*  Text Node Manipulation
	/* -------------------------------------------- */
	 /**
	 * Recursively identify the text nodes within a parent HTML node for potential content replacement.
	 * @param {HTMLElement} parent    The parent HTML Element
	 * @return {Text[]}               An array of contained Text nodes
	 * @private
	 */
	static _getTextNodes(parent) {
		const text = [];
		const walk = document.createTreeWalker(parent, NodeFilter.SHOW_TEXT, null, false);
		while( walk.nextNode() ) text.push(walk.currentNode);
		return text;
	}
	 /* -------------------------------------------- */
	 /**
	 * Facilitate the replacement of text node content using a matching regex rule and a provided replacement function.
	 * @private
	 */
	static _replaceTextContent(text, rgx, func) {
		let replaced = false;
		for ( let t of text ) {
			const matches = t.textContent.matchAll(rgx);
			for ( let match of Array.from(matches).reverse() ) {
				const replacement = func(...match);
				if ( replacement ) {
					this._replaceTextNode(t, match, replacement);
					replaced = true;
				}
			}
		}
		return replaced;
	}
	 /* -------------------------------------------- */
	 /**
	 * Replace a matched portion of a Text node with a replacement Node
	 * @param {Text} text
	 * @param {RegExpMatchArray} match
	 * @param {Node} replacement
	 * @private
	 */
	static _replaceTextNode(text, match, replacement) {
		let target = text;
		if ( match.index > 0 ) {
			target = text.splitText(match.index);
		}
		if ( match[0].length < target.length ) {
			target.splitText(match[0].length);
		}
		target.replaceWith(replacement);
	}
	 /* -------------------------------------------- */
	/*  Text Replacement Functions
	/* -------------------------------------------- */
	 /**
	 * Create a dynamic entity link from a regular expression match
	 * @param {string} match          The full matched string
	 * @param {string} type           The matched entity type or "Compendium"
	 * @param {string} target         The requested match target (_id or name)
	 * @param {string} name           A customized or over-ridden display name for the link
	 * @return {HTMLAnchorElement}    An HTML element for the entity link
	 * @private
	 */
	static _createEntityLink(match, type, target, name) {
		 // Prepare replacement data
		const data = {
			cls: ["entity-link"],
			icon: null,
			dataset: {},
			name: name
		};
		let broken = false;
		 // Get a matched World entity
		if (CONST.ENTITY_TYPES.includes(type)) {
			const config = CONFIG[type];
			 // Get the linked Entity
			const collection = config.entityClass.collection;
			const entity = /^[a-zA-Z0-9]{16}$/.test(target) ? collection.get(target) : collection.getName(target);
			if (!entity) broken = true;
			 // Update link data
			data.name = data.name || (broken ? target : entity.name);
			data.icon = config.sidebarIcon;
			data.dataset = {entity: type, id: broken ? null : entity.id};
		}
		 // Get a matched Compendium entity
		else if (type === "Compendium") {
			 // Get the linked Entity
			let [scope, packName, id] = target.split(".");
			const pack = game.packs.get(`${scope}.${packName}`);
			if ( pack ) {
				if (pack.index.length) {
					const entry = pack.index.find(i => (i._id === id) || (i.name === id));
					if (!entry) broken = true;
					else id = entry._id;
					data.name = data?.name || entry?.name || id;
				}
				 // Update link data
				const config = CONFIG[pack.metadata.entity];
				data.icon = config.sidebarIcon;
				data.dataset = {pack: pack.collection, id: id};
			}
			else broken = true;
		}
		 // Flag a link as broken
		if (broken) {
			data.icon = "fas fa-unlink";
			data.cls.push("broken");
		}
		 // Construct the formed link
		const a = document.createElement('a');
		a.classList.add(...data.cls);
		a.draggable = true;
		for (let [k, v] of Object.entries(data.dataset)) {
			a.dataset[k] = v;
		}
		a.innerHTML = `<i class="${data.icon}"></i> ${data.name}`;
		return a;
	}
	 /* -------------------------------------------- */
	 /**
	 * Replace a hyperlink-like string with an actual HTML <a> tag
	 * @param {string} match          The full matched string
	 * @return {HTMLAnchorElement}    An HTML element for the entity link
	 * @private
	 */
	static _createHyperlink(match) {
		const a = document.createElement('a');
		a.classList.add("hyperlink");
		a.href = match;
		a.target = "_blank";
		a.rel = "nofollow noopener";
		a.textContent = match;
		return a;
	}
	 /* -------------------------------------------- */
	 /**
	 * Replace an inline roll formula with a rollable <a> element or an eagerly evaluated roll result
	 * @param {string} match      The matched string
	 * @param {string} command    An optional command
	 * @param {string} formula    The matched formula
	 * @param {string} closing    The closing brackets for the inline roll
	 * @return {string}           The replaced match
	 */
	static _createInlineRoll(match, command, formula, closing, ...args) {
		const isDeferred = !!command;
		const rollData = args.pop();
		let roll;
		 // Define default inline data
		const data = {
			cls: ["inline-roll"],
			dataset: {}
		};
		 // Handle the possibility of closing brackets
		if ( closing.length === 3 ) formula += "]";
		 // Extract roll data as a parsed chat command
		if ( isDeferred ) {
			const chatCommand = `${command}${formula}`;
			let parsedCommand = null;
			try {
				parsedCommand = ChatLog.parse(chatCommand);
			}
			catch(err) { return null; }
			const flavor = parsedCommand[1][3];
			 // Set roll data
			data.cls.push(parsedCommand[0]);
			data.dataset.mode = parsedCommand[0];
			data.dataset.flavor = flavor ? flavor.trim() : "";
			data.dataset.formula = parsedCommand[1][2].trim();
			data.result = parsedCommand[1][2].trim();
			data.title = data.dataset.flavor || data.dataset.formula;
		}
		 // Perform the roll immediately
		else {
			try {
				roll = Roll.create(formula, rollData).roll();
				data.cls.push("inline-result");
				data.result = roll.total;
				data.title = formula;
				data.dataset.roll = escape(JSON.stringify(roll));
			}
			catch(err) { return null; }
		}
		 // Construct and return the formed link element
		const a = document.createElement('a');
		a.classList.add(...data.cls);
		a.title = data.title;
		for (let [k, v] of Object.entries(data.dataset)) {
			a.dataset[k] = v;
		}
		a.innerHTML = `<i class="fas fa-dice-d20"></i> ${data.result}`;
		return a;
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 static activateListeners() {
		const body = $("body");
		body.on("click", "a.entity-link", this._onClickEntityLink);
		body.on('dragstart', "a.entity-link", this._onDragEntityLink);
		body.on("click", "a.inline-roll", this._onClickInlineRoll);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle click events on Entity Links
	 * @param {Event} event
	 * @private
	 */
	static async _onClickEntityLink(event) {
		event.preventDefault();
		const  a = event.currentTarget;
		let entity = null;
		 // Target 1 - Compendium Link
		if ( a.dataset.pack ) {
			const pack = game.packs.get(a.dataset.pack);
			let id = a.dataset.id;
			if ( a.dataset.lookup ) {
				if ( !pack.index.length ) await pack.getIndex();
				const entry = pack.index.find(i => (i._id === a.dataset.lookup) || (i.name === a.dataset.lookup));
				id = entry._id;
			}
			entity = id ? await pack.getEntity(id) : null;
		}
		 // Target 2 - World Entity Link
		else {
			const cls = CONFIG[a.dataset.entity].entityClass;
			entity = cls.collection.get(a.dataset.id);
			if ( entity.entity === "Scene" && entity.journal ) entity = entity.journal;
			if ( !entity.hasPerm(game.user, "LIMITED") ) {
				return ui.notifications.warn(`You do not have permission to view this ${entity.entity} sheet.`);
			}
		}
		if ( !entity ) return;
		 // Action 1 - Execute an Action
		if ( entity.entity === "Macro" ) {
			if ( !entity.hasPerm(game.user, "LIMITED") ) {
				return ui.notifications.warn(`You do not have permission to use this ${entity.entity}.`);
			}
			return entity.execute();
		}
		 // Action 2 - Render the Entity sheet
		return entity.sheet.render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle left-mouse clicks on an inline roll, dispatching the formula or displaying the tooltip
	 * @param {MouseEvent} event    The initiating click event
	 * @private
	 */
	static async _onClickInlineRoll(event) {
		event.preventDefault();
		const a = event.currentTarget;
		 // For inline results expand or collapse the roll details
		if ( a.classList.contains("inline-result") ) {
			if ( a.classList.contains("expanded") ) {
				return Roll._collapseInlineResult(a);
			} else {
				return Roll._expandInlineResult(a);
			}
		}
		 // Get the current speaker
		const msg = CONFIG.ChatMessage.entityClass;
		const speaker = msg.getSpeaker();
		let actor = msg.getSpeakerActor(speaker);
		let rollData = actor ? actor.getRollData() : {};
		 // Obtain roll data from the contained sheet, if the inline roll is within an Actor or Item sheet
		const sheet = a.closest(".sheet");
		if ( sheet ) {
			const app = ui.windows[sheet.dataset.appid];
			if ( ["Actor", "Item"].includes(app?.object?.entity) ) rollData = app.object.getRollData();
		}
		 // Execute a deferred roll
		const roll = Roll.create(a.dataset.formula, rollData).roll();
		return roll.toMessage({flavor: a.dataset.flavor, speaker}, {rollMode: a.dataset.mode});
	}
	 /* -------------------------------------------- */
	 /**
	 * Begin a Drag+Drop workflow for a dynamic content link
	 * @param {Event} event   The originating drag event
	 * @private
	 */
	static _onDragEntityLink(event) {
		event.stopPropagation();
		const a = event.currentTarget;
		let dragData = null;
		 // Case 1 - Compendium Link
		if ( a.dataset.pack ) {
			const pack = game.packs.get(a.dataset.pack);
			let id = a.dataset.id;
			if ( a.dataset.lookup && pack.index.length ) {
				const entry = pack.index.find(i => (i._id === a.dataset.lookup) || (i.name === a.dataset.lookup));
				if ( entry ) id = entry._id;
			}
			if ( !id ) return false;
			dragData = { type: pack.entity, pack: pack.collection, id: id };
		}
		 // Case 2 - World Entity Link
		else dragData = { type: a.dataset.entity, id: a.dataset.id };
		event.originalEvent.dataTransfer.setData("text/plain", JSON.stringify(dragData));
	}
	/* -------------------------------------------- */
	 /**
	 * Begin a a data transfer drag event with default handling
	 * @private
	 */
	_onDragStart(event) {
	 event.stopPropagation();
	 let li = event.currentTarget.closest("li.directory-item");
		const dragData = li.classList.contains("folder") ?
			{ type: "Folder", id: li.dataset.folderId, entity: this.constructor.entity } :
			{ type: this.constructor.entity, id: li.dataset.entityId };
		event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
		this._dragType = dragData.type;
	}
	/* -------------------------------------------- */
	 /**
	 * Handle dropping of transferred data onto the active rich text editor
	 * @param {Event} event     The originating drop event which triggered the data transfer
	 * @param {tinyMCE} editor  The TinyMCE editor instance being dropped on
	 * @private
	 */
	static async _onDropEditorData(event, editor) {
		event.preventDefault();
	 const data = JSON.parse(event.dataTransfer.getData('text/plain'));
	 if ( !data ) return;
		// Case 1 - Entity from Compendium Pack
		if ( data.pack ) {
			const pack = game.packs.get(data.pack);
			if (!pack) return;
			const entity = await pack.getEntity(data.id);
			const link = `@Compendium[${data.pack}.${data.id}]{${entity.name}}`;
			editor.insertContent(link);
		}
		 // Case 2 - Entity from World
		else {
			const config = CONFIG[data.type];
			if ( !config ) return false;
			const entity = config.collection.instance.get(data.id);
			if ( !entity ) return false;
			const link = `@${data.type}[${entity._id}]{${entity.name}}`;
			editor.insertContent(link);
		}
	}
}

// Singleton decoder area
TextEditor._decoder = document.createElement('textarea');

// Global Export
window.TextEditor = TextEditor;

/**
 * The FilePicker application renders contents of the server-side public directory
 * This app allows for navigating and uploading files to the public path
 * @type {Application}
 */
class FilePicker extends Application {
	constructor(options={}) {
		super(options);
		 /**
		 * The full requested path given by the user
		 * @type {string}
		 */
		this.request = options.current;
		 /**
		 * The file sources which are available for browsing
		 * @type {Object}
		 */
		this.sources = Object.entries({
			data: {
				target: "",
				label: game.i18n.localize("FILES.SourceUser"),
				icon: "fas fa-database"
			},
			public: {
				target: "",
				label: game.i18n.localize("FILES.SourceCore"),
				icon: "fas fa-server"
			},
			s3: {
				buckets: [],
				bucket: "",
				target: "",
				label: game.i18n.localize("FILES.SourceS3"),
				icon: "fas fa-cloud"
			}
		}).reduce((obj, s) => {
			if ( game.data.files.storages.includes(s[0]) ) obj[s[0]] = s[1];
			return obj;
		}, {});
		 /**
		 * Track the active source tab which is being browsed
		 * @type {string}
		 */
		this.activeSource = options.activeSource || "data";
		 /**
		 * The latest set of results browsed from the server
		 * @type {Object}
		 */
		this.results = {};
		 /**
		 * The general file type which controls the set of extensions which will be accepted
		 * @type {string}
		 */
		this.type = options.type;
		 /**
		 * The target HTML element this file picker is bound to
		 * @type {HTMLElement}
		 */
		this.field = options.field;
		 /**
		 * A button which controls the display of the picker UI
		 * @type {HTMLElement}
		 */
		this.button = options.button;
		 /**
		 * The display mode of the FilePicker UI
		 * @type {string}
		 */
		this.displayMode = options.displayMode || FilePicker.LAST_DISPLAY_MODE;
		 /**
		 * The current set of file extensions which are being filtered upon
		 * @type {string[]}
		 */
		this.extensions = this._getExtensions(this.type);
		 // Infer the source
		const [source, target] = this._inferCurrentDirectory(this.request);
		this.activeSource = source;
		this.sources[source].target = target;
		 // Track whether we have loaded files
		this._loaded = false;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
				template: "templates/apps/filepicker.html",
				classes: ["filepicker"],
				width: 520,
				tabs: [{navSelector: ".tabs"}],
				dragDrop: [{dragSelector: ".file", dropSelector: ".filepicker-body"}],
				tileSize: false,
				filters: [{inputSelector: 'input[name="filter"]', contentSelector: ".filepicker-body"}]
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Given a current file path, determine the directory it belongs to
	 * @param {string} target   The currently requested target path
	 * @return {string[]}       An array of the inferred source and target directory path
	 */
	_inferCurrentDirectory(target) {
		 // Determine target
		const ignored = [CONST.DEFAULT_TOKEN];
		if ( !target || ignored.includes(target) ) target = this.constructor.LAST_BROWSED_DIRECTORY;
		let source = "data";
		 // Check for s3 matches
		const s3Match = this.constructor.matchS3URL(target);
		if ( s3Match ) {
			this.sources.s3.bucket = s3Match.groups.bucket;
			source = "s3";
			target = s3Match.groups.key;
		}
		 // Non-s3 URL matches
		else if ( ["http://", "https://"].some(c => target.startsWith(c)) ) {
			target = "";
		}
		 // Local file matches
		else {
			const publicDirs = ["css", "fonts", "icons", "lang", "scripts", "sounds", "ui"];
			if (publicDirs.some(d => target.startsWith(d))) source = "public";
		}
		 // Split off the file name and retrieve just the directory path
		const dir = target.split("/").slice(0, -1).join("/");
		return [source, dir];
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the valid file extensions for a given named file picker type
	 * @param {string} type
	 * @return {string[]}
	 * @private
	 */
	_getExtensions(type) {
		 // Identify allowed extensions
		let types = [];
		if ( type === "image" ) types = CONST.IMAGE_FILE_EXTENSIONS;
		else if ( type === "audio" ) types = CONST.AUDIO_FILE_EXTENSIONS;
		else if ( type === "video" ) types = CONST.VIDEO_FILE_EXTENSIONS;
		else if ( type === "imagevideo") types = CONST.IMAGE_FILE_EXTENSIONS.concat(CONST.VIDEO_FILE_EXTENSIONS);
		if ( types.length === 0 ) return undefined;
		 // Return the allowed types
		else return types.reduce((arr, t) => {
			arr.push(`.${t}`);
			arr.push(`.${t.toUpperCase()}`);
			return arr;
		}, []);
	}
	 /* -------------------------------------------- */
	 /**
	 * Test a URL to see if it matches a well known s3 key pattern
	 * @param {string} url          An input URL to test
	 * @return {RegExpMatchArray|null}   A regular expression match
	 */
	static matchS3URL(url) {
		const endpoint = game.data.files.s3?.endpoint;
		if ( !endpoint ) return null;
		 // Match new style S3 urls
		const s3New = new RegExp(`^${endpoint.protocol}//(?<bucket>.*).${endpoint.host}/(?<key>.*)`);
		const matchNew = url.match(s3New);
		if ( matchNew ) return matchNew;
		 // Match old style S3 urls
		const s3Old = new RegExp(`^${endpoint.protocol}//${endpoint.host}/(?<bucket>[^/]+)/(?<key>.*)`);
		return url.match(s3Old);
	}
	 /* -------------------------------------------- */
	 /**
	 * Parse a s3 key to learn the bucket and the key prefix used for the request
	 * @param {string} key    A fully qualified key name or prefix path
	 * @return {{bucket: string, keyPrefix: string}}
	 * @private
	 */
	static parseS3URL(key) {
		try {
			const url = new URL(key);
			return {
				bucket: url.host.split(".").shift(),
				keyPrefix: url.pathname.slice(1)
			};
		} catch(err) {
			return {
				bucket: null,
				keyPrefix: ""
			}
		}
	}
	 /* -------------------------------------------- */
	/*  FilePicker Properties                       */
	/* -------------------------------------------- */
	 /** @override */
	get title() {
		let type = this.type || "file";
		return game.i18n.localize(type === "imagevideo" ? "FILES.TitleImageVideo" : `FILES.Title${type.capitalize()}`);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the source object for the currently active source
	 * @return {Object}
	 */
	get source() {
		return this.sources[this.activeSource];
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the target directory for the currently active source
	 * @return {string}
	 */
	get target() {
		return this.source.target;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a flag for whether the current user is able to upload file content
	 * @return {boolean}
	 */
	get canUpload() {
		if ( !["data", "s3"].includes(this.activeSource) ) return false;
		return game.isAdmin || (game.user && game.user.can("FILES_UPLOAD"));
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the upload URL to which the FilePicker should post uploaded files
	 * @return {string}
	 */
	static get uploadURL() {
		return getRoute("upload");
	}
	 /* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */
	 /** @override */
	async getData(options) {
		const result = this.result;
		const source = this.source;
		let target = decodeURIComponent(source.target);
		const isS3 = this.activeSource === "s3";
		 // Sort directories alphabetically and store their paths
		let dirs = result.dirs.map(d => { return {
			name: decodeURIComponent(d.split("/").pop()),
			path: d,
			private: result.private || result.privateDirs.includes(d)
		}});
		dirs = dirs.sort((a, b) => a.name.localeCompare(b.name));
		 // Sort files alphabetically and store their client URLs
		let files = result.files.map(f => {
			let img = f;
			if ( VideoHelper.hasVideoExtension(f) ) img = "icons/svg/video.svg";
			else if ( AudioHelper.hasAudioExtension(f) ) img = "icons/svg/sound.svg";
			return {
				name: decodeURIComponent(f.split("/").pop()),
				url: f,
				img: img
			}
		});
		files = files.sort((a, b) => a.name.localeCompare(b.name));
		 // Return rendering data
		return {
			bucket: isS3 ? source.bucket : null,
			canGoBack: this.activeSource !== "",
			canUpload: this.canUpload,
			canSelect: !this.options.tileSize,
			cssClass: [this.displayMode, result.private ? "private": "public"].join(" "),
			dirs: dirs,
			displayMode: this.displayMode,
			extensions: this.extensions,
			files: files,
			isS3: isS3,
			noResults: dirs.length + files.length === 0,
			request: this.request,
			source: source,
			sources: this.sources,
			target: target,
			tileSize: this.options.tileSize ? (FilePicker.LAST_TILE_SIZE || canvas.dimensions.size) : null,
			user: game.user
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Browse to a specific location for this FilePicker instance
	 * @param {string} [target]   The target within the currently active source location.
	 * @param {Object} [options]  Browsing options
	 */
	async browse(target, options={}) {
		 // If the user does not have permission to browse, do not proceed
		if ( game.world && !game.user.can("FILES_BROWSE") ) return;
		 // Configure browsing parameters
		target = typeof target === "string" ? target : this.target;
		const source = this.activeSource;
		options = mergeObject({
			extensions: this.extensions,
			wildcard: false
		}, options);
		 // Determine the S3 buckets which may be used
		if ( source === "s3" ) {
			if ( this.constructor.S3_BUCKETS === null ) {
				const buckets = await this.constructor.browse("s3", "");
				this.constructor.S3_BUCKETS = buckets.dirs;
			}
			this.sources.s3.buckets = this.constructor.S3_BUCKETS;
			if ( !this.source.bucket ) this.source.bucket = this.constructor.S3_BUCKETS[0];
			options.bucket = this.source.bucket;
		}
		 // Avoid browsing certain paths
		if ( target.startsWith("/") ) target = target.slice(1);
		if ( target === CONST.DEFAULT_TOKEN ) target = this.constructor.LAST_BROWSED_DIRECTORY;
		 // Request files from the server
		const result = await this.constructor.browse(source, target, options).catch(error => {
			ui.notifications.warn(error);
			return this.constructor.browse(source, "", options);
		});
		 // Populate browser content
		this.result = result;
		this.source.target = result.target;
		if ( source === "s3" ) this.source.bucket = result.bucket;
		this.constructor.LAST_BROWSED_DIRECTORY = result.target;
		this._loaded = true;
		 // Render the application
		this.render(true);
		return result;
	}
	 /* -------------------------------------------- */
	 /**
	 * Browse files for a certain directory location
	 * @param {string} source     The source location in which to browse. See FilePicker#sources for details
	 * @param {string} target     The target within the source location
	 * @param {Object} options              Optional arguments
	 * @param {string} options.bucket       A bucket within which to search if using the S3 source
	 * @param {string[]} options.extensions An Array of file extensions to filter on
	 * @param {boolean} options.wildcard    The requested dir represents a wildcard path
	 *
	 * @return {Promise}          A Promise which resolves to the directories and files contained in the location
	 */
	static async browse(source, target, options={}) {
		const data = {action: "browseFiles", storage: source, target: target};
		return this._manageFiles(data, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Configure metadata settings regarding a certain file system path
	 * @param {string} source     The source location in which to browse. See FilePicker#sources for details
	 * @param {string} target     The target within the source location
	 * @param {Object} options    Optional arguments which modify the request
	 * @return {Promise<Object>}
	 */
	static async configurePath(source, target, options={}) {
		const data = {action: "configurePath", storage: source, target: target};
		return this._manageFiles(data, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a subdirectory within a given source. The requested subdirectory path must not already exist.
	 * @param {string} source     The source location in which to browse. See FilePicker#sources for details
	 * @param {string} target     The target within the source location
	 * @param {Object} options    Optional arguments which modify the request
	 * @return {Promise<Object>}
	 */
	static async createDirectory(source, target, options={}) {
		const data = {action: "createDirectory", storage: source, target: target};
		return this._manageFiles(data, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * General dispatcher method to submit file management commands to the server
	 * @returns {Promise<object>}
	 * @private
	 */
	static async _manageFiles(data, options) {
		return new Promise((resolve, reject) => {
			game.socket.emit("manageFiles", data, options, result => {
				if (result.error) return reject(result.error);
				resolve(result);
			});
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Dispatch a POST request to the server containing a directory path and a file to upload
	 * @param {string} source   The data source to which the file should be uploaded
	 * @param {string} path     The destination path
	 * @param {File} file       The File object to upload
	 * @param {object} [options={}]  Additional file upload options passed as form data
	 * @return {Promise<Object>}  The response object
	 */
	static async upload(source, path, file, options={}) {
		 // Create the form data to post
		const fd = new FormData();
		fd.set("source", source);
		fd.set("target", path);
		fd.set("upload", file);
		Object.entries(options).forEach(o => fd.set(...o));
		 // Dispatch the request
		const request = await fetch(this.uploadURL, {method: "POST", body: fd});
		if ( request.status === 413 ) {
			return ui.notifications.error(game.i18n.localize("FILES.ErrorTooLarge"));
		}
		 // Attempt to obtain the response
		const response = await request.json().catch(err => { return {} });
		if (response.error) {
			ui.notifications.error(response.error);
			return false;
		}
		else if ( !response.path ) {
			return ui.notifications.error(game.i18n.localize("FILES.ErrorSomethingWrong"));
		}
		 // Display additional response messages
		if (response.message) {
			if ( /^(modules|systems)/.test(response.path) ) {
				ui.notifications.warn(game.i18n.localize("FILES.WarnUploadModules"))
			}
			ui.notifications.info(response.message);
		}
		return response;
	}
	 /* -------------------------------------------- */
	 /**
	 * Additional actions performed when the file-picker UI is rendered
	 */
	render(force, options) {
		if ( game.world && !game.user.can("FILES_BROWSE") ) return;
		this.position.height = null;
		this.element.css({height: ""});
		if ( !this._loaded ) return this.browse();
		else super.render(force, options);
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /**
	 * Activate listeners to handle user interactivity for the FilePicker UI
	 * @param html
	 */
	activateListeners(html) {
		this._tabs[0].active = this.activeSource;
	 super.activateListeners(html);
	 const header = html.find("header.filepicker-header");
	 const form = html[0];
		 // Change the directory
		const target = header.find('input[name="target"]');
		target.on("keydown", this._onRequestTarget.bind(this));
		target[0].focus();
		 // Header Control Buttons
		html.find(".current-dir button").click(this._onClickDirectoryControl.bind(this));
		 // Change the S3 bucket
		html.find('select[name="bucket"]').change(this._onChangeBucket.bind(this));
		 // Activate display mode controls
		const modes = html.find(".display-modes");
		modes.on("click", ".display-mode", this._onChangeDisplayMode.bind(this));
		for ( let li of modes[0].children ) {
			li.classList.toggle("active", li.dataset.mode === this.displayMode);
		}
		 // Upload new file
		if ( this.canUpload ) form.upload.onchange = ev => this._onUpload(ev);
		 // Directory-level actions
		html.find(".directory").on("click", "li", this._onPick.bind(this));
		// Flag the current pick
	 let li = form.querySelector(`.file[data-path="${this.request}"]`);
	 if ( li ) li.classList.add("picked");
		// Form submission
		form.onsubmit = ev => this._onSubmit(ev);
		 // Intersection Observer to lazy-load images
		const files = html.find(".files-list");
		const observer = new IntersectionObserver(this._onLazyLoadImages.bind(this), {root: files[0]});
		files.find("li.file").each((i, li) => observer.observe(li));
	}
	/* -------------------------------------------- */
	 /**
	 * Handle a click event to change the display mode of the File Picker
	 * @param {MouseEvent} event    The triggering click event
	 * @private
	 */
	_onChangeDisplayMode(event) {
		event.preventDefault();
		const a = event.currentTarget;
		if ( !FilePicker.DISPLAY_MODES.includes(a.dataset.mode) ) {
			throw new Error("Invalid display mode requested");
		}
		if ( a.dataset.mode === this.displayMode ) return;
		FilePicker.LAST_DISPLAY_MODE = this.displayMode = a.dataset.mode;
		this.render();
	}
	/* -------------------------------------------- */
	 /** @override */
	_onChangeTab(event, tabs, active) {
		this.activeSource = active;
		this.browse(this.source.target);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_canDragStart(selector) {
		return (game.user && game.user.isGM) && (canvas && canvas.tiles._active);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_canDragDrop(selector) {
		return this.canUpload;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragStart(event) {
		const li = event.currentTarget;
		 // Get the tile size ratio
		const tileSize = parseInt(li.closest("form").tileSize.value) || canvas.dimensions.size;
		FilePicker.LAST_TILE_SIZE = tileSize;
		const ratio = canvas.dimensions.size / tileSize;
		 // Set drag data
		const dragData = {
			type: "Tile",
			img: li.dataset.path,
			tileSize: tileSize
		};
		event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
		 // Create the drag preview for the image
		const img = li.querySelector("img");
		const w = img.naturalWidth * ratio * canvas.stage.scale.x;
		const h = img.naturalHeight * ratio * canvas.stage.scale.y;
		const preview = DragDrop.createDragImage(img, w, h);
		event.dataTransfer.setDragImage(preview, w/2, h/2);
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _onDrop(event) {
		if ( this.activeSource === "public" ) return;
		const form = event.currentTarget.closest("form");
		form.disabled = true;
		const target = form.target.value;
		 // Process the data transfer
		const data = event.dataTransfer;
		const files = data.files;
		if ( !files || !files.length ) return;
		 // Iterate over dropped files
		for ( let upload of files ) {
			if ( !this.extensions.some(ext => upload.name.endsWith(ext)) ) {
				ui.notifications.error(`Incorrect ${this.type} file extension. Supports ${this.extensions.join(" ")}.`);
				continue;
			}
			const response = await this.constructor.upload(this.activeSource, target, upload, {
				bucket: form.bucket ? form.bucket.value : null
			});
			if ( response ) this.request = response.path;
		}
		 // Re-enable the form
		form.disabled = false;
		return this.browse(target);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle user submission of the address bar to request an explicit target
	 * @param {KeyboardEvent} event     The originating keydown event
	 * @private
	 */
	_onRequestTarget(event) {
		if ( event.key === "Enter" ) {
			event.preventDefault();
			this.browse(event.target.value);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle requests from the IntersectionObserver to lazily load an image file
	 * @private
	 */
	_onLazyLoadImages(...args) {
		return SidebarTab.prototype._onLazyLoadImage.call(this, ...args);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle file or folder selection within the file picker
	 * @param {Event} event     The originating click event
	 * @private
	 */
	_onPick(event) {
		const li = event.currentTarget;
		const form = li.closest("form");
		if ( li.classList.contains("dir") ) return this.browse(li.dataset.path);
		for ( let l of li.parentElement.children ) {
			l.classList.toggle("picked", l === li);
		}
		if ( form.file ) form.file.value = li.dataset.path;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle backwards navigation of the fol6der structure
	 * @private
	 */
	_onClickDirectoryControl(event) {
		event.preventDefault();
		const button = event.currentTarget;
		const action = button.dataset.action;
		switch(action) {
			case "back":
				let target = this.target.split("/");
				target.pop();
				return this.browse(target.join("/"));
			case "mkdir":
				return this._createDirectoryDialog(this.source);
			case "toggle-privacy":
				let isPrivate = !this.result.private;
				const data = {private: isPrivate, bucket: this.result.bucket};
				return this.constructor.configurePath(this.activeSource, this.target, data).then(r => {
					this.result.private = r.private;
					this.render();
				})
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Present the user with a dialog to create a subdirectory within their currently browsed file storate location.
	 * @private
	 */
	_createDirectoryDialog(source) {
		const form = `<form><div class="form-group">
		<label>Directory Name</label>
		<input type="text" name="dirname" placeholder="directory-name" required/>
		</div></form>`;
		return Dialog.confirm({
			title: "Create Subfolder",
			content: form,
			yes: async html => {
				const dirname = html.querySelector("input").value;
				const path = [source.target, dirname].filterJoin("/");
				await this.constructor.createDirectory(this.activeSource, path, {bucket: source.bucket});
				return this.browse(this.target);
			},
			options: {jQuery: false}
		})
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle changes to the bucket selector
	 * @private
	 */
	_onChangeBucket(event) {
		event.preventDefault();
		const select = event.currentTarget;
		this.sources.s3.bucket = select.value;
		return this.browse("/");
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onSearchFilter(event, query, html) {
		const rgx = new RegExp(RegExp.escape(query), "i");
		for ( let ol of html.querySelectorAll(".directory") ) {
			for ( let li of ol.children ) {
				const f = li.dataset.path.split("/").pop();
				li.style.display = !rgx.test(f) ? "none" : "";
			}
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle file picker form submission
	 * @param ev {Event}
	 * @private
	 */
	_onSubmit(ev) {
		ev.preventDefault();
		let path = ev.target.file.value;
		if ( !path ) return ui.notifications.error("You must select a file to proceed.");
		 // Update the target field
		if ( this.field ) {
			this.field.value = path;
			this.field.dispatchEvent(new Event("change"));
		}
		 // Trigger a callback and close
		if ( this.options.callback ) this.options.callback(path);
		this.close();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle file upload
	 * @param ev
	 * @private
	 */
	async _onUpload(ev) {
		const form = ev.target.form;
		const upload = form.upload.files[0];
		 // Validate file extension
		if ( !this.extensions.some(ext => upload.name.endsWith(ext)) ) {
			ui.notifications.error(`Incorrect ${this.type} file extension. Supports ${this.extensions.join(" ")}.`);
			return false;
		}
		 // Dispatch the request
		const target = form.target.value;
		const options = { bucket: form.bucket ? form.bucket.value : null };
		const response = await this.constructor.upload(this.activeSource, target, upload, options);
		 // Handle errors
		if ( response.error ) {
			console.error(response.error);
			return ui.notifications.error(response.error);
		}
		 // Flag the uploaded file as the new request
		this.request = response.path;
		return this.browse(target);
	}
	 /* -------------------------------------------- */
	/*  Factory Methods
	/* -------------------------------------------- */
	 /**
	 * Bind the file picker to a new target field.
	 * Assumes the user will provide a <button> HTMLElement which has the data-target and data-type attributes
	 * The data-target attribute should provide the name of the input field which should receive the selected file
	 * The data-type attribute is a string in ["image", "audio"] which sets the file extensions which will be accepted
	 *
	 * @param button {HTMLElement}    The button element
	 */
	static fromButton(button, options) {
		if ( !(button instanceof HTMLElement ) ) throw "You must pass an HTML button";
		let type = button.getAttribute("data-type");
		 // Identify the target form field
		let form = button.form,
				target = form[button.getAttribute("data-target")];
		if ( !target ) return;
		 // Build and return a FilePicker instance
		return new FilePicker({field: target, type: type, current: target.value, button: button});
	}
}

/**
 * Record the last-browsed directory path so that re-opening a different FilePicker instance uses the same target
 * @type {string}
 */
FilePicker.LAST_BROWSED_DIRECTORY = "";

/**
 * Record the last-configured tile size which can automatically be applied to new FilePicker instances
 * @type {number|null}
 */
FilePicker.LAST_TILE_SIZE = null;
	/**
 * Record the last-configured display mode so that re-opening a different FilePicker instance uses the same mode.
 * @type {string}
 */
FilePicker.LAST_DISPLAY_MODE = "list";

/**
 * Enumerate the allowed FilePicker display modes
 * @type {Object<string,number>}
 */
FilePicker.DISPLAY_MODES = ["list", "thumbs", "tiles", "images"];

/**
 * Cache the names of S3 buckets which can be used
 * @type {Array|null}
 */
FilePicker.S3_BUCKETS = null;

/**
 * A controller class for managing a text input widget that filters the contents of some other UI element
 * @see {@link Application}
 *
 * @param {string} inputSelector    The CSS selector used to target the text input element.
 * @param {string} contentSelector  The CSS selector used to target the content container for these tabs.
 * @param {string} initial          The initial value of the search query.
 * @param {Function} callback       A callback function which executes when the filter changes.
 * @param {number} delay            The number of milliseconds to wait for text input before processing.
 */
class SearchFilter {
	constructor({inputSelector, contentSelector, initial="", callback, delay=100}={}) {
		 /**
		 * The value of the current query string
		 * @type {string}
		 */
		this.query = initial;
		 /**
		 * A callback function to trigger when the tab is changed
		 * @type {Function|null}
		 */
		this.callback = callback;
		 /**
		 * The CSS selector used to target the tab navigation element
		 * @type {string}
		 */
		this._inputSelector = inputSelector;
		 /**
		 * A reference to the HTML navigation element the tab controller is bound to
		 * @type {HTMLElement|null}
		 */
		this._input = null;
		 /**
		 * The CSS selector used to target the tab content element
		 * @type {string}
		 */
		this._contentSelector = contentSelector;
		 /**
		 * A reference to the HTML container element of the tab content
		 * @type {HTMLElement|null}
		 */
		this._content = null;
		 /**
		 * A debounced function which applies the search filtering
		 * @type {Function}
		 */
		this._filter = debounce(this.callback, delay);
	}
	 /* -------------------------------------------- */
	 /**
	 * Bind the SearchFilter controller to an HTML application
	 * @param {HTMLElement} html
	 */
	bind(html) {
		 // Identify navigation element
		this._input = html.querySelector(this._inputSelector);
		if ( !this._input ) return;
		this._input.value = this.query;
		 // Identify content container
		if ( !this._contentSelector ) this._content = null;
		else if ( html.matches(this._contentSelector) ) this._content = html;
		else this._content = html.querySelector(this._contentSelector);
		 // Register the handler for input changes
		this._input.addEventListener("keyup", this._onKeyUp.bind(this));
		this._input.addEventListener("keydown", event => {
			if ( event.key === "Enter" ) event.preventDefault();
		});
		 // Set the initial filtering conditions
		const event = new KeyboardEvent("keyup", {"key": "Enter", "code": "Enter"});
		this.callback(event, this.query, this._content)
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle key-up events within the filter input field
	 * @param {KeyboardEvent} event   The key-up event
	 * @private
	 */
	_onKeyUp(event) {
		event.preventDefault();
		let input = event.currentTarget;
		this.query = input.value.trim();
		this._filter(event, this.query, this._content);
	}
}
/**
 * An extension of the native FormData implementation.
 *
 * This class functions the same way that the default FormData does, but it is more opinionated about how
 * input fields of certain types should be evaluated and handled.
 *
 * It also adds support for certain Foundry VTT specific concepts including:
 *  Support for defined data types and type conversion
 *  Support for TinyMCE editors
 *  Support for editable HTML elements
 *
 * @extends {FormData}
 *
 * @param {HTMLFormElement} form        The form being processed
 * @param {object[]} [editors]          An array of TinyMCE editor instances which are present in this form
 * @param {{string, string}} [dtypes]   A mapping of data types for form fields
 */
class FormDataExtended extends FormData {
	constructor(form, {editors=[], dtypes={}}={}) {
		super();
		 /**
		 * A mapping of data types requested for each form field
		 * @type {{string, string}}
		 */
		this.dtypes = dtypes;
		 /**
		 * A record of TinyMCE editors which are linked to this form
		 * @type {object[]}
		 */
		this.editors = editors;
		 // Process the provided form
		this.process(form);
	}
	 /* -------------------------------------------- */
	 /**
	 * Process the HTML form element to populate the FormData instance.
	 * @param {HTMLFormElement} form      The HTML form
	 */
	process(form) {
		 // Process standard form elements
		for ( let el of form.elements ) {
			if ( !el.name || el.disabled || (el.tagName === "BUTTON") ) continue;
			if ( this.has(el.name) ) continue;
			const field = form.elements[el.name];
			this.dtypes[el.name] = el.dataset.dtype ?? "String";
			 // Radio Checkboxes
			if ( el.type === "radio" ) {
				const chosen = Array.from(field).find(r => r.checked);
				this.set(el.name, chosen ? chosen.value : null);
				continue;
			}
			 // Multi-Select
			if ( el.type === "select-multiple" ) {
				const chosen = [];
				for ( let opt of el.options ) {
					if ( opt.selected ) chosen.push(opt.value);
				}
				this.dtypes[el.name] = "JSON";
				this.set(el.name, JSON.stringify(chosen));
				continue;
			}
			 // Duplicate Fields
			if ( field instanceof RadioNodeList ) {
				const values = [];
				for ( let f of field ) {
					if ( f.disabled ) values.push(null);
					else if ( f.type === "checkbox" ) values.push(f.checked);
					else values.push(f.value)
				}
				this.set(el.name, JSON.stringify(values));
				this.dtypes[el.name] = "JSON";
				continue;
			}
			 // Boolean Checkboxes
			if ( el.type === "checkbox" ) {
				this.set(el.name, el.checked || "");
				this.dtypes[el.name] = "Boolean";
				continue;
			}
			 // Other Inputs
			if ( ["number", "range"].includes(el.type) ) {
				this.dtypes[el.name] = "Number";
			}
			this.set(el.name, el.value.trim());
		}
		 // Process MCE editors
		for ( let [name, editor] of Object.entries(this.editors) ) {
			if ( editor.mce ) {
				this.set(name, editor.mce.getContent());
				this.delete(editor.mce.id); // Delete hidden MCE inputs
			}
		}
		 // Process editable HTML fields
		const editableFields = form.querySelectorAll('[data-edit]');
		for ( let el of editableFields ) {
			const name = el.dataset.edit;
			if ( this.has(name) || el.getAttribute("disabled") || (name in this.editors) ) continue;
			if (el.tagName === "IMG") this.set(name, el.getAttribute("src"));
			else this.set(name, el.innerHTML.trim());
			this.dtypes[name] = el.dataset.dtype ?? "String";
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Export the FormData as an object
	 * @return {object}
	 */
	toObject() {
		const data = {};
		for ( let [k, v] of this.entries() ) {
			const dtype = this.dtypes[k];
			if ( dtype === "Boolean" ) v = v === "true";
			else if ( dtype === "JSON" ) v = JSON.parse(v);
			else if ( (dtype === "String") && !v ) v = "";
			else {
				if ( v === "" ) v = null;
				if ( (v !== null) && ( window[dtype] instanceof Function ) ) {
					try {
						v = window[dtype](v);
					} catch(err) {
						console.warn(`The form field ${k} was not able to be cast to the requested data type ${dtype}`);
					}
				}
			}
			data[k] = v;
		}
		return data;
	}
}

/**
 * A common framework for displaying notifications to the client.
 * Submitted notifications are added to a queue, and up to 3 notifications are displayed at once.
 * Each notification is displayed for 5 seconds at which point further notifications are pulled from the queue.
 *
 * @extends {Application}
 *
 * @example
 * ui.notifications.info("This is an info message");
 * ui.notifications.warn("This is a warning message");
 * ui.notifications.error("This is an error message");
 * ui.notifications.info("This is a 4th message which will not be shown until the first info message is done");
 */
class Notifications extends Application {
	constructor(options) {
		super(options);
		 /**
		 * Submitted notifications which are queued for display
		 * @type {object[]}
		 */
		this.queue = [];
		 /**
		 * Notifications which are currently displayed
		 * @type {object[]}
		 */
		this.active = [];
		 // Initialize any pending messages
		this.initialize();
	}
	/* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
			popOut: false,
			id: "notifications",
			template: "templates/hud/notifications.html"
		});
	}
	/* -------------------------------------------- */
	 /**
	 * Initialize the Notifications system by displaying any system-generated messages which were passed from the server.
	 */
	initialize() {
		if ( !MESSAGES ) return;
		for ( let m of MESSAGES ) {
			this.notify(game.i18n.localize(m.message), m.type, m.options);
		}
	}
	/* -------------------------------------------- */
	 /** @override */
	_renderInner(...args) {
		return $('<ol id="notifications"></ol>');
	}
	/* -------------------------------------------- */
	 /** @override */
	async _render(...args) {
		await super._render(...args);
		while ( this.queue.length ) this.fetch();
	}
	/* -------------------------------------------- */
	 /**
	 * Push a new notification into the queue
	 * @param {string} message      The content of the notification message
	 * @param {string} type         The type of notification, currently "info", "warning", and "error" are supported
	 * @param {boolean} permanent   Whether the notification should be permanently displayed unless otherwise dismissed
	 */
	notify(message, type="info", {permanent=false}={}) {
		 // Construct notification data
		let n = {
			message: message,
			type: ["info", "warning", "error"].includes(type) ? type : "info",
			timestamp: new Date().getTime(),
			permanent: permanent
		};
		this.queue.push(n);
		 // Call the fetch method
		if ( this.rendered ) this.fetch();
	}
	/* -------------------------------------------- */
	 /**
	 * Display a notification with the "info" type
	 * @param {string} message    The content of the notification message
	 * @param {Object} options    Notification options passed to the notify function
	 * @returns {void}
	 */
	info(message, options) {
	 this.notify(message, "info", options);
	}
	/* -------------------------------------------- */
	 /**
	 * Display a notification with the "warning" type
	 * @param {string} message    The content of the notification message
	 * @param {Object} options    Notification options passed to the notify function
	 * @returns {void}
	 */
	warn(message, options) {
	 this.notify(message, "warning", options);
	}
	/* -------------------------------------------- */
	 /**
	 * Display a notification with the "error" type
	 * @param {string} message    The content of the notification message
	 * @param {Object} options    Notification options passed to the notify function
	 * @returns {void}
	 */
	error(message, options) {
	 this.notify(message, "error", options);
	}
	/* -------------------------------------------- */
	 /**
	 * Retrieve a pending notification from the queue and display it
	 * @private
	 * @returns {void}
	 */
	fetch() {
	 if ( this.queue.length === 0 || this.active.length >= 3 ) return;
		const next = this.queue.pop();
		const now = Date.now();
		let cleared = false;
		 // Define the function to remove the notification
		const _remove = li => {
			if ( cleared ) return;
			li.fadeOut(66, () => li.remove());
			this.active.pop();
			return this.fetch();
		};
		 // Construct a new notification
		const cls = ["notification", next.type, next.permanent ? "permanent": null].filterJoin(" ");
		const li = $(`<li class="${cls}">${next.message}<i class="close fas fa-times-circle"></i></li>`);
``
		// Add click listener to dismiss
		li.click(ev => { if ( Date.now() - now > 250 ) _remove(li) });
	 this.element.prepend(li);
	 li.hide().slideDown(132);
	 this.active.push(li);
		// Schedule clearing the notification 5 seconds later
	 if ( !next.permanent ) window.setTimeout(() => _remove(li), 5000);
	}
}

/**
 * A controller class for managing tabbed navigation within an Application instance.
 * @see {@link Application}
 *
 * @param {string} navSelector      The CSS selector used to target the navigation element for these tabs
 * @param {string} contentSelector  The CSS selector used to target the content container for these tabs
 * @param {string} initial          The tab name of the initially active tab
 * @param {Function|null} callback  An optional callback function that executes when the active tab is changed
 *
 * @example
 * <!-- Example HTML -->
 * <nav class="tabs" data-group="primary-tabs">
 *   <a class="item" data-tab="tab1">Tab 1</li>
 *   <a class="item" data-tab="tab2">Tab 2</li>
 * </nav>
 *
 * <section class="content">
 *   <div class="tab" data-tab="tab1" data-group="primary-tabs">Content 1</div>
 *   <div class="tab" data-tab="tab2" data-group="primary-tabs">Content 2</div>
 * </section>
 *
 * @example
 * // JavaScript
 * const tabs = new Tabs({navSelector: ".tabs", contentSelector: ".content", initial: "tab1"});
 * tabs.bind(html);
 */
class Tabs {
	constructor({navSelector, contentSelector, initial, callback}={}) {
		 /**
		 * The value of the active tab
		 * @type {string}
		 */
		this.active = initial;
		 /**
		 * A callback function to trigger when the tab is changed
		 * @type {Function|null}
		 */
		this.callback = callback;
		 /**
		 * The CSS selector used to target the tab navigation element
		 * @type {string}
		 */
		this._navSelector = navSelector;
		 /**
		 * A reference to the HTML navigation element the tab controller is bound to
		 * @type {HTMLElement|null}
		 */
		this._nav = null;
		 /**
		 * The CSS selector used to target the tab content element
		 * @type {string}
		 */
		this._contentSelector = contentSelector;
		 /**
		 * A reference to the HTML container element of the tab content
		 * @type {HTMLElement|null}
		 */
		this._content = null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Bind the Tabs controller to an HTML application
	 * @param {HTMLElement} html
	 */
	bind(html) {
		 // Identify navigation element
		this._nav = html.querySelector(this._navSelector);
		if ( !this._nav ) return;
		 // Identify content container
		if ( !this._contentSelector ) this._content = null;
		else if ( html.matches(this._contentSelector )) this._content = html;
		else this._content = html.querySelector(this._contentSelector);
		 // Initialize the active tab
		this.activate(this.active);
		 // Register listeners
		this._nav.addEventListener("click", this._onClickNav.bind(this))
	}
	 /* -------------------------------------------- */
	 /**
	 * Activate a new tab by name
	 * @param {string} tabName
	 * @param {boolean} triggerCallback
	 */
	activate(tabName, {triggerCallback=false}={}) {
		 // Validate the requested tab name
		const group = this._nav.dataset.group;
		const items = this._nav.querySelectorAll("[data-tab]");
		if ( !items.length ) return;
		const valid = Array.from(items).some(i => i.dataset.tab === tabName);
		if ( !valid ) tabName = items[0].dataset.tab;
		 // Change active tab
		for ( let i of items ) {
			i.classList.toggle("active", i.dataset.tab === tabName);
		}
		 // Change active content
		if ( this._content ) {
			const tabs = this._content.querySelectorAll("[data-tab]");
			for ( let t of tabs ) {
				if ( t.dataset.group && (t.dataset.group !== group) ) continue;
				t.classList.toggle("active", t.dataset.tab === tabName);
			}
		}
		 // Store the active tab
		this.active = tabName;
		 // Optionally trigger the callback function
		if ( triggerCallback ) this.callback(null, this, tabName);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle click events on the tab navigation entries
	 * @param {MouseEvent} event    A left click event
	 * @private
	 */
	_onClickNav(event) {
		const tab = event.target.closest("[data-tab]");
		if ( !tab ) return;
		event.preventDefault();
		const tabName = tab.dataset.tab;
		if ( tabName !== this.active) this.activate(tabName, {triggerCallback: true});
	}
}

const TabsV2 = Tabs;
/**
 * Render the Sidebar container, and after rendering insert Sidebar tabs
 */
class Sidebar extends Application {
	constructor(...args) {
		super(...args);
		 /**
		 * Sidebar application instances
		 * @type {Application[]}
		 */
		this.apps = [];
		 /**
		 * Track whether the sidebar container is currently collapsed
		 * @type {boolean}
		 */
		this._collapsed = false;
	}
	 /* -------------------------------------------- */
	 /** @inheritdoc */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 id: "sidebar",
			template: "templates/sidebar/sidebar.html",
			popOut: false,
			width: 300,
			tabs: [{navSelector: ".tabs", contentSelector: "#sidebar", initial: "chat"}]
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the name of the active Sidebar tab
	 * @type {string}
	 */
	get activeTab() {
		return this._tabs[0].active;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return an Array of pop-out sidebar tab Application instances
	 * @type {Application[]}
	 */
	get popouts() {
		return this.apps.map(a => a._popout).filter(p => p);
	}
	/* -------------------------------------------- */
	/*  Rendering
	/* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const canUpdate = game.user.isGM && game.data.coreUpdate;
		return {
			coreUpdate: canUpdate ? game.i18n.format("SETUP.UpdateAvailable", game.data.coreUpdate) : false,
			user: game.user
		};
	}
		/* -------------------------------------------- */
	 /** @override */
	async _render(...args) {
		// Render the Sidebar container only once
		if ( !this.rendered ) await super._render(...args);
		 // Define the sidebar tab names to render
	 const tabs = ["chat", "combat", "actors", "items", "journal", "tables", "playlists", "compendium", "settings"];
	 if ( game.user.isGM ) tabs.push("scenes");
		 // Render sidebar Applications
		for ( let name of tabs ) {
			const app = ui[name];
			try {
				await app._render(true, {})
			} catch(err) {
				console.error(`Failed to render Sidebar tab ${name}`);
				console.error(err);
			}
		}
	}
	/* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */
	 /**
	 * Activate a Sidebar tab by it's name
	 * @param {string} tabName      The tab name corresponding to it's "data-tab" attribute
	 */
	activateTab(tabName) {
		this._tabs[0].activate(tabName, {triggerCallback: true});
	}
	/* -------------------------------------------- */
	 /**
	 * Expand the Sidebar container from a collapsed state.
	 * Take no action if the sidebar is already expanded.
	 */
	expand() {
		if ( !this._collapsed ) return;
		const sidebar = this.element;
		const tab = sidebar.find(".sidebar-tab.active");
		const icon = sidebar.find("#sidebar-tabs a.collapse i");
		 // Animate the sidebar expansion
		tab.hide();
		sidebar.animate({width: this.options.width, height: this.position.height}, 150, () => {
			sidebar.css({width: "", height: ""});
			icon.removeClass("fa-caret-left").addClass("fa-caret-right");
			tab.fadeIn(250, () => tab.css("display", ""));
			this._collapsed = false;
			sidebar.removeClass("collapsed");
			Hooks.callAll("sidebarCollapse", this, this._collapsed);
		})
	}
	/* -------------------------------------------- */
	 /**
	 * Collapse the sidebar to a minimized state.
	 * Take no action if the sidebar is already collapsed.
	 */
	collapse() {
		if ( this._collapsed ) return;
		const sidebar = this.element;
		const tab = sidebar.find(".sidebar-tab.active");
		const icon = sidebar.find("#sidebar-tabs a.collapse i");
		 // Animate the sidebar collapse
		tab.fadeOut(250, () => {
			sidebar.animate({width: 30, height: 370}, 150, () => {
				icon.removeClass("fa-caret-right").addClass("fa-caret-left");
				this._collapsed = true;
				sidebar.addClass("collapsed");
				tab.css("display", "");
				Hooks.callAll("sidebarCollapse", this, this._collapsed);
			})
		})
	}
	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */
	 /** @inheritdoc */
	activateListeners(html) {
	 super.activateListeners(html);
		 // Right click pop-out
		const nav = this._tabs[0]._nav;
		nav.addEventListener('contextmenu', this._onRightClickTab.bind(this));
		 // Toggle Collapse
		const collapse = nav.querySelector(".collapse");
		collapse.addEventListener("click", this._onToggleCollapse.bind(this));
	}
	/* -------------------------------------------- */
	 /** @override */
	_onChangeTab(event, tabs, active) {
		const app = ui[active];
		if ( (active === "chat") && app ) app.scrollBottom();
		if ( this._collapsed ) {
			if ( active !== "chat") app.renderPopout(app);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle right-click events on tab controls to trigger pop-out containers for each tab
	 * @param {Event} event     The originating contextmenu event
	 * @private
	 */
	_onRightClickTab(event) {
		const li = event.target.closest(".item");
		if ( !li ) return;
		event.preventDefault();
		const tabName = li.dataset.tab;
		const tabApp = ui[tabName];
		if ( tabName !== "chat" ) tabApp.renderPopout(tabApp);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle toggling of the Sidebar container's collapsed or expanded state
	 * @param {Event} event
	 * @private
	 */
	_onToggleCollapse(event) {
		event.preventDefault();
		if ( this._collapsed ) this.expand();
		else this.collapse();
	}
}

/**
 * An abstract pattern followed by the different tabs of the sidebar
 * @type {Application}
 * @abstract
 * @interface
 */
class SidebarTab extends Application {
	constructor(...args) {
		super(...args);
		 /**
		 * The base name of this sidebar tab
		 * @type {string}
		 */
		this.tabName = this.constructor.defaultOptions.id;
		 /**
		 * A reference to the pop-out variant of this SidebarTab, if one exists
		 * @type {SidebarTab}
		 * @private
		 */
		this._popout = null;
		 /**
		 * Denote whether or not this is the original version of the sidebar tab, or a pop-out variant
		 * @type {SidebarTab}
		 */
		this._original = null;
	}
	/* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 popOut: false,
			width: 300,
			baseApplication: "SidebarTab"
		});
	}
	/* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */
	 /** @override */
	async _renderInner(data) {
	 let html = await super._renderInner(data);
	 if ( ui.sidebar && ui.sidebar.activeTab === this.options.id ) html.addClass('active');
	 if ( this.popOut ) html.removeClass("tab");
	 return html;
	}
	/* -------------------------------------------- */
	 /** @override */
	async _render(...args) {
		// Trigger rendering of pop-out tabs
		if ( this._popout ) {
			this._popout.render(...args);
		}
		// Resize pop-out tabs
	 if ( this._original ) {
		 this.position.height = "auto";
		}
		// Parent rendering logic
		return super._render(...args);
	}
	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /**
	 * Activate this SidebarTab, switching focus to it
	 */
	activate() {
		ui.sidebar.activateTab(this.tabName);
	}
	/* -------------------------------------------- */
	 /** @override */
	async close(options) {
	 if ( this.popOut ) {
		 const base = this._original;
		 base._popout = null;
		 return super.close(options);
		}
		return false;
	}
	/* -------------------------------------------- */
	 /**
	 * Create a second instance of this SidebarTab class which represents a singleton popped-out container
	 * @return {SidebarTab}   The popped out sidebar tab instance
	 */
	createPopout() {
		if ( this._popout ) return this._popout;
		const pop = new this.constructor({
			id: `${this.options.id}-popout`,
			classes: this.options.classes.concat([["sidebar-popout"]]),
			popOut: true
		});
		this._popout = pop;
		pop._original = this;
		return pop;
	}
	/* -------------------------------------------- */
	 /**
	 * Render the SidebarTab as a pop-out container
	 */
	renderPopout() {
	 const pop = this.createPopout();
	 pop.render(true);
	}
	 /* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */
	 /**
	 * Handle lazy loading for sidebar images to only load them once they become observed
	 * @param entries
	 * @param observer
	 */
	_onLazyLoadImage(entries, observer) {
		for ( let e of entries ) {
			if ( !e.isIntersecting ) continue;
			const li = e.target;
			 // Background Image
			if ( li.dataset.backgroundImage ) {
				li.style["background-image"] = `url("${li.dataset.backgroundImage}")`;
				delete li.dataset.backgroundImage;
			}
			 // Avatar image
			const img = li.querySelector("img");
			if ( img && img.dataset.src ) {
				img.src = img.dataset.src;
				delete img.dataset.src;
			}
			 // No longer observe the target
			observer.unobserve(e.target);
		}
	}
}

/**
 * A shared pattern for the sidebar directory which Actors, Items, and Scenes all use
 * @extends {SidebarTab}
 * @abstract
 * @interface
 */
class SidebarDirectory extends SidebarTab {
	constructor(options) {
		super(options);
		 /**
		 * References to the set of Entities which are displayed in the Sidebar
		 * @type {Entity[]}
		 */
		this.entities = null;
		 /**
		 * Reference the set of Folders which exist in this Sidebar
		 * @type {Folder[]}
		 */
		this.folders = null;
		 // Initialize sidebar content
		this.initialize();
		 // Record the directory as an application of the collection if it is not a popout
		if ( !this.options.popOut ) this.constructor.collection.apps.push(this);
	}
	/* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
	 const el = this.entity.toLowerCase();
	 return mergeObject(super.defaultOptions, {
			id: `${el}s`,
			template: `templates/sidebar/${el}-directory.html`,
			title: `${this.entity}s Directory`,
			renderUpdateKeys: ["name", "img", "thumb", "permission", "sort", "folder"],
			height: "auto",
			scrollY: ["ol.directory-list"],
			dragDrop: [{ dragSelector: ".directory-item",  dropSelector: ".directory-list"}],
			filters: [{inputSelector: 'input[name="search"]', contentSelector: ".directory-list"}]
		});
	}
	/* -------------------------------------------- */
	 /**
	 * The named entity which this Sidebar Directory contains
	 * @type {string}
	 */
	static get entity() {
	 throw "A SidebarDirectory subclass must define the entity name which it displays."
	}
	/* -------------------------------------------- */
	 /**
	 * The Entity collection which this Sidebar Directory contains
	 * @type {EntityCollection}
	 */
	static get collection() {
		throw "A SidebarDirectory subclass must define the EntityCollection it displays."
	}
	/* -------------------------------------------- */
	 /**
	 * A reference to the Entity class which is displayed within this EntityCollection
	 * @return {Entity}
	 */
	static get cls() {
		return CONFIG[this.entity].entityClass;
	}
	/* -------------------------------------------- */
	/*  Initialization Helpers
	/* -------------------------------------------- */
	 /**
	 * Initialize the content of the directory by categorizing folders and entities into a hierarchical tree structure.
	 */
	initialize() {
		 // Assign Folders
		this.folders = game.folders.filter(f => f.type === this.constructor.entity);
		 // Assign Entities
		this.entities = this.constructor.collection.filter(e => e.visible);
		 // Build Tree
		this.tree = this.constructor.setupFolders(this.folders, this.entities);
	}
	/* -------------------------------------------- */
	 /**
	 * Given an entity type and a list of entities, set up the folder tree for that entity
	 * @param {Folder[]} folders    The Array of Folder objects to organize
	 * @param {Entity[]} entities   The Array of Entity objects to organize
	 * @return {Object}             A tree structure containing the folders and entities
	 */
	static setupFolders(folders, entities) {
		entities = entities.filter(a => a.visible);
		const depths = [];
		const handled = new Set();
		 // Iterate parent levels
		const root = {_id: null};
		let batch = [root];
		for ( let i = 0; i < CONST.FOLDER_MAX_DEPTH; i++ ) {
			depths[i] = [];
			for ( let folder of batch ) {
				if ( handled.has(folder.id) ) continue;
				 // Classify content for this folder
				try {
					[folders, entities] = this._populate(folder, folders, entities);
				} catch(err) {
					console.error(err);
					continue;
				}
				 // Add child folders to the correct depth level
				depths[i] = depths[i].concat(folder.children);
				handled.add(folder.id);
			}
			batch = depths[i];
		}
		 // Populate content to any remaining folders and assign them to the root level
		const remaining = depths[CONST.FOLDER_MAX_DEPTH-1].concat(folders);
		for ( let f of remaining ) {
			[folders, entities] = this._populate(f, folders, entities, {allowChildren: false});
		}
		depths[0] = depths[0].concat(folders);
		 // Filter folder visibility
		for ( let i = CONST.FOLDER_MAX_DEPTH - 1; i >= 0; i-- ) {
			depths[i] = depths[i].reduce((arr, f) => {
				f.children = f.children.filter(c => c.displayed);
				if ( !f.displayed ) return arr;
				f.depth = i+1;
				arr.push(f);
				return arr;
			}, []);
		}
		 // Return the root level contents of folders and entities
		return {
			root: true,
			content: root.content.concat(entities),
			children: depths[0]
		};
	}
	 /* -------------------------------------------- */
	 /**
	 * Populate a single folder with child folders and content
	 * This method is called recursively when building the folder tree
	 * @private
	 */
	static _populate(folder, folders, entities, {allowChildren=true}={}) {
		const id = folder._id;
		 // Define sorting function for this folder
		const alpha = folder.data?.sorting === "a";
		const s = alpha ? (a, b) => a.name.localeCompare(b.name) : (a, b) => a.data.sort - b.data.sort;
		 // Partition folders into children and unassigned folders
		let [u, children] = folders.partition(f => allowChildren && (f.data.parent === id));
		folder.children = children.sort(s);
		folders = u;
		 // Partition entities into contents and unassigned entities
		const [e, content] = entities.partition(e => e.data.folder === id);
		folder.content = content.sort(s);
		entities = e;
		 // Return the remainder
		return [folders, entities];
	}
	/* -------------------------------------------- */
	/*  Application Rendering
	/* -------------------------------------------- */
	 /** @override */
	render(force, context={}) {
		// Only re-render the sidebar directory for certain types of updates
	 const {action, data, entityType} = context;
	 if ( action && !["create", "update", "delete"].includes(action) ) return;
	 if ( (entityType !== "Folder") && (action === "update") && !data.some(d => {
		 return this.options.renderUpdateKeys.some(k => k in d);
		}) ) return;
		// Re-build the tree and render
		this.initialize();
	 super.render(force, context);
		return this;
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		return {
			user: game.user,
			tree: this.tree,
			canCreate: this.constructor.cls.can(game.user, "create"),
			sidebarIcon: CONFIG[this.constructor.entity].sidebarIcon
		};
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onSearchFilter(event, query, html) {
		const isSearch = !!query;
		let entityIds = new Set();
		let folderIds = new Set();
		 // Match entities and folders
		if ( isSearch ) {
			const rgx = new RegExp(RegExp.escape(query), "i");
			 // Match entity names
			for ( let e of this.entities ) {
				if ( rgx.test(e.name) ) {
					entityIds.add(e.id);
					if ( e.data.folder ) folderIds.add(e.data.folder);
				}
			}
			 // Match folder tree
			const includeFolders = fids => {
				const folders = this.folders.filter(f => fids.has(f._id));
				const pids = new Set(folders.filter(f => f.data.parent).map(f => f.data.parent));
				if ( pids.size ) {
					pids.forEach(p => folderIds.add(p));
					includeFolders(pids);
				}
			};
			includeFolders(folderIds);
		}
		 // Toggle each directory item
		for ( let el of html.querySelectorAll(".directory-item") ) {
			 // Entities
			if (el.classList.contains("entity")) {
				el.style.display = (!isSearch || entityIds.has(el.dataset.entityId)) ? "flex" : "none";
			}
			 // Folders
			if (el.classList.contains("folder")) {
				let match = isSearch && folderIds.has(el.dataset.folderId);
				el.style.display = (!isSearch || match) ? "flex" : "none";
				if (isSearch && match) el.classList.remove("collapsed");
				else el.classList.toggle("collapsed", !game.folders._expanded[el.dataset.folderId]);
			}
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Collapse all subfolders in this directory
	 */
	collapseAll() {
		this.element.find('li.folder').addClass("collapsed");
		for ( let f of this.folders ) {
			game.folders._expanded[f._id] = false;
		}
		if ( this.popOut ) this.setPosition();
	}
	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /**
	 * Activate event listeners triggered within the Actor Directory HTML
	 */
	activateListeners(html) {
	 super.activateListeners(html);
		const directory = html.find(".directory-list");
		const entries = directory.find(".directory-item");
		 // Directory-level events
		html.find('.create-entity').click(ev => this._onCreateEntity(ev));
		html.find('.collapse-all').click(this.collapseAll.bind(this));
		html.find(".folder .folder .folder .create-folder").remove(); // Prevent excessive folder nesting
		if ( game.user.isGM ) html.find('.create-folder').click(ev => this._onCreateFolder(ev));
		// Entry-level events
		directory.on("click", ".entity-name", this._onClickEntityName.bind(this));
		directory.on("click", ".folder-header", this._toggleFolder.bind(this));
		const dh = this._onDragHighlight.bind(this);
		html.find(".folder").on("dragenter", dh).on("dragleave", dh);
		this._contextMenu(html);
		 // Intersection Observer
		const observer = new IntersectionObserver(this._onLazyLoadImage.bind(this), { root: directory[0] });
		entries.each((i, li) => observer.observe(li));
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle clicking on an Entity name in the Sidebar directory
	 * @param {Event} event   The originating click event
	 * @private
	 */
	_onClickEntityName(event) {
		event.preventDefault();
		const element = event.currentTarget;
		const entityId = element.parentElement.dataset.entityId;
		const entity = this.constructor.collection.get(entityId);
		const sheet = entity.sheet;
		 // If the sheet is already rendered:
		if ( sheet.rendered ) {
			sheet.maximize();
			sheet.bringToTop();
		}
		 // Otherwise render the sheet
		else sheet.render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle new creation request
	 * @param {MouseEvent} event    The originating button click event
	 * @private
	 */
	async _onCreateEntity(event) {
		event.preventDefault();
		event.stopPropagation();
		const button = event.currentTarget;
		const data = {folder: button.dataset.folder};
		const options = {width: 320, left: window.innerWidth - 630, top: button.offsetTop };
		return this.constructor.cls.createDialog(data, options);
	}
	/* -------------------------------------------- */
	 /**
	 * Create a new Folder in this SidebarDirectory
	 * @param {MouseEvent} event    The originating button click event
	 * @private
	 */
	_onCreateFolder(event) {
	 event.preventDefault();
	 event.stopPropagation();
	 const button = event.currentTarget;
		const parent = button.dataset.parentFolder;
		const data = {parent: parent ? parent : null, type: this.constructor.entity};
		const options = {top: button.offsetTop, left: window.innerWidth - 310 - FolderConfig.defaultOptions.width};
	 Folder.createDialog(data, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle toggling the collapsed or expanded state of a folder within the directory tab
	 * @param {MouseEvent} event    The originating click event
	 * @private
	 */
	_toggleFolder(event) {
		let folder = $(event.currentTarget.parentElement);
		let collapsed = folder.hasClass("collapsed");
		game.folders._expanded[folder.attr("data-folder-id")] = collapsed;
		 // Expand
		if ( collapsed ) folder.removeClass("collapsed");
		 // Collapse
		else {
			folder.addClass("collapsed");
			const subs = folder.find('.folder').addClass("collapsed");
			subs.each((i, f) => game.folders._expanded[f.dataset.folderId] = false);
		}
		 // Resize container
		if ( this.popOut ) this.setPosition();
	}
	/* -------------------------------------------- */
	 /** @override */
	_onDragStart(event) {
	 let li = event.currentTarget.closest(".directory-item");
		const dragData = li.classList.contains("folder") ?
			{ type: "Folder", id: li.dataset.folderId, entity: this.constructor.entity } :
			{ type: this.constructor.entity, id: li.dataset.entityId };
		event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
		this._dragType = dragData.type;
	}
	 /* -------------------------------------------- */
	 /**
	 * Highlight folders as drop targets when a drag event enters or exits their area
	 * @param {DragEvent} event     The DragEvent which is in progress
	 */
	_onDragHighlight(event) {
		const li = event.currentTarget;
		if ( !li.classList.contains("folder") ) return;
		event.stopPropagation();  // Don't bubble to parent folders
		 // Remove existing drop targets
		if ( event.type === "dragenter" ) {
			for ( let t of li.closest(".directory-list").querySelectorAll(".droptarget") ) {
				t.classList.remove("droptarget");
			}
		}
		 // Remove current drop target
		if ( event.type === "dragleave" ) {
			const el = document.elementFromPoint(event.clientX, event.clientY);
			const parent = el.closest(".folder");
			if ( parent === li ) return;
		}
		 // Add new drop target
		li.classList.toggle("droptarget", event.type === "dragenter");
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDrop(event) {
		const cls = this.constructor.entity;
		 // Try to extract the data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData('text/plain'));
		}
		catch (err) {
			return false;
		}
		let correctType = (data.type === cls) || ((data.type === "Folder") && (data.entity === cls));
		if ( !correctType ) return false;
		 // Call the drop handler
		this._handleDropData(event, data);
	}
	 /* -------------------------------------------- */
	 /**
	 * Define the behavior of the sidebar tab when it received a dropped data object
	 * @param {Event} event   The original drop event
	 * @param {Object} data   The data being dropped
	 * @private
	 */
	_handleDropData(event, data) {
		 // Determine the drop target
		const collection = this.constructor.collection;
		const sel = this._dragDrop[0].dragSelector;
		const dt = event.target.closest(sel) || null;
		const isFolder = dt && dt.classList.contains("folder");
		const targetId = dt ? (isFolder ? dt.dataset.folderId : dt.dataset.entityId) : null;
		 // Determine the closest folder ID
		const closestFolder = dt ? dt.closest(".folder") : null;
		if ( closestFolder ) closestFolder.classList.remove("droptarget");
		const closestFolderId = closestFolder ? closestFolder.dataset.folderId : null;
		 // Case 1 - New data is explicitly provided
		if ( data.data ) {
			const createData = mergeObject(data.data, { folder: closestFolderId });
			if ( collection.get(createData._id ) ) throw new Error("An Entity with this _id already exists!");
			return collection.object.create(createData);
		}
		 // Case 2 - Data to import from a Compendium pack
		else if ( data.pack ) {
			const updateData = { folder: closestFolderId };
			const options = { renderSheet: true };
			return this.constructor.collection.importFromCollection(data.pack, data.id, updateData, options);
		}
		 // Case 3 - Sort a Folder
		if ( data.type === "Folder" ) {
			const folder = game.folders.get(data.id);
			const sortData = {sortKey: "sort", sortBefore: true};
			if (isFolder && dt.classList.contains("collapsed") ) {    // Dropped on a collapsed Folder
				sortData.target = game.folders.get(targetId);
				sortData.parentId = sortData.target.data.parent;
			} else if ( isFolder )  {                                 // Dropped on an expanded Folder
				if ( Number(dt.dataset.folderDepth) === CONST.FOLDER_MAX_DEPTH ) return; // Prevent going beyond max depth
				sortData.target = null;
				sortData.parentId = targetId;
				if ( data.id === targetId ) return; // Don't drop folders on yourself
			} else {                                                  // Dropped on an Entity
				sortData.parentId = closestFolderId;
				sortData.target = closestFolder && closestFolder.classList.contains("collapsed") ? closestFolder : null;
			}
			 // Determine Folder siblings
			sortData.siblings = game.folders.entities.filter(f => {
				return (f.data.parent === sortData.parentId) && (f.data.type === folder.data.type) && (f !== folder);
			});
			sortData.updateData = {parent: sortData.parentId};
			folder.sortRelative(sortData);
		}
		 // Case 4 - Sort an Entity
		else {
			const entity = collection.get(data.id);
			const isEntity = dt && dt.classList.contains("entity");
			const sortData = {sortKey: "sort", sortBefore: true};
			 // Handle different targets
			if ( isEntity ) {   // Drop on an Entity
				sortData.target = collection.get(targetId);
				sortData.folderId = sortData.target.data.folder;
			} else {            // Drop on a Folder or null
				sortData.target = null;
				sortData.folderId = closestFolderId;
			}
			 // Determine Entity siblings and updateData
			sortData.siblings = collection.entities.filter(e => {
				return (e.data.folder === sortData.folderId) && (e._id !== data.id);
			});
			sortData.updateData = { folder: sortData.folderId };
			entity.sortRelative(sortData);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Default folder context actions
	 * @param html {jQuery}
	 * @private
	 */
	_contextMenu(html) {
		 // Folder Context
		const folderOptions = this._getFolderContextOptions();
		Hooks.call(`get${this.constructor.name}FolderContext`, html, folderOptions);
		if (folderOptions) new ContextMenu(html, ".folder .folder-header", folderOptions);
		 // Entity Context
		const entryOptions = this._getEntryContextOptions();
		Hooks.call(`get${this.constructor.name}EntryContext`, html, entryOptions);
		if (entryOptions) new ContextMenu(html, ".entity", entryOptions);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the set of ContextMenu options which should be used for Folders in a SidebarDirectory
	 * @return {object[]}   The Array of context options passed to the ContextMenu instance
	 * @private
	 */
	_getFolderContextOptions() {
		return [
			{
				name: "FOLDER.Edit",
				icon: '<i class="fas fa-edit"></i>',
				condition: game.user.isGM,
				callback: header => {
					const li = header.parent()[0];
					const folder = game.folders.get(li.dataset.folderId);
					const options = {top: li.offsetTop, left: window.innerWidth - 310 - FolderConfig.defaultOptions.width};
					new FolderConfig(folder, options).render(true);
				}
			},
			{
				name: "PERMISSION.Configure",
				icon: '<i class="fas fa-lock"></i>',
				condition: () => game.user.isGM,
				callback: header => {
					const li = header.parent()[0];
					const folder = game.folders.get(li.dataset.folderId);
					new PermissionControl(folder, {
						top: Math.min(li.offsetTop, window.innerHeight - 350),
						left: window.innerWidth - 720
					}).render(true);
				}
			},
			{
				name: "FOLDER.Export",
				icon: `<i class="fas fa-atlas"></i>`,
				condition: header => {
					const folder = game.folders.get(header.parent().data("folderId"));
					return CONST.COMPENDIUM_ENTITY_TYPES.includes(folder.type);
				},
				callback: header => {
					const li = header.parent();
					const folder = game.folders.get(li.data("folderId"));
					return folder.exportDialog(null, {
							top: Math.min(li[0].offsetTop, window.innerHeight - 350),
							left: window.innerWidth - 720,
							width: 400
					});
				}
			},
			{
				name: "FOLDER.CreateTable",
				icon: `<i class="${CONFIG.RollTable.sidebarIcon}"></i>`,
				condition: header => {
					const folder = game.folders.get(header.parent().data("folderId"));
					return CONST.COMPENDIUM_ENTITY_TYPES.includes(folder.type);
				},
				callback: header => {
					const li = header.parent()[0];
					const folder = game.folders.get(li.dataset.folderId);
					return Dialog.confirm({
						title: `${game.i18n.localize("FOLDER.CreateTable")}: ${folder.name}`,
						content: game.i18n.localize("FOLDER.CreateTableConfirm"),
						yes: () => RollTable.fromFolder(folder),
						options: {
							top: Math.min(li.offsetTop, window.innerHeight - 350),
							left: window.innerWidth - 680,
							width: 360
						}
					});
				}
			},
			{
				name: "FOLDER.Remove",
				icon: '<i class="fas fa-trash"></i>',
				condition: game.user.isGM,
				callback: header => {
					const li = header.parent();
					const folder = game.folders.get(li.data("folderId"));
					Dialog.confirm({
						title: `${game.i18n.localize("FOLDER.Remove")} ${folder.name}`,
						content: game.i18n.localize("FOLDER.RemoveConfirm"),
						yes: () => folder.delete({deleteSubfolders: false, deleteContents: false}),
						options: {
							top: Math.min(li[0].offsetTop, window.innerHeight - 350),
							left: window.innerWidth - 720,
							width: 400
						}
					});
				}
			},
			{
				name: "FOLDER.Delete",
				icon: '<i class="fas fa-dumpster"></i>',
				condition: game.user.isGM,
				callback: header => {
					const li = header.parent();
					const folder = game.folders.get(li.data("folderId"));
					Dialog.confirm({
						title: `${game.i18n.localize("FOLDER.Delete")} ${folder.name}`,
						content: game.i18n.localize("FOLDER.DeleteConfirm"),
						yes: () => folder.delete({deleteSubfolders: true, deleteContents: true}),
						options: {
							top: Math.min(li[0].offsetTop, window.innerHeight - 350),
							left: window.innerWidth - 720,
							width: 400
						}
					});
				}
			}
		];
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the set of ContextMenu options which should be used for Entities in a SidebarDirectory
	 * @return {object[]}   The Array of context options passed to the ContextMenu instance
	 * @private
	 */
	_getEntryContextOptions() {
		return [
			{
				name: "FOLDER.Clear",
				icon: '<i class="fas fa-folder"></i>',
				condition: li => {
					const entity = this.constructor.collection.get(li.data("entityId"));
					return game.user.isGM && !!entity.data.folder;
				},
				callback: li => {
					const entity = this.constructor.collection.get(li.data("entityId"));
					entity.update({folder: null});
				}
			},
			{
				name: "SIDEBAR.Delete",
				icon: '<i class="fas fa-trash"></i>',
				condition: () => game.user.isGM,
				callback: li => {
					const entity = this.constructor.collection.get(li.data("entityId"));
					Dialog.confirm({
						title: `${game.i18n.localize("SIDEBAR.Delete")} ${entity.name}`,
						content: game.i18n.localize("SIDEBAR.DeleteConfirm"),
						yes: entity.delete.bind(entity),
						options: {
							top: Math.min(li[0].offsetTop, window.innerHeight - 350),
							left: window.innerWidth - 720
						}
					});
				}
			},
			{
				name: "SIDEBAR.Duplicate",
				icon: '<i class="far fa-copy"></i>',
				condition: () => game.user.isGM,
				callback: li => {
					const entity = this.constructor.collection.get(li.data("entityId"));
					return entity.clone({name: `${entity.name} (Copy)`});
				}
			},
			{
				name: "PERMISSION.Configure",
				icon: '<i class="fas fa-lock"></i>',
				condition: () => game.user.isGM,
				callback: li => {
					const entity = this.constructor.collection.get(li.data("entityId"));
					new PermissionControl(entity, {
						top: Math.min(li[0].offsetTop, window.innerHeight - 350),
						left: window.innerWidth - 720
					}).render(true);
				}
			},
			{
				name: "SIDEBAR.Export",
				icon: '<i class="fas fa-file-export"></i>',
				condition: li => {
					const entity = this.constructor.collection.get(li.data("entityId"));
					return entity.owner;
				},
				callback: li => {
					const entity = this.constructor.collection.get(li.data("entityId"));
					entity.exportToJSON();
				}
			},
			{
				name: "SIDEBAR.Import",
				icon: '<i class="fas fa-file-import"></i>',
				condition: li => {
					const entity = this.constructor.collection.get(li.data("entityId"));
					return entity.owner;
				},
				callback: li => {
					const entity = this.constructor.collection.get(li.data("entityId"));
					entity.importFromJSONDialog();
				}
			}
		];
	}
}

/**
 * The default Actor Sheet
 *
 * This Application is responsible for rendering an actor's attributes and allowing the actor to be edited.
 *
 * System modifications may elect to override this class to better suit their own game system by re-defining the value
 * ``CONFIG.Actor.sheetClass``.
	* @type {BaseEntitySheet}
 *
 * @param actor {Actor}                 The Actor instance being displayed within the sheet.
 * @param [options] {Object}            Additional options which modify the rendering of the Actor's sheet.
 * @param [options.editable] {boolean}  Is the Actor editable? Default is true.
 */
class ActorSheet extends BaseEntitySheet {
	constructor(...args) {
		super(...args);
		 /**
		 * If this Actor Sheet represents a synthetic Token actor, reference the active Token
		 * @type {Token}
		 */
		this.token = this.object.token;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			height: 720,
			width: 800,
			template: "templates/sheets/actor-sheet.html",
			closeOnSubmit: false,
			submitOnClose: true,
			submitOnChange: true,
			resizable: true,
			baseApplication: "ActorSheet",
			dragDrop: [{dragSelector: ".item-list .item", dropSelector: null}]
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	get id() {
		const actor = this.actor;
		let id = `actor-${actor.id}`;
		if (actor.isToken) id += `-${actor.token.id}`;
		return id;
	}
	 /* -------------------------------------------- */
	 /** @override */
	get title() {
		return (this.token && !this.token.data.actorLink) ? `[Token] ${this.actor.name}` : this.actor.name;
	}
	 /* -------------------------------------------- */
	 /**
	 * A convenience reference to the Actor entity
	 * @type {Actor}
	 */
	get actor() {
		return this.object;
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const data = super.getData(options);
		 // Entity data
		data.actor = data.entity;
		data.data = data.entity.data;
		 // Owned items
		data.items = data.actor.items;
		data.items.sort((a, b) => (a.sort || 0) - (b.sort || 0));
		return data;
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _render(force=false, options={}) {
		if ( force ) this.token = options.token || null;
		return super._render(force, options);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_getHeaderButtons() {
		let buttons = super._getHeaderButtons();
		 // Token Configuration
		const canConfigure = game.user.isGM || (this.actor.owner && game.user.can("TOKEN_CONFIGURE"));
		if (this.options.editable && canConfigure) {
			buttons = [
				{
					label: "Sheet",
					class: "configure-sheet",
					icon: "fas fa-cog",
					onclick: ev => this._onConfigureSheet(ev)
				},
				{
					label: this.token ? "Token" : "Prototype Token",
					class: "configure-token",
					icon: "fas fa-user-circle",
					onclick: ev => this._onConfigureToken(ev)
				}
			].concat(buttons);
		}
		return buttons
	}
	 /* -------------------------------------------- */
	/*  Event Listeners                             */
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		 // Support Image updates
		if ( this.options.editable ) {
			html.find('img[data-edit]').click(ev => this._onEditImage(ev));
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle requests to configure the prototype Token for the Actor
	 * @private
	 */
	_onConfigureToken(event) {
		event.preventDefault();
		const token = this.token || new Token(this.actor.data.token || {});
		new TokenConfig(token, {
			left: Math.max(this.position.left - 560 - 10, 10),
			top: this.position.top,
			configureDefault: !this.token
		}).render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle requests to configure the default sheet used by this Actor
	 * @private
	 */
	_onConfigureSheet(event) {
		event.preventDefault();
		new EntitySheetConfig(this.actor, {
			top: this.position.top + 40,
			left: this.position.left + ((this.position.width - 400) / 2)
		}).render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle changing the actor profile image by opening a FilePicker
	 * @private
	 */
	_onEditImage(event) {
		const attr = event.currentTarget.dataset.edit;
		const current = getProperty(this.actor.data, attr);
		const fp = new FilePicker({
			type: "image",
			current: current,
			callback: path => {
				event.currentTarget.src = path;
				this._onSubmit(event);
			},
			top: this.position.top + 40,
			left: this.position.left + 10
		});
		return fp.browse();
	}
	 /* -------------------------------------------- */
	 /** @override */
	_updateObject(event, formData) {
		const diffData = diffObject(this.actor.data, expandObject(formData));
		return super._updateObject(event, diffData);
	}
	 /* -------------------------------------------- */
	/*  Drag and Drop                               */
	/* -------------------------------------------- */
	 /** @override */
	_canDragStart(selector) {
		return this.options.editable && this.actor.owner;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_canDragDrop(selector) {
		return this.options.editable && this.actor.owner;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragStart(event) {
		const li = event.currentTarget;
		if ( event.target.classList.contains("entity-link") ) return;
		 // Create drag data
		const dragData = {
			actorId: this.actor.id,
			sceneId: this.actor.isToken ? canvas.scene?.id : null,
			tokenId: this.actor.isToken ? this.actor.token.id : null
		};
		 // Owned Items
		if ( li.dataset.itemId ) {
			const item = this.actor.items.get(li.dataset.itemId);
			dragData.type = "Item";
			dragData.data = item.data;
		}
		 // Active Effect
		if ( li.dataset.effectId ) {
			const effect = this.actor.effects.get(li.dataset.effectId);
			dragData.type = "ActiveEffect";
			dragData.data = effect.data;
		}
		 // Set data transfer
		event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _onDrop(event) {
		 // Try to extract the data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData('text/plain'));
		} catch (err) {
			return false;
		}
		const actor = this.actor;
		 // Handle the drop with a Hooked function
		const allowed = Hooks.call("dropActorSheetData", actor, this, data);
		if ( allowed === false ) return;
		 // Handle different data types
		switch ( data.type ) {
			case "ActiveEffect":
				return this._onDropActiveEffect(event, data);
			case "Actor":
				return this._onDropActor(event, data);
			case "Item":
				return this._onDropItem(event, data);
			case "Folder":
				return this._onDropFolder(event, data);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the dropping of ActiveEffect data onto an Actor Sheet
	 * @param {DragEvent} event     The concluding DragEvent which contains drop data
	 * @param {Object} data         The data transfer extracted from the event
	 * @return {Promise<Object>}    A data object which describes the result of the drop
	 * @private
	 */
	async _onDropActiveEffect(event, data) {
		const actor = this.actor;
		if ( !actor.owner ) return;
		let sameActor = (data.actorId === actor._id) || (actor.isToken && (data.tokenId === actor.token.id));
		if ( sameActor ) return;
		const effect = await ActiveEffect.fromDropData(data);
		if ( !effect ) return;
		return this.actor.createEmbeddedEntity("ActiveEffect", effect.data);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle dropping of an Actor data onto another Actor sheet
	 * @param {DragEvent} event     The concluding DragEvent which contains drop data
	 * @param {Object} data         The data transfer extracted from the event
	 * @return {Promise<Object>}    A data object which describes the result of the drop
	 * @private
	 */
	async _onDropActor(event, data) {
		if ( !this.actor.owner ) return false;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle dropping of an item reference or item data onto an Actor Sheet
	 * @param {DragEvent} event     The concluding DragEvent which contains drop data
	 * @param {Object} data         The data transfer extracted from the event
	 * @return {Promise<Object>}    A data object which describes the result of the drop
	 * @private
	 */
	async _onDropItem(event, data) {
		if ( !this.actor.owner ) return false;
		const item = await Item.fromDropData(data);
		const itemData = duplicate(item.data);
		 // Handle item sorting within the same Actor
		const actor = this.actor;
		let sameActor = (data.actorId === actor._id) || (actor.isToken && (data.tokenId === actor.token.id));
		if (sameActor) return this._onSortItem(event, itemData);
		 // Create the owned item
		return this._onDropItemCreate(itemData);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle dropping of a Folder on an Actor Sheet.
	 * Currently supports dropping a Folder of Items to create all items as owned items.
	 * @param {DragEvent} event     The concluding DragEvent which contains drop data
	 * @param {Object} data         The data transfer extracted from the event
	 * @return {Promise<Object>}    A data object which describes the result of the drop
	 * @private
	 */
	async _onDropFolder(event, data) {
		if ( !this.actor.owner ) return false;
		if ( data.entity !== "Item" ) return;
		const folder = game.folders.get(data.id);
		if ( !folder ) return;
		return this._onDropItemCreate(folder.entities.map(e => e.data));
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the final creation of dropped Item data on the Actor.
	 * This method is factored out to allow downstream classes the opportunity to override item creation behavior.
	 * @param {object} itemData     The item data requested for creation
	 * @return {Promise<Actor>}
	 * @private
	 */
	async _onDropItemCreate(itemData) {
		return this.actor.createEmbeddedEntity("OwnedItem", itemData);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a drop event for an existing Owned Item to sort that item
	 * @param {Event} event
	 * @param {Object} itemData
	 * @private
	 */
	_onSortItem(event, itemData) {
		 // TODO - for now, don't allow sorting for Token Actor overrides
		if (this.actor.isToken) return;
		 // Get the drag source and its siblings
		const source = this.actor.getOwnedItem(itemData._id);
		const siblings = this.actor.items.filter(i => {
			return (i.data.type === source.data.type) && (i.data._id !== source.data._id);
		});
		 // Get the drop target
		const dropTarget = event.target.closest(".item");
		const targetId = dropTarget ? dropTarget.dataset.itemId : null;
		const target = siblings.find(s => s.data._id === targetId);
		 // Ensure we are only sorting like-types
		if (target && (source.data.type !== target.data.type)) return;
		 // Perform the sort
		const sortUpdates = SortingHelpers.performIntegerSort(source, {target: target, siblings});
		const updateData = sortUpdates.map(u => {
			const update = u.update;
			update._id = u.target.data._id;
			return update;
		});
		 // Perform the update
		return this.actor.updateEmbeddedEntity("OwnedItem", updateData);
	}
}
/**
 * Configure the Combat tracker to display additional information as appropriate
 * @type {FormApplication}
 */
class CombatTrackerConfig extends FormApplication {
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "combat-config",
			title: game.i18n.localize("COMBAT.Settings"),
			classes: ["sheet", "combat-sheet"],
			template: "templates/sheets/combat-config.html",
			width: 420
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	async getData(options) {
		return {
			settings: game.settings.get("core", Combat.CONFIG_SETTING),
			attributeChoices: this.getAttributeChoices()
		};
	};
	 /* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		return game.settings.set("core", Combat.CONFIG_SETTING, {
			resource: formData.resource,
			skipDefeated: formData.skipDefeated
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Get an Array of attribute choices which could be tracked for Actors in the Combat Tracker
	 * @return {Promise<Array>}
	 */
	getAttributeChoices() {
		const actorData = {};
		for ( let model of Object.values(game.system.model.Actor) ) {
			mergeObject(actorData, model);
		}
		const attributes = TokenConfig.getTrackedAttributes(actorData, []);
		attributes.bar.forEach(a => a.push("value"));
		return TokenConfig.getTrackedAttributeChoices(attributes);
	}
}

/**
 * Configure or create a single Combatant within a Combat entity.
 * @type {FormApplication}
 */
class CombatantConfig extends FormApplication {
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "combatant-config",
			title: game.i18n.localize("COMBAT.CombatantConfig"),
			classes: ["sheet", "combat-sheet"],
			template: "templates/sheets/combatant-config.html",
			width: 420
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	get title() {
		return game.i18n.localize(this.object._id ? "COMBAT.CombatantUpdate" : "COMBAT.CombatantCreate");
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		if ( this.object._id ) {
			formData._id = this.object._id;
			return game.combat.updateCombatant(formData);
		}
		return game.combat.createCombatant(formData);
	}
}

/**
 * A form designed for creating and editing an Active Effect on an Actor or Item entity.
 * @implements {FormApplication}
 *
 * @param {ActiveEffect} object     The target active effect being configured
 * @param {object} [options]        Additional options which modify this application instance
 */
class ActiveEffectConfig extends FormApplication {
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			classes: ["sheet", "active-effect-sheet"],
			title: "EFFECT.ConfigTitle",
			template: "templates/sheets/active-effect-config.html",
			width: 560,
			height: "auto",
			tabs: [{navSelector: ".tabs", contentSelector: "form", initial: "details"}]
		});
	}
	 /* ----------------------------------------- */
	 /** @override */
	get title() {
		return `${game.i18n.localize("EFFECT.ConfigTitle")}: ${this.object.data.label}`;
	}
	 /* ----------------------------------------- */
	 /** @override */
	getData(options) {
		return {
			effect: duplicate(this.object.data),
			isActorEffect: this.object.parent.entity === "Actor",
			isItemEffect: this.object.parent.entity === "Item",
			submitText: "EFFECT.Submit",
			modes: Object.entries(CONST.ACTIVE_EFFECT_MODES).reduce((obj, e) => {
				obj[e[1]] = game.i18n.localize("EFFECT.MODE_"+e[0]);
				return obj;
			}, {})
		};
	}
	 /* ----------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find(".effect-control").click(this._onEffectControl.bind(this));
	}
	 /* ----------------------------------------- */
	 /**
	 * Provide centralized handling of mouse clicks on control buttons.
	 * Delegate responsibility out to action-specific handlers depending on the button action.
	 * @param {MouseEvent} event      The originating click event
	 * @private
	 */
	_onEffectControl(event) {
		event.preventDefault();
		const button = event.currentTarget;
		switch ( button.dataset.action ) {
			case "add":
				this._addEffectChange(button);
				return this.submit({preventClose: true}).then(() => this.render());
			case "delete":
				button.closest(".effect-change").remove();
				return this.submit({preventClose: true}).then(() => this.render());
		}
	}
	 /* ----------------------------------------- */
	 /**
	 * Handle adding a new change to the changes array.
	 * @param {HTMLElement} button    The clicked action button
	 * @private
	 */
	_addEffectChange(button) {
		const changes = button.closest(".tab").querySelector(".changes-list");
		const last = changes.lastElementChild;
		const idx = last ? last.dataset.index+1 : 0;
		const change = $(`
		<li class="effect-change flexrow" data-index="${idx}">
				<input type="text" name="changes.${idx}.key" value=""/>
				<input type="number" name="changes.${idx}.mode" value="2"/>
				<input type="text" name="changes.${idx}.value" value=""/>
		</li>`);
		changes.appendChild(change[0]);
	}
	 /* ----------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		formData = expandObject(formData);
		formData.changes = Object.values(formData.changes || {});
		for ( let c of formData.changes ) {
			// TODO - store as numeric when it's unambiguous, remove this later. See #4309
			const n = parseFloat(c.value)
			if ( String(n) === c.value ) c.value = n;
		}
		return this.object.update(formData);
	}
}

/**
 * Edit a folder, configuring its name and appearance
 * @extends {FormApplication}
 */
class FolderConfig extends FormApplication {
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			classes: ["sheet", "folder-edit"],
			template: "templates/sidebar/folder-edit.html",
			width: 360
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	get id() {
		return this.object.id ? `folder-edit-${this.object.id}` : "folder-create";
	}
	 /* -------------------------------------------- */
	 /** @override */
	get title() {
		if ( this.object._id ) return `${game.i18n.localize("FOLDER.Update")}: ${this.object.name}`;
		return game.i18n.localize("FOLDER.Create");
	}
	 /* -------------------------------------------- */
	 /** @override */
	async getData(options) {
		return {
			folder: this.object.data,
			sortingModes: {"a": "FOLDER.SortAlphabetical", "m": "FOLDER.SortManual"},
			submitText: game.i18n.localize(this.object._id ? "FOLDER.Update" : "FOLDER.Create")
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		if ( !formData.parent ) formData.parent = null;
		if ( !this.object._id ) return Folder.create(mergeObject(this.object.data, formData));
		return this.object.update(formData);
	}
}

/**
 * A tool for fine tuning the grid in a Scene
 * @extends {FormApplication}
 */
class GridConfig extends FormApplication {
	constructor(scene, sheet, ...args) {
		super(scene, ...args);
		 /**
		 * Track the Scene Configuration sheet reference
		 * @type {SceneConfig}
		 */
		this.sheet = sheet;
		 /**
		 * The counter-factual dimensions being evaluated
		 * @type {Object}
		 */
		this._dimensions = {};
		 /**
		 * A reference to the bound key handler function so it can be removed
		 * @type {Function|null}
		 * @private
		 */
		this._keyHandler = null;
		 /**
		 * A reference to the bound mousewheel handler function so it can be removed
		 * @type {Function|null}
		 * @private
		 */
		this._wheelHandler = null;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "grid-config",
			template: "templates/scene/grid-config.html",
			title: game.i18n.localize("SCENES.GridConfigTool"),
			width: 480,
			height: "auto",
			closeOnSubmit: true,
			submitOnChange: true
		});
	}
	/* -------------------------------------------- */
	 /** @override */
	getData(options) {
		return {
			gridTypes: SceneConfig._getGridTypes(),
			scale: canvas.background.img ? this.object.data.width / canvas.background.img.texture.width : 1,
			scene: this.object.data
		};
	}
	/* -------------------------------------------- */
	 /** @override */
	async _render(...args) {
		await super._render(...args);
		if ( !this.object.data.img ) {
			ui.notifications.warn(game.i18n.localize("WARNING.GridConfigNoBG"));
		}
		for ( let l of canvas.layers ) {
			if ( !["BackgroundLayer", "GridLayer"].includes(l.name) ) l.visible = false;
		}
		this._refresh({grid: true, background: true});
	}
	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		this._keyHandler = this._keyHandler || this._onKeyDown.bind(this);
		document.addEventListener("keydown", this._keyHandler);
		this._wheelHandler = this._wheelHandler || this._onWheel.bind(this);
		document.addEventListener("wheel", this._wheelHandler, {passive: false});
		html.find('button[name="reset"]').click(this._onReset.bind(this));
	}
	/* -------------------------------------------- */
	 /** @override */
	async close(options) {
		document.removeEventListener("keydown", this._keyHandler);
		document.removeEventListener("wheel", this._wheelHandler);
		this._keyHandler = this._wheelHandler = null;
		if ( canvas.ready ) await canvas.draw();
		await this.sheet.maximize();
		return super.close(options);
	}
	/* -------------------------------------------- */
	 /**
	 * Handle resetting the form and re-drawing back to the original dimensions
	 * @param {KeyboardEvent} event    The original keydown event
	 * @private
	 */
	_onKeyDown(event) {
		const key = game.keyboard.getKey(event);
		if ( !(key in game.keyboard.moveKeys) || game.keyboard.hasFocus ) return;
		event.preventDefault();
		 const up = ["w", "W", "ArrowUp"];
		const down = ["s", "S", "ArrowDown"];
		const left = ["a", "A", "ArrowLeft"];
		const right = ["d", "D", "ArrowRight"];
		 // Increase the Scene scale on shift + up or down
		if ( event.shiftKey ) {
			let delta = up.includes(key) ? 1 : (down.includes(key) ? -1 : 0);
			this._scaleBackgroundSize(delta);
		}
		 // Resize grid size on ALT
		else if ( event.altKey ) {
			let delta = up.includes(key) ? 1 : (down.includes(key) ? -1 : 0);
			this._scaleGridSize(delta);
		}
		 // Shift grid position
		else {
			if ( up.includes(key) ) this._shiftBackground({deltaY: -1});
			else if ( down.includes(key) ) this._shiftBackground({deltaY: 1});
			else if ( left.includes(key) ) this._shiftBackground({deltaX: -1});
			else if ( right.includes(key) ) this._shiftBackground({deltaX: 1});
		}
	}
	/* -------------------------------------------- */
	 /**
	 * Handle resetting the form and re-drawing back to the original dimensions
	 * @param {WheelEvent} event    The original wheel event
	 * @private
	 */
	_onWheel(event) {
		if ( event.deltaY === 0 ) return;
		 // Increase the Scene scale on shift
		if ( event.shiftKey ) {
			event.preventDefault();
			event.stopImmediatePropagation();
			this._scaleBackgroundSize(-Math.sign(event.deltaY));
		}
		 // Increase the Grid scale on alt
		if ( event.altKey ) {
			event.preventDefault();
			event.stopImmediatePropagation();
			this._scaleGridSize(-Math.sign(event.deltaY));
		}
	}
	/* -------------------------------------------- */
	 /**
	 * Handle resetting the form and re-drawing back to the original dimensions
	 * @param {MouseEvent} event    The original click event
	 * @private
	 */
	_onReset(event) {
		event.preventDefault();
		this._dimensions = {};
		this.render();
	}
	/* -------------------------------------------- */
	/*  Previewing and Updating Functions           */
	/* -------------------------------------------- */
	 /**
	 * Scale the background size relative to the grid size
	 * @param {number} delta          The directional change in background size
	 * @private
	 */
	_scaleBackgroundSize(delta) {
		const scale = Math.round((parseFloat(this.form.scale.value) + (0.05 * delta)) * 100) / 100;
		this.form.scale.value = Math.clamped(scale, 0.25, 10.0);
		this._refresh({background: true});
	}
	/* -------------------------------------------- */
	 /**
	 * Scale the grid size relative to the background image.
	 * When scaling the grid size in this way, constrain the allowed values between 50px and 300px.
	 * @param {number} delta          The grid size in pixels
	 * @private
	 */
	_scaleGridSize(delta) {
		this.form.grid.value = Math.clamped(parseInt(this.form.grid.value) + delta, 50, 300);
		this._refresh({grid: true});
	}
	/* -------------------------------------------- */
	 /**
	 * Shift the background image relative to the grid layer
	 * @param {number} deltaX         The number of pixels to shift in the x-direction
	 * @param {number} deltaY         The number of pixels to shift in the y-direction
	 * @private
	 */
	_shiftBackground({deltaX=0, deltaY=0}={}) {
		this.form.shiftX.value = parseInt(this.form.shiftX.value) + deltaX;
		this.form.shiftY.value = parseInt(this.form.shiftY.value) + deltaY;
		this._refresh({background: true});
	}
	/* -------------------------------------------- */
	 /**
	 * Temporarily refresh the display of the BackgroundLayer and GridLayer for the new pending dimensions
	 * @param {boolean} background      Refresh the background display?
	 * @param {boolean} grid            Refresh the grid display?
	 * @private
	 */
	_refresh({background=false, grid=false}={}) {
		const form = this.form;
		const bg = canvas.background.img;
		const tex = bg ? bg.texture : {width: canvas.scene.data.width, height: canvas.scene.data.height};
		 // Establish new Scene dimensions
		const scale = parseFloat(form.scale.value);
		const d = this._dimensions = Canvas.getDimensions({
			width: tex.width * scale,
			height: tex.height * scale,
			padding: this.object.data.padding,
			grid: Math.max(parseInt(form.grid.value), 50),
			gridDistance: this.object.data.gridDistance,
			shiftX: parseInt(form.shiftX.value),
			shiftY: parseInt(form.shiftY.value)
		});
		canvas.dimensions = d;
		 // Update the background
		if ( background && bg ) {
			bg.position.set(d.paddingX - d.shiftX, d.paddingY - d.shiftY);
			bg.width = d.sceneWidth;
			bg.height = d.sceneHeight;
			grid = true;
		}
		 // Update the grid layer
		if ( grid ) {
			canvas.grid.tearDown();
			canvas.grid.draw({type: parseInt(form.gridType.value), dimensions: d, gridColor: 0xFF0000, gridAlpha: 1.0});
			canvas.stage.hitArea = new PIXI.Rectangle(0, 0, d.width, d.height);
		}
	}
	/* -------------------------------------------- */
	 /** @override */
	_onChangeInput(event) {
		event.preventDefault();
		this._refresh({background: true, grid: true});
	}
	/* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		formData.width = Math.round(this._dimensions.sceneWidth);
		formData.height = Math.round(this._dimensions.sceneHeight);
		return this.object.update(formData, {fromSheet: true});
	}
}

/**
 * An Image Popout Application which features a single image in a lightbox style frame.
 * This popout can also be used as a form, allowing the user to edit an image which is being used.
 * Furthermore, this application allows for sharing the display of an image with other connected players.
 * @extends {FormApplication}
 *
 * @example
 * // Construct the Application instance
 * const ip = new ImagePopout("path/to/image.jpg", {
 *   title: "My Featured Image",
 *   shareable: true,
 *   entity: game.actors.getName("My Hero")
 * });
 *
 * // Display the image popout
 * ip.render(true);
 *
 * // Share the image with other connected players
 * ip.share();
 */
class ImagePopout extends FormApplication {
	constructor(src, options={}) {
		super(src, options);
		this._related = null;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
	 const options = super.defaultOptions;
	 mergeObject(options, {
			template: "templates/apps/image-popout.html",
			classes: ["image-popout", "dark"],
			editable: false,
			resizable: true,
			shareable: false,
			uuid: null
		});
	 return options;
	}
	 /* -------------------------------------------- */
	 /** @override */
	get title() {
		return this.isTitleVisible() ? super.title : "";
	}
	 /* -------------------------------------------- */
	 /** @override */
	async getData(options) {
		const data = super.getData();
		await this.getRelatedObject();
		data.showTitle = this.isTitleVisible();
		data.image = this.object;
		return data;
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether the title of the image popout should be visible to the user
	 * @returns {boolean}
	 */
	isTitleVisible() {
		if ( this._related && this._related["hasPerm"] ) {
			return this._related.hasPerm(game.user, "LIMITED");
		}
		return true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Provide a reference to the Entity referenced by this popout, if one exists
	 * @return {Promise<*>}
	 */
	async getRelatedObject() {
		if ( this.options.uuid && !this._related ) {
			this._related = await fromUuid(this.options.uuid);
		}
		return this._related;
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _render(...args) {
		this.position = await this.constructor.getPosition(this.object);
		return super._render(...args);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_getHeaderButtons() {
		let buttons = super._getHeaderButtons();
		if ( game.user.isGM && this.options.shareable ) {
			buttons.unshift({
				label: "JOURNAL.ActionShow",
				class: "share-image",
				icon: "fas fa-eye",
				onclick: ev => this.shareImage()
			});
		}
		return buttons
	}
	 /* -------------------------------------------- */
	/*  Helper Methods
	/* -------------------------------------------- */
	 /**
	 * Determine the correct position and dimensions for the displayed image
	 * @returns {Object}    The positioning object which should be used for rendering
	 * @private
	 */
	static async getPosition(img) {
		if ( !img ) return { width: 720, height: window.innerHeight * 0.8 };
		const position = {};
		let size;
		try {
			size = await this.getImageSize(img);
		} catch(err) {
			return { width: 720, height: window.innerHeight * 0.8 };
		}
		let wh = window.innerHeight,
				ww = window.innerWidth,
				wr = window.innerWidth / window.innerHeight,
				ir = size[0] / size[1];
		if (ir > wr) {
			position.width = Math.min(size[0] * 2, parseInt(0.95 * ww));
			position.height = parseInt(position.width / ir);
		} else {
			position.height = Math.min(size[1] * 2, parseInt(0.95 * wh));
			position.width = parseInt(position.height * ir);
		}
		position.top = (wh - position.height) / 2;
		position.left = (ww - position.width) / 2;
		return position;
	}
	 /* -------------------------------------------- */
	 /**
	 * Determine the Image dimensions given a certain path
	 * @return {Promise<Array.<Number>>}
	 */
	static getImageSize(path) {
		return new Promise((resolve, reject) => {
			let img = new Image();
			img.onload = function() {
				resolve([this.width, this.height]);
			};
			img.onerror = reject;
			img.src = path;
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Share the displayed image with other connected Users
	 */
	shareImage() {
		game.socket.emit("shareImage", {
			image: this.object,
			title: this.options.title,
			uuid: this.options.uuid
		});
		ui.notifications.info(game.i18n.format("JOURNAL.ActionShowSuccess", {
			mode: "image",
			title: this.options.title,
			which: "all"
		}));
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a received request to display an image.
	 * @param {string} image
	 * @param {string} title
	 * @param {string} uuid
	 * @return {ImagePopout}
	 * @private
	 */
	static _handleShareImage({image, title, uuid}={}) {
		return new ImagePopout(image, {
			title: title,
			uuid: uuid,
			shareable: false,
			editable: false
		}).render(true);
	}
}

/**
 * The default Item Sheet
 *
 * This Application is responsible for rendering an item's attributes and allowing the item to be edited.
 *
 * System modifications may elect to override this class to better suit their own game system by re-defining the value
 * ``CONFIG.Item.sheetClass``.
	* @type {BaseEntitySheet}
 *
 * @param item {Item}                   The Item instance being displayed within the sheet.
 * @param [options] {Object}            Additional options which modify the rendering of the item.
 */
class ItemSheet extends BaseEntitySheet {
	constructor(...args) {
		super(...args);
		if ( this.actor ) {
			this.actor.apps[this.appId] = this;
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			template: "templates/sheets/item-sheet.html",
			width: 500,
			closeOnSubmit: false,
			submitOnClose: true,
			submitOnChange: true,
			resizable: true,
			baseApplication: "ItemSheet"
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	get id() {
		if (this.actor) return `actor-${this.actor.id}-item-${this.item.id}`;
		else return `item-${this.object.id}`;
	}
	 /* -------------------------------------------- */
	 /**
	 * A convenience reference to the Item entity
	 * @type {Item}
	 */
	get item() {
		return this.object;
	}
	 /* -------------------------------------------- */
	 /**
	 * The Actor instance which owns this item. This may be null if the item is unowned.
	 * @type {Actor}
	 */
	get actor() {
		return this.item.actor;
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const data = super.getData(options);
		data.item = data.entity;
		data.data = data.entity.data;
		return data;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_getHeaderButtons() {
		let buttons = super._getHeaderButtons();
		let canConfigure = this.isEditable && game.user.isGM;
		if (!canConfigure) return buttons;
		 // Add a Sheet Configuration button
		buttons.unshift({
			label: "Sheet",
			class: "configure-sheet",
			icon: "fas fa-cog",
			onclick: ev => this._onConfigureSheet(ev)
		});
		return buttons;
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		if (!this.options.editable) return;
		html.find('img[data-edit]').click(ev => this._onEditImage(ev));
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle requests to configure the default sheet used by this Item
	 * @private
	 */
	_onConfigureSheet(event) {
		event.preventDefault();
		new EntitySheetConfig(this.item, {
			top: this.position.top + 40,
			left: this.position.left + ((this.position.width - 400) / 2)
		}).render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle changing the item image
	 * @private
	 */
	_onEditImage(event) {
		const attr = event.currentTarget.dataset.edit;
		const current = getProperty(this.item.data, attr);
		const fp = new FilePicker({
			type: "image",
			current: current,
			callback: path => {
				event.currentTarget.src = path;
				if ( this.options.submitOnChange ) {
					this._onSubmit(event);
				}
			},
			top: this.position.top + 40,
			left: this.position.left + 10
		});
		return fp.browse();
	}
}

/**
 * The JournalEntry Configuration Sheet
 * @implements {BaseEntitySheet}
 *
 * @param {JournalEntry} entity     The JournalEntry instance which is being edited
 * @param {object} [options]        Application options
 */
class JournalSheet extends BaseEntitySheet {
	constructor(object, options={}) {
		super(object, options);
		this._sheetMode = this.options.sheetMode || this._inferDefaultMode();
	}
	/* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			classes: ["sheet", "journal-sheet"],
			width: 720,
			height: 800,
			resizable: true,
			closeOnSubmit: false,
			submitOnClose: true,
			viewPermission: ENTITY_PERMISSIONS.NONE
		});
	}
	/* -------------------------------------------- */
	 /** @override */
	get id() {
	 return `journal-${this.object.id}`;
	}
	 /* -------------------------------------------- */
	 /** @override */
	get template() {
		if ( this._sheetMode === "image" ) return ImagePopout.defaultOptions.template;
		return "templates/journal/sheet.html";
	}
	 /* -------------------------------------------- */
	 /** @override */
	get title() {
		return this.object.permission ? this.object.name : "";
	}
	/* -------------------------------------------- */
	 /**
	 * Guess the default view mode for the sheet based on the player's permissions to the Entry
	 * @return {string}
	 * @private
	 */
	_inferDefaultMode() {
		const hasImage = !!this.object.data.img;
		const hasText = this.object.data.content;
		 // If the user only has limited permission, show an image or nothing
		if ( this.object.limited ) return hasImage ? "image" : null;
		 // Otherwise prefer text if it exists
		return hasText || !hasImage ? "text" : "image";
	}
	/* -------------------------------------------- */
	 /** @override */
	async _render(force, options={}) {
		 // Determine the sheet rendering mode
		const mode = options.sheetMode || this._sheetMode;
		if ( mode === null ) return false;
		if ( (mode === this._sheetMode) && this.rendered ) return super._render(force, options);
		 // Asynchronously begin closing the current sheet
		let promises = [this.close({submit: false})];
		 // Update image sizing
		if ( mode === "image" ) {
			const img = this.object.data.img;
			if ( img ) promises.push(ImagePopout.getPosition(img).then(position => {
				this.position = position;
			}));
			options.classes = this.options.classes.concat(ImagePopout.defaultOptions.classes);
		}
		 // Update text sizing
		else if ( mode === "text" ) {
			this.position = { width: this.options.width, height: this.options.height };
		}
		 // Render the new sheet once things are processed
		return Promise.all(promises).then(() => {
			this._sheetMode = mode;
			return super._render(force, options);
		});
	}
	/* -------------------------------------------- */
	 /** @override */
	_getHeaderButtons() {
		const buttons = super._getHeaderButtons();
		const isOwner = this.object.owner;
		const atLeastLimited = !!this.object.compendium || this.object.hasPerm(game.user, "LIMITED");
		const atLeastObserver = !!this.object.compendium || this.object.hasPerm(game.user, "OBSERVER");
		const hasMultipleModes = !!this.object.data.img && !!this.object.data.content;
		 // Image Mode
		if ( isOwner || (atLeastLimited && hasMultipleModes) ) {
			buttons.unshift({
				label: "JOURNAL.ModeImage",
				class: "entry-image",
				icon: "fas fa-image",
				onclick: ev => this._onSwapMode(ev, "image")
			})
		}
		 // Text Mode
		if ( isOwner || (atLeastObserver && hasMultipleModes) ) {
			buttons.unshift({
				label: "JOURNAL.ModeText",
				class: "entry-text",
				icon: "fas fa-file-alt",
				onclick: ev => this._onSwapMode(ev, "text")
			})
		}
		 // Share Entry
		if ( game.user.isGM ) {
			buttons.unshift({
				label: "JOURNAL.ActionShow",
				class: "share-image",
				icon: "fas fa-eye",
				onclick: ev => this._onShowPlayers(ev)
			});
		}
		return buttons;
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const data = super.getData(options);
		data.title = this.title; // Needed for image mode
		data.image = this.object.data.img;
		data.folders = game.folders.filter(f => (f.data.type === "JournalEntry") && f.displayed);
		return data
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		if ( this._sheetMode === "image" ) {
			formData.name = formData.title;
			delete formData["title"];
			formData.img = formData.image;
			delete formData["image"];
		}
		return super._updateObject(event, formData);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle requests to switch the rendered mode of the Journal Entry sheet
	 * Save the form before triggering the show request, in case content has changed
	 * @param {Event} event   The triggering click event
	 * @param {string} mode   The journal mode to display
	 */
	async _onSwapMode(event, mode) {
		event.preventDefault();
		await this.submit();
		this.render(true, {sheetMode: mode});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle requests to show the referenced Journal Entry to other Users
	 * Save the form before triggering the show request, in case content has changed
	 * @param {Event} event   The triggering click event
	 */
	async _onShowPlayers(event) {
		event.preventDefault();
		await this.submit();
		return this.object.show(this._sheetMode, true);
	}
}

/**
 * A Macro configuration sheet
 * @extends {BaseEntitySheet}
 *
 * @see {@link Macro} The Macro Entity which is being configured
 */
class MacroConfig extends BaseEntitySheet {
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			classes: ["sheet", "macro-sheet"],
			template: "templates/sheets/macro-config.html",
			width: 560,
			height: 480,
			resizable: true
		});
	}
	/* -------------------------------------------- */
	 /** @override */
	get id() {
		return `macro-config-${this.object._id}`;
	}
	/* -------------------------------------------- */
	 /** @override */
	getData() {
		const data = super.getData();
		data.macroTypes = duplicate(game.system.entityTypes.Macro);
		if ( !Macros.canUseScripts(game.user) ) data.macroTypes.findSplice(t => t === "script");
		data.macroScopes = CONST.MACRO_SCOPES;
		return data;
	}
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find('img[data-edit="img"]').click(ev => this._onEditImage(ev));
		html.find("button.execute").click(this._onExecute.bind(this));
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle changing the actor profile image by opening a FilePicker
	 * @private
	 */
	_onEditImage(event) {
		const fp = new FilePicker({
			type: "image",
			current: this.object.data.img,
			callback: path => {
				event.currentTarget.src = path;
				this._onSubmit(event, {preventClose: true});
			},
			top: this.position.top + 40,
			left: this.position.left + 10
		})
		return fp.browse();
	}
	 /* -------------------------------------------- */
	 /**
	 * Save and execute the macro using the button on the configuration sheet
	 * @param {MouseEvent} event      The originating click event
	 * @return {Promise<void>}
	 * @private
	 */
	async _onExecute(event) {
		event.preventDefault();
		await this._onSubmit(event, {preventClose: true}); // Submit pending changes
		this.object.execute(); // Execute the macro
	}
		/* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		if ( !this.object.data._id ) {
			return Macro.create(formData);
		} else {
			return super._updateObject(event, formData);
		}
	}
}

/**
 * A configuration Form Application for modifying the properties of a MeasuredTemplate object.
 * @extends {FormApplication}
 * @see {@link MeasuredTemplate}
 */
class MeasuredTemplateConfig extends FormApplication {
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 id: "template-config",
			classes: ["sheet", "template-sheet"],
			title: "Measurement Template Configuration",
			template: "templates/scene/template-config.html",
			width: 400
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData() {
		return {
			object: duplicate(this.object.data),
			options: this.options,
			templateTypes: CONFIG.MeasuredTemplate.types,
			gridUnits: canvas.scene.data.gridUnits,
			submitText: this.options.preview ? "Create" : "Update"
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		if ( this.object.id ) {
			formData["id"] = this.object.id;
			return this.object.update(formData);
		}
		return this.object.constructor.create(formData);
	}
}

/**
 * A generic application for configuring permissions for various Entity types
 * @extends {BaseEntitySheet}
 */
class PermissionControl extends BaseEntitySheet {
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
			id: "permission",
			template: "templates/apps/permission.html",
			width: 400
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	get title() {
		return `${game.i18n.localize("PERMISSION.Title")}: ${this.entity.name}`;
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const e = this.entity;
		const isFolder = e instanceof Folder;
		 // User permission levels
		const playerLevels = {};
		if ( isFolder ) {
			playerLevels["-2"] = game.i18n.localize("PERMISSION.DEFAULT");
			playerLevels["-1"] = game.i18n.localize("PERMISSION.NOCHANGE");
		} else {
			playerLevels["-1"] = game.i18n.localize("PERMISSION.DEFAULT");
		}
		for ( let [n, l] of Object.entries(CONST.ENTITY_PERMISSIONS) ) {
			playerLevels[l] = game.i18n.localize(`PERMISSION.${n}`);
		}
		 // Default permission levels
		const defaultLevels = duplicate(playerLevels);
		if ( isFolder ) delete defaultLevels["-2"];
		else delete defaultLevels["-1"];
		 // Player users
		const users = game.users.map(u => {
			return {
				user: u,
				level: e.data.permission?.[u._id] ?? "-1"
			};
		});
		 // Construct and return the data object
		return {
			entity: e,
			currentDefault: e.data.permission?.default ?? "-1",
			instructions: game.i18n.localize(isFolder ? "PERMISSION.HintFolder" : "PERMISSION.HintEntity"),
			defaultLevels,
			playerLevels,
			isFolder,
			users
		};
	}
	 /* -------------------------------------------- */
	 /** @override */
 async _updateObject(event, formData) {
		event.preventDefault();
		if (!game.user.isGM) throw new Error("You do not have the ability to configure permissions.");
		 // Collect user permissions
		const perms = {};
		for ( let [user, level] of Object.entries(formData) ) {
			if ( (name !== "default") && (level === "-1") ) {
				delete perms[user];
				continue;
			}
			perms[user] = parseInt(level);
		}
		 // Update all entities in a Folder
		if ( this.entity instanceof Folder ) {
			const cls = CONFIG[this.entity.type].entityClass;
			const updates = this.entity.content.map(e => {
				const p = duplicate(e.data.permission);
				for ( let [k, v] of Object.entries(perms) ) {
					if ( v === -2 ) delete p[k];
					else p[k] = v;
				}
				return {_id: e.id, permission: p}
			});
			return cls.update(updates, {diff: false, recursive: false, noHook: true});
		}
		 // Update a single Entity
		return this.entity.update({permission: perms}, {diff: false, recursive: false, noHook: true});
	}
}

/**
 * The Player Configuration application provides a form used to allow the current client to 
 * edit preferences and configurations about their own User entity.
 * @type {FormApplication}
 * 
 * @param {User} user       The User entity being configured.
 * @param {Object} options  Additional rendering options which modify the behavior of the form.
 */
class PlayerConfig extends FormApplication {
	constructor(user, options) {
		super(user, options);
		this.user = this.object;
		game.actors.apps.push(this);
	}
	/* -------------------------------------------- */
	 /**
	 * Assign the default options which are supported by the entity edit sheet
	 * @type {Object}
	 */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "player-config",
			template: "templates/user/player-config.html",
			width: 400,
			height: "auto"
		})
	}
	 /* -------------------------------------------- */
	 get title() {
		return `${game.i18n.localize("PLAYERS.ConfigTitle")}: ${this.user.name}`;
	}
	 /* -------------------------------------------- */
	 /**
	 * Provide data to the form
	 * @return {Object}   The data provided to the template when rendering the form
	 */
	getData() {
		const controlled = game.users.entities.map(e => e.data.character).filter(a => a);
		const actors = game.actors.entities.filter(a => a.hasPerm(this.user, "OBSERVER") && !controlled.includes(a._id));
		return {
			user: this.user,
			actors: actors,
			options: this.options
		}
	}
	/* -------------------------------------------- */
	 /**
	 * Activate the default set of listeners for the Entity sheet
	 * These listeners handle basic stuff like form submission or updating images
	 *
	 * @param html {JQuery}     The rendered template ready to have listeners attached
	 */
	activateListeners(html) {
		super.activateListeners(html);
		 // When a character is clicked, record it's ID in the hidden input
		let input = html.find('[name="character"]');
		html.find('.actor').click(ev => {
			 // Record the selected actor
			let li = ev.currentTarget;
			let actorId = li.getAttribute("data-actor-id");
			input.val(actorId);
			 // Add context to the selection
			for ( let a of html[0].getElementsByClassName("actor") ) {
				a.classList.remove("context");
			}
			li.classList.add("context");
		});
		 // Release the currently selected character
		html.find('button[name="release"]').click(ev => {
			if ( canvas.tokens ) canvas.tokens.releaseAll();
			this.user.update({character: null}).then(() => this.render(false));
		});
		 // Support Image updates
		html.find('img[data-edit="avatar"]').click(ev => this._onEditAvatar(ev));
	}
	 /* -------------------------------------------- */
		/**
	 * Handle changing the user avatar image by opening a FilePicker
	 * @private
	 */
	_onEditAvatar(event) {
		event.preventDefault();
		const fp = new FilePicker({
			type: "image",
			current: this.user.data.avatar,
			callback: path => {
				event.currentTarget.src = path;
				this._onSubmit(event, {preventClose: true});
			},
			top: this.position.top + 40,
			left: this.position.left + 10
		});
		return fp.browse();
	}
	 /* -------------------------------------------- */
	 /**
	 * This method is called upon form submission after form data is validated
	 * @param event {Event}       The initial triggering submission event
	 * @param formData {Object}   The object of validated form data with which to update the object
	 * @private
	 */
	async _updateObject(event, formData) {
		return this.user.update(formData);
	}
}

/* -------------------------------------------- */
/**
 * Playlist Configuration Sheet
 * @extends {BaseEntitySheet}
 */
class PlaylistConfig extends BaseEntitySheet {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = "playlist-config";
		options.template = "templates/playlist/edit-playlist.html";
		options.width = 360;
		return options;
	}
	 /* -------------------------------------------- */
	 /** @override */
	get title() {
		return `${game.i18n.localize("PLAYLIST.Edit")}: ${this.object.name}`;
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const data = duplicate(this.object.data);
		data.modes = Object.keys(CONST.PLAYLIST_MODES).reduce((obj, val) => {
			obj[val.titleCase()] = CONST.PLAYLIST_MODES[val];
			return obj;
		}, {});
		return data;
	}
}
	/* -------------------------------------------- */
	/**
 * Playlist Sound Configuration Sheet
 * @type {FormApplication}
 *
 * @param {Playlist} playlist   The Playlist entity within which the Sound is configured
 * @param {Object} sound        An Object for the Playlist Sound data
 * @param {Object} options      Additional application rendering options
 */
class PlaylistSoundConfig extends FormApplication {
	constructor(playlist, sound, options) {
		super(sound, options);
		this.playlist = playlist;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "track-config",
			template: "templates/playlist/edit-track.html",
			width: 360
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	get title() {
		return `${game.i18n.localize("PLAYLIST.SoundEdit")}: ${this.object.name}`;
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const data = duplicate(this.object);
		data.lvolume = AudioHelper.volumeToInput(data.volume);
		return data;
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		if (!game.user.isGM) throw "You do not have the ability to edit playlist sounds.";
		formData["volume"] = AudioHelper.inputToVolume(formData["lvolume"]);
		if (this.object._id) {
			formData["_id"] = this.object._id;
			return this.playlist.updateEmbeddedEntity("PlaylistSound", formData, {});
		}
		return this.playlist.createEmbeddedEntity("PlaylistSound", formData, {});
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find('input[name="path"]').change(this._onSourceChange.bind(this));
		return html;
	}
	 /* -------------------------------------------- */
	 /**
	 * Auto-populate the track name using the provided filename, if a name is not already set
	 * @param {Event} event
	 * @private
	 */
	_onSourceChange(event) {
		event.preventDefault();
		const field = event.target;
		const form = field.form;
		if (!form.name.value) form.name.value = field.value.split("/").pop().split(".").shift();
	}
}

/**
 * The RollTable configuration sheet
 * @type {BaseEntitySheet}
 *
 * @param table {RollTable}          The rollable table entity being configured
 * @param options {Object}           Additional application rendering options
 */
class RollTableConfig extends BaseEntitySheet {
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			classes: ["sheet", "roll-table-config"],
			template: "templates/sheets/roll-table-config.html",
			width: 720,
			height: "auto",
			closeOnSubmit: false,
			viewPermission: ENTITY_PERMISSIONS.OBSERVER,
			scrollY: ["ol.table-results"],
			dragDrop: [{dragSelector: null, dropSelector: null}]
		})
	}
	 /* -------------------------------------------- */
	 /** @override */
	get title() {
		return `${game.i18n.localize("TABLE.SheetTitle")}: ${this.entity.name}`;
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const results = this.entity.results.map(r => {
			r = duplicate(r);
			r.isText = r.type === CONST.TABLE_RESULT_TYPES.TEXT;
			r.isEntity = r.type === CONST.TABLE_RESULT_TYPES.ENTITY;
			r.isCompendium = r.type === CONST.TABLE_RESULT_TYPES.COMPENDIUM;
			r.img = r.img || CONFIG.RollTable.resultIcon;
			r.text = TextEditor.decodeHTML(r.text);
			return r;
		});
		results.sort((a, b) => a.range[0] - b.range[0]);
		 // Merge data and return;
		return mergeObject(super.getData(), {
			results: results,
			resultTypes: Object.entries(CONST.TABLE_RESULT_TYPES).reduce((obj, v) => {
				obj[v[1]] = v[0].titleCase();
				return obj;
			}, {}),
			entityTypes: CONST.COMPENDIUM_ENTITY_TYPES,
			compendiumPacks: Array.from(game.packs.keys())
		});
	}
	 /* -------------------------------------------- */
	/* 	Event Listeners and Handlers								*/
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		 // Roll the Table
		const button = html.find("button.roll");
		button.click(this._onRollTable.bind(this));
		button[0].disabled = false;
		 // The below options require an editable sheet
		if (!this.options.editable) return;
		 // Reset the Table
		html.find("button.reset").click(this._onResetTable.bind(this));
		 // Save the sheet on checkbox change
		html.find('input[type="checkbox"]').change(this._onSubmit.bind(this));
		 // Create a new Result
		html.find("a.create-result").click(this._onCreateResult.bind(this));
		 // Delete a Result
		html.find("a.delete-result").click(this._onDeleteResult.bind(this));
		 // Support Image updates
		html.find('img[data-edit]').click(this._onEditImage.bind(this));
		 // Lock or Unlock a Result
		html.find("a.lock-result").click(this._onLockResult.bind(this));
		 // Modify Result Type
		html.find(".result-type select").change(this._onChangeResultType.bind(this));
		 // Re-normalize Table Entries
		html.find(".normalize-results").click(this._onNormalizeResults.bind(this));
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle creating a TableResult in the RollTable entity
	 * @param {MouseEvent} event        The originating mouse event
	 * @param {object} [resultData]     An optional object of result data to use
	 * @return {Promise}
	 * @private
	 */
	async _onCreateResult(event, resultData={}) {
		event.preventDefault();
		 // Save any pending changes
		await this._onSubmit(event);
		 // Get existing results
		const results = this.entity.results;
		let last = results[results.length - 1];
		 // Get weight and range data
		let weight = last ? (last.weight || 1) : 1;
		let totalWeight = results.reduce((t, r) => t + r.weight, 0) || 1;
		let minRoll = results.length ? Math.min(...results.map(r => r.range[0])) : 0;
		let maxRoll = results.length ? Math.max(...results.map(r => r.range[1])) : 0;
		 // Determine new starting range
		let spread = maxRoll - minRoll + 1,
			perW = Math.round(spread / totalWeight);
		let range = [maxRoll + 1, maxRoll + (weight * perW)];
		 // Create the new Result
		resultData = mergeObject({
			type: last ? last.type : CONST.TABLE_RESULT_TYPES.TEXT,
			collection: last ? last.collection : null,
			weight: weight,
			range: range,
			drawn: false
		}, resultData);
		return this.entity.createEmbeddedEntity("TableResult", resultData);
	}
	 /* -------------------------------------------- */
	 /**
	 * Submit the entire form when a table result type is changed, in case there are other active changes
	 * @param {Event} event
	 * @private
	 */
	_onChangeResultType(event) {
		event.preventDefault();
		const rt = CONST.TABLE_RESULT_TYPES;
		const select = event.target;
		const value = parseInt(select.value);
		const key = select.name.replace(".type", ".collection.js");
		let collection = "";
		if ( value === rt.ENTITY ) collection = "Actor";
		else if ( value === rt.COMPENDIUM ) collection = game.packs.keys().next().value;
		const updateData = {[key]: collection, resultId: ""};
		return this._onSubmit(event, {updateData});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle deleting a TableResult from the RollTable entity
	 * @param event
	 * @return {Promise}
	 * @private
	 */
	async _onDeleteResult(event) {
		event.preventDefault();
		await this._onSubmit(event);
		const li = event.currentTarget.closest(".table-result");
		return this.entity.deleteEmbeddedEntity("TableResult", li.dataset.resultId);
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _onDrop(event) {
		 // Try to extract the data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData('text/plain'));
		} catch (err) {
			return false;
		}
		 // Handle the drop with a Hooked function
		const allowed = Hooks.call("dropRollTableSheetData", this.entity, this, data);
		if (allowed === false) return;
		 // Get the dropped entity
		if (!CONST.ENTITY_TYPES.includes(data.type)) return;
		const cls = CONFIG[data.type].entityClass;
		const entity = await cls.fromDropData(data);
		if ( !entity ) return;
		 // Delegate to the onCreate handler
		const isCompendium = !!entity.compendium;
		return this._onCreateResult(event, {
			type: isCompendium ? CONST.TABLE_RESULT_TYPES.COMPENDIUM : CONST.TABLE_RESULT_TYPES.ENTITY,
			collection: isCompendium ? data.pack : entity.entity,
			text: entity.name,
			resultId: entity.id,
			img: entity.data.img || null
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle changing the actor profile image by opening a FilePicker
	 * @param {Event} event
	 * @private
	 */
	_onEditImage(event) {
		const img = event.currentTarget;
		const isHeader = img.dataset.edit === "img";
		let current = this.entity.data.img;
		if ( !isHeader ) {
			const li = img.closest(".table-result");
			const result = this.entity.getTableResult(li.dataset.resultId);
			if (result.type !== CONST.TABLE_RESULT_TYPES.TEXT) return;
			current = result.img;
		}
		const fp = new FilePicker({
			type: "image",
			current: current,
			callback: path => {
				img.src = path;
				this._onSubmit(event);
			},
			top: this.position.top + 40,
			left: this.position.left + 10
		});
		return fp.browse();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a button click to re-normalize dice result ranges across all RollTable results
	 * @param {Event} event
	 * @private
	 */
	async _onNormalizeResults(event) {
		event.preventDefault();
		if ( !this.rendered || this._submitting) return false;
		 // Save any pending changes
		await this._onSubmit(event);
		 // Normalize the RollTable
		return this.entity.normalize();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle toggling the drawn status of the result in the table
	 * @param {Event} event
	 * @private
	 */
	_onLockResult(event) {
		event.preventDefault();
		const li = event.currentTarget.closest("li.table-result");
		const result = this.entity.getTableResult(li.dataset.resultId);
		return this.entity.updateEmbeddedEntity("TableResult", {_id: result._id, drawn: !result.drawn});
	}
	 /* -------------------------------------------- */
	 /**
	 * Reset the Table to it's original composition with all options unlocked
	 * @param {Event} event
	 * @private
	 */
	_onResetTable(event) {
		event.preventDefault();
		return this.entity.reset();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle drawing a result from the RollTable
	 * @param {Event} event
	 * @private
	 */
	async _onRollTable(event) {
		event.preventDefault();
		await this.submit({preventClose: true, preventRender: true});
		event.currentTarget.disabled = true;
		let tableRoll = this.entity.roll();
		const draws = this.entity._getResultsForRoll(tableRoll.roll.total);
		if ( draws.length ) {
			if (game.settings.get("core", "animateRollTable")) await this._animateRoll(draws);
			await this.entity.draw(tableRoll);
		}
		event.currentTarget.disabled = false;
	}
	 /* -------------------------------------------- */
	 /**
	 * Configure the update object workflow for the Roll Table configuration sheet
	 * Additional logic is needed here to reconstruct the results array from the editable fields on the sheet
	 * @param {Event} event            The form submission event
	 * @param {Object} formData        The validated FormData translated into an Object for submission
	 * @return {Promise}
	 * @private
	 */
	async _updateObject(event, formData) {
		 // Expand the data to update the results array
		const expanded = expandObject(formData);
		expanded.results = expanded.hasOwnProperty("results") ? Object.values(expanded.results) : [];
		for (let r of expanded.results) {
			 // Update the Range array
			r.range = [r.rangeL, r.rangeH];
			 // Link entity types
			if (r.type === CONST.TABLE_RESULT_TYPES.ENTITY) {
				const config = r.collection ? CONFIG[r.collection] : null;
				const collection = config ? config.collection.instance : null;
				if (!collection) continue;
				 // Get the original entity, if the name still matches - take no action
				const original = r.resultId ? collection.get(r.resultId) : null;
				if (original && (original.name === r.text)) continue;
				 // Otherwise find the entity by ID or name (id preferred)
				const ent = collection.entities.find(e => (e._id === r.text) || (e.name === r.text)) || null;
				r.resultId = ent ? ent._id : null;
				r.text = ent ? ent.name : null;
				r.img = ent ? ent.img : null;
				r.img = ent ? (ent.data.thumb || ent.data.img) : null;
			}
			 // Link Compendium types
			else if (r.type === CONST.TABLE_RESULT_TYPES.COMPENDIUM) {
				const pack = game.packs.get(r.collection);
				if (pack) {
					const index = await pack.getIndex();
					 // Get the original entry, if the name still matches - take no action
					const original = r.resultId ? index.find(i => i._id === r.resultId) : null;
					if (original && (original.name === r.text)) continue;
					 // Otherwise find the entity by ID or name (id preferred)
					const ent = index.find(i => (i._id === r.text) || (i.name === r.text)) || null;
					r.resultId = ent ? ent._id : null;
					r.text = ent ? ent.name : null;
					r.img = ent ? ent.img : null;
				}
			}
		}
		 // Update the object
		return this.entity.update(expanded);
	}
	 /* -------------------------------------------- */
	 /**
	 * Display a roulette style animation when a Roll Table result is drawn from the sheet
	 * @param {object[]} results     An Array of drawn table results to highlight
	 * @return {Promise}
	 * @private
	 */
	async _animateRoll(results) {
		 // Get the list of results and their indices
		const ol = this.element.find(".table-results")[0];
		const drawnIds = new Set(results.map(r => r._id));
		const drawnItems = Array.from(ol.children).filter(item => drawnIds.has(item.dataset.resultId));
		 // Set the animation timing
		const nResults = this.object.results.length;
		const maxTime = 2000;
		let animTime = 50;
		let animOffset = Math.round(ol.offsetHeight / (ol.children[1].offsetHeight * 2));
		const nLoops = Math.min(Math.ceil(maxTime/(animTime * nResults)), 4);
		if ( nLoops === 1 ) animTime = maxTime / nResults;
		 // Animate the roulette
		await this._animateRoulette(ol, drawnIds, nLoops, animTime, animOffset);
		 // Flash the results
		const flashes = drawnItems.map(li => this._flashResult(li));
		return Promise.all(flashes);
	}
	 /* -------------------------------------------- */
	 /**
	 * Animate a "roulette" through the table until arriving at the final loop and a drawn result
	 * @return {Promise<void>}
	 * @private
	 */
	async _animateRoulette(ol, drawnIds, nLoops, animTime, animOffset) {
		let loop = 0;
		let idx = 1;
		let item = null;
		return new Promise(resolve => {
			let animId = setInterval(() => {
				if (idx === 1) loop++;
				if (item) item.classList.remove("roulette");
				 // Scroll to the next item
				item = ol.children[idx];
				ol.scrollTop = (idx - animOffset) * item.offsetHeight;
				 // If we are on the final loop
				if ( (loop === nLoops) && drawnIds.has(item.dataset.resultId) ) {
					clearInterval(animId);
					return resolve();
				}
				 // Continue the roulette and cycle the index
				item.classList.add("roulette");
				idx = idx < ol.children.length - 1 ? idx+1 : 1;
			}, animTime);
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Display a flashing animation on the selected result to emphasize the draw
	 * @param {HTMLElement} item      The HTML <li> item of the winning result
	 * @return {Promise<void>}
	 * @private
	 */
	async _flashResult(item) {
		return new Promise(resolve => {
			let count = 0;
			let animId = setInterval(() => {
				if (count % 2) item.classList.remove("roulette");
				else item.classList.add("roulette");
				if (count === 7) {
					clearInterval(animId);
					resolve();
				}
				count++;
			}, 50);
		})
	}
}

/**
 * A Scene configuration sheet
 * @extends {BaseEntitySheet}
 * @see {@link Scene} The Scene Entity which is being configured
 */
class SceneConfig extends BaseEntitySheet {
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			classes: ["sheet", "scene-sheet"],
			template: "templates/scene/config.html",
			width: 680,
			height: "auto"
		});
	}
	/* -------------------------------------------- */
	 /** @override */
	get id() {
		return `scene-config-${this.object._id}`;
	}
	/* -------------------------------------------- */
	 /** @override */
	get title() {
		return `${game.i18n.localize("SCENES.ConfigTitle")}: ${this.object.name}`;
	}
	/* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const data = super.getData(options);
		 // Selectable types
		data.gridTypes = this.constructor._getGridTypes();
		data.weatherTypes = this._getWeatherTypes();
		 // Referenced entities
		data.playlists = this._getEntities(game.playlists);
		data.journals = this._getEntities(game.journal);
		 // Global illumination threshold
		data.hasGlobalThreshold = data.entity.globalLightThreshold !== null;
		data.entity.globalLightThreshold = data.entity.globalLightThreshold ?? 0;
		return data;
	}
	/* -------------------------------------------- */
	 /**
	 * Get an enumeration of the available grid types which can be applied to this Scene
	 * @return {Object}
	 * @private
	 */
	static _getGridTypes() {
	 const labels = {
		 "GRIDLESS": "SCENES.GridGridless",
			"SQUARE": "SCENES.GridSquare",
			"HEXODDR": "SCENES.GridHexOddR",
			"HEXEVENR": "SCENES.GridHexEvenR",
			"HEXODDQ": "SCENES.GridHexOddQ",
			"HEXEVENQ": "SCENES.GridHexEvenQ"
		};
		return Object.keys(CONST.GRID_TYPES).reduce((obj, t) => {
		 obj[CONST.GRID_TYPES[t]] = labels[t];
		 return obj;
		}, {});
	}
	/* -------------------------------------------- */
	 /**
	 * Get the available weather effect types which can be applied to this Scene
	 * @return {Object}
	 * @private
	 */
	_getWeatherTypes() {
		const types = {};
		for ( let [k, v] of Object.entries(CONFIG.weatherEffects) ) {
			types[k] = v.label;
		}
		return types;
	}
	/* -------------------------------------------- */
	 /**
	 * Get the alphabetized entities which can be chosen as a configuration for the scene
	 * @param {EntityCollection} collection
	 * @return {object[]}
	 * @private
	 */
	_getEntities(collection) {
		const entities = collection.entities.map(e => {
			return {_id: e.data._id, name: e.data.name};
		});
		entities.sort((a, b) => a.name.localeCompare(b.name));
		return entities;
	}
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find("button.capture-position").click(this._onCapturePosition.bind(this));
		html.find("button.grid-config").click(this._onGridConfig.bind(this))
	}
	/* -------------------------------------------- */
	 /**
	 * Capture the current Scene position and zoom level as the initial view in the Scene config
	 * @param {Event} event   The originating click event
	 * @private
	 */
	_onCapturePosition(event) {
		event.preventDefault();
		const btn = event.currentTarget;
		const form = btn.form;
		form["initial.x"].value = parseInt(canvas.stage.pivot.x);
		form["initial.y"].value = parseInt(canvas.stage.pivot.y);
		form["initial.scale"].value = canvas.stage.scale.x;
		ui.notifications.info("Captured canvas position as initial view in the Scene configuration form.")
	}
	/* -------------------------------------------- */
	 /** @override */
	_onChangeRange(event) {
		super._onChangeRange(event);
		const rng = event.target;
		if ( (rng.name === "darkness") && this.object.isView ) {
			canvas.lighting.refresh(Number(rng.value));
		}
	}
	/* -------------------------------------------- */
	 /**
	 * Handle click events to open the grid configuration application
	 * @param {Event} event   The originating click event
	 * @private
	 */
	async _onGridConfig(event) {
		event.preventDefault();
		if ( !this.object.isView ) await this.object.view();
		new GridConfig(this.object, this).render(true);
		return this.minimize();
	}
	/* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		 // Capture initial camera position
		const initialViewAttrs = ["initial.x", "initial.y", "initial.scale"];
		if ( initialViewAttrs.every(a => !formData[a]) ) {
			for ( let a of initialViewAttrs ) {
				delete formData[a];
			}
			formData.initial = null;
		}
		 // Toggle global illumination threshold
		if ( formData.hasGlobalThreshold === false ) formData.globalLightThreshold = null;
		 // Perform the update
		return this.entity.update(formData, {fromSheet: true});
	}
}

/**
 * Entity Sheet Configuration Application
 * @type {FormApplication}
 * @param entity {Entity}      The Entity object for which the sheet is being configured
 * @param options {Object}     Additional Application options
 */
class EntitySheetConfig extends FormApplication {
	static get defaultOptions() {
	 const options = super.defaultOptions;
	 options.id = "sheet-config";
	 options.template = "templates/sheets/sheet-config.html";
	 options.width = 400;
	 return options;
	}
	 /* -------------------------------------------- */
	 /**
	 * Add the Entity name into the window title
	 * @type {string}
	 */
	get title() {
		return `${this.object.name}: Sheet Configuration`;
	}
	 /* -------------------------------------------- */
	 /**
	 * Construct and return the data object used to render the HTML template for this form application.
	 * @return {Object}
	 */
	getData(options) {
		const entityName = this.object.entity;
		const config = CONFIG[entityName];
		const type = this.object.data.type || CONST.BASE_ENTITY_TYPE;
		let defaultClass = null;
		 // Classes which can be chosen
		const classes = Object.values(config.sheetClasses[type]).reduce((obj, c) => {
			obj[c.id] = c.label;
			if ( c.default && !defaultClass ) defaultClass = c.id;
			return obj;
		}, {});
		 // Return data
		return {
			entityName: entityName,
			isGM: game.user.isGM,
			object: duplicate(this.object.data),
			options: this.options,
			sheetClass: this.object.getFlag("core", "sheetClass") ?? "",
			sheetClasses: classes,
			defaultClass: defaultClass,
			blankLabel: game.i18n.localize("SHEETS.DefaultSheet")
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * This method is called upon form submission after form data is validated
	 * @param event {Event}       The initial triggering submission event
	 * @param formData {Object}   The object of validated form data with which to update the object
	 * @private
	 */
	async _updateObject(event, formData) {
		event.preventDefault();
		const original = this.getData();
		 // De-register the current sheet class
		const sheet = this.object.sheet;
		await sheet.close();
		this.object._sheet = null;
		delete this.object.apps[sheet.appId];
		 // Update world settings
		if ( game.user.isGM && (formData.defaultClass !== original.defaultClass) ) {
			const setting = await game.settings.get("core", "sheetClasses") || {};
			mergeObject(setting, {[`${this.object.entity}.${this.object.data.type}`]: formData.defaultClass});
			await game.settings.set("core", "sheetClasses", setting);
		}
		 // Update the Entity-specific override
		if ( formData.sheetClass !== original.sheetClass ) {
			await this.object.setFlag("core", "sheetClass", formData.sheetClass);
		}
		 // Re-draw the updated sheet
		this.object.sheet.render(true);
	}
	 /* -------------------------------------------- */
	/*  Configuration Methods
	/* -------------------------------------------- */
	 /**
	 * Initialize the configured Sheet preferences for Entities which support dynamic Sheet assignment
	 * Create the configuration structure for supported entities
	 * Process any pending sheet registrations
	 * Update the default values from settings data
	 */
	static initializeSheets() {
		 // Create placeholder entity/type mapping
		const entities = [Actor, Item];
		for ( let ent of entities ) {
			const types = this._getEntityTypes(ent);
			CONFIG[ent.name].sheetClasses = types.reduce((obj, type) => {
				obj[type] = {};
				return obj;
			}, {});
		}
		 // Register any pending sheets
		this._pending.forEach(p => {
			if ( p.action === "register" ) this._registerSheet(p);
			else if ( p.action === "unregister" ) this._unregisterSheet(p);
		});
		this._pending = [];
		 // Update default sheet preferences
		const defaults = game.settings.get("core", "sheetClasses");
		this._updateDefaultSheets(defaults)
	}
	 /* -------------------------------------------- */
	 /**
	 * Register a sheet class as a candidate which can be used to display entities of a given type
	 * @param {Entity} entityClass      The Entity for which to register a new Sheet option
	 * @param {string} scope            Provide a unique namespace scope for this sheet
	 * @param {Application} sheetClass  A defined Application class used to render the sheet
	 * @param {Object} options          Additional options used for sheet registration
	 * @param {string} [options.label]          A human readable label for the sheet name, which will be localized
	 * @param {string[]} [options.types]        An array of entity types for which this sheet should be used
	 * @param {boolean} [options.makeDefault]   Whether to make this sheet the default for provided types
	 */
	static registerSheet(entityClass, scope, sheetClass, {label, types=[], makeDefault=false}={}) {
		const id = `${scope}.${sheetClass.name}`;
		const config = {entityClass, id, label, sheetClass, types, makeDefault};
		 // If the game is ready, register the sheet with the configuration object, otherwise add to pending
		if ( (game instanceof Game) && game.ready ) this._registerSheet(config);
		else {
			config["action"] = "register";
			this._pending.push(config);
		}
	}
	 static _registerSheet({entityClass, id, label, sheetClass, types, makeDefault}={}) {
		types = this._getEntityTypes(entityClass, types);
		let classes = CONFIG[entityClass.name].sheetClasses;
		for ( let t of types ) {
			classes[t][id] = {
				id: id,
				cls: sheetClass,
				default: makeDefault,
				label: label ? game.i18n.localize(label) : id
			};
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Unregister a sheet class, removing it from the list of available Applications to use for an Entity type
	 * @param {Entity} entityClass      The Entity for which to register a new Sheet option
	 * @param {string} scope            Provide a unique namespace scope for this sheet
	 * @param {Application} sheetClass  A defined Application class used to render the sheet
	 * @param {object[]} types             An Array of types for which this sheet should be removed
	 */
	static unregisterSheet(entityClass, scope, sheetClass, {types=[]}={}) {
		const id = `${scope}.${sheetClass.name}`;
		const config = {entityClass, id, types};
		 // If the game is ready remove the sheet directly, otherwise remove from pending
		if ( (game instanceof Game) && game.ready ) this._unregisterSheet(config);
		else {
			config["action"] = "unregister";
			this._pending.push(config);
		}
	}
	 static _unregisterSheet({entityClass, id, types}={}) {
		types = this._getEntityTypes(entityClass, types);
		let classes = CONFIG[entityClass.name].sheetClasses;
		for ( let t of types ) {
			delete classes[t][id];
		}
	}
	 /* -------------------------------------------- */
	 static _getEntityTypes(entityClass, types=[]) {
		if ( types.length ) return types;
		const systemTypes = game.system.entityTypes[entityClass.name];
		return systemTypes.length ? systemTypes : [CONST.BASE_ENTITY_TYPE];
	}
	 /* -------------------------------------------- */
	 /**
	 * Update the currently default Sheets using a new core world setting
	 * @param {Object} setting
	 * @private
	 */
	static _updateDefaultSheets(setting={}) {
		if ( !Object.keys(setting).length ) return;
		const entities = [Actor, Item];
		for ( let ent of entities ) {
			let classes = CONFIG[ent.name].sheetClasses;
			let defaults = setting[ent.name] || {};
			if ( !defaults ) continue;
			 // Update default preference for registered sheets
			for ( let [type, sheetId] of Object.entries(defaults) ) {
				const sheets = Object.values(classes[type] || {});
				let requested = sheets.find(s => s.id === sheetId);
				if ( requested ) sheets.forEach(s => s.default = s.id === sheetId);
			}
			 // Close and de-register any existing sheets
			ent.collection.entities.forEach(e => {
				Object.values(e.apps).forEach(e => e.close());
				e.apps = {};
			});
		}
	}
}

EntitySheetConfig._pending = [];
/**
 * The Chat Bubble Class
 * This application displays a temporary message sent from a particular Token in the active Scene.
 * The message is displayed on the HUD layer just above the Token.
 */
class ChatBubbles {
	constructor() {
		this.template = "templates/hud/chat-bubble.html";
		 /**
		 * Track active Chat Bubbles
		 * @type {Object}
		 */
		this.bubbles = {};
		 /**
		 * Track which Token was most recently panned to highlight
		 * Use this to avoid repeat panning
		 * @type {Token}
		 * @private
		 */
		this._panned = null;
	}
	/* -------------------------------------------- */
	 /**
	 * A reference to the chat bubbles HTML container in which rendered bubbles should live
	 * @return {jQuery}
	 */
	get container() {
		return $("#chat-bubbles");
	}
	/* -------------------------------------------- */
	 /**
	 * Speak a message as a particular Token, displaying it as a chat bubble
	 * @param {Token} token       The speaking Token
	 * @param {string} message    The spoken message text
	 * @param {boolean} emote     Whether to style the speech bubble as an emote
	 * @returns {Promise<void>}   A Promise which resolves once the chat bubble has been created
	 */
	async say(token, message, {emote=false}={}) {
		if ( !token || !message ) return;
		let allowBubbles = game.settings.get("core", "chatBubbles");
		if ( !allowBubbles ) return;
		const panToSpeaker = game.settings.get("core", "chatBubblesPan");
		 // Clear any existing bubble for the speaker
		await this._clearBubble(token);
		 // Create the HTML and call the chatBubble hook
		let html = $(await this._renderHTML({token, message, emote}));
		const allowed = Hooks.call("chatBubble", token, html, message, {emote});
		if ( allowed === false ) return;
		 // Set initial dimensions
		let dimensions = this._getMessageDimensions(message);
		this._setPosition(token, html, dimensions);
		 // Append to DOM
		this.container.append(html);
		 // Pan to the speaker
		if ( panToSpeaker && (this._panned !== token) ) {
			canvas.animatePan({x: token.x, y: token.y, scale: Math.max(1, canvas.stage.scale.x), duration: 1000});
			this._panned = token;
		}
		 // Get animation duration and settings
		const duration = this._getDuration(html);
		const scroll = dimensions.unconstrained - dimensions.height;
		 // Animate the bubble
		html.fadeIn(250, () => {
			if ( scroll > 0 ) {
				html.find(".bubble-content").animate({ top: -1 * scroll }, duration - 1000, 'linear');
			}
			setTimeout(() => html.fadeOut(250, () => html.remove()), duration);
		});
	}
	/* -------------------------------------------- */
	 /**
	 * Clear any existing chat bubble for a certain Token
	 * @param {Token} token
	 * @private
	 */
	async _clearBubble(token) {
		let existing = $(`.chat-bubble[data-token-id="${token.id}"]`);
		if ( !existing.length ) return;
		return new Promise(resolve => {
			existing.fadeOut(100, () => {
				existing.remove();
				resolve();
			});
		})
	}
	/* -------------------------------------------- */
	 /**
	 * Render the HTML template for the chat bubble
	 * @param {Object} data         Template data
	 * @return {Promise<string>}    The rendered HTML
	 * @private
	 */
	async _renderHTML(data) {
		data.cssClasses = [
			data.emote ? "emote" : null
		].filter(c => c !== null).join(" ");
		return renderTemplate(this.template, data);
	}
	/* -------------------------------------------- */
	 /**
	 * Before displaying the chat message, determine it's constrained and unconstrained dimensions
	 * @param {string} message    The message content
	 * @return {Object}           The rendered message dimensions
	 * @private
	 */
	_getMessageDimensions(message) {
		let div = $(`<div class="chat-bubble" style="visibility:hidden">${message}</div>`);
		$('body').append(div);
		let dims = {
			width: div[0].clientWidth + 8,
			height: div[0].clientHeight
		};
		div.css({maxHeight: "none"});
		dims.unconstrained = div[0].clientHeight;
		div.remove();
		return dims;
	}
	/* -------------------------------------------- */
	 /**
	 * Assign styling parameters to the chat bubble, toggling either a left or right display (randomly)
	 * @private
	 */
	_setPosition(token, html, dimensions) {
		let cls = Math.random() > 0.5 ? "left" : "right";
		html.addClass(cls);
		const pos = {
			height: dimensions.height,
			width: dimensions.width,
			top: token.y - dimensions.height - 8
		};
		if ( cls === "right" ) pos.left = token.x - (dimensions.width - token.w);
		else pos.left = token.x;
		html.css(pos);
	}
	 /* -------------------------------------------- */
	 /**
	* Determine the length of time for which to display a chat bubble.
	* Research suggests that average reading speed is 200 words per minute.
	* Since these are short-form messages, we multiply reading speed by 1.5.
	* Clamp the result between 1 second (minimum) and 20 seconds (maximum)
	* @param {jQuery}     The HTML message
	* @returns {number}   The number of milliseconds for which to display the message
	*/
	_getDuration(html) {
		let words = html.text().split(" ").map(w => w.trim()).length;
		let ms = (words * 60 * 1000) / 300;
		return Math.clamped(1000, ms, 20000);
	}
}
			/**
 * Render the HUD container
 * @type {Application}
 */
class HeadsUpDisplay extends Application {
	constructor(...args) {
		super(...args);
		 /**
		 * Token HUD
		 * @type {TokenHUD}
		 */
		this.token = new TokenHUD();
		 /**
		 * Tile HUD
		 * @type {TileHUD}
		 */
		this.tile = new TileHUD();
		 /**
		 * Drawing HUD
		 * @type {DrawingHUD}
		 */
		this.drawing = new DrawingHUD();
		 /**
		 * Chat Bubbles
		 * @type {ChatBubbles}
		 */
		this.bubbles = new ChatBubbles();
	}
	 /* -------------------------------------------- */
	 /**
	 * Define default options which configure the HUD
	 */
	static get defaultOptions() {
	 const options = super.defaultOptions;
		options.id = "hud";
	 options.template = "templates/hud/hud.html";
		options.popOut = false;
		return options;
	}
	 /* -------------------------------------------- */
	 getData() {
		if ( !canvas.ready ) return {};
		return {
			width: canvas.dimensions.width,
			height: canvas.dimensions.height
		}
	}
	 /* -------------------------------------------- */
	 async _render(...args) {
		await super._render(...args);
		this.align();
	}
	 /* -------------------------------------------- */
	 align() {
		const hud = this.element[0];
		let {x, y} = canvas.background.getGlobalPosition();
		let scale = canvas.stage.scale.x;
		hud.style.left = x+"px";
		hud.style.top = y+"px";
		hud.style.transform = `scale(${scale})`;
	}
}

/**
 * @typedef {{name: string, label: string, icon: string}} SceneControlTool
 * @typedef {{name: string, title: string, layer: string, icon: string, tools: SceneControlTool[]}} SceneControl
 */

/**
 * Scene controls navigation menu
 * @extends {Application}
 */
class SceneControls extends Application {
	constructor(options) {
	 super(options);
		 /**
		 * The name of the active Scene Control toolset
		 * @type {string}
		 */
	 this.activeControl = "token";
		 /**
		 * The Array of Scene Control buttons which are currently rendered
		 * @type {SceneControl[]}
		 */
	 this.controls = this._getControlButtons();
	}
	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 width: 100,
			id: "controls",
			template: "templates/hud/controls.html",
			popOut: false
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the active control set
	 * @type {SceneControl|null}
	 */
	get control() {
	 if ( !this.controls ) return null;
	 return this.controls.find(c => c.name === this.activeControl) || null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the name of the active tool within the active control set
	 * @type {string|null}
	 */
	get activeTool() {
	 const control = this.control;
	 return control ? control.activeTool : null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the actively controlled tool
	 * @type {SceneControlTool|null}
	 */
	get tool() {
		const control = this.control;
		if ( !control ) return null;
		const tool = control.tools.find(t => t.name === control.activeTool);
		return tool || null;
	}
	 /* -------------------------------------------- */
	 /**
	 * A convenience reference for whether the currently active tool is a Ruler
	 * @type {boolean}
	 */
	get isRuler() {
	 return this.activeTool === "ruler";
	}
	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /**
	 * Initialize the Scene Controls by obtaining the set of control buttons and rendering the HTML
	 * @param {object} options      Options which modify how the controls UI is initialized
	 * @param {string} [options.control]      An optional control set to set as active
	 * @param {string} [options.layer]        An optional layer name to target as the active control
	 * @param {string} [options.tool]         A specific named tool to set as active for the palette
	 */
	initialize({control, layer, tool}={}) {
		const tools = this.controls.reduce((obj, t) => {
			obj[t.name] = t.activeTool;
			return obj;
		}, {});
		 // Set the new control
		if ( control ) this.activeControl = control;
		else if ( layer && this.controls ) {
			const control = this.controls.find(c => c.layer === layer);
			if ( control ) this.activeControl = control.name;
		}
		 // Update the control buttons
		this.controls = this._getControlButtons();
		if ( tool ) tools[this.activeControl] = tool;
		for ( let c of this.controls ) {
			c.activeTool = tools[c.name];
		}
		this.render(true);
	}
	/* -------------------------------------------- */
	 /** @override */
	getData(options) {
	 const isActive = !!canvas?.scene;
		// Filter to control tool sets which can be displayed
		let controls = this.controls.filter(s => s.visible !== false).map(s => {
			s = duplicate(s);
			 // Add styling rules
			s.css = isActive && (this.activeControl === s.name) ? "active" : "";
			 // Prepare contained tools
			s.tools = s.tools.filter(t => t.visible !== false).map(t => {
				let active = isActive && ((s.activeTool === t.name) || (t.toggle && t.active));
				t.css = [
					t.toggle ? "toggle" : null,
					active ? "active" : null
				].filter(t => !!t).join(" ");
				return t;
			});
			return s;
		});
		 // Return data for rendering
	 return {
		 active: isActive,
			cssClass: isActive ? "" : "disabled",
			controls: controls.filter(s => s.tools.length)
		};
	}
		/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		html.find('.scene-control').click(this._onClickLayer.bind(this));
		html.find('.control-tool').click(this._onClickTool.bind(this));
	}
	/* -------------------------------------------- */
	 /**
	 * Handle click events on a Control set
	 * @param {Event} event   A click event on a tool control
	 * @private
	 */
	_onClickLayer(event) {
		event.preventDefault();
		if ( !canvas?.ready ) return;
		const li = event.currentTarget;
		const controlName = li.dataset.control;
		this.activeControl = controlName;
		const control = this.controls.find(c => c.name === controlName);
		if ( control && control.layer ) canvas.getLayer(control.layer).activate();
	}
	/* -------------------------------------------- */
	 /**
	 * Handle click events on Tool controls
	 * @param {Event} event   A click event on a tool control
	 * @private
	 */
	_onClickTool(event) {
		event.preventDefault();
		if ( !canvas?.ready ) return;
		const li = event.currentTarget;
		const control = this.control;
		const toolName = li.dataset.tool;
		const tool = control.tools.find(t => t.name === toolName);
		 // Handle Toggles
		if ( tool.toggle ) {
			tool.active = !tool.active;
			if ( tool.onClick instanceof Function ) tool.onClick(tool.active);
		}
		 // Handle Buttons
		else if ( tool.button ) {
			if ( tool.onClick instanceof Function ) tool.onClick();
		}
		 // Handle Tools
		else {
			control.activeTool = toolName;
			if ( tool.onClick instanceof Function ) tool.onClick();
		}
		 // Render the controls
		this.render();
	}
	/* -------------------------------------------- */
	 /**
	 * Get the set of Control sets and tools that are rendered as the Scene Controls.
	 * These controls may be extended using the "getSceneControlButtons" Hook.
	 * @return {SceneControl[]}
	 * @private
	 */
	_getControlButtons() {
		const controls = [];
		const isGM = game.user.isGM;
		 // Token Controls
		controls.push({
			name: "token",
			title: "CONTROLS.GroupBasic",
			layer: "TokenLayer",
			icon: "fas fa-user-alt",
			tools: [
				{
					name: "select",
					title: "CONTROLS.BasicSelect",
					icon: "fas fa-expand"
				},
				{
					name: "target",
					title: "CONTROLS.TargetSelect",
					icon: "fas fa-bullseye"
				},
				{
					name: "ruler",
					title: "CONTROLS.BasicMeasure",
					icon: "fas fa-ruler"
				}
			],
			activeTool: "select"
		});
		 // Measurement Layer Tools
		controls.push({
			name: "measure",
			title: "CONTROLS.GroupMeasure",
			layer: "TemplateLayer",
			icon: "fas fa-ruler-combined",
			visible: game.user.can("TEMPLATE_CREATE"),
			tools: [
				{
					name: "circle",
					title: "CONTROLS.MeasureCircle",
					icon: "far fa-circle"
				},
				{
					name: "cone",
					title: "CONTROLS.MeasureCone",
					icon: "fas fa-angle-left"
				},
				{
					name: "rect",
					title: "CONTROLS.MeasureRect",
					icon: "far fa-square"
				},
				{
					name: "ray",
					title: "CONTROLS.MeasureRay",
					icon: "fas fa-arrows-alt-v"
				},
				{
					name: "clear",
					title: "CONTROLS.MeasureClear",
					icon: "fas fa-trash",
					visible: isGM,
					onClick: () => canvas.templates.deleteAll(),
					button: true
				}
			],
			activeTool: "circle"
		});
		 // Tiles Layer
		controls.push({
			name: "tiles",
			title: "CONTROLS.GroupTile",
			layer: "TilesLayer",
			icon: "fas fa-cubes",
			visible: isGM,
			tools: [
				{
					name: "select",
					title: "CONTROLS.TileSelect",
					icon: "fas fa-expand"
				},
				{
					name: "tile",
					title: "CONTROLS.TilePlace",
					icon: "fas fa-cube"
				},
				{
					name: "browse",
					title: "CONTROLS.TileBrowser",
					icon: "fas fa-folder",
					button: true,
					onClick: () => {
						new FilePicker({
							type: "imagevideo",
							displayMode: "tiles",
							tileSize: true
						}).render(true);
					}
				}
			],
			activeTool: "select"
		});
		 // Drawing Tools
		controls.push({
			name: "drawings",
			title: "CONTROLS.GroupDrawing",
			layer: "DrawingsLayer",
			icon: "fas fa-pencil-alt",
			visible: game.user.can("DRAWING_CREATE"),
			tools: [
				{
					name: "select",
					title: "CONTROLS.DrawingSelect",
					icon: "fas fa-expand"
				},
				{
					name: "rect",
					title: "CONTROLS.DrawingRect",
					icon: "fas fa-square"
				},
				{
					name: "ellipse",
					title: "CONTROLS.DrawingEllipse",
					icon: "fas fa-circle"
				},
				{
					name: "polygon",
					title: "CONTROLS.DrawingPoly",
					icon: "fas fa-draw-polygon"
				},
				{
					name: "freehand",
					title: "CONTROLS.DrawingFree",
					icon: "fas fa-signature"
				},
				{
					name: "text",
					title: "CONTROLS.DrawingText",
					icon: "fas fa-font"
				},
				{
					name: "configure",
					title: "CONTROLS.DrawingConfig",
					icon: "fas fa-cog",
					onClick: () => canvas.drawings.configureDefault(),
					button: true
				},
				{
					name: "clear",
					title: "CONTROLS.DrawingClear",
					icon: "fas fa-trash",
					visible: isGM,
					onClick: () => canvas.drawings.deleteAll(),
					button: true
				}
			],
			activeTool: "select"
		});
		 // Walls Layer Tools
		controls.push({
			name: "walls",
			title: "CONTROLS.GroupWall",
			layer: "WallsLayer",
			icon: "fas fa-university",
			visible: isGM,
			tools: [
				{
					name: "select",
					title: "CONTROLS.WallSelect",
					icon: "fas fa-expand"
				},
				{
					name: "walls",
					title: "CONTROLS.WallDraw",
					icon: "fas fa-bars"
				},
				{
					name: "terrain",
					title: "CONTROLS.WallTerrain",
					icon: "fas fa-mountain"
				},
				{
					name: "invisible",
					title: "CONTROLS.WallInvisible",
					icon: "fas fa-eye-slash"
				},
				{
					name: "ethereal",
					title: "CONTROLS.WallEthereal",
					icon: "fas fa-mask"
				},
				{
					name: "doors",
					title: "CONTROLS.WallDoors",
					icon: "fas fa-door-open"
				},
				{
					name: "secret",
					title: "CONTROLS.WallSecret",
					icon: "fas fa-user-secret"
				},
				{
					name: "clone",
					title: "CONTROLS.WallClone",
					icon: "far fa-clone"
				},
				{
					name: "snap",
					title: "CONTROLS.WallSnap",
					icon: "fas fa-plus",
					toggle: true,
					active: !!canvas?.walls._forceSnap,
					onClick: toggled => canvas.walls._forceSnap = toggled
				},
				{
					name: "clear",
					title: "CONTROLS.WallClear",
					icon: "fas fa-trash",
					onClick: () => canvas.walls.deleteAll(),
					button: true
				}
			],
			activeTool: "walls"
		});
		 // Lighting Layer Tools
		controls.push({
			name: "lighting",
			title: "CONTROLS.GroupLighting",
			layer: "LightingLayer",
			icon: "far fa-lightbulb",
			visible: isGM,
			tools: [
				{
					name: "light",
					title: "CONTROLS.LightDraw",
					icon: "fas fa-lightbulb"
				},
				{
					name: "day",
					title: "CONTROLS.LightDay",
					icon: "fas fa-sun",
					onClick: () => canvas.scene.update({darkness: 0.0}, {animateDarkness: true}),
					button: true
				},
				{
					name: "night",
					title: "CONTROLS.LightNight",
					icon: "fas fa-moon",
					onClick: () => canvas.scene.update({darkness: 1.0}, {animateDarkness: true}),
					button: true
				},
				{
					name: "reset",
					title: "CONTROLS.LightReset",
					icon: "fas fa-cloud",
					onClick: () => {
						new Dialog({
							title: game.i18n.localize("CONTROLS.FOWResetTitle"),
							content: `<p>${game.i18n.localize("CONTROLS.FOWResetDesc")}</p>`,
							buttons: {
								yes: {
									icon: '<i class="fas fa-check"></i>',
									label: "Yes",
									callback: () => canvas.sight.resetFog()
								},
								no: {
									icon: '<i class="fas fa-times"></i>',
									label: "No"
								}
							}
						}).render(true);
					},
					button: true
				},
				{
					name: "clear",
					title: "CONTROLS.LightClear",
					icon: "fas fa-trash",
					onClick: () => canvas.lighting.deleteAll(),
					button: true
				}
			],
			activeTool: "light"
		});
		 // Sounds Layer Tools
		controls.push({
			name: "sounds",
			title: "CONTROLS.GroupSound",
			layer: "SoundsLayer",
			icon: "fas fa-music",
			visible: isGM,
			tools: [
				{
					name: "sound",
					title: "CONTROLS.SoundDraw",
					icon: "fas fa-volume-up"
				},
				{
					name: "clear",
					title: "CONTROLS.SoundClear",
					icon: "fas fa-trash",
					onClick: () => canvas.sounds.deleteAll(),
					button: true
				}
			],
			activeTool: "sound"
		});
		 // Notes Layer Tools
		controls.push({
			name: "notes",
			title: "CONTROLS.GroupNotes",
			layer: "NotesLayer",
			icon: "fas fa-bookmark",
			tools: [
				{
					name: "select",
					title: "CONTROLS.NoteSelect",
					icon: "fas fa-expand"
				},
				{
					name: "toggle",
					title: "CONTROLS.NoteToggle",
					icon: "fas fa-map-pin",
					toggle: true,
					active: game.settings.get("core", NotesLayer.TOGGLE_SETTING),
					onClick: toggled => game.settings.set("core", NotesLayer.TOGGLE_SETTING, toggled)
				},
				{
					name: "clear",
					title: "CONTROLS.NoteClear",
					icon: "fas fa-trash",
					visible: isGM,
					onClick: () => canvas.notes.deleteAll(),
					button: true
				}
			],
			activeTool: 'select'
		});
		 // Pass the Scene Controls to a hook function to allow overrides or changes
		Hooks.callAll(`getSceneControlButtons`, controls);
		return controls;
	}
}

/**
 * The global action bar displayed at the bottom of the game view.
 * The Hotbar is a UI element at the bottom of the screen which contains Macros as interactive buttons.
 * The Hotbar supports 5 pages of global macros which can be dragged and dropped to organize as you wish.
 *
 * Left clicking a Macro button triggers its effect.
 * Right clicking the button displays a context menu of Macro options.
 * The number keys 1 through 0 activate numbered hotbar slots.
 * Pressing the delete key while hovering over a Macro will remove it from the bar.
 *
 * @extends {Application}
 *
 * @see {@link Macros}
 * @see {@link Macro}
 */
class Hotbar extends Application {
	constructor(options) {
	 super(options);
	 game.macros.apps.push(this);
		 /**
		 * The currently viewed macro page
		 * @type {number}
		 */
		this.page = 1;
		 /**
		 * The currently displayed set of macros
		 * @type {Macro[]}
		 */
		this.macros = [];
		 /**
		 * Track collapsed state
		 * @type {boolean}
		 */
		this._collapsed = false;
		 /**
		 * Track which hotbar slot is the current hover target, if any
		 * @type {number|null}
		 */
		this._hover = null;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "hotbar",
			template: "templates/hud/hotbar.html",
			popOut: false,
			dragDrop: [{ dragSelector: ".macro-icon", dropSelector: "#macro-list" }]
		});
	}
	/* -------------------------------------------- */
	 /** @override */
	getData(options) {
	 this.macros = this._getMacrosByPage(this.page);
		return {
			page: this.page,
			macros: this.macros,
			barClass: this._collapsed ? "collapsed" : ""
		};
	}
	/* -------------------------------------------- */
	 /**
	 * Get the Array of Macro (or null) values that should be displayed on a numbered page of the bar
	 * @param {number} page
	 * @returns {Macro[]}
	 * @private
	 */
	_getMacrosByPage(page) {
		const macros = game.user.getHotbarMacros(page);
		for ( let [i, m] of macros.entries() ) {
			m.key = i<9 ? i+1 : 0;
			m.cssClass = m.macro ? "active" : "inactive";
			m.icon = m.macro ? m.macro.data.img : null;
		}
		return macros;
	}
	/* -------------------------------------------- */
	 /**
	 * Collapse the Hotbar, minimizing its display.
	 * @return {Promise}    A promise which resolves once the collapse animation completes
	 */
	async collapse() {
		if ( this._collapsed ) return true;
		const toggle = this.element.find("#bar-toggle");
		const icon = toggle.children("i");
		const bar = this.element.find("#action-bar");
		return new Promise(resolve => {
			bar.slideUp(200, () => {
				bar.addClass("collapsed");
				icon.removeClass("fa-caret-down").addClass("fa-caret-up");
				this._collapsed = true;
				resolve(true);
			});
		});
	}
	/* -------------------------------------------- */
	 /**
	 * Expand the Hotbar, displaying it normally.
	 * @return {Promise}    A promise which resolves once the expand animation completes
	 */
	expand() {
		if ( !this._collapsed ) return true;
		const toggle = this.element.find("#bar-toggle");
		const icon = toggle.children("i");
		const bar = this.element.find("#action-bar");
		return new Promise(resolve => {
			bar.slideDown(200, () => {
				bar.css("display", "");
				bar.removeClass("collapsed");
				icon.removeClass("fa-caret-up").addClass("fa-caret-down");
				this._collapsed = false;
				resolve(true);
			});
		});
	}
	/* -------------------------------------------- */
	 /**
	 * Change to a specific numbered page from 1 to 5
	 * @param {number} page     The page number to change to.
	 */
	changePage(page) {
		this.page = Math.clamped(page ?? 1, 1, 5);
		this.render();
	}
	/* -------------------------------------------- */
	 /**
	 * Change the page of the hotbar by cycling up (positive) or down (negative)
	 * @param {number} direction    The direction to cycle
	 */
	cyclePage(direction) {
		direction = Number.isNumeric(direction) ? Math.sign(direction) : 1;
		if ( direction > 0 ) {
			this.page = this.page < 5 ? this.page+1 : 1;
		} else {
			this.page = this.page > 1 ? this.page-1 : 5;
		}
		this.render();
	}
	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		 // Macro actions
		html.find('#bar-toggle').click(this._onToggleBar.bind(this));
		html.find("#macro-directory").click(ev => ui.macros.renderPopout(true));
		html.find(".macro").click(this._onClickMacro.bind(this)).hover(this._onHoverMacro.bind(this));
		html.find(".page-control").click(this._onClickPageControl.bind(this));
		 // Activate context menu
		this._contextMenu(html);
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a Context Menu attached to each Macro button
	 * @param html
	 * @private
	 */
	_contextMenu(html) {
		new ContextMenu(html, ".macro", [
			{
				name: "MACRO.Edit",
				icon: '<i class="fas fa-edit"></i>',
				condition: li => {
					const macro = game.macros.get(li.data("macro-id"));
					return macro ? macro.owner : false;
				},
				callback: li => {
					const macro = game.macros.get(li.data("macro-id"));
					macro.sheet.render(true);
				}
			},
			{
				name: "MACRO.Remove",
				icon: '<i class="fas fa-times"></i>',
				callback: li => {
					game.user.assignHotbarMacro(null, li.data("slot"));
				}
			},
			{
				name: "MACRO.Delete",
				icon: '<i class="fas fa-trash"></i>',
				condition: li => {
					const macro = game.macros.get(li.data("macro-id"));
					return macro ? macro.owner : false;
				},
				callback: li => {
					const macro = game.macros.get(li.data("macro-id"));
					return Dialog.confirm({
						title: `${game.i18n.localize("MACRO.Delete")} ${macro.name}`,
						content: game.i18n.localize("MACRO.DeleteConfirm"),
						yes: macro.delete.bind(macro)
					});
				}
			},
		]);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle left-click events to
	 * @param event
	 * @private
	 */
	async _onClickMacro(event) {
		event.preventDefault();
		const li = event.currentTarget;
		 // Case 1 - create a new Macro
		if ( li.classList.contains("inactive") ) {
			const macro = await Macro.create({name: "New Macro", type: "chat", scope: "global"});
			await game.user.assignHotbarMacro(macro, li.dataset.slot);
			macro.sheet.render(true);
		}
		 // Case 2 - trigger a Macro
		else {
			const macro = game.macros.get(li.dataset.macroId);
			return macro.execute();
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle hover events on a macro button to track which slot is the hover target
	 * @param {Event} event   The originating mouseover or mouseleave event
	 * @private
	 */
	_onHoverMacro(event) {
		event.preventDefault();
		const li = event.currentTarget;
		const hasAction = !li.classList.contains("inactive");
		 // Remove any existing tooltip
		const tooltip = li.querySelector(".tooltip");
		if ( tooltip ) li.removeChild(tooltip);
		 // Handle hover-in
		if ( event.type === "mouseenter" ) {
			this._hover = li.dataset.slot;
			if ( hasAction ) {
				const macro = game.macros.get(li.dataset.macroId);
				const tooltip = document.createElement("SPAN");
				tooltip.classList.add("tooltip");
				tooltip.textContent = macro.name;
				li.appendChild(tooltip);
			}
		}
		 // Handle hover-out
		else {
			this._hover = null;
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle pagination controls
	 * @param {Event} event   The originating click event
	 * @private
	 */
	_onClickPageControl(event) {
		this.cyclePage(event.currentTarget.dataset.action === "page-up" ? 1 : -1);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_canDragStart(selector) {
		return true;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragStart(event) {
		const li = event.currentTarget.closest(".macro");
		if ( !li.dataset.macroId ) return false;
		const dragData = { type: "Macro", id: li.dataset.macroId, slot: li.dataset.slot };
		event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
	}
	 /* -------------------------------------------- */
	 /** @override */
	_canDragDrop(selector) {
		return true;
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _onDrop(event) {
		event.preventDefault();
		 // Try to extract the data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData('text/plain'));
		}
		catch (err) { return }
		 // Get the drop target
		const li = event.target.closest(".macro");
		 // Allow for a Hook function to handle the event
		if ( Hooks.call("hotbarDrop", this, data, li.dataset.slot) === false ) return;
		 // Only handle Macro drops
		const macro = await this._getDropMacro(data);
		if ( macro ) game.user.assignHotbarMacro(macro, li.dataset.slot, {fromSlot: data.slot});
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the Macro entity being dropped in the Hotbar. If the data comes from a non-World source, create the Macro
	 * @param {Object} data             The data transfer attached to the DragEvent
	 * @return {Promise<Macro|null>}    A Promise which returns the dropped Macro, or null
	 * @private
	 */
	async _getDropMacro(data) {
		if ( data.type !== "Macro" ) return null;
		 // Case 1 - Data explicitly provided (but no ID)
		if ( data.data && !data.id ) {
			return await Macro.create(data.data);
		}
		 // Case 2 - Imported from a Compendium pack
		else if ( data.pack ) {
			const createData = await game.packs.get(data.pack).getEntry(data.id);
			return Macro.create(createData);
		}
		 // Case 3 - Imported from a World ID
		else {
			return game.macros.get(data.id);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle click events to toggle display of the macro bar
	 * @param {Event} event
	 * @private
	 */
	_onToggleBar(event) {
		event.preventDefault();
		if ( this._collapsed ) this.expand();
		else this.collapse();
	}
}

/**
 * An abstract base class for displaying a heads-up-display interface bound to a Placeable Object on the canvas
 * @type {Application}
 * @abstract
 * @interface
 */
class BasePlaceableHUD extends Application {
	constructor(...args) {
		super(...args);
		 /**
		 * Reference a PlaceableObject this HUD is currently bound to
		 * @type {PlaceableObject}
		 */
		this.object = null;
	}
	/* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 classes: ["placeable-hud"],
			popOut: false
		});
	}
	/* -------------------------------------------- */
	 /**
	 * Convenience access for the canvas layer which this HUD modifies
	 * @type {PlaceablesLayer}
	 */
	get layer() {
		return this.object.layer;
	}
	/* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */
	 /**
	 * Bind the HUD to a new PlaceableObject and display it
	 * @param {PlaceableObject} object    A PlaceableObject instance to which the HUD should be bound
	 */
	bind(object) {
	 const states = this.constructor.RENDER_STATES;
	 if ( [states.CLOSING, states.RENDERING].includes(this._state) ) return;
	 if ( this.object ) this.clear();
		// Record the new object
	 if ( !(object instanceof PlaceableObject ) || (object.scene !== canvas.scene) ) {
		 throw new Error("You may only bind a HUD instance to a PlaceableObject in the currently viewed Scene.")
		}
	 this.object = object;
		 // Render the HUD
		this.render(true);
		this.element.hide().fadeIn(200);
	}
	/* -------------------------------------------- */
	 /**
	 * Clear the HUD by fading out it's active HTML and recording the new display state
	 */
	clear() {
	 let states = this.constructor.RENDER_STATES;
	 if ( this._state <= states.NONE ) return;
	 this._state = states.CLOSING;
		// Unbind
	 this.object = null;
	 this.element.hide();
	 this._element = null;
		this._state = states.NONE
	}
	/* -------------------------------------------- */
	 /** @override */
	async _render(...args) {
	 await super._render(...args);
	 this.setPosition();
	}
	/* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const data = duplicate(this.object.data);
		return mergeObject(data, {
			id: this.id,
			classes: this.options.classes.join(" "),
			appId: this.appId,
			isGM: game.user.isGM,
			icons: CONFIG.controlIcons
		});
	}
	/* -------------------------------------------- */
	 /** @override */
	setPosition({left, top, width, height, scale}={}) {
	 const position = {
		 width: width || this.object.width,
			height: height || this.object.height,
			left: left ?? this.object.x,
			top: top ?? this.object.y
		};
		this.element.css(position);
	}
	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		html.find(".visibility").click(this._onToggleVisibility.bind(this));
		html.find(".locked").click(this._onToggleLocked.bind(this));
		html.find(".sort-up").click(this._onSort.bind(this, true));
		html.find(".sort-down").click(this._onSort.bind(this, false));
	}
	/* -------------------------------------------- */
	 /**
	 * Toggle the visible state of all controlled objects in the Layer
	 * @param {PointerEvent} event    The originating click event
	 * @private
	 */
	async _onToggleVisibility(event) {
		event.preventDefault();
		 // Toggle the visible state
		const isHidden = this.object.data.hidden;
		const updates = this.layer.controlled.map(o => {
			return {_id: o.id, hidden: !isHidden};
		});
		 // Update all objects
		await this.layer.updateMany(updates);
		event.currentTarget.classList.toggle("active", !isHidden);
	}
	/* -------------------------------------------- */
	 /**
	 * Toggle locked state of all controlled objects in the Layer
	 * @param {PointerEvent} event    The originating click event
	 * @private
	 */
	async _onToggleLocked(event) {
		event.preventDefault();
		 // Toggle the visible state
		const isLocked = this.object.data.locked;
		const updates = this.layer.controlled.map(o => {
			return {_id: o.id, locked: !isLocked};
		});
		 // Update all objects
		await this.layer.updateMany(updates);
		event.currentTarget.classList.toggle("active", !isLocked);
	}
	/* -------------------------------------------- */
	 /**
	 * Handle sorting the z-order of the object
	 * @param event
	 * @param up
	 * @return {Promise<void>}
	 * @private
	 */
	async _onSort(up, event) {
		event.preventDefault();
		const siblings = this.layer.placeables;
		const controlled = this.layer.controlled.filter(o => !o.data.locked);
		 // Determine target sort index
		let z = 0;
		if ( up ) {
			controlled.sort((a, b) => a.data.z - b.data.z);
			z = siblings.length ? Math.max(...siblings.map(o => o.data.z)) + 1 : 1;
		}
		else {
			controlled.sort((a, b) => b.data.z - a.data.z);
			z = siblings.length ? Math.min(...siblings.map(o => o.data.z)) - 1 : -1;
		}
		 // Update all controlled objects
		const updates = controlled.map((o, i) => {
			let d = up ? i : i * -1;
			return {_id: o.id, z: z + d};
		});
		await this.layer.updateMany(updates);
	}
}

/**
 * A simple main menu application
 * @type {Application}
 */
class MainMenu extends Application {
	static get defaultOptions() {
	 const options = super.defaultOptions;
	 options.id = "menu";
	 options.template = "templates/hud/menu.html";
	 options.popOut = false;
	 return options;
	}
	 /* ----------------------------------------- */
	 /**
	 * The structure of menu items
	 * @return {Object}
	 */
	get items() {
		return {
			 reload: {
				label: "MENU.Reload",
				icon: '<i class="fas fa-redo"></i>',
				enabled: true,
				onClick: () => window.location.reload()
			},
			logout: {
				label: "MENU.Logout",
				icon: '<i class="fas fa-user"></i>',
				enabled: true,
				onClick: () => game.logOut()
			},
			players: {
				label: "MENU.Players",
				icon: '<i class="fas fa-users"></i>',
				enabled: game.user.isGM,
				onClick: () => window.location.href = "./players"
			},
			world: {
				label: "MENU.Setup",
				icon: '<i class="fas fa-globe"></i>',
				enabled: game.user.isGM,
				onClick: () => game.shutDown()
			}
		}
	}
	/* -------------------------------------------- */
	 /** @override */
	getData() {
		return {
			items: this.items
		}
	}
	 /* ----------------------------------------- */
	 /** @override */
	activateListeners(html) {
		for ( let [k, v] of Object.entries(this.items) ) {
			html.find('.menu-'+k).click(ev => v.onClick());
		}
	}
	 /* ----------------------------------------- */
	 /**
	 * Toggle display of the menu (or render it in the first place)
	 */
	toggle() {
		let menu = this.element;
		if ( !menu.length ) this.render(true);
		else menu.slideToggle(150);
	}
}
/**
 * Top menu scene navigation
 * @type {Application}
 */
class SceneNavigation extends Application {
	constructor(options) {
	 super(options);
	 game.scenes.apps.push(this);
		 /**
		 * Navigation collapsed state
		 * @type {boolean}
		 */
		this._collapsed = false;
	}
	 /* -------------------------------------------- */
	 /**
	 * Assign the default options which are supported by the SceneNavigation UI
	 * @type {Object}
	 */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "navigation",
			template: "templates/hud/navigation.html",
			popOut: false,
			dragDrop: [{dragSelector: ".scene"}]
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Return an Array of Scenes which are displayed in the Navigation bar
	 * @return {Scene[]}
	 */
	get scenes() {
		const scenes = game.scenes.entities.filter(s => {
			return (s.data.navigation && s.visible) || s.active || s.isView;
		});
		scenes.sort((a, b) => a.data.navOrder - b.data.navOrder);
		return scenes;
	}
		/* -------------------------------------------- */
	/*  Application Rendering
	/* -------------------------------------------- */
	 /** @override */
	render(force, context={}) {
		let { renderContext, renderData} = context;
		if ( renderContext ) {
			const events = ["createScene", "updateScene", "deleteScene"];
			if ( !events.includes(renderContext) ) return;
			const updateKeys = ["name", "permission", "permission.default", "active", "navigation", "navName", "navOrder"];
			if ( renderContext === "updateScene" && !updateKeys.some(k => renderData.hasOwnProperty(k)) ) return;
		}
		return super.render(force, context);
	}
	/* -------------------------------------------- */
	 /** @override */
	async _render(...args) {
		await super._render(...args);
		const loading = document.getElementById("loading");
		const nav = this.element[0];
		loading.style.top = `${nav.offsetTop + nav.offsetHeight}px`;
	}
	/* -------------------------------------------- */
	 /** @override */
	getData(options) {
		 // Modify Scene data
		const scenes = this.scenes.map(s => {
			let data = duplicate(s.data);
			let users = game.users.entities.filter(u => u.active && (u.viewedScene === s._id));
			data.name = TextEditor.truncateText(data.navName || data.name, {maxLength: 32});
		 data.users = users.map(u => { return {letter: u.name[0], color: u.data.color} });
		 data.visible = (game.user.isGM || s.owner || s.active);
		 data.css = [
			 s.isView ? "view" : null,
				s.active ? "active" : null,
				data.permission.default === 0 ? "gm" : null
			].filter(c => !!c).join(" ");
		 return data;
		});
		 // Return data for rendering
		return {
			collapsed: this._collapsed,
			scenes: scenes
		}
	}
	/* -------------------------------------------- */
	 /**
	 * Expand the SceneNavigation menu, sliding it down if it is currently collapsed
	 */
	expand() {
		if ( !this._collapsed ) return true;
		const nav = this.element;
		const icon = nav.find("#nav-toggle i.fas");
		const ul = nav.children("#scene-list");
		return new Promise(resolve => {
			ul.slideDown(200, () => {
				nav.removeClass("collapsed");
				icon.removeClass("fa-caret-down").addClass("fa-caret-up");
				this._collapsed = false;
				Hooks.callAll("collapseSceneNavigation", this, this._collapsed);
				return resolve(true);
			});
		});
	}
	/* -------------------------------------------- */
	 /**
	 * Collapse the SceneNavigation menu, sliding it up if it is currently expanded
	 * @return {Promise<boolean>}
	 */
	async collapse() {
		if ( this._collapsed ) return true;
		const nav = this.element;
		const icon = nav.find("#nav-toggle i.fas");
		const ul = nav.children("#scene-list");
		return new Promise(resolve => {
			ul.slideUp(200, () => {
				nav.addClass("collapsed");
				icon.removeClass("fa-caret-up").addClass("fa-caret-down");
				this._collapsed = true;
				Hooks.callAll("collapseSceneNavigation", this, this._collapsed);
				return resolve(true);
			});
		});
	}
	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */
	 /**
	 * Activate Scene Navigation event listeners
	 * @param html
	 */
	activateListeners(html) {
		super.activateListeners(html);
		 // Click event listener
		const scenes = html.find('.scene');
		scenes.click(this._onClickScene.bind(this));
		html.find('#nav-toggle').click(this._onToggleNav.bind(this));
		 // Activate Context Menu
		const contextOptions = this._getContextMenuOptions();
		Hooks.call("getSceneNavigationContext", html, contextOptions);
		if ( contextOptions ) new ContextMenu(html, ".scene", contextOptions);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the set of ContextMenu options which should be applied for Scenes in the menu
	 * @return {object[]}   The Array of context options passed to the ContextMenu instance
	 * @private
	 */
	_getContextMenuOptions() {
		return [
			{
				name: "SCENES.Activate",
				icon: '<i class="fas fa-bullseye"></i>',
				condition: li => game.user.isGM && !game.scenes.get(li.data("sceneId")).data.active,
				callback: li => {
					let scene = game.scenes.get(li.data("sceneId"));
					scene.activate();
				}
			},
			{
				name: "SCENES.Configure",
				icon: '<i class="fas fa-cogs"></i>',
				condition: game.user.isGM,
				callback: li => {
					let scene = game.scenes.get(li.data("sceneId"));
					scene.sheet.render(true);
				}
			},
			{
				name: "SCENES.Notes",
				icon: '<i class="fas fa-scroll"></i>',
				condition: li => {
					if ( !game.user.isGM ) return false;
					const scene = game.scenes.get(li.data("sceneId"));
					return !!scene.journal;
				},
				callback: li => {
					const scene = game.scenes.get(li.data("sceneId"));
					const entry = scene.journal;
					if ( entry ) {
						const sheet = entry.sheet;
						sheet.options.sheetMode = "text";
						sheet.render(true);
					}
				}
			},
			{
				name: "SCENES.Preload",
				icon: '<i class="fas fa-download"></i>',
				condition: game.user.isGM,
				callback: li => {
					let sceneId = li.attr("data-scene-id");
					game.scenes.preload(sceneId, true);
				}
			},
			{
				name: "SCENES.ToggleNav",
				icon: '<i class="fas fa-compass"></i>',
				condition: li => {
					const scene = game.scenes.get(li.data("sceneId"));
					return game.user.isGM && ( !scene.data.active );
				},
				callback: li => {
					const scene = game.scenes.get(li.data("sceneId"));
					scene.update({navigation: !scene.data.navigation});
				}
			}
		];
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle left-click events on the scenes in the navigation menu
	 * @param {Event} event
	 * @private
	 */
	_onClickScene(event) {
		event.preventDefault();
		let sceneId = event.currentTarget.dataset.sceneId;
		game.scenes.get(sceneId).view();
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragStart(event) {
		const sceneId = event.currentTarget.dataset.sceneId;
		event.dataTransfer.setData("text/plain", JSON.stringify({
			type: "SceneNavigation",
			id: sceneId,
		}));
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _onDrop(event) {
		 // Process drop data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData("text/plain"));
		} catch(err) {
			return false;
		}
		if ( data.type !== "SceneNavigation" ) return false;
		 // Identify the entity, the drop target, and the set of siblings
		const entity = game.scenes.get(data.id);
		const dropTarget = event.target.closest(".scene") || null;
		const sibling = dropTarget ? game.scenes.get(dropTarget.dataset.sceneId) : null;
		if ( sibling && (sibling._id === entity._id) ) return;
		const siblings = this.scenes.filter(s => s._id !== entity._id);
		 // Update the navigation sorting for each Scene
		entity.sortRelative({
			target: sibling,
			siblings: siblings,
			sortKey: "navOrder",
			sortBefore: true
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle navigation menu toggle click events
	 * @param {Event} event
	 * @private
	 */
	_onToggleNav(event) {
		event.preventDefault();
		if ( this._collapsed ) this.expand();
		else this.collapse();
	}
	 /* -------------------------------------------- */
	 static _onLoadProgress(context, pct) {
		const loader = document.getElementById("loading");
		pct = Math.clamped(pct, 0, 100);
		loader.querySelector("#context").textContent = context;
		loader.querySelector("#loading-bar").style.width = `${pct}%`;
		loader.querySelector("#progress").textContent = `${pct}%`;
		loader.style.display = "block";
		if ( (pct === 100 ) && !loader.hidden) $(loader).fadeOut(2000);
	}
}

/**
 * Pause notification in the HUD
 * @type {Application}
 */
class Pause extends Application {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = "pause";
		options.template = "templates/hud/pause.html";
		options.popOut = false;
		return options;
	}
	 /* -------------------------------------------- */
	 /**
	 * Prepare the default data which is required to render the Pause UI
	 */
	getData() {
		return {
			paused: game.paused
		};
	}
}

/* -------------------------------------------- */

/**
 * The active Player List application
 * @Extends {Application}
 */
class PlayerList extends Application {
	constructor(options) {
		super(options);
		game.users.apps.push(this);
		 /**
		 * An internal toggle for whether or not to show offline players or hide them
		 * @type {boolean}
		 * @private
		 */
		this._showOffline = false;
	}
	/* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 id: "players",
			template: "templates/user/players.html",
			popOut: false
		});
	}
	/* -------------------------------------------- */
	/*  Application Rendering
	/* -------------------------------------------- */
	 /** @override */
	render(force, context={}) {
		let { renderContext, renderData} = context;
		if ( renderContext ) {
			const events = ["createUser", "updateUser", "deleteUser"];
			if ( !events.includes(renderContext) ) return;
			const updateKeys = ["name", "permission", "permission.default", "active", "navigation"];
			if ( renderContext === "updateUser" && !updateKeys.some(k => renderData.hasOwnProperty(k)) ) return;
		}
		return super.render(force, context);
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		 // Process user data by adding extra characteristics
		const users = game.users.entities.filter(u => this._showOffline || u.active).map(u => {
			u.charname = u.character ? u.character.name.split(" ")[0] : "";
			const color = u.active ? u.data.color : "#333333",
					rgb = PIXI.utils.hex2rgb(color.replace("#", "0x")),
					border = u.active ? PIXI.utils.hex2string(PIXI.utils.rgb2hex(rgb.map(c => Math.min(c * 2, 1)))) : "#000000";
			u.color = color;
			u.border = border;
			return u;
		}).sort((a, b) => {
			if ( (b.role >= USER_ROLES.ASSISTANT) && (b.role > a.role) ) return 1;
			return a.name.localeCompare(b.name);
		})
		 // Determine whether to hide the players list when using AV conferencing
		let hide = false;
		if ( game.webrtc && game.webrtc.settings.mode >= AVSettings.AV_MODES.VIDEO ) {
			hide = game.webrtc.settings.client.hidePlayerList;
		}
		 // Return the data for rendering
		return {
			users: users,
			showOffline: this._showOffline,
			hide: hide
		};
	}
	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		 // Toggle online/offline
		html.find("h3").click(this._onToggleOfflinePlayers.bind(this));
		 // Context menu
		const contextOptions = this._getUserContextOptions();
		Hooks.call(`getUserContextOptions`, html, contextOptions);
		new ContextMenu(html, ".player", contextOptions);
	}
	/* -------------------------------------------- */
	 /**
	 * Return the default context options available for the Players application
	 * @return {object[]}
	 * @private
	 */
	_getUserContextOptions() {
		return [
			{
				name: game.i18n.localize("PLAYERS.ConfigTitle"),
				icon: '<i class="fas fa-male"></i>',
				condition: li => game.user.isGM || (li[0].dataset.userId === game.user._id),
				callback: li => {
					const user = game.users.get(li[0].dataset.userId);
					new PlayerConfig(user).render(true)
				}
			},
			{
				name: game.i18n.localize("PLAYERS.ViewAvatar"),
				icon: '<i class="fas fa-image"></i>',
				condition: li => {
					const user = game.users.get(li[0].dataset.userId);
					return user.avatar !== CONST.DEFAULT_TOKEN;
				},
				callback: li => {
					let user = game.users.get(li.data("user-id"));
					new ImagePopout(user.avatar, {
						title: user.name,
						shareable: false,
						uuid: user.uuid
					}).render(true);
				}
			},
			{
				name: game.i18n.localize("PLAYERS.PullToScene"),
				icon: '<i class="fas fa-directions"></i>',
				condition: li => game.user.isGM && (li[0].dataset.userId !== game.user._id),
				callback: li => game.socket.emit("pullToScene", canvas.scene._id, li.data("user-id"))
			},
			{
				name: game.i18n.localize("PLAYERS.Kick"),
				icon: '<i class="fas fa-door-open"></i>',
				condition: li => {
					const user = game.users.get(li[0].dataset.userId);
					return game.user.isGM && user.active && !user.isSelf;
				},
				callback: li => {
					const user = game.users.get(li[0].dataset.userId);
					const role = user.role;
					user.update({role: CONST.USER_ROLES.NONE}).then(u => u.update({role}));
					ui.notifications.info(`${user.name} has been kicked from the world.`);
				}
			},
			{
				name: game.i18n.localize("PLAYERS.Ban"),
				icon: '<i class="fas fa-ban"></i>',
				condition: li => {
					const user = game.users.get(li[0].dataset.userId);
					return game.user.isGM && !user.isSelf && (user.role !== CONST.USER_ROLES.NONE);
				},
				callback: li => {
					const user = game.users.get(li[0].dataset.userId);
					user.update({role: CONST.USER_ROLES.NONE});
					ui.notifications.info(`${user.name} has been <strong>banned</strong> from the world.`);
				}
			},
			{
				name: game.i18n.localize("PLAYERS.UnBan"),
				icon: '<i class="fas fa-ban"></i>',
				condition: li => {
					const user = game.users.get(li[0].dataset.userId);
					return game.user.isGM && !user.isSelf && (user.role === CONST.USER_ROLES.NONE);
				},
				callback: li => {
					const user = game.users.get(li[0].dataset.userId);
					user.update({role: CONST.USER_ROLES.PLAYER});
					ui.notifications.info(`${user.name} has been restored to a Player role in the World.`);
				}
			}
		];
	}
	/* -------------------------------------------- */
	 /**
	 * Toggle display of the Players hud setting for whether or not to display offline players
	 * @param {Event} event   The originating click event
	 * @private
	 */
	_onToggleOfflinePlayers(event) {
		event.preventDefault();
		this._showOffline = !this._showOffline;
		this.render();
	}
}

/**
 * Audio/Video Conferencing Configuration Sheet
 * @type {FormApplication}
 */
class AVConfig extends FormApplication {
	constructor(object, options) {
		super(object || game.webrtc, options);
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			title: game.i18n.localize("WEBRTC.Title"),
			id: "av-config",
			template: "templates/sidebar/apps/av-config.html",
			popOut: true,
			width: 480,
			height: "auto",
			tabs: [{navSelector: ".tabs", contentSelector: "form", initial: "general"}]
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	async getData(options) {
		const settings = this.object.settings;
		const videoSources = await this.object.client.getVideoSources();
		const audioSources = await this.object.client.getAudioSources();
		const audioSinks = await this.object.client.getAudioSinks();
		 // If the currently chosen device is unavailable, display a separate option for 'unavailable device (use default)'
		const { videoSrc, audioSrc, audioSink } = settings.client;
		const videoSrcUnavailable = videoSrc && (videoSrc !== "default") && !Object.keys(videoSources).includes(videoSrc);
		const audioSrcUnavailable = audioSrc && (audioSrc !== "default") && !Object.keys(audioSources).includes(audioSrc);
		const audioSinkUnavailable = audioSink && (audioSink !== "default") && !Object.keys(audioSinks).includes(audioSink);
		const isSSL = window.location.protocol === "https:";
		 // Audio/Video modes
		const modes = {
			[AVSettings.AV_MODES.DISABLED]: "WEBRTC.ModeDisabled",
			[AVSettings.AV_MODES.AUDIO]: "WEBRTC.ModeAudioOnly",
			[AVSettings.AV_MODES.VIDEO]: "WEBRTC.ModeVideoOnly",
			[AVSettings.AV_MODES.AUDIO_VIDEO]: "WEBRTC.ModeAudioVideo"
		};
		 // Voice Broadcast modes
		const voiceModes = Object.values(AVSettings.VOICE_MODES).reduce((obj, m) => {
			obj[m] = game.i18n.localize("WEBRTC.VoiceMode"+m.titleCase());
			return obj;
		}, {});
		 // Return data to the template
		return {
			user: game.user,
			modes,
			voiceModes,
			serverTypes: {FVTT: "WEBRTC.FVTTSignalingServer", custom: "WEBRTC.CustomSignalingServer"},
			turnTypes: {server: "WEBRTC.TURNServerProvisioned", custom: "WEBRTC.CustomTURNServer"},
			settings,
			canSelectMode: game.user.isGM && isSSL,
			noSSL: !isSSL,
			videoSources,
			audioSources,
			audioSinks: isObjectEmpty(audioSinks) ? false : audioSinks,
			videoSrcUnavailable,
			audioSrcUnavailable,
			audioSinkUnavailable
		};
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		 // Push-to-talk key assignment
		const ptt = html.find('input[name="client.voice.pttName"]');
		ptt.keydown(this._onPTTKeyDown.bind(this)).mousedown(this._onPTTMouseDown.bind(this));
		 // Options below are GM only
		if ( !game.user.isGM ) return;
		html.find('select[name="world.server.type"]').change(this._onServerTypeChanged.bind(this));
		html.find('select[name="world.turn.type"]').change(this._onTurnTypeChanged.bind(this));
		 // Activate or de-activate the custom server and turn configuration sections based on current settings
		const settings = this.object.settings;
		this._setConfigSectionEnabled(".webrtc-custom-server-config", settings.world.server.type === "custom");
		this._setConfigSectionEnabled(".webrtc-custom-turn-config", settings.world.turn.type === "custom");
	}
	 /* -------------------------------------------- */
	 /**
	 * Set a section's input to enabled or disabled
	 * @param {string} selector    Selector for the section to enable or disable
	 * @param {boolean} enabled    Whether to enable or disable this section
	 * @private
	 */
	_setConfigSectionEnabled(selector, enabled = true) {
		let section = this.element.find(selector);
		if (section) {
			section.css("opacity", enabled ? 1.0 : 0.5);
			section.find("input").prop("disabled", !enabled);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Callback when the server type changes
	 * Will enable or disable the server section based on whether the user selected a custom server or not
	 * @param {Event} event   The event that triggered the server type change
	 * @private
	 */
	_onServerTypeChanged(event) {
		event.preventDefault();
		const choice = event.currentTarget.value;
		this._setConfigSectionEnabled(".webrtc-custom-server-config", choice === "custom")
	}
	 /* -------------------------------------------- */
	 /**
	 * Callback when the turn server type changes
	 * Will enable or disable the turn section based on whether the user selected a custom turn or not
	 * @param {Event} event   The event that triggered the turn server type change
	 * @private
	 */
	_onTurnTypeChanged(event) {
		event.preventDefault();
		const choice = event.currentTarget.value;
		this._setConfigSectionEnabled(".webrtc-custom-turn-config", choice === "custom")
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the assignment of a push-to-talk/push-to-mute key
	 * @param {Event} event
	 * @private
	 */
	_onPTTKeyDown(event) {
		event.preventDefault();
		event.target.value = event.originalEvent.key.toUpperCase();
		const form = event.target.form;
		form["client.voice.pttKey"].value = event.originalEvent.keyCode;
		form["client.voice.pttMouse"].value = false;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the assignment of a push-to-talk/push-to-mute mouse key
	 * @param {Event} event
	 * @private
	 */
	_onPTTMouseDown(event) {
		if (document.activeElement !== event.target) return;
		event.preventDefault();
		const button = event.originalEvent.button;
		event.target.value = `MOUSE-${button}`;
		const form = event.target.form;
		form["client.voice.pttKey"].value = button;
		form["client.voice.pttMouse"].value = true;
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		const settings = game.webrtc.settings;
		settings.client.videoSrc = settings.client.videoSrc || null;
		settings.client.audioSrc = settings.client.audioSrc || null;
		const update = expandObject(formData);
		 // Update world settings
		if ( game.user.isGM ) {
			const world = mergeObject(settings.world, update.world);
			game.settings.set("core", "rtcWorldSettings", world);
		}
		 // Update client settings
		const client = mergeObject(settings.client, update.client);
		game.settings.set("core", "rtcClientSettings", client);
	}
}
/**
 * Abstraction of the Application interface to be used with the Draggable class as a substitute for the app
 * This class will represent one popout feed window and handle its positioning and draggability
 * @param {CameraViews} view      The CameraViews application that this popout belongs to
 * @param {string} userId         ID of the user this popout belongs to
 * @param {jQuery} element        The div element of this specific popout window
 */
class CameraPopoutAppWrapper {
	constructor(view, userId, element) {
		this.view = view;
		this.element = element;
		this.userId = userId;
		let setting = game.webrtc.settings.getUser(userId);
		this.setPosition({ left: setting.x, top: setting.y, width: setting.width });
		new Draggable(this, element.find(".camera-view"), element.find(".video-container")[0], true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the current position of this popout window
	 */
	get position() {
		return mergeObject(this.element.position(), {
			width: this.element.outerWidth(),
			height: this.element.outerHeight(),
			scale: 1
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	setPosition({ left, top, width, height, scale } = {}) {
		const updates = {};
		 // Constrain aspect ratio + 30px for nameplate
		if (width || height) {
			if (width) height = Math.floor(width * 3 / 4 + 30);
			else if (height) width = Math.floor((height - 30) * 4 / 3);
			this.element.outerWidth(width);
			this.element.outerHeight(height);
			updates.width = width;
		}
		 // Position
		this.element.css({ left, top });
		if (left) updates.x = left;
		if ( top ) updates.y = top;
		 // Save settings
		if ( !isObjectEmpty(updates) ) {
			const current = game.webrtc.settings.client.users[this.userId] || {};
			const update = mergeObject(current, updates);
			game.webrtc.settings.set("client", `users.${this.userId}`, update);
		}
	}
	 /* -------------------------------------------- */
	 _onResize(event) {}
	 /* -------------------------------------------- */
	 /** @override */
	bringToTop() {
		let parent = this.element.parent();
		let children = parent.children();
		let lastElement = children[children.length - 1];
		if (lastElement !== this.element[0]) {
			game.webrtc.settings.set("client", `users.${this.userId}.z`, ++this.view.maxZ);
			parent.append(this.element);
		}
	}
}

/**
 * The Camera UI View that displays all the camera feeds as individual video elements.
 * @type {Application}
 *
 * @param {WebRTC} webrtc     The WebRTC Implementation to display
 */
class CameraViews extends Application {
	constructor(webrtc, options) {
		super(options);
		game.users.apps.push(this);
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "camera-views",
			template: "templates/hud/camera-views.html",
			popOut: false
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * A reference to the master AV orchestrator instance
	 * @type {AVMaster}
	 */
	get webrtc() {
		return game.webrtc;
	}
	 /* -------------------------------------------- */
	/* Public API                                   */
	/* -------------------------------------------- */
	 /**
	 * Obtain a reference to the div.camera-view which is used to portray a given Foundry User.
	 * @param {string} userId     The ID of the User entity
	 * @return {HTMLElement|null}
	 */
	getUserCameraView(userId) {
		return this.element.find(`.camera-view[data-user=${userId}]`)[0] || null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Obtain a reference to the video.user-camera which displays the video channel for a requested Foundry User.
	 * If the user is not broadcasting video this will return null.
	 * @param {string} userId     The ID of the User entity
	 * @return {HTMLVideoElement|null}
	 */
	getUserVideoElement(userId) {
		return this.element.find(`.camera-view[data-user=${userId}] video.user-camera`)[0] || null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Sets whether a user is currently speaking or not
	 *
	 * @param {string} userId     The ID of the user
	 * @param {boolean} speaking  Whether the user is speaking
	 */
	setUserIsSpeaking(userId, speaking) {
		const view = this.getUserCameraView(userId);
		if ( view ) view.classList.toggle("speaking", speaking);
	}
	 /* -------------------------------------------- */
	/*  Application Rendering                       */
	/* -------------------------------------------- */
	 /**
	 * Extend the render logic to first check whether a render is necessary based on the context
	 * If a specific context was provided, make sure an update to the navigation is necessary before rendering
	 */
	render(force, context={}) {
		const { renderContext, renderData } = context;
		if (this.webrtc.mode === AVSettings.AV_MODES.DISABLED)
			return;
		if (renderContext) {
			if (renderContext !== "updateUser")
				return;
			const updateKeys = ["name", "permissions", "role", "active", "color", "sort", "character", "avatar"];
			if (!updateKeys.some(k => renderData.hasOwnProperty(k)))
				return;
		}
		return super.render(force, context);
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _render(force = false, options = {}) {
		await super._render(force, options);
		this._setPlayerListVisibility();
		this.webrtc.onRender();
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const settings = this.webrtc.settings;
		const userSettings = settings.users;
		 // Get the sorted array of connected users
		const connectedIds = this.webrtc.client.getConnectedUsers();
		const users = connectedIds.reduce((users, u) => {
			const data = this._getDataForUser(u, userSettings[u]);
			if ( data ) users.push(data);
			return users;
		}, []);
		users.sort(this.constructor._sortUsers);
		 // Maximum Z of all user popout windows
		this.maxZ = Math.max(...users.map(u => userSettings[u.id].z));
		 // Define a dynamic class for the camera dock container which affects it's rendered style
		let dockClass = `camera-size-${settings.client.dockSize} camera-position-${settings.client.dockPosition}`;
		if (!users.some(u => !u.settings.popout)) dockClass += " webrtc-dock-empty";
		 // Alter the body class depending on whether the players list is hidden
		if (settings.client.hidePlayerList) document.body.classList.add("players-hidden");
		else document.body.classList.remove("players-hidden");
		 // Return data for rendering
		return {
			self: game.user,
			users: users,
			dockClass: dockClass,
			muteAll: settings.muteAll
		};
	}
	 /* -------------------------------------------- */
	 /**
	 * Prepare rendering data for a single user
	 * @private
	 */
	_getDataForUser(userId, settings) {
		const user = game.users.get(userId);
		if ( !user || !user.active ) return null;
		const charname = user.character ? user.character.name.split(" ")[0] : "";
		 // CSS classes for the frame
		const frameClass = settings.popout ? "camera-box-popout" : "camera-box-dock";
		const audioClass = this.webrtc.canUserBroadcastAudio(userId) ? null : "no-audio";
		const videoClass = this.webrtc.canUserBroadcastVideo(userId) ? null : "no-video";
		 // Return structured User data
		return {
			user: user,
			id: user.id,
			local: user.isSelf,
			name: user.name,
			color: user.data.color,
			colorAlpha: hexToRGBAString(colorStringToHex(user.data.color), 0.20),
			charname: user.isGM ? game.i18n.localize("GM") : charname,
			avatar: user.avatar,
			settings: settings,
			volume: AudioHelper.volumeToInput(settings.volume),
			cameraViewClass: [frameClass, videoClass, audioClass].filterJoin(" ")
		};
	}
	 /* -------------------------------------------- */
	 /**
	 * A custom sorting function that orders/arranges the user display frames
	 * @return {number}
	 * @private
	 */
	static _sortUsers(a, b) {
		const as = a.settings;
		const bs = b.settings;
		if (as.popout && bs.popout) return as.z - bs.z; // Sort popouts by z-index
		if (as.popout) return -1;                       // Show popout feeds first
		if (bs.popout) return 1;
		if (a.user.isSelf) return -1;                   // Show local feed first
		if (b.user.isSelf) return 1;
		if (a.hasVideo && !b.hasVideo) return -1;       // Show remote users with a camera before those without
		if (b.hasVideo && !a.hasVideo) return 1;
		return a.user.data.sort - b.user.data.sort;     // Sort according to user order
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		 // Display controls when hovering over the video container
		let cvh = this._onCameraViewHover.bind(this);
		html.find('.camera-view').hover(cvh, cvh);
		 // Handle clicks on AV control buttons
		html.find(".av-control").click(this._onClickControl.bind(this));
		 // Handle volume changes
		html.find(".webrtc-volume-slider").change(this._onVolumeChange.bind(this));
		 // Hide Global permission icons depending on the A/V mode
		const mode = this.webrtc.mode;
		if (mode === AVSettings.AV_MODES.VIDEO) html.find('[data-action="toggle-audio"]').hide();
		if (mode === AVSettings.AV_MODES.AUDIO) html.find('[data-action="toggle-video"]').hide();
		 // Make each popout window draggable
		for (let popout of this.element.find(".app.camera-view-popout")) {
			let box = popout.querySelector(".camera-view");
			new CameraPopoutAppWrapper(this, box.dataset.user, $(popout));
		}
		 // Listen to the video's srcObjectSet event to set the display mode of the user.
		for (let video of this.element.find("video")) {
			const view = video.closest(".camera-view");
			this._refreshView(view);
			video.addEventListener('webrtcVideoSet', ev => {
				const view = video.closest(".camera-view");
				if ( view.dataset.user !== ev.detail ) return;
				this._refreshView(view);
			});
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * On hover in a camera container, show/hide the controls.
	 * @event {Event} event   The original mouseover or mouseout hover event
	 * @private
	 */
	_onCameraViewHover(event) {
		this._toggleControlVisibility(event.currentTarget, event.type === "mouseenter", null);
	}
	 /* -------------------------------------------- */
	 /**
	 * On clicking on a toggle, disable/enable the audio or video stream.
	 * @event {MouseEvent} event   The originating click event
	 * @private
	 */
	async _onClickControl(event) {
		event.preventDefault();
		 // Reference relevant data
		const button = event.currentTarget;
		const action = button.dataset.action;
		const view = button.closest(".camera-view");
		const user = game.users.get(view.dataset.user);
		const settings = this.webrtc.settings;
		const userSettings = settings.getUser(user.id);
		 // Handle different actions
		switch ( action ) {
			 // Globally block video
			case "block-video": {
				if (!game.user.isGM) break;
				await user.update({"permissions.BROADCAST_VIDEO": !userSettings.canBroadcastVideo});
				this._refreshView(view);
				break;
			}
			 // Globally block audio
			case "block-audio": {
				if (!game.user.isGM) break;
				await user.update({"permissions.BROADCAST_AUDIO": !userSettings.canBroadcastAudio});
				this._refreshView(view);
				break;
			}
			 // Toggle video display
			case "toggle-video": {
				if ( !user.isSelf ) break;
				if ( userSettings.hidden && !userSettings.canBroadcastVideo ) {
					return ui.notifications.warn(game.i18n.localize("WEBRTC.WarningCannotEnableVideo"))
				}
				await settings.set("client", `users.${user.id}.hidden`, !userSettings.hidden);
				this._refreshView(view);
				break;
			}
			 // Toggle audio output
			case "toggle-audio":
				if ( !user.isSelf ) break;
				if ( userSettings.muted && !userSettings.canBroadcastAudio ) {
					return ui.notifications.warn(game.i18n.localize("WEBRTC.WarningCannotEnableAudio"))
				}
				await settings.set("client", `users.${user.id}.muted`, !userSettings.muted);
				this._refreshView(view);
				break;
			 // Toggle mute all peers
			case "mute-peers":
				if ( !user.isSelf ) break;
				await settings.set("client", "muteAll", !settings.client.muteAll);
				this._refreshView(view);
				break;
			 // Configure settings
			case "configure":
				return this.webrtc.config.render(true);
			 // Toggle popout
			case "toggle-popout":
				await settings.set("client", `users.${user.id}.popout`, !userSettings.popout);
				return this.render();
			 // Hide players
			case "toggle-players":
				await settings.set("client", "hidePlayerList", !settings.client.hidePlayerList);
				return this.render();
			 // Cycle camera size
			case "change-size":
				const sizes = ["large", "medium", "small"];
				const size = sizes.indexOf(settings.client.dockSize);
				const next = size+1 >= sizes.length ? 0 : size+1;
				await settings.set("client", "dockSize", sizes[next]);
				return this.render();
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Change volume control for a stream
	 * @param {Event} event   The originating change event from interaction with the range input
	 * @private
	 */
	_onVolumeChange(event) {
		const input = event.currentTarget;
		const box = input.closest(".camera-view");
		const userId = box.dataset.user;
		let volume = AudioHelper.inputToVolume(input.value);
		box.getElementsByTagName("video")[0].volume = volume;
		this.webrtc.settings.set("client", `users.${userId}.volume`, volume);
	}
	 /* -------------------------------------------- */
	/*  Internal Helpers                            */
	/* -------------------------------------------- */
	 /**
	 * Dynamically refresh the state of a single camera view
	 * @param {HTMLElement} view      The view container div
	 * @private
	 */
	_refreshView(view) {
		const userId = view.dataset.user;
		const isSelf = game.user._id === userId;
		const clientSettings = game.webrtc.settings.client;
		const userSettings = game.webrtc.settings.getUser(userId);
		 // Identify permissions
		const cbv = game.webrtc.canUserBroadcastVideo(userId);
		const csv = game.webrtc.canUserShareVideo(userId);
		const cba = game.webrtc.canUserBroadcastAudio(userId);
		const csa = game.webrtc.canUserShareAudio(userId);
		 // Refresh video display
		const video = view.querySelector("video.user-camera");
		const avatar = view.querySelector("img.user-avatar");
		if (video && avatar) {
			video.style.visibility = csv ? 'visible' : "hidden";
			video.style.display = csv ? "block" : "none";
			avatar.style.display = csv ? "none" : "unset";
		}
		 // Hidden and muted status icons
		view.querySelector(".status-hidden").classList.toggle("hidden", csv);
		view.querySelector(".status-muted").classList.toggle("hidden", csa);
		 // Volume bar and video output volume
		video.volume = userSettings.volume;
		video.muted = isSelf || clientSettings.muteAll; // Mute your own video
		const volBar = view.querySelector(".volume-bar");
		const displayBar = (userId !== game.user._id) && cba;
		volBar.style.display = displayBar ? "block" : "none";
		volBar.disabled = !displayBar;
		 // Control toggle states
		const actions = {
			"block-video": {state: !cbv, display: game.user.isGM && !isSelf},
			"block-audio": {state: !cba, display: game.user.isGM && !isSelf},
			"toggle-video": {state: !csv, display: isSelf},
			"toggle-audio": {state: !csa, display: isSelf},
			"mute-peers": {state: clientSettings.muteAll, display: isSelf},
			"toggle-players": {state: !clientSettings.hidePlayerList, display: isSelf}
		};
		const toggles = view.querySelectorAll(".av-control.toggle");
		for ( let button of toggles ) {
			const action = button.dataset.action;
			if (!(action in actions) ) continue;
			const state = actions[action].state;
			const displayed = actions[action].display;
			button.style.display = displayed ? "block" : "none";
			button.enabled = displayed;
			button.children[0].classList.remove(this._getToggleIcon(action, !state));
			button.children[0].classList.add(this._getToggleIcon(action, state));
			button.setAttribute("title", this._getToggleTooltip(action, state));
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Render changes needed to the PlayerList ui.
	 * Show/Hide players depending on option.
	 * @private
	 */
	_setPlayerListVisibility() {
		let players = document.getElementById("players");
		if (! players ) return;
		players.classList.toggle("hidden", this.webrtc.settings.client.hidePlayerList);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the icon class that should be used for various action buttons with different toggled states.
	 * The returned icon should represent the visual status of the NEXT state (not the CURRENT state).
	 *
	 * @param {string} action     The named av-control button action
	 * @param {boolean} state     The CURRENT action state.
	 * @return {string}           The icon that represents the NEXT action state.
	 * @private
	 */
	_getToggleIcon(action, state) {
		const actionMapping = {
			"block-video": ["fa-video", "fa-video-slash"],            // True means "blocked"
			"block-audio": ["fa-microphone", "fa-microphone-slash"],  // True means "blocked"
			"toggle-video": ["fa-video", "fa-video-slash"],           // True means "enabled"
			"toggle-audio": ["fa-microphone", "fa-microphone-slash"], // True means "enabled"
			"mute-peers": ["fa-volume-up", "fa-volume-mute"],         // True means "muted"
			"toggle-players": ["fa-caret-square-right", "fa-caret-square-left"] // True means "displayed"
		};
		const icons = actionMapping[action];
		return icons ? icons[state ? 1: 0] : null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the text title that should be used for various action buttons with different toggled states.
	 * The returned title should represent the tooltip of the NEXT state (not the CURRENT state).
	 *
	 * @param {string} action     The named av-control button action
	 * @param {boolean} state     The CURRENT action state.
	 * @return {string}           The icon that represents the NEXT action state.
	 * @private
	 */
	_getToggleTooltip(action, state) {
		const actionMapping = {
			"block-video": ["BlockUserVideo", "AllowUserVideo"],      // True means "blocked"
			"block-audio": ["BlockUserAudio", "AllowUserAudio"],      // True means "blocked"
			"toggle-video": ["DisableMyVideo", "EnableMyVideo"],      // True means "enabled"
			"toggle-audio": ["DisableMyAudio", "EnableMyAudio"],      // True means "enabled"
			"mute-peers": ["MutePeers", "UnmutePeers"],               // True means "muted"
			"toggle-players": ["ShowPlayers", "HidePlayers"]          // True means "displayed"
		};
		const labels = actionMapping[action];
		return game.i18n.localize(`WEBRTC.Tooltip${labels ? labels[state ? 1 : 0] : ""}`);
	}
	 /* -------------------------------------------- */
	 /**
	 * Show or hide UI control elements
	 * This replaces the use of jquery.show/hide as it simply adds a class which has display:none
	 * which allows us to have elements with display:flex which can be hidden then shown without
	 * breaking their display style.
	 * This will show/hide the toggle buttons, volume controls and overlay sidebars
	 * @param {jQuery} container    The container for which to show/hide control elements
	 * @param {boolean} show        Whether to show or hide the controls
	 * @param {string} selector     Override selector to specify which controls to show or hide
	 * @private
	 */
	_toggleControlVisibility(container, show, selector) {
		selector = selector || `.control-bar`;
		container.querySelectorAll(selector).forEach(c => c.classList.toggle("hidden", !show));
	}
}

/**
 * Configuration sheet for the Drawing object
 * @type {FormApplication}
 *
 * @param {Drawing} drawing         The Drawing object being configured
 * @param {object} options          Additional application rendering options
 * @param {boolean} [options.preview]  Configure a preview version of the Drawing which is not yet saved
 */
class DrawingConfig extends FormApplication {
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 id: "drawing-config",
			classes: ["sheet"],
			template: "templates/scene/drawing-config.html",
			width: 480,
			height: 360,
			configureDefault: false,
			tabs: [{navSelector: ".tabs", contentSelector: "form", initial: "position"}]
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	get title() {
		const title = this.options.configureDefault ? "DRAWING.ConfigDefaultTitle" : "DRAWING.ConfigTitle";
		return game.i18n.localize(title);
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const author = game.users.get(this.object.data.author);
		 // Submit text
		let submit;
		if ( this.options.configureDefault ) submit = "DRAWING.SubmitDefault";
		else submit = this.options.preview ? "DRAWING.SubmitCreate" : "DRAWING.SubmitUpdate";
		 // Return data
		return {
			author: author ? author.name : "",
			isDefault: this.options.configureDefault,
			fillTypes: this.constructor._getFillTypes(),
			fontFamilies: CONFIG.fontFamilies.reduce((obj, f) => {
				obj[f] = f;
				return obj;
			}, {}),
			object: duplicate(this.object.data),
			options: this.options,
			submitText: submit
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the names and labels of fill type choices which can be applied
	 * @return {Object}
	 * @private
	 */
	static _getFillTypes() {
		return Object.entries(CONST.DRAWING_FILL_TYPES).reduce((obj, v) => {
			obj[v[1]] = `DRAWING.FillType${v[0].titleCase()}`;
			return obj;
		}, {});
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		if ( !this.object.owner ) throw new Error("You do not have the ability to configure this Drawing object.");
		 // Configure the default Drawing settings
		if ( this.options.configureDefault ) {
			await Drawing.create(mergeObject(formData, {
				type: DRAWING_TYPES.RECTANGLE,
				author: game.user._id,
				x: 1000,
				y: 1000
			}), {temporary: true}); // This is to ensure the default data is valid
			return game.settings.set("core", DrawingsLayer.DEFAULT_CONFIG_SETTING, formData);
		}
		 // Create or update a Drawing
		if ( this.object.id ) {
			formData["id"] = this.object.id;
			return this.object.update(formData);
		}
		return this.object.constructor.create(formData);
	}
	 /* -------------------------------------------- */
	 /** @override */
	async close(options) {
		await super.close(options);
		if ( this.preview ) {
			this.preview.removeChildren();
			this.preview = null;
		}
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
	 super.activateListeners(html);
		html.find('button[name="resetDefault"]').click(this._onResetDefaults.bind(this));
	}
	 /* -------------------------------------------- */
	 /**
	 * Reset the user Drawing configuration settings to their default values
	 * @param event
	 * @private
	 */
	_onResetDefaults(event) {
		event.preventDefault();
	 game.settings.set("core", DrawingsLayer.DEFAULT_CONFIG_SETTING, {});
	 this.object.data = canvas.drawings._getNewDrawingData({});
		this.render();
	}
}

/* -------------------------------------------- */

/**
 * An implementation of the PlaceableHUD base class which renders a heads-up-display interface for Drawing objects.
 * @extends {BasePlaceableHUD}
 */
class DrawingHUD extends BasePlaceableHUD {
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 id: "drawing-hud",
			template: "templates/hud/drawing-hud.html"
		});
	}
	/* -------------------------------------------- */
	 /** @override */
	getData() {
		const data = super.getData();
		return mergeObject(data, {
			lockedClass: data.locked ? "active" : "",
			visibilityClass: data.hidden ? "active" : "",
		});
	}
	/* -------------------------------------------- */
	 /** @override */
	setPosition() {
	 let {x, y, width, height} = this.object.drawing.hitArea;
	 const c = 70;
	 const p = 10;
	 const position = {
		 width: width + (c * 2) + (p * 2),
			height: height + (p * 2),
			left: x + this.object.data.x - c - p,
			top: y + this.object.data.y - p
		};
		this.element.css(position);
	}
}

/**
 * Light Source Configuration Sheet
 * @implements {FormApplication}
 *
 * @param light {AmbientLight} The AmbientLight object for which settings are being configured
 * @param options {Object}     LightConfig ui options (see Application)
 */
class LightConfig extends FormApplication {
	constructor(...args) {
		super(...args);
		if (!game.user.isGM) throw "You do not have the ability to configure an AmbientLight object.";
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			classes: ["sheet", "light-sheet"],
			title: "LIGHT.ConfigTitle",
			template: "templates/scene/light-config.html",
			width: 480
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const animationTypes = {"": "None"};
		for ( let [k, v] of Object.entries(CONFIG.Canvas.lightAnimations) ) {
			animationTypes[k] = v.label;
		}
		const lightTypes = Object.entries(CONST.SOURCE_TYPES).reduce((obj, e) => {
			obj[e[1]] = `LIGHT.Type${e[0].titleCase()}`;
			return obj;
		}, {});
		return {
			object: duplicate(this.object.data),
			options: this.options,
			submitText: game.i18n.localize(this.options.preview ? "LIGHT.Create" : "LIGHT.Update"),
			lightTypes: lightTypes,
			lightAnimations: animationTypes,
			colorIntensity: Math.sqrt(this.object.data.tintAlpha).toNearest(0.05)
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find("input, select").change(this._onPreviewChange.bind(this));
	}
	 /* -------------------------------------------- */
	 /** @override */
	async close(options) {
		this._resetObject(true);
		return super.close(options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Preview the change caused by a change on the form by refreshing the display of the light source
	 * @private
	 */
	_onPreviewChange(event) {
		const input = event.currentTarget;
		if ( !this._originalData ) this._originalData = duplicate(this.object.data);
		this.object.data = mergeObject(this.object.data, this._getSubmitData(), {inplace: false});
		if ( input.dataset.edit ) this.object.data[input.dataset.edit] = input.value;
		this.object.updateSource();
		this.object.refresh();
	}
	 /* -------------------------------------------- */
	 /** @override */
	_getSubmitData(updateData) {
		const data = super._getSubmitData(updateData);
		data.tintAlpha = Math.pow(data.tintAlpha, 2).toNearest(0.01);
		return data;
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		this._resetObject(false);
		if ( this.object.id ) return this.object.update(formData);
		return this.object.constructor.create(formData);
	}
	 /* -------------------------------------------- */
	 /**
	 * Reset the state of the previewed light source object to its original data
	 * @private
	 */
	_resetObject(refresh=true) {
		if ( this._originalData ) {
			this.object.data = this._originalData;
			if ( refresh ) this.object.refresh();
		}
		this._originalData = null;
	}
}

/**
 * Placeable Note configuration sheet
 * @type {FormApplication}
 * @param note {Note}          The Note object for which settings are being configured
 * @param options {Object}     Additional Application options
 */
class NoteConfig extends FormApplication {
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 id: "note-config",
			title: game.i18n.localize("NOTE.ConfigTitle"),
			template: "templates/scene/note-config.html",
			width: 400
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const entry = game.journal.get(this.object.data.entryId) || {};
		return {
			entryIcons: invertObject(CONFIG.JournalEntry.noteIcons),
			entryId: entry._id,
			entryName: entry.name,
			entries: game.journal.entities,
			fontFamilies: CONFIG.fontFamilies.reduce((obj, f) => {
				obj[f] = f;
				return obj;
			}, {}),
			object: duplicate(this.object.data),
			options: this.options,
			textAnchors: Object.entries(CONST.TEXT_ANCHOR_POINTS).reduce((obj, e) => {
				obj[e[1]] = game.i18n.localize(`JOURNAL.Anchor${e[0].titleCase()}`);
				return obj;
			}, {})
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		if ( this.object.id ) return this.object.update(formData);
		else {
			canvas.notes.preview.removeChildren();
			return this.object.constructor.create(formData);
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	async close(options) {
		if ( !this.object.id ) canvas.notes.preview.removeChildren();
		return super.close(options);
	}
}

/**
 * Ambient Sound Config Sheet
 * @extends {FormApplication}
 *
 * @param {AmbientSound} sound       The sound object being configured
 * @param {object} options           Additional application rendering options
 * @param {boolean} options.preview  Configure a preview version of a sound which is not yet saved
 */
class AmbientSoundConfig extends FormApplication {
	constructor(...args) {
		super(...args);
		if (!game.user.isGM) throw "You do not have the ability to configure an AmbientSound object.";
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "sound-config",
			classes: ["sheet", "sound-sheet"],
			title: "SOUND.ConfigTitle",
			template: "templates/scene/sound-config.html",
			width: 480
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		return {
			object: duplicate(this.object.data),
			options: this.options,
			submitText: game.i18n.localize(this.options.preview ? "SOUND.Create" : "SOUND.Update"),
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		if ( this.object.id ) return this.object.update(formData);
		return this.object.constructor.create(formData);
	}
	 /* -------------------------------------------- */
	 /** @override */
	async close(options) {
		await super.close(options);
		if ( this.preview ) {
			this.preview.removeChildren();
			this.preview = null;
		}
	}
}

/* -------------------------------------------- */

/**
 * Tile Config Sheet
 * @extends {FormApplication}
 *
 * @param {Tile} tile                The Tile object being configured
 * @param {Object} options           Additional application rendering options
 * @param {boolean} options.preview  Configure a preview version of a tile which is not yet saved
 */
class TileConfig extends FormApplication {
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "tile-config",
			classes: ["sheet", "tile-sheet"],
			title: "Tile Configuration",
			template: "templates/scene/tile-config.html",
			width: 400,
			submitOnChange: true
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		return {
			object: duplicate(this.object.data),
			options: this.options,
			submitText: this.options.preview ? "Create" : "Update"
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onChangeInput(event) {
		const fd = new FormDataExtended(event.currentTarget.form);
		for ( let [k, v] of Object.values(fd.toObject()) ) {
			this.object.data[k] = v;
		}
		this.object.refresh();
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		if (!game.user.isGM) throw "You do not have the ability to configure a Tile object.";
		if ( this.object.id ) {
			formData["id"] = this.object.id;
			return this.object.update(formData, {diff: false});
		}
		return this.object.constructor.create(formData);
	}
	 /* -------------------------------------------- */
	 /** @override */
	async close(options) {
		await super.close(options);
		if ( this.preview ) {
			this.preview.removeChildren();
			this.preview = null;
		}
	}
}

/**
 * An implementation of the PlaceableHUD base class which renders a heads-up-display interface for Tile objects.
 * @extends {BasePlaceableHUD}
 */
class TileHUD extends BasePlaceableHUD {
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 id: "tile-hud",
			template: "templates/hud/drawing-hud.html"
		});
	}
	/* -------------------------------------------- */
	 /** @override */
	getData() {
		const data = super.getData();
		return mergeObject(data, {
			lockedClass: data.locked ? "active" : "",
			visibilityClass: data.hidden ? "active" : "",
		});
	}
	/* -------------------------------------------- */
	 /** @override */
	setPosition() {
	 let {x, y, width, height} = this.object.hitArea;
	 const c = 70;
	 const p = -10;
	 const position = {
		 width: width + (c * 2) + (p * 2),
			height: height + (p * 2),
			left: x + this.object.data.x - c - p,
			top: y + this.object.data.y - p
		};
		this.element.css(position);
	}
}

/**
 * A Token Configuration Application
 * @type {FormApplication}
 *
 * @param {Token} token      The Token object for which settings are being configured
 * @param {object} options   TokenConfig ui options (see Application)
 * @param {boolean} [options.configureDefault]   Configure the default actor token on submit
 */
class TokenConfig extends FormApplication {
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
			classes: ["sheet", "token-sheet"],
			template: "templates/scene/token-config.html",
			width: 480,
			height: "auto",
			tabs: [{navSelector: ".tabs", contentSelector: "form", initial: "character"}]
		});
	}
	/* -------------------------------------------- */
	 /** @override */
	get id() {
		let id = this.token.id;
		if ( !id ) id = this.actor.id;
		return id ? `token-config-${id}` : `token-config`;
	}
	/* -------------------------------------------- */
	 /**
	 * Convenience access for the Token object
	 * @type {Token}
	 */
	get token() {
	 return this.object;
	}
	 /* -------------------------------------------- */
	 /**
	 * Convenience access for the Token's linked Actor, if any
	 * @type {Actor|null}
	 */
	get actor() {
		return this.token.actor;
	}
	/* -------------------------------------------- */
		/** @override */
	get title() {
		if ( this.options.configureDefault ) return `[${game.i18n.localize("TOKEN.TitlePrototype")}] ${this.actor.name}`;
		return `${this.token.name}: ${game.i18n.localize("TOKEN.Title")}`;
	}
	 /* -------------------------------------------- */
	 /** @override */
	async getData(options) {
		const actor = this.token.actor;
		let hasAlternates = actor && this.token.id ? actor.data.token.randomImg : false;
		const attributes = this.constructor.getTrackedAttributes(this.actor ? this.actor.data.data : {});
		return {
			cssClasses: [this.options.configureDefault ? "prototype" : null].filter(c => !!c).join(" "),
			isPrototype: this.options.configureDefault,
			hasAlternates: hasAlternates,
			alternateImages: hasAlternates ? await this._getAlternateTokenImages() : [],
			object: duplicate(this.token.data),
			options: this.options,
			gridUnits: canvas.ready ? canvas.scene.data.gridUnits : game.system.gridUnits,
			barAttributes: this.constructor.getTrackedAttributeChoices(attributes),
			bar1: this.object.getBarAttribute("bar1"),
			bar2: this.object.getBarAttribute("bar2"),
			displayModes: Object.entries(CONST.TOKEN_DISPLAY_MODES).reduce((obj, e) => {
				obj[e[1]] = game.i18n.localize(`TOKEN.DISPLAY_${e[0]}`);
				return obj;
			}, {}),
			actors: game.actors.entities.reduce((actors, a) => {
				if ( !a.owner ) return actors;
				actors.push({'_id': a._id, 'name': a.name});
				return actors;
			}, []).sort((a, b) => a.name.localeCompare(b.name)),
			dispositions: Object.entries(CONST.TOKEN_DISPOSITIONS).reduce((obj, e) => {
				obj[e[1]] = game.i18n.localize(`TOKEN.${e[0]}`);
				return obj;
			}, {}),
			lightAnimations: Object.entries(CONFIG.Canvas.lightAnimations).reduce((obj, e) => {
				obj[e[0]] = game.i18n.localize(e[1].label);
				return obj;
			}, {"": game.i18n.localize("None")}),
			lightAlpha: Math.sqrt(this.object.data.lightAlpha).toNearest(0.05),
			isGM: game.user.isGM
		};
	}
	 /* -------------------------------------------- */
	 /** @override */
	async render(...args) {
		if ( !game.user.can("TOKEN_CONFIGURE") || !this.token.owner ) {
			return ui.notifications.warn("You do not have permission to configure this Token!");
		}
		return super.render(...args);
	}
	 /* -------------------------------------------- */
	 /**
	 * Inspect the Actor data model and identify the set of attributes which could be used for a Token Bar
	 * @return {string[]}
	 */
	static getTrackedAttributeChoices(attributes) {
		attributes.bar = attributes.bar.map(v => v.join("."));
		attributes.bar.sort((a, b) => a.localeCompare(b));
		attributes.value = attributes.value.map(v => v.join("."));
		attributes.value.sort((a, b) => a.localeCompare(b));
		return {
			[game.i18n.localize("TOKEN.BarAttributes")]: attributes.bar,
			[game.i18n.localize("TOKEN.BarValues")]: attributes.value
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether an individual data object is a valid attribute - containing both a "value" and "max" field
	 * @param {Object} data     The data object to search
	 * @param {string[]} _path  The attribute path being recursed
	 * @return {Object}         An object containing both bar and value attribute paths
	 * @private
	 */
	static getTrackedAttributes(data, _path=[]) {
		 // Track the path and record found attributes
		const attributes = {
			"bar": [],
			"value": []
		};
		 // Recursively explore the object
		for ( let [k, v] of Object.entries(data) ) {
			let p  = _path.concat([k]);
			 // Check objects for both a "value" and a "max"
			if ( v instanceof Object ) {
				const isBar = ("value" in v) && ("max" in v);
				if ( isBar ) attributes.bar.push(p);
				else {
					const inner = this.getTrackedAttributes(data[k], p);
					attributes.bar.push(...inner.bar);
					attributes.value.push(...inner.value);
				}
			}
			 // Otherwise identify values which are numeric or null
			else if ( Number.isNumeric(v) || (v === null) ) {
				attributes.value.push(p);
			}
		}
		return attributes;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get an Object of image paths and filenames to display in the Token sheet
	 * @return {Promise}
	 * @private
	 */
	async _getAlternateTokenImages() {
		const images = await this.actor.getTokenImages();
		return images.reduce((obj, i) => {
			obj[i] = i.split("/").pop();
			return obj;
		}, {});
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find(".bar-attribute").change(this._onBarChange.bind(this));
		html.find(".alternate-images").change(ev => ev.target.form.img.value = ev.target.value);
		html.find('button.assign-token').click(this._onAssignToken.bind(this));
	}
	 /* -------------------------------------------- */
	 /** @override */
	_getSubmitData(updateData = {}) {
		const data = super._getSubmitData(updateData);
		data.lightAlpha = Math.pow(data.lightAlpha, 2).toNearest(0.01);
		return data;
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		 // Verify the user has the ability to update a Token configuration
		if ( !this.token.owner || !game.user.can("TOKEN_CONFIGURE") ) {
			throw new Error("You do not have permission to configure this token");
		}
		 // Configure prototype Token data
		if ( formData.actorId && this.options.configureDefault ) {
			await this._updateActorData(formData);
		}
		 // Update a token on the canvas
		if ( this.token.parent !== null ) {
			await this.token.update(formData);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Update certain fields of a linked actor token when token configuration is changed
	 * @param tokenData {Object}    The new token data
	 */
	_updateActorData(tokenData) {
		 // Get the actor to update
		let actor = this.token.actor;
		if ( !actor ) return;
		let actorData = {};
		 // Only update certain default token fields
		let update = {};
		for ( let [k, v] of Object.entries(tokenData) ) {
			if ( this.options.configureDefault || ["name", "img"].includes(k) || k.startsWith("bar.") ) {
				update[k] = v;
			}
		}
		actorData['token'] = mergeObject(actor.data.token, update, {inplace: false});
		 // Update the Actor
		return actor.update(actorData);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle Token assignment requests to update the default prototype Token
	 * @param {MouseEvent} event  The left-click event on the assign token button
	 * @private
	 */
	async _onAssignToken(event) {
		event.preventDefault();
		 // Get controlled Token data
		let tokens = canvas.ready ? canvas.tokens.controlled : [];
		if ( tokens.length !== 1 ) {
			ui.notifications.warn(game.i18n.localize("TOKEN.AssignWarn"));
			return;
		}
		const token = duplicate(tokens.pop().data);
		token.tokenId = token.x = token.y = null;
		 // Update the prototype token for the actor using the existing Token instance
		const actor = this.actor;
		await actor.update({token: token}, {diff: false, recursive: false, noHook: true});
		ui.notifications.info(game.i18n.format("TOKEN.AssignSuccess", {name: actor.name}));
		return this.close();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle changing the attribute bar in the drop-down selector to update the default current and max value
	 * @private
	 */
	async _onBarChange(ev) {
		const form = ev.target.form;
		const attr = this.object.getBarAttribute(null, {alternative: ev.target.value});
		const bar = ev.target.name.split(".").shift();
		form.querySelector(`input.${bar}-value`).value = attr !== null ? attr.value : "";
		form.querySelector(`input.${bar}-max`).value = ((attr !== null) && (attr.type === "bar")) ? attr.max : "";
	}
}

/**
 * An implementation of the PlaceableHUD base class which renders a heads-up-display interface for Token objects.
 * This interface provides controls for visibility, attribute bars, elevation, status effects, and more.
 * @type {BasePlaceableHUD}
 */
class TokenHUD extends BasePlaceableHUD {
	 /**
	 * Track whether the status effects control palette is currently expanded or hidden
	 * @type {boolean}
	 * @private
	 */
	_statusEffects = false;
	 /* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "token-hud",
			template: "templates/hud/token-hud.html"
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	bind(object) {
		this._statusEffects = false;
		return super.bind(object);
	}
	 /* -------------------------------------------- */
	 /**
	 * Refresh the currently active state of all status effect icons in the Token HUD selector.
	 */
	refreshStatusIcons() {
		const effects = this.element.find(".status-effects")[0];
		const statuses = this._getStatusEffectChoices();
		for ( let img of effects.children ) {
			const status = statuses[img.getAttribute("src")] || {};
			img.classList.toggle("overlay", !!status.isOverlay);
			img.classList.toggle("active", !!status.isActive);
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	setPosition(_position) {
		const td = this.object.data;
		const ratio = canvas.dimensions.size / 100;
		const position = {
			width: td.width * 100,
			height: td.height * 100,
			left: this.object.x,
			top: this.object.y,
		};
		if ( ratio !== 1 ) position.transform = `scale(${ratio})`;
		this.element.css(position);
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const data = super.getData(options);
		const bar1 = this.object.getBarAttribute("bar1");
		const bar2 = this.object.getBarAttribute("bar2");
		return mergeObject(data, {
			canConfigure: game.user.can("TOKEN_CONFIGURE"),
			canToggleCombat: ui.combat !== null,
			displayBar1: bar1 && (bar1.type !== "none"),
			bar1Data: bar1,
			displayBar2: bar2 && (bar2.type !== "none"),
			bar2Data: bar2,
			visibilityClass: data.hidden ? "active" : "",
			effectsClass: this._statusEffects ? "active" : "",
			combatClass: this.object.inCombat ? "active" : "",
			targetClass: this.object.targeted.has(game.user) ? "active" : "",
			statusEffects: this._getStatusEffectChoices(data)
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Get an array of icon paths which represent valid status effect choices
	 * @private
	 */
	_getStatusEffectChoices() {
		const token = this.object;
		 // Get statuses which are active for the token actor
		const actor = token.actor || null;
		const statuses = actor ? actor.effects.reduce((obj, e) => {
			const id = e.getFlag("core", "statusId");
			if ( id ) {
				obj[id] = {
					id: id,
					overlay: !!e.getFlag("core", "overlay")
				}
			}
			return obj;
		}, {}) : {};
		 // Prepare the list of effects from the configured defaults and any additional effects present on the Token
		const tokenEffects = duplicate(token.data.effects) || [];
		if ( token.data.overlayEffect ) tokenEffects.push(token.data.overlayEffect);
		return CONFIG.statusEffects.concat(tokenEffects).reduce((obj, e) => {
			const src = e.icon ?? e;
			if ( src in obj ) return obj;
			const status = statuses[e.id] || {};
			const isActive = !!status.id || token.data.effects.includes(src);
			const isOverlay = !!status.overlay || token.data.overlayEffect === src;
			obj[src] = {
				id: e.id ?? "",
				title: e.label ? game.i18n.localize(e.label) : null,
				src,
				isActive,
				isOverlay,
				cssClass: [
					isActive ? "active" : null,
					isOverlay ? "overlay" : null
				].filterJoin(" ")
			};
			return obj;
		}, {});
	}
	 /* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		 // Set the initial state of effect selection
		this._toggleStatusEffects(this._statusEffects);
		 // Attribute Bars
		html.find(".attribute input")
			.click(this._onAttributeClick)
			.keydown(this._onAttributeKeydown.bind(this))
			.change(this._onAttributeUpdate.bind(this))
		 // Token Control Icons
		html.find(".config").click(this._onTokenConfig.bind(this));
		html.find(".combat").click(this._onToggleCombat.bind(this));
		html.find(".effects > img").click(this._onClickStatusEffects.bind(this));
		html.find(".target").click(this._onToggleTarget.bind(this));
		 // Status Effects Controls
		html.find(".status-effects")
			.on("click", ".effect-control", this._onToggleEffect.bind(this))
			.on("contextmenu", ".effect-control", event => this._onToggleEffect(event, {overlay: true}));
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle initial click to focus an attribute update field
	 * @private
	 */
	_onAttributeClick(event) {
		event.currentTarget.select();
	}
	 /* -------------------------------------------- */
	 /**
	 * Force field handling on an Enter keypress even if the value of the field did not change.
	 * This is important to suppose use cases with negative number values.
	 * @param {KeyboardEvent} event     The originating keydown event
	 * @private
	 */
	_onAttributeKeydown(event) {
		const code = game.keyboard.getKey(event);
		if ( code === "Enter" ) return this._onAttributeUpdate(event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle attribute bar update
	 * @private
	 */
	_onAttributeUpdate(event) {
		event.preventDefault();
		if ( !this.object ) return;
		 // Acquire string input
		const input = event.currentTarget;
		let strVal = input.value.trim();
		let isDelta = strVal.startsWith("+") || strVal.startsWith("-");
		if (strVal.startsWith("=")) strVal = strVal.slice(1);
		let value = Number(strVal);
		 // For attribute bar values, update the associated Actor
		const bar = input.dataset.bar;
		const actor = this.object?.actor;
		if ( bar && actor ) {
			const attr = this.object.getBarAttribute(bar);
			actor.modifyTokenAttribute(attr.attribute, value, isDelta, attr.type === "bar");
		}
		 // Otherwise update the Token directly
		else {
			const current = this.object.data[input.name];
			this.object.update({[input.name]: isDelta ? current + value : value});
		}
		 // Clear the HUD
		this.clear();
	}
	 /* -------------------------------------------- */
	 /**
	 * Toggle Token combat state
	 * @private
	 */
	async _onToggleCombat(event) {
		event.preventDefault();
		await this.object.toggleCombat();
		event.currentTarget.classList.toggle("active", this.object.inCombat);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle Token configuration button click
	 * @private
	 */
	_onTokenConfig(event) {
		event.preventDefault();
		this.object.sheet.render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle left-click events to toggle the displayed state of the status effect selection palette
	 * @param {MouseEvent }event
	 * @private
	 */
	_onClickStatusEffects(event) {
		event.preventDefault();
		this._toggleStatusEffects(!this._statusEffects);
	}
	 /* -------------------------------------------- */
	 /**
	 * Assign css selectors for the active state of the status effects selection palette
	 * @private
	 */
	_toggleStatusEffects(active) {
		this._statusEffects = active;
		const button = this.element.find(".control-icon.effects")[0];
		button.classList.toggle("active", active);
		const palette = button.querySelector(".status-effects");
		palette.classList.toggle("active", active);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle toggling a token status effect icon
	 * @private
	 */
	_onToggleEffect(event, {overlay=false}={}) {
		event.preventDefault();
		let img = event.currentTarget;
		const effect = ( img.dataset.statusId && this.object.actor ) ?
			CONFIG.statusEffects.find(e => e.id === img.dataset.statusId) :
			img.getAttribute("src");
		return this.object.toggleEffect(effect, {overlay});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle toggling the target state for this Token
	 * @private
	 */
	_onToggleTarget(event) {
		event.preventDefault();
		const btn = event.currentTarget;
		const token = this.object;
		const targeted = !token.isTargeted;
		token.setTarget(targeted, {releaseOthers: false});
		btn.classList.toggle("active", targeted);
	}
}

/**
 * Wall Configuration Sheet
 * @type {FormApplication}
 * @param object {Wall}        The Wall object for which settings are being configured
 * @param options {Object}     Additional options which configure the rendering of the configuration sheet.
 */
class WallConfig extends FormApplication {
	static get defaultOptions() {
	 const options = super.defaultOptions;
	 options.id = "wall-config";
		options.title = "Wall Configuration";
	 options.template = "templates/scene/wall-config.html";
	 options.width = 400;
	 options.editTargets = [];
	 return options;
	}
	 /* -------------------------------------------- */
	 /**
	 * Provide a dynamically rendered title for the Wall Configuration sheet
	 * @type {string}
	 */
	get title() {
		let title = this.options.editTargets.length ? "WALLS.TitleMany" : "WALLS.Title";
		return game.i18n.localize(title);
	}
	 /* -------------------------------------------- */
	 /**
	 * Construct and return the data object used to render the HTML template for this form application.
	 * @return {Object}
	 */
	getData() {
		return {
			object: duplicate(this.object.data),
			options: this.options,
			moveTypes: Object.keys(CONST.WALL_MOVEMENT_TYPES).reduce((obj, key) => {
				let k = CONST.WALL_MOVEMENT_TYPES[key];
				obj[k] = key.titleCase();
				return obj;
			}, {}),
			senseTypes: Object.keys(CONST.WALL_SENSE_TYPES).reduce((obj, key) => {
				let k = CONST.WALL_SENSE_TYPES[key];
				obj[k] = key.titleCase();
				return obj;
			}, {}),
			dirTypes: Object.keys(CONST.WALL_DIRECTIONS).reduce((obj, key) => {
				let k = CONST.WALL_DIRECTIONS[key];
				obj[k] = key.titleCase();
				return obj;
			}, {}),
			doorTypes: Object.keys(CONST.WALL_DOOR_TYPES).reduce((obj, key) => {
				let k = CONST.WALL_DOOR_TYPES[key];
				obj[k] = key.titleCase();
				return obj;
			}, {}),
			doorStates: Object.keys(CONST.WALL_DOOR_STATES).reduce((obj, key) => {
				let k = CONST.WALL_DOOR_STATES[key];
				obj[k] = key.titleCase();
				return obj;
			}, {}),
			isDoor: this.object.data.door > CONST.WALL_DOOR_TYPES.NONE
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * This method is called upon form submission after form data is validated
	 * @param event {Event}       The initial triggering submission event
	 * @param formData {Object}   The object of validated form data with which to update the object
	 * @private
	 */
	async _updateObject(event, formData) {
		 // Update many walls
		const wallIds = this.options.editTargets;
		if ( wallIds.length ) {
			const updateData = canvas.scene.data.walls.reduce((arr, w) => {
				if ( wallIds.includes(w._id) ) arr.push(mergeObject(w, formData, {inplace: false}));
				return arr;
			}, []);
			return canvas.scene.updateEmbeddedEntity("Wall", updateData);
		}
		 // Update single wall
		else return this.object.update(formData);
	}
}

/**
 * The End User License Agreement
 * Display the license agreement and prompt the user to agree before moving forwards
 * @type {Application}
 */
class EULA extends Application {
	static get defaultOptions() {
	 const options = super.defaultOptions;
	 options.id = "eula";
	 options.template = "templates/setup/eula.html";
	 options.title = "End User License Agreement";
	 options.width = 720;
	 options.popOut = true;
	 return options;
	}
	 /* -------------------------------------------- */
	 /**
	 * A reference to the setup URL used under the current route prefix, if any
	 * @return {string}
	 */
	get licenseURL() {
		return getRoute("license");
	}
	 /* -------------------------------------------- */
	 /** @override */
	async getData() {
	 let html = await fetch("license.html").then(r => r.text());
	 return {
			html: html
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _renderOuter(options) {
	 const id = this.id;
	 const classes = Array.from(options.classes || this.options.classes).join(" ");
		// Override the normal window app wrapper so it cannot be closed or minimized
	 const parsed = $.parseHTML(`<div id="${id}" class="app window-app ${classes}" data-appid="${this.appId}">
			<header class="window-header flexrow">
					<h4 class="window-title">${this.title}</h4>
			</header>
			<section class="window-content"></section>
		</div>`);
	 const html = $(parsed[0]);
		 // Make the outer window draggable
		const header = html.find('header')[0];
		new Draggable(this, html, header, this.options.resizable);
		 // Set the outer frame z-index
		if ( Object.keys(ui.windows).length === 0 ) _maxZ = 100;
		html.css({zIndex: Math.min(++_maxZ, 9999)});
		return html;
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		const form = html[0].children[1];
		html.find("#decline").click(this._onDecline.bind(this));
		form.onsubmit = this._onSubmit.bind(this);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle refusal of the EULA by checking the decline button
	 * @param {MouseEvent} event    The originating click event
	 */
	_onDecline(event) {
		const button = event.currentTarget;
		ui.notifications.error(`You have declined the End User License Agreement and cannot use the software.`);
		button.form.dataset.clicked = "decline";
	}
	 /* -------------------------------------------- */
	 /**
	 * Validate form submission before sending it onwards to the server
	 * @param event
	 */
	_onSubmit(event) {
		const form = event.target;
		if ( form.dataset.clicked === "decline" ) {
			return setTimeout(() => window.location.href = CONST.WEBSITE_URL, 1000);
		}
		if ( !form.agree.checked ) {
			event.preventDefault();
			ui.notifications.error(`You must agree to the ${this.options.title} before proceeding.`);
		}
	}
}

/**
 * A special class of Dialog which allows for the installation of Packages.
 * @extends {Application}
 */
class InstallPackage extends Application {
	constructor(data, options) {
		super(options);
		this.data = data;
		 /**
		 * The instance of the setup form to which this is linked
		 * @type {SetupConfigurationForm}
		 */
		this.setup = data.setup;
		 /**
		 * The category being filtered for
		 * @type {string}
		 */
		this._category = "all";
		 /**
		 * The visibility being filtered for
		 * @type {string}
		 */
		this._visibility = "all";
	}
	/* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 id: "install-package",
		 template: "templates/setup/install-package.html",
			classes: ["dialog"],
			width: 720,
			height: 620,
			scrollY: [".categories", ".package-list"],
			filters: [{inputSelector: 'input[name="filter"]', contentSelector: ".package-list"}]
		});
	}
	/* -------------------------------------------- */
	 /** @override */
	get title() {
		return game.i18n.localize("SETUP.Install"+this.data.packageType.titleCase());
	}
	/* -------------------------------------------- */
	 /** @override */
	render(...args) {
		// Lazily load packages
		const type = this.data.packageType;
		if ( InstallPackage.cache[type].packages === null ) {
			InstallPackage.getPackages(type).then(() => this.render());
		}
		return super.render(...args);
	}
	/* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const data = super.getData(options);
		const type = data.packageType = this.data.packageType;
		const packages = InstallPackage.cache[type].packages || [];
		const tags = InstallPackage.cache[type].tags || {};
		data.loading = !packages.length;
		 // Category filters
		data.tags = Object.entries(tags).reduce((tags, t) => {
			let [k, v] = t;
			v.active = this._category === t[0];
			v.css = t[1].active ? " active" : "";
			tags[k] = v;
			return tags;
		}, {});
		 // Visibility filters
		data.visibility = [
			{ id: "inst", css: this._visibility === "inst" ? " active" : "", label: "SETUP.PackageVisInst" },
			{ id: "unin", css: this._visibility === "unin" ? " active" : "", label: "SETUP.PackageVisUnin" },
			{ id: "all", css: this._visibility === "all" ? " active" : "", label: "SETUP.PackageVisAll" }
		];
		 // Filter packages
		const installed = new Set(game.data[`${type}s`].map(s => s.id));
		data.packages = packages.filter(p => {
			if ( (this._visibility === "unin") && p.installed ) return false;
			if ( (this._visibility === "inst") && !p.installed ) return false;
			p.installed = installed.has(p.name);
			p.cssClass = [p.installed ? "installed" : null, p.locked ? "locked": null].filterJoin(" ");
			if ( this._category === "all" ) return true;
			if ( this._category === "premium" ) return p.is_protected;
			if ( this._category === "exclusive" ) return p.is_exclusive;
			return p.tags.includes(this._category);
		});
		return data;
	}
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html[0].children[0].onsubmit = ev => ev.preventDefault();
		html.find(".package-title a").click(this._onClickPackageTitle.bind(this));
		html.find("button.install").click(this._onClickPackageInstall.bind(this));
		html.find(".category .filter").click(this._onClickCategoryFilter.bind(this));
		html.find(".visibilities .visibility").click(this._onClickVisibilityFilter.bind(this));
	}
	/* -------------------------------------------- */
	 /**
	 * Handle left-click events to filter to a certain module category
	 * @param {MouseEvent} event
	 * @private
	 */
	_onClickCategoryFilter(event) {
		event.preventDefault();
		this._category = event.target.dataset.category || "all";
		this.render();
	}
	/* -------------------------------------------- */
	 /**
	 * Handle left-click events to filter to a certain visibility state
	 * @param {MouseEvent} event
	 * @private
	 */
	_onClickVisibilityFilter(event) {
		event.preventDefault();
		this._visibility = event.target.dataset.visibility || "all";
		this.render();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a left-click event on the package title
	 * @param {MouseEvent} event
	 * @private
	 */
	_onClickPackageTitle(event) {
		event.preventDefault();
		const li = event.currentTarget.closest(".package");
		if ( li.classList.contains("installed") ) return;
		if ( li.classList.contains("locked") ) {
			const href = `https://foundryvtt.com/packages/${li.dataset.packageId}/`;
			return window.open(href, "_blank");
		}
		const form = li.closest("form");
		form.manifestURL.value = li.querySelector("button.install").dataset.manifest;
	}
	/* -------------------------------------------- */
	 /**
	 * Handle a left-click event on the package "Install" button
	 * @param {MouseEvent} event
	 * @private
	 */
	_onClickPackageInstall(event) {
		event.preventDefault();
		const button = event.currentTarget;
		button.disabled = true;
		const type = this.data.packageType;
		let manifest = button.dataset.manifest;
		 // Install from manifest field
		if (button.dataset.action === "install-url") {
			manifest = button.form.manifestURL.value.trim();
		}
		 // Install from package listing
		else {
			const li = button.closest(".package");
			if ( li.classList.contains("locked") ) {
				const href = `https://foundryvtt.com/packages/${li.dataset.packageId}/`;
				return window.open(href, "_blank");
			}
		}
		 // Execute the installation
		return SetupConfiguration.installPackage({type, manifest});
	}
	/* -------------------------------------------- */
	 /** @override */
	_onSearchFilter(event, query, html) {
		const rgx = new RegExp(RegExp.escape(query || ""), "i");
		for ( let li of html.children ) {
			if ( !query ) {
				li.classList.remove("hidden");
				continue;
			}
			const id = li.dataset.packageId;
			const title = li.querySelector(".package-title a")?.textContent;
			const author = li.querySelector(".tag.author").textContent;
			const match = rgx.test(id) || rgx.test(title) || rgx.test(author);
			li.classList.toggle("hidden", !match);
		}
	}
	/* -------------------------------------------- */
	 /**
	 * Organize package data and cache it to the application
	 * @param {string} type   The type of packages being retrieved
	 * @return {object[]}     The retrieved or cached packages
	 */
	static async getPackages(type) {
		if ( this.cache[type].packages !== null ) return this.cache[type].packages;
		const response = await SetupConfiguration.getPackages({type});
		if ( response.error ) {
			ui.notifications.error(game.i18n.localize("ERROR.LoadPackages"));
			console.error(response.error);
		}
		 // Identify package tags and counts
		const {packages, owned} = response;
		const counts = {premium: 0, exclusive: 0};
		const unordered_tags = {};
		for ( let p of packages ) {
			p.owned = p.is_protected && owned.includes(p.id);
			p.locked = p.is_protected && !p.owned;
			p.tags = p.tags.map(t => {
				const [k, v] = t;
				if ( !unordered_tags[k] ) unordered_tags[k] = {label: v, count: 0, [type]: true};
				unordered_tags[k].count++;
				return k;
			});
			if ( p.is_exclusive ) counts.exclusive++;
			if ( p.is_protected ) counts.premium++;
		}
		 // Organize category tags
		const sorted_tags = Array.from(Object.keys(unordered_tags));
		sorted_tags.sort();
		const tags = sorted_tags.reduce((obj, k) => {
			obj[k] = unordered_tags[k];
			return obj;
		}, {
			all: { label: "All Packages", count: packages.length, [type]: true},
			premium: { label: "Premium Content", count: counts.premium, [type]: true},
			exclusive: { label: "Exclusive Content", count: counts.exclusive, [type]: true }
		});
		 // Cache and return
		this.cache[type].packages = packages;
		this.cache[type].tags = tags;
		return packages;
	}
}

/**
 * A cached object of retrieved packages from the web server
 * @type {{world: object[], system: object[], module: object[]}}
 */
InstallPackage.cache = {
	world: { packages: null, tags: null },
	module: { packages: null, tags: null },
	system: { packages: null, tags: null }
};
	/**
 * The Package Configuration setup application
 * @type {Application}
 */
class SetupConfigurationForm extends FormApplication {
	constructor({systems, modules, worlds, currentWorld=null}={}) {
		super({});
		 /**
		 * Valid Game Systems to choose from
		 * @type {object[]}
		 */
		this.systems = systems;
		 /**
		 * Install Modules to configure
		 * @type {object[]}
		 */
		this.modules = modules;
		 /**
		 * The Array of available Worlds to load
		 * @type {object[]}
		 */
		this.worlds = worlds;
		 /**
		 * The currently inspected World
		 * @type {string}
		 */
		this.currentWorld = currentWorld;
		 /**
		 * The currently viewed tab
		 * @type {string}
		 */
		this._tab = "worlds";
		 /**
		 * Track the button elements which represent updates for different named packages
		 * @type {HTMLElement|null}
		 */
		this._progressButton = null;
		 // Activate socket listeners used in the setup view
		this.activateSocketListeners();
	}
	/* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 id: "setup-configuration",
			classes: ["dark"],
			template: "templates/setup/setup-config.html",
			popOut: false,
			scrollY: ["#world-list", "#system-list", "#module-list"],
			tabs: [{navSelector: ".tabs", contentSelector: ".content", initial: "worlds"}]
		});
	}
	/* -------------------------------------------- */
	 /** @override */
	getData(options) {
		 // Configuration options
		options = game.data.options;
		options.upnp = options.upnp !== false;
		 // Prepare Systems
		const systems = this.systems.map(s => {
			this.constructor.tagPackageAvailability(s);
			return s;
		}).sort((a, b) => a.data.title.localeCompare(b.data.title));
		 // Prepare Modules
		const modules = this.modules.map(m => {
			this.constructor.tagPackageAvailability(m);
			const deps = (m.data?.dependencies ?? []).reduce((arr, d) => {
				if ( d?.name ) arr.push(d.name);
				return arr;
			}, []);
			m.dependencies = deps.length ? deps : null;
			return m;
		}).sort((a, b) => a.data.title.localeCompare(b.data.title));
		 // Prepare Worlds
		const worlds = this.worlds.map(w => {
			w.active = w.id === this.current;
			w.shortDesc = TextEditor.previewHTML(w.data.description);
			this.constructor.tagPackageAvailability(w);
			return w;
		}).sort((a, b) => a.data.title.localeCompare(b.data.title));
		 // Return data for rendering
		const coreVersion = game.data.version;
		return {
			coreVersion: coreVersion,
			coreVersionHint: game.i18n.format("SETUP.CoreVersionHint", {coreVersion}),
			systems: systems,
			modules: modules,
			worlds: worlds,
			languages: game.data.languages,
			options: options,
			adminKey: game.data.adminKey,
			world: this.worlds.find(w => w.id === this.current),
			current: this.current,
			updateChannels: Object.entries(CONST.SOFTWARE_UPDATE_CHANNELS).reduce((obj, c) => {
				obj[c[0]] = game.i18n.localize(c[1]);
				return obj;
			}, {}),
			coreUpdate: game.data.coreUpdate ? game.i18n.format("SETUP.UpdateAvailable", game.data.coreUpdate) : false
		};
	}
	/* -------------------------------------------- */
	 static tagPackageAvailability(pkg) {
		const ac = CONST.PACKAGE_AVAILABILITY_CODES;
		switch(pkg.data.availability) {
			case ac.REQUIRES_SYSTEM:
				pkg.unavailable = game.i18n.localize("SETUP.RequireSystem");
				break;
			case ac.REQUIRES_DEPENDENCY:
				pkg.unavailable = game.i18n.localize("SETUP.RequireDep");
				break;
			case ac.REQUIRES_CORE:
				pkg.unavailable = game.i18n.localize("SETUP.RequireCore");
				break;
			case ac.REQUIRES_UPDATE:
				pkg.incompatible = game.i18n.localize("SETUP.CompatibilityRisk");
				break;
			case ac.UNKNOWN:
				pkg.incompatible = game.i18n.localize("SETUP.CompatibilityUnknown");
				break;
		}
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		 // Confirm Admin Changes
		html.find("button#admin-save").click(this._onSaveAdmin.bind(this));
		 // Create or Edit World
		html.find("button#create-world, button.edit-world").click(this._onWorldConfig.bind(this));
		 // Generic Submission Button
		html.find('button[type="submit"]').click(this._onSubmitButton.bind(this));
		 // Install Package
		html.find("button.install-package").click(this._onInstallPackageDialog.bind(this));
		 // Update Package
		html.find("button.update").click(this._onUpdatePackage.bind(this));
		 // Update All Packages
		html.find("button.update-packages").click(this._onUpdatePackages.bind(this));
		 // Uninstall Package
		html.find("button.uninstall").click(this._onUninstallPackage.bind(this));
		 // Update Core
		html.find("button#update-core").click(this._onCoreUpdate.bind(this));
	}
	 /* -------------------------------------------- */
	 /**
	 * Post the setup configuration form
	 * @param {Object} data
	 * @return {Promise}
	 * @private
	 */
	async _post(data) {
		 // Construct form data
		const formData = new FormDataExtended(this.form);
		for ( let [k, v] of Object.entries(data) ) {
			formData.set(k, v);
		}
		 // Post the request and handle redirects
		const request = await fetch(SetupConfiguration.setupURL, { method: "POST", body: formData });
		if ( request.redirected ) return window.location.href = request.url;
		 // Process response
		const response = await request.json();
		if ( response.error ) {
			const err = new Error(response.error);
			err.stack = response.stack;
			ui.notifications.error(response.error);
			throw err;
		}
		return response
	}
	 /* -------------------------------------------- */
	 /**
	 * Reload the setup view by re-acquiring setup data and re-rendering the form
	 * @private
	 */
	async reload() {
		this._progressButton = null;
		return Game.getSetupData(game.socket).then(setupData => {
			mergeObject(game.data, setupData);
			mergeObject(this, setupData);
			this.render();
			Object.values(ui.windows).forEach(app => {
				if ( app instanceof InstallPackage ) app.render();
			});
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Generic button handler for the setup form which submits a POST request including any dataset on the button itself
	 * @param {MouseEvent} event    The originating mouse click event
	 * @return {Promise}
	 * @private
	 */
	async _onSubmitButton(event) {
		event.preventDefault();
		 // Construct data to post
		const button = event.currentTarget;
		button.disabled = true;
		const data = duplicate(button.dataset);
		data.action = button.value;
		 // Warn about world migration
		if ( data.action === "launchWorld" ) {
			const world = game.data.worlds.find(w => w.data.name === data.world);
			if ( !world ) return;
			const oldMajor = world.data.coreVersion.split(".").slice(0, 2).join(".");
			const newMajor = game.data.version.split(".").slice(0, 2).join(".");
			if ( isNewerVersion(newMajor, oldMajor) ) {
				const confirm = await Dialog.confirm({
					title: game.i18n.localize("SETUP.WorldMigrationRequiredTitle"),
					content: game.i18n.format("SETUP.WorldMigrationRequired", {
						world: world.data.title,
						oldVersion: world.data.coreVersion,
						newVersion: game.data.version,
						nIncompatible: game.data.modules.filter(m => m.incompatible).length,
						nModules: game.data.modules.length
					}),
				});
				if ( !confirm ) return button.disabled = false;
			}
		}
		 // Submit the post request
		const response = await this._post(data);
		button.disabled = false;
		return response;
	}
	 /* -------------------------------------------- */
	 /**
	 * Confirm user intent when saving admin changes to the application configuration
	 * @param {MouseEvent} event    The originating mouse click event
	 * @return {Promise}
	 * @private
	 */
	async _onSaveAdmin(event) {
		event.preventDefault();
		event.stopImmediatePropagation();
		return Dialog.confirm({
			title: "Save Application Configuration",
			content: `<p class="notification">Modifying these configuration options will cause the server to be shut down and 
						require that you restart the server manually. Do you wish to continue?</p>`,
			yes: () => {
				this._post({action: "adminConfigure"}).then(() => {
					this.element.html(`<p>The Foundry VTT server has been terminated to apply changes. You must restart manually.</p>`);
				})
			},
			defaultYes: false
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Begin creation of a new World using the config form
	 * @param {MouseEvent} event    The originating mouse click event
	 * @private
	 */
	_onWorldConfig(event) {
		event.preventDefault();
		const button = event.currentTarget;
		let data = {};
		const options = {};
		if ( button.dataset.world ) {
			data = game.data.worlds.find(w => w.data.name === button.dataset.world);
		} else {
			options.create = true;
		}
		new WorldConfig(data, options).render(true)
	}
	 /* -------------------------------------------- */
	/*  Package Management                          */
	/* -------------------------------------------- */
	 /**
	 * Handle install button clicks to add new packages
	 * @param {Event} event
	 * @private
	 */
	async _onInstallPackageDialog(event) {
		event.preventDefault();
		let button = this._progressButton = event.currentTarget;
		const list = button.closest(".tab").querySelector(".package-list");
		const type = list.dataset.packageType;
		new InstallPackage({packageType: type, setup: this}).render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle update button press for a single Package
	 * @param {Event} event
	 * @private
	 */
	_onUpdatePackage(event) {
		event.preventDefault();
		 // Disable the button
		const button = event.currentTarget;
		button.disabled = true;
		 // Obtain the package metadata
		let li = button.closest("li.package");
		let id = li.dataset.packageId;
		let type = li.closest("ul.package-list").dataset.packageType;
		const pack = game.data[`${type}s`].find(p => p.id === id);
		if ( !pack || !pack.data.manifest ) return;
		 // Inquire with the server for updates
		if ( button.dataset.state === "check" ) {
			return this._updateCheckOne(type, id, button);
		}
		 // Execute upon an update
		if ( button.dataset.state === "update" ) {
			return this._updateDownloadOne(type, id, button);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Execute upon an update check for a single Package
	 * @param {string} type         The package type to check
	 * @param {string} name         The package name to check
	 * @param {HTMLElement} button  The update button for the package
	 * @return {Promise<boolean>}
	 * @private
	 */
	async _updateCheckOne(type, name, button) {
		 // Get the update manifest from the server
		const manifest = await SetupConfiguration.checkPackage({type, name});
		if ( manifest.error ) return ui.notifications.error(manifest.error, {permanent: true});
		 // Packages which cannot be updated because they require a more modern core version
		if ( !manifest.isSupported ) {
			button.innerHTML = '<i class="fas fa-ban"></i><label>Blocked</label>';
			button.dataset.state = "none";
			button.disabled = true;
			return ui.notifications.warn(game.i18n.format("SETUP.PackageUpdateBlocked", {
				name: manifest.name,
				vreq: manifest.minimumCoreVersion,
				vcur: game.data.version
			}))
		}
		 // Packages which can be updated
		if ( manifest.isUpgrade ) {
			button.innerHTML = '<i class="fas fa-download"></i><label>Update</label>';
			button.dataset.state = "update";
			button.dataset.manifest = manifest.manifest;
			button.disabled = false;
		}
		 // Packages which are already current
		else {
			button.innerHTML = '<i class="fas fa-check"></i><label>Current</label>';
			button.dataset.state = "none";
			button.disabled = true;
		}
		return manifest.isUpgrade;
	}
	 /* -------------------------------------------- */
	 /**
	 * Execute upon an update download for a single Package
	 * Returns a Promise which resolves once the download has successfully started
	 * @param {string} type         The package type to install
	 * @param {string} name         The package name to install
	 * @param {HTMLElement} button  The Download button
	 * @return {Promise}
	 * @private
	 */
	async _updateDownloadOne(type, name, button) {
		this._progressButton = button;
		const manifest = await SetupConfiguration.installPackage({type, name, manifest: button.dataset.manifest});
		this._progressButton = null;
		return manifest;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle uninstall button clicks to remove existing packages
	 * @param {Event} event
	 * @private
	 */
	_onUninstallPackage(event) {
		event.preventDefault();
		 // Disable the button
		let button = event.currentTarget;
		button.disabled = true;
		 // Obtain the package metadata
		const li = button.closest(".package");
		const name = li.dataset.packageId;
		const type = li.closest(".package-list").dataset.packageType;
		 // Get the target package
		let collection = game.data[type+"s"];
		let idx = collection.findIndex(p => p.id === name);
		let pack = collection[idx];
		 // Define a warning message
		let warning = `<p>Are you sure you want to delete the ${type.titleCase()} <strong>${pack.data.title}</strong>?</p>`
		if ( type === "world" ) {
			warning += `<p class="notification"><strong>Warning:</strong> This will permanently delete your world content and <strong>can not</strong> be un-done. Are you sure you wish to do this?</strong>.</p>`
			warning += `<p>Type the exact title of your world <strong>${pack.data.title}</strong> in the box below to proceed</p>`;
			warning += `<p><input id="delete-confirm" type="text" required></p>`;
		} else {
			warning += `<p class="notification"><strong>Warning:</strong> This operation cannot be un-done.</p>`
		}
		 // Confirm deletion request
		Dialog.confirm({
			title: `Delete ${type.titleCase()}: ${pack.data.title}`,
			content: warning,
			yes: async html => {
				 // Confirm World deletion
				if ( type === "world" ) {
					const confirm = html.find("#delete-confirm").val();
					if ( confirm !== pack.data.title ) {
						return ui.notifications.error("You must enter the exact World name to confirm the deletion request.");
					}
				}
				 // Submit the server request
				const response = await SetupConfiguration.uninstallPackage({type, name});
				if ( response.error ) {
					const err = new Error(response.error);
					err.stack = response.stack;
					ui.notifications.error(game.i18n.localize("SETUP.UninstallFailure") + ": " + err.message);
					console.error(err);
				} else {
					ui.notifications.info(`${type.titleCase()} ${name} ${game.i18n.localize("SETUP.UninstallSuccess")}.`);
					collection.splice(idx, 1);
				}
				 // Re-render the setup form
				this.render();
			}
		}).then(() => button.disabled = false);
	}
	 /* -------------------------------------------- */
	 /**
	 * Execute upon an update-all workflow to update all packages of a certain type
	 * @param {Event} event
	 * @private
	 */
	async _onUpdatePackages(event) {
		event.preventDefault();
		let button = event.currentTarget;
		button.disabled = true;
		let ol = $(".tab.active .package-list");
		let type = ol.data("packageType");
		 // Get Packages
		let packages = [];
		ol.children(".package").each((i, li) => {
			const id = li.dataset.packageId;
			const pack = game.data[`${type}s`].find(p => p.id === id);
			if ( pack && pack.data.manifest ) packages.push({
				id: id,
				status: "none",
				button: li.querySelector("button.update")
			});
		});
		 // Check for updates in parallel
		const checks = packages.map(p => {
			return this._updateCheckOne(type, p.id, p.button).then(available => p.available = available);
		});
		await Promise.all(checks);
		 // Execute updates one at a time
		for (let p of packages ) {
			if ( !p.available ) continue;
			await this._updateDownloadOne(type, p.id, p.button).catch(err => {});
			p.available = false;
		}
	}
	 /* -------------------------------------------- */
	/*  Core Software Update                        */
	/* -------------------------------------------- */
	 /**
	 * Handle button clicks to update the core VTT software
	 * @param {Event} event
	 * @private
	 */
	async _onCoreUpdate(event) {
		const button = event.currentTarget;
		const form = button.form;
		const label = button.children[1];
		 // Disable the form
		button.disabled = true;
		form.disabled = true;
		 // Condition next step based on action
		if ( button.value === "updateDownload" ) {
			this._progressButton = button;
		}
		 // Post the update request
		const response = await this._post({action: button.value}).catch(err => {
			button.disabled = false;
			form.disabled = false;
			throw err;
		});
		 // Proceed to download step
		if ( button.value === "updateCheck" ) {
			ui.notifications.info(game.i18n.format("SETUP.UpdateInfoAvailable", {version: response.version}));
			label.textContent = game.i18n.format("SETUP.UpdateButtonDownload", {version: response.version});
			button.value = "updateDownload";
			button.disabled = false;
			if ( response.notes ) new UpdateNotes(response).render(true);
			if ( response.willDisableModules ) {
				ui.notifications.warn(game.i18n.format("SETUP.UpdateWarningWillDisable", {
					nIncompatible: game.data.modules.filter(m => m.incompatible).length,
					nModules: game.data.modules.length
				}), {permanent: true});
			}
		} else {
			ui.notifications.info(response.message);
			return this.close();
		}
	}
	 /* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */
	 /**
	 * Activate socket listeners related to the Setup Configuration form
	 */
	activateSocketListeners() {
		const socket = game.socket;
		socket.on("progress", data => {
			this._updateProgressBar(data);
			this._updateProgressButton(data);
		})
	}
	 /* -------------------------------------------- */
	 /**
	 * Update the display of an installation progress bar for a particular progress packet
	 * @param {Object} data   The progress update data
	 * @private
	 */
	_updateProgressBar(data) {
		const tabName = data.type === "core" ? "update" : data.type+"s";
		const tab = this.element.find(`.tab[data-tab="${tabName}"]`);
		if ( !tab.hasClass("active") ) return;
		const progress = tab.find(".progress-bar");
		progress.css("visibility", "visible");
		 // Update bar and label position
		let pl = `${data.pct}%`;
		let bar = progress.children(".bar");
		bar.css("width", pl);
		let barLabel = progress.children(".pct");
		barLabel.text(pl);
		barLabel.css("left", pl);
	}
	 /* -------------------------------------------- */
	 /**
	 * Update installation progress for a particular button which triggered the action
	 * @param {Object} data   The progress update data
	 * @private
	 */
	_updateProgressButton(data) {
		const button = this._progressButton;
		if ( !button ) return;
		button.disabled = data.pct < 100;
		 // Update Icon
		const icon = button.querySelector("i");
		if ( data.pct < 100 ) icon.className = "fas fa-spinner fa-pulse";
		 // Update label
		const label = button.querySelector("label");
		if ( label ) label.textContent = data.step;
		else button.textContent = " " + data.step;
	}
}

/**
 * The client side Updater application
 * This displays the progress of patching/update progress for the VTT
 * @type {Application}
 */
class UpdateNotes extends Application {
	constructor(target, options) {
		super(options);
		this.target = target;
	}
	 /* ----------------------------------------- */
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 id: "update-notes",
			template: "templates/setup/update-notes.html",
			width: 600
		});
	}
	 /* ----------------------------------------- */
	 /** @override */
	get title() {
		return `Update Notes - Foundry Virtual Tabletop ${this.target.version}`;
	}
	 /* ----------------------------------------- */
	 /** @override */
	async getData(options) {
		return {
			notes: this.target.notes
		}
	}
	 /* ----------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find("button").click(ev => {
			ev.preventDefault();
			const button = ev.currentTarget;
			button.disabled = true;
			document.getElementById("update-core").click();
			button.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Downloading`;
		});
	}
}

/**
 * The User Management setup application
 * @extends {FormApplication}
 */
class UserManagement extends FormApplication {
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 id: "manage-players",
			classes: ["dark"],
			template: "templates/setup/user-management.html",
			popOut: false,
			closeOnSubmit: false,
			scrollY: ["#player-list"]
		});
	}
	/* -------------------------------------------- */
	 /** @override */
	async _render(...args) {
		await getTemplate(this.constructor.USER_TEMPLATE);
		return super._render(...args);
	}
	/* -------------------------------------------- */
	 /** @override */
	getData(options) {
		return {
			user: game.user,
			users: this.object.entities.map(u => u.data),
			roles: CONST.USER_ROLES,
			options: this.options,
			userTemplate: this.constructor.USER_TEMPLATE
		};
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find('button[data-action]').click(this._onAction.bind(this));
		html.find('input.show').change(this._onKeyShow.bind(this));
		html.on('click', '.user-delete', this._onUserDelete.bind(this));
	}
	 /* -------------------------------------------- */
	 /** @override */
	_updateObject(event, formData) {
		 // Construct updates array
		const updates = Object.entries(expandObject(formData).users).reduce((arr, e) => {
			const [id, user] = e;
			user._id = id;
			arr.push(user);
			return arr;
		}, []);
		 // The World must have at least one Gamemaster
		if ( !updates.some(u => u.role === USER_ROLES.GAMEMASTER) ) {
			return ui.notifications.error(game.i18n.localize("USERS.NoGMError"))
		}
		 // Update all users and redirect
		return User.update(updates).catch(err => {
			ui.notifications.error(err);
		}).then(() => {
			ui.notifications.info(game.i18n.localize("USERS.UpdateSuccess"));
			return setTimeout(() => window.location.href = getRoute("game"), 1000);
		})
	}
	 /* -------------------------------------------- */
	 /**
	 * Reveal the access key for each player so that it can be learned without being changed
	 * @private
	 */
	_onKeyShow(event) {
		const box = event.currentTarget;
		const key = box.previousElementSibling;
		key.type = box.checked ? "text" : "password";
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle new user creation event
	 * @private
	 */
	async _onAction(event) {
		event.preventDefault();
		const button = event.currentTarget;
		button.disabled = true;
		switch ( button.dataset.action ) {
			case "create-user":
				await this._onUserCreate();
				break;
			case "configure-permissions":
				new PermissionConfig().render(true);
				break;
		}
		button.disabled = false;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle creating a new User record in the form
	 * @private
	 */
	async _onUserCreate() {
		 // Create the new User
		const user = await User.create({
			name: "Player "+$('.player').length,
			role: CONST.USER_ROLES.PLAYER
		});
		 // Render the User's HTML
		const html = await renderTemplate(this.constructor.USER_TEMPLATE, {
			user: user.data,
			roles: CONST.USER_ROLES
		});
		 // Append the player to the list and restore the button
		$("#player-list").append(html);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle user deletion event
	 * @private
	 */
	_onUserDelete(event) {
		event.preventDefault();
		let button = $(event.currentTarget),
			li = button.parents('.player'),
			user = game.users.get(li.attr("data-user-id"));
		 // Craft a message
		let message = "<h3>Are you sure?</h3><p>This user will be deleted from the game world.</p>";
		if (user.isGM) message += '<p class="warning"><strong>You are about to delete a Game-Master user!</strong></p>';
		 // Render a confirmation dialog
		new Dialog({
			title: `Delete User ${user.name}?`,
			content: message,
			buttons: {
				yes: {
					icon: '<i class="fas fa-trash"></i>',
					label: "Delete",
					callback: () => {
						user.delete();
						li.slideUp(200, () => li.remove());
					}
				},
				no: {
					icon: '<i class="fas fa-times"></i>',
					label: "Cancel"
				},
			},
			default: 'yes'
		}).render(true);
	}
}

UserManagement.USER_TEMPLATE = 'templates/setup/player-create.html';

/**
 * The World Management setup application
 * @type {Application}
 */
class WorldConfig extends FormApplication {
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "world-config",
			template: "templates/setup/world-config.html",
			width: 600,
			height: "auto",
			create: false
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	get title() {
		return this.options.create ? "Create New World" : `Edit World: ${this.object.data.title}`;
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const ac = PACKAGE_AVAILABILITY_CODES;
		const systems = game.data.systems.filter(s => {
			if ( this.object.data && ( this.object.data.system === s.id ) ) return true;
			return ![ac.REQUIRES_DEPENDENCY, ac.REQUIRES_CORE].includes( s.data.availability );
		});
		const nextDate = new Date(this.object?.data?.nextSession);
		return {
			world: this.object,
			systems: systems,
			isCreate: this.options.create,
			submitText: this.options.create ? "Create World" : "Update World",
			nextDate: nextDate.isValid() ? nextDate.toDateInputString() : "",
			nextTime: nextDate.isValid() ? nextDate.toTimeInputString() : ""
		};
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	async _onSubmit(event) {
		event.preventDefault();
		const form = event.target || this.form;
		form.disabled = true;
		 // Get form data
		const data = this._getSubmitData();
		if ( this.options.create ) data.action = "createWorld";
		else {
			data.action = "editWorld";
			data.name = this.object.data.name;
			if ( !data.disableModules ) delete data.disableModules;
			if ( !data.resetKeys ) delete data.resetKeys;
		}
		 // Handle next session schedule fields
		if ( data.nextSession.some(t => !!t) ) {
			const now = new Date();
			const dateStr = `${data.nextSession[0] || now.toDateString()} ${data.nextSession[1] || now.toTimeString()}`;
			const date = new Date(dateStr);
			data.nextSession = isNaN(date) ? null : date.toISOString();
		}
		else data.nextSession = null;
		 // Dispatch the POST request
		const response = await fetch(window.location.pathname, {
			method: "POST",
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(data)
		}).then(r => r.json());
		form.disabled = false;
		 // Display error messages
		if ( response.error ) return ui.notifications.error(response.error);
		 // Handle successful creation
		const world = game.data.worlds.find(w => w.id === response.id);
		if ( world ) mergeObject(world.data, response.data);
		else game.data.worlds.push(response);
		if ( ui.setup ) ui.setup.render();
		return this.close();
	}
}
	class ChatPopout extends Application {
	constructor(message, options) {
		super(options);
		 /**
		 * The displayed Chat Message entity
		 * @type {ChatMessage}
		 */
		this.message = message;
		 // Register the application
		this.message.apps[this.appId] = this;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			width: 300,
			height: "auto",
			classes: ["chat-popout"]
		})
	}
	 /* -------------------------------------------- */
	 /** @override */
	get id() {
		return `chat-popout-${this.message.id}`;
	}
	 /* -------------------------------------------- */
	 /** @override */
	get title() {
		let title = this.message.data.flavor ?? this.message.data.speaker.alias;
		return title.length > 32 ? title.substr(0, 32) + " ..." : title;
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _renderInner(data, options) {
		const html = await this.message.render();
		html.find(".message-delete").remove();
		return html;
	}
}

/**
 * A game settings configuration application
 * This form renders the settings defined via the game.settings.register API which have config = true
 *
 * @extends {FormApplication}
 */
class SettingsConfig extends FormApplication {
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			title: game.i18n.localize("SETTINGS.Title"),
			id: "client-settings",
			template: "templates/sidebar/apps/settings-config.html",
			width: 600,
			height: "auto",
			tabs: [
				{navSelector: ".tabs", contentSelector: ".content", initial: "core"}
			]
		})
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const gs = game.settings;
		const canConfigure =  game.user.can("SETTINGS_MODIFY");
		 // Set-up placeholder structure for core, system, and module settings
		const data = {
			core: {version: game.data.version, menus: [], settings: []},
			system: {title: game.system.data.title, menus: [], settings: []},
			modules: {}
		};
		 // Register a module the first time it is seen
		const registerModule = name => {
			const module = game.modules.get(name);
			data.modules[name] = {title: module ? module.data.title : "General Module Settings", menus: [], settings: []};
		};
		 // Classify all menus
		for ( let menu of gs.menus.values() ) {
			if ( menu.restricted && !canConfigure ) continue;
			if ( menu.module === "core" ) {
				data.core.menus.push(menu);
			}
			else if ( menu.module === game.system.id ) {
				data.system.menus.push(menu);
			}
			else {
				const name = menu.module || "module";
				if ( !data.modules[name] ) registerModule(name);
				data.modules[name].menus.push(menu);
			}
		}
		 // Classify all settings
		for ( let setting of gs.settings.values() ) {
			 // Exclude settings the user cannot change
			if ( !setting.config || (!canConfigure && (setting.scope !== "client")) ) continue;
			 // Update setting data
			const s = duplicate(setting);
			s.name = game.i18n.localize(s.name);
			s.hint = game.i18n.localize(s.hint);
			s.value = game.settings.get(s.module, s.key);
			s.type = setting.type instanceof Function ? setting.type.name : "String";
			s.isCheckbox = setting.type === Boolean;
			s.isSelect = s.choices !== undefined;
			s.isRange = (setting.type === Number) && s.range;
			 // Classify setting
			const name = s.module;
			if ( name === "core" ) data.core.settings.push(s);
			else if ( name === game.system.id ) data.system.settings.push(s);
			else {
				if ( !data.modules[name] ) registerModule(name);
				data.modules[name].settings.push(s);
			}
		}
		 // Sort Module headings by name
		data.modules = Object.values(data.modules).sort((a, b) => a.title.localeCompare(b.title));
		 // Flag categories that have nothing
		data.core.none = (data.core.menus.length + data.core.settings.length) === 0;
		data.system.none = (data.system.menus.length + data.system.settings.length) === 0;
		 // Return data
		return {
			user: game.user,
			canConfigure: canConfigure,
			systemTitle: game.system.data.title,
			data: data
		};
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find('.submenu button').click(this._onClickSubmenu.bind(this));
		html.find('button[name="reset"]').click(this._onResetDefaults.bind(this));
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle activating the button to configure User Role permissions
	 * @param event {Event}   The initial button click event
	 * @private
	 */
	_onClickSubmenu(event) {
		event.preventDefault();
		const menu = game.settings.menus.get(event.currentTarget.dataset.key);
		if ( !menu ) return ui.notifications.error("No submenu found for the provided key");
		const app = new menu.type();
		return app.render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle button click to reset default settings
	 * @param event {Event}   The initial button click event
	 * @private
	 */
	_onResetDefaults(event) {
		event.preventDefault();
		const button = event.currentTarget;
		const form = button.form;
		for ( let [k, v] of game.settings.settings.entries() ) {
			if ( v.config ) {
				let input = form[k];
				if (input.type === "checkbox") input.checked = v.default;
				else if (input) input.value = v.default;
			}
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		for ( let [k, v] of Object.entries(flattenObject(formData)) ) {
			let s = game.settings.settings.get(k);
			let current = game.settings.get(s.module, s.key);
			if ( v !== current ) {
				await game.settings.set(s.module, s.key, v);
			}
		}
	}
}

/**
 * Keyboard Controls Reference Sheet
 * @type {Application}
 */
class ControlsReference extends Application {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.title = game.i18n.localize("CONTROLS.Title");
		options.id = "controls-reference";
		options.template = "templates/sidebar/apps/controls-reference.html";
		options.width = 600;
		return options;
	}
}

/**
 * Game Invitation Links Reference
 * @extends {Application}
 */
class InvitationLinks extends Application {
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "invitation-links",
			template: "templates/sidebar/apps/invitation-links.html",
			title: game.i18n.localize("INVITATIONS.Title"),
			width: 400
		})
	}
	/* -------------------------------------------- */
	/** @override */
	getData() {
		return game.data.addresses;
	}
	/* -------------------------------------------- */
	/** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find(".invite-link").click(ev => {
			ev.preventDefault();
			ev.target.select();
			document.execCommand('copy');
			ui.notifications.info(game.i18n.localize("INVITATIONS.Copied"));
		});
	}
}

/**
 * The Module Management Application.
 * This application provides a view of which modules are available to be used and allows for configuration of the
 * set of modules which are active within the World.
 *
 * @implements {FormApplication}
 */
class ModuleManagement extends FormApplication {
	constructor(...args) {
		super(...args);
		this._filter = "all";
		this._expanded = false;
		this._checked = {};
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			title: game.i18n.localize("MODMANAGE.Title"),
			id: "module-management",
			template: "templates/sidebar/apps/module-management.html",
			popOut: true,
			width: 680,
			height: "auto",
			scrollY: [".package-list"],
			closeOnSubmit: false,
			filters: [{inputSelector: 'input[name="search"]', contentSelector: ".package-list"}]
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	get isEditable() {
		return game.user.can("SETTINGS_MODIFY");
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const settings = game.settings.get("core", this.constructor.CONFIG_SETTING);
		const editable = this.isEditable;
		const counts = {all: game.data.modules.length, active: 0, inactive: 0};
		 // Prepare modules
		const modules = game.data.modules.reduce((arr, m) => {
			const isActive = settings[m.id] === true;
			if ( isActive ) counts.active++;
			else counts.inactive++;
			if ( !editable && !isActive ) return arr;
			 // Apply filters
			if ( (this._filter === "active") && !isActive ) return arr;
			if ( (this._filter === "inactive") && isActive ) return arr;
			 // Modify data
			if ( !this.isEditable && !isActive ) return arr;
			SetupConfigurationForm.tagPackageAvailability(m);
			const mod = duplicate(m.data);
			mod.active = isActive;
			mod.css = isActive ? " active" : "";
			mod.hasPacks = mod.packs.length > 0;
			mod.hasScripts = mod.scripts.length > 0;
			mod.hasStyles = mod.styles.length > 0;
			mod.systemOnly = mod.systems && (mod.systems.indexOf(game.system.id) !== -1);
			mod.systemTag = game.system.id;
			mod.incompatible = m.incompatible;
			mod.unavailable = m.unavailable;
			mod.dependencies = mod.dependencies ? mod.dependencies.map(d => d.name) : null;
			return arr.concat([mod]);
		}, []).sort((a, b) => a.title.localeCompare(b.title));
		 // Filters
		const filters = ["all", "active", "inactive"].map(f => {
			return {
				id: f,
				label: game.i18n.localize(`MODMANAGE.Filter${f.titleCase()}`),
				css: this._filter === f ? " active" : "",
				count: counts[f] || 0
			}
		});
		 // Return data for rendering
		return { editable, filters, modules, query: this._query, expanded: this._expanded };
	}
	 /* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find('button[name="deactivate"]').click(this._onDeactivateAll.bind(this));
		html.find('.filter').click(this._onFilterList.bind(this));
		html.find('button.expand').click(this._onExpandCollapse.bind(this));
		html.find('input[type="checkbox"').change(this._onChangeCheckbox.bind(this));
		 // Restore state
		Object.entries(this._checked).forEach(c => {
			if ( this.form[c[0]] ) this.form[c[0]].checked = c[1];
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		const settings = game.settings.get("core", this.constructor.CONFIG_SETTING);
		const setting = mergeObject(settings, formData);
		 // Ensure all dependencies are satisfied
		for ( let [k, v] of Object.entries(setting) ) {
			if ( v === false ) continue;
			const mod = game.modules.get(k);
			if ( !mod ) {
				delete setting[k];
				continue;
			}
			if ( !mod.data.dependencies?.length ) continue;
			const missing = mod.data.dependencies.reduce((arr, d) => {
				if ( d.type && (d.type !== "module") ) return arr;
				if ( !setting[d.name] ) arr.push(d.name);
				return arr;
			}, []);
			if ( missing.length ) {
				const warning = game.i18n.format("MODMANAGE.DepMissing", {module: k, missing: missing.join(", ")});
				this.options.closeOnSubmit = false;
				return ui.notifications.warn(warning)
			}
		}
		 // Apply the setting
		return game.settings.set("core", this.constructor.CONFIG_SETTING, setting);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle changes to a module checkbox to prompt for whether or not to enable dependencies
	 * @private
	 */
	_onChangeCheckbox(event) {
		const input = event.target;
		this._checked[input.name] = input.checked;
		const module = game.modules.get(input.name);
		if ( !module.data.dependencies?.length ) return;
		return Dialog.confirm({
			title: "Toggle Dependencies?",
			content: game.i18n.format(input.checked ? "MODMANAGE.DepEnable" : "MODMANAGE.DepDisable", {
				number: module.data.dependencies.length
			}),
			yes: () => {
				for ( let d of module.data.dependencies ) {
					const dep = input.form[d.name];
					if ( dep ) dep.checked = input.checked;
				}
			}
		})
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a button-click to deactivate all modules
	 * @private
	 */
	_onDeactivateAll(event) {
		event.preventDefault();
		for ( let input of this.element[0].querySelectorAll('input[type="checkbox"]') ) {
			this._checked[input.name] = input.checked = false;
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle expanding or collapsing the display of descriptive elements
	 * @private
	 */
	_onExpandCollapse(event) {
		event.preventDefault();
		this._expanded = !this._expanded;
		this.render();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a button-click to deactivate all modules
	 * @private
	 */
	_onFilterList(event) {
		event.preventDefault();
		this._filter = event.target.dataset.filter;
		this.render();
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onSearchFilter(event, query, html) {
		const rgx = new RegExp(RegExp.escape(query), "i");
		for ( let li of html.children ) {
			if ( !query ) {
				li.classList.remove("hidden");
				continue;
			}
			const name = li.dataset.moduleName;
			const title = (li.querySelector(".package-title")?.textContent || "").trim();
			const author = (li.querySelector(".author")?.textContent || "").trim();
			const match = rgx.test(name) || rgx.test(title) || rgx.test(author);
			li.classList.toggle("hidden", !match);
		}
	}
}

ModuleManagement.CONFIG_SETTING = "moduleConfiguration";
/**
 * An application for configuring the permissions which are available to each User role.
 * @extends {FormApplication}
 */
class PermissionConfig extends FormApplication {
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			title: game.i18n.localize("PERMISSION.Title"),
			id: "permissions-config",
			template: "templates/sidebar/apps/permission-config.html",
			width: 660,
			height: "auto",
			scrollY: [".permissions-list"],
			closeOnSubmit: true
		})
	}
	 /* -------------------------------------------- */
	 /** @override */
	async getData(options) {
		const current = await game.settings.get("core", "permissions");
		return {
			roles: Object.keys(CONST.USER_ROLES).reduce((obj, r) => {
				if ( r === "NONE" ) return obj;
				obj[r] = `USER.Role${r.titleCase()}`;
				return obj;
			}, {}),
			permissions: this._getPermissions(current)
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Prepare the permissions object used to render the configuration template
	 * @return {object[]}
	 * @private
	 */
	_getPermissions(current) {
		const rgm = CONST.USER_ROLES.GAMEMASTER;
		 // Get permissions
		const perms = Object.entries(duplicate(CONFIG.User.permissions)).reduce((arr, e) => {
			const perm = e[1];
			perm.id = e[0];
			perm.label = game.i18n.localize(perm.label);
			perm.hint = game.i18n.localize(perm.hint);
			arr.push(perm);
			return arr;
		}, []);
		perms.sort((a, b) => a.label.localeCompare(b.label));
		 // Configure permission roles
		for ( let p of perms ) {
			const roles = current[p.id] || Array.fromRange(rgm + 1).slice(p.defaultRole);
			p.roles = Object.values(CONST.USER_ROLES).reduce((arr, role) => {
				if ( role === CONST.USER_ROLES.NONE ) return arr;
				arr.push({
					name: `${p.id}.${role}`,
					value: roles.includes(role),
					disabled: (role === rgm) && (!p.disableGM)
				});
				return arr;
			}, []);
		}
		return perms;
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find('button[name="reset"]').click(this._onResetDefaults.bind(this));
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle button click to reset default settings
	 * @param event {Event}   The initial button click event
	 * @private
	 */
	async _onResetDefaults(event) {
		event.preventDefault();
		const defaults = this._getPermissions({});
		await game.settings.set("core", "permissions", defaults);
		ui.notifications.info(`Reset User role permission configuration to default values.`);
		return this.render();
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _onSubmit(event, options) {
		event.target.querySelectorAll("input[disabled]").forEach(i => i.disabled = false);
		return super._onSubmit(event, options);
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _updateObject(event, formData) {
		const permissions = expandObject(formData);
		for ( let [k, v] of Object.entries(permissions) ) {
			if ( !(k in CONST.USER_PERMISSIONS ) ) {
				delete permissions[k];
				continue
			}
			permissions[k] = Object.entries(v).reduce((arr, r) => {
				if ( r[1] === true ) arr.push(parseInt(r[0]));
				return arr;
			}, []);
		}
		await game.settings.set("core", "permissions", permissions);
		ui.notifications.info(`Updated User role permission configuration.`);
	}
}

/**
 * A directory list of Actor entities in the Sidebar
 * @type {SidebarDirectory}
 * @see {@link Actor}
 */
class ActorDirectory extends SidebarDirectory {
	constructor(...args) {
		super(...args);
		this._dragDrop[0].permissions["dragstart"] = () => game.user.can("TOKEN_CREATE");
		this._dragDrop[0].permissions["dragdrop"] = () => game.user.can("ACTOR_CREATE");
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get entity() {
	 return "Actor";
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get collection() {
		return game.actors;
	}
	 /* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const data = super.getData(options);
		data.folderPartial = "templates/sidebar/folder-partial.html";
		data.entityPartial = "templates/sidebar/actor-partial.html";
		return data;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_canDragStart(selector) {
		return game.user.can("TOKEN_CREATE");
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragStart(event) {
		const li = event.currentTarget.closest(".directory-item");
		let actor = null;
		if ( li.dataset.entityId ) {
			actor = game.actors.get(li.dataset.entityId);
			if ( !actor || !actor.visible ) return false;
		}
		 // Parent directory drag start handling
		super._onDragStart(event);
		 // Create the drag preview for the Token
		if ( actor && canvas.ready ) {
			const img = li.querySelector("img");
			const td = actor.data.token;
			const w = td.width * canvas.dimensions.size * td.scale * canvas.stage.scale.x;
			const h = td.height * canvas.dimensions.size * td.scale * canvas.stage.scale.y;
			const preview = DragDrop.createDragImage(img, w, h);
			event.dataTransfer.setDragImage(preview, w / 2, h / 2);
		}
	}
		/* -------------------------------------------- */
	 /** @override */
	_canDragDrop(selector) {
		return game.user.can("ACTOR_CREATE");
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _onClickEntityName(event) {
		event.preventDefault();
		const actorId = event.currentTarget.closest(".actor").dataset.entityId;
		const actor = this.constructor.collection.get(actorId);
		if ( actor.sheet.token ) await actor.sheet.close();
		super._onClickEntityName(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_getEntryContextOptions() {
		const options = super._getEntryContextOptions();
		return [
			{
				name: "SIDEBAR.CharArt",
				icon: '<i class="fas fa-image"></i>',
				condition: li => {
					const actor = game.actors.get(li.data("entityId"));
					return actor.data.img !== CONST.DEFAULT_TOKEN;
				},
				callback: li => {
					const actor = game.actors.get(li.data("entityId"));
					new ImagePopout(actor.data.img, {
						title: actor.name,
						shareable: true,
						uuid: actor.uuid
					}).render(true);
				}
			},
			{
				name: "SIDEBAR.TokenArt",
				icon: '<i class="fas fa-image"></i>',
				condition: li => {
					const actor = game.actors.get(li.data("entityId"));
					if ( actor.data.token.randomImg ) return false;
					return ![null, undefined, CONST.DEFAULT_TOKEN].includes(actor.data.token.img);
				},
				callback: li => {
					const actor = game.actors.get(li.data("entityId"));
					new ImagePopout(actor.data.token.img, {
						title: actor.name,
						shareable: true,
						uuid: actor.uuid
					}).render(true);
				}
			}
		].concat(options);
	}
}

/**
 * The Chat Log application displayed in the Sidebar
 * @extends {SidebarTab}
 * @see {Sidebar}
 */
class ChatLog extends SidebarTab {
	constructor(options) {
		super(options);
		 /**
		 * Track whether the user currently has pending text in the chat box
		 * @type {boolean}
		 */
		this._pendingText = "";
		 /**
		 * Track the history of the past 5 sent messages which can be accessed using the arrow keys
		 * @type {object[]}
		 * @private
		 */
		this._sentMessages = [];
		 /**
		 * Track which remembered message is being currently displayed to cycle properly
		 * @type {number}
		 * @private
		 */
		this._sentMessageIndex = -1;
		 /**
		 * Track the time when the last message was sent to avoid flooding notifications
		 * @type {number}
		 * @private
		 */
		this._lastMessageTime = 0;
		 /**
		 * Track the id of the last message displayed in the log
		 * @type {string|null}
		 * @private
		 */
		this._lastId = null;
		 /**
		 * Track the last received message which included the user as a whisper recipient.
		 * @type {ChatMessage|null}
		 * @private
		 */
		this._lastWhisper = null;
		 // Update timestamps every 15 seconds
		setInterval(this.updateTimestamps, 1000 * 15);
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "chat",
			template: "templates/sidebar/chat-log.html",
			title: game.i18n.localize("CHAT.Title"),
			scrollContainer: null,
			stream: false
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * A reference to the Messages collection that the chat log displays
	 * @type {Messages}
	 */
	get collection() {
		return game.messages;
	}
	 /* -------------------------------------------- */
	/*  Application Rendering                       */
	/* -------------------------------------------- */
	 /** @override */
	getData(options) {
		return {
			user: game.user,
			rollMode: game.settings.get("core", "rollMode"),
			rollModes: CONFIG.Dice.rollModes,
			isStream: !!this.options.stream
		};
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _render(...args) {
		if (this.rendered) return; // Never re-render the Chat Log itself, only it's contents
		await super._render(...args);
		await this._renderBatch(CONFIG.ChatMessage.batchSize);
		this.scrollBottom();
	}
	 /* -------------------------------------------- */
	 /**
	 * Render a batch of additional messages, prepending them to the top of the log
	 * @param {number} size     The batch size to include
	 * @return {Promise<void>}
	 * @private
	 */
	async _renderBatch(size) {
		if ( !this.rendered ) return;
		this._state = Application.RENDER_STATES.RENDERING;
		const messages = game.messages.entities;
		const log = this.element.find("#chat-log");
		 // Get the index of the last rendered message
		let lastIdx = messages.findIndex(m => m._id === this._lastId);
		lastIdx = lastIdx !== -1 ? lastIdx : messages.length;
		 // Get the next batch to render
		let targetIdx = Math.max(lastIdx - size,  0);
		let m = null;
		if ( lastIdx !== 0 ) {
			let html = [];
			for ( let i=targetIdx; i<lastIdx; i++) {
				m = messages[i];
				if (!m.visible) continue;
				try {
					html.push(await m.render());
				} catch (err) {
					console.error(`Chat message ${m.id} failed to render.\n${err})`);
				}
			}
			 // Prepend the HTML
			log.prepend(html);
			this._lastId = messages[targetIdx].id;
		}
		 // Restore the rendered state
		this._state = Application.RENDER_STATES.RENDERED;
	}
	 /* -------------------------------------------- */
	 /** @override */
	renderPopout(original) {
		throw new Error("The Chat Log does not support pop-out mode");
	}
	 /* -------------------------------------------- */
	/*  Chat Sidebar Methods                        */
	/* -------------------------------------------- */
	 /**
	 * Delete all message HTML from the log
	 */
	deleteAll() {
		$("#chat-log").children().each(function() {
			$(this).slideUp();
		}, () => log.html(""));
	}
	 /* -------------------------------------------- */
	 /**
	 * Delete a single message from the chat log
	 * @param {string} messageId    The ChatMessage entity to remove from the log
	 * @param {boolean} [deleteAll] Is this part of a flush operation to delete all messages?
	 */
	deleteMessage(messageId, {deleteAll=false}={}) {
		let li = this.element.find(`.message[data-message-id="${messageId}"]`);
		 // Update the last index
		if ( deleteAll ) {
			this._lastId = null;
		} else if ( messageId === this._lastId ) {
			const next = li[0].nextElementSibling;
			this._lastId = !!next ? next.dataset.messageId : null;
		}
		 // Remove the deleted message
		if ( li.length ) li.slideUp(100, () => li.remove());
	}
	 /* -------------------------------------------- */
	 /**
	 * Trigger a notification that alerts the user visually and audibly that a new chat log message has been posted
	 */
	notify(message) {
		this._lastMessageTime = new Date();
		if ( !this.rendered ) return;
		 // Display the chat notification icon and remove it 3 seconds later
		let icon = $('#chat-notification');
		if ( icon.is(":hidden") ) icon.fadeIn(100);
		setTimeout(() => {
			if ( new Date() - this._lastMessageTime > 3000 && icon.is(":visible") ) icon.fadeOut(100);
		}, 3001);
		 // Play a notification sound effect
		if ( message.data.sound ) AudioHelper.play({src: message.data.sound});
	}
	 /* -------------------------------------------- */
	 /**
	 * Parse a chat string to identify the chat command (if any) which was used
	 * @param {string} message    The message to match
	 * @return {string[]}         The identified command and regex match
	 */
	static parse(message) {
		 // Dice roll regex
		let formula = '([^#]*)';                  // Capture any string not starting with '#'
		formula += '(?:(?:#\\s?)(.*))?';          // Capture any remaining flavor text
		const roll = '^(\\/r(?:oll)? )';          // Regular rolls, support /r or /roll
		const gm = '^(\\/gmr(?:oll)? )';          // GM rolls, support /gmr or /gmroll
		const br = '^(\\/b(?:lind)?r(?:oll)? )';  // Blind rolls, support /br or /blindroll
		const sr = '^(\\/s(?:elf)?r(?:oll)? )';   // Self rolls, support /sr or /sroll
		const any = '([^]*)';                     // Any character, including new lines
		 // Define regex patterns
		const patterns = {
			"roll": new RegExp(roll+formula, 'i'),
			"gmroll": new RegExp(gm+formula, 'i'),
			"blindroll": new RegExp(br+formula, 'i'),
			"selfroll": new RegExp(sr+formula, 'i'),
			"ic": new RegExp('^(\/ic )'+any, 'i'),
			"ooc": new RegExp('^(\/ooc )'+any, 'i'),
			"emote": new RegExp('^(\/(?:em(?:ote)?|me) )'+any, 'i'),
			"whisper": new RegExp(/^(\/w(?:hisper)?\s{1})(\[(?:[^\]]+)\]|(?:[^\s]+))\s+([^]*)/, 'i'),
			"reply": new RegExp('^(\/reply )'+any, 'i'),
			"gm": new RegExp('^(\/gm )'+any, 'i'),
			'players': new RegExp('^(\/players )'+any, 'i'),
			"invalid": /^(\/[^\s]+)/, // Any other message starting with a slash command is invalid
		};
		 // Iterate over patterns, finding the first match
		let c, rgx, match;
		for ( [c, rgx] of Object.entries(patterns) ) {
			match = message.match(rgx); 
			if ( match ) return [c, match];
		}
		return ["none", [message, "", message]];
	}
	 /* -------------------------------------------- */
	 /**
	 * Post a single chat message to the log
	 * @param {ChatMessage} message   A ChatMessage entity instance to post to the log
	 * @param {boolean} [notify]      Trigger a notification which shows the log as having a new unread message
	 * @return {Promise<void>}        A Promise which resolves once the message is posted
	 */
	async postOne(message, notify=false) {
		if ( !message.visible ) return;
		 // Track internal flags
		if ( !this._lastId ) this._lastId = message.id; // Ensure that new messages don't result in batched scrolling
		if ( (message.data.whisper || []).includes(game.user.id) && !message.isRoll ) {
			this._lastWhisper = message;
		}
		 // Render the message to the log
		return message.render().then(html => {
			this.element.find("#chat-log").append(html);
			this.scrollBottom();
			if ( notify ) this.notify(message);
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Scroll the chat log to the bottom
	 * @private
	 */
	scrollBottom() {
		const el = this.element;
		const log = el.length ? el[0].querySelector("#chat-log") : null;
		if ( log ) log.scrollTop = log.scrollHeight;
	}
	 /* -------------------------------------------- */
	 /**
	 * Update the content of a previously posted message after its data has been replaced
	 * @param {ChatMessage} message   The ChatMessage instance to update
	 * @param {boolean} notify        Trigger a notification which shows the log as having a new unread message
	 */
	updateMessage(message, notify=false) {
		let li = this.element.find(`.message[data-message-id="${message.id}"]`);
		if ( li.length ) message.render().then(html => li.replaceWith(html));
		else this.postOne(message, false);
		if ( notify ) this.notify(message);
	}
	 /* -------------------------------------------- */
	 updateTimestamps() {
		let stamps = game.messages.entities.reduce((acc, val) => { acc[val._id] = val.data.timestamp; return acc;}, {});
		$("#chat-log").children().each((i, li) => {
			let id = li.getAttribute("data-message-id"),
					stamp = stamps[id];
			if ( !stamp ) return;
			li.querySelector('.message-timestamp').textContent = timeSince(stamp);
		})
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */
	 /**
	 * Activate event listeners triggered within the ChatLog application
	 * @param html {jQuery|HTMLElement}
	 */
	activateListeners(html) {
		 // Load new messages on scroll
		html.find("#chat-log").scroll(this._onScrollLog.bind(this));
		 // Chat message entry
		html.find("#chat-message").keydown(this._onChatKeyDown.bind(this));
		 // Expand dice roll tooltips
		html.on("click", ".dice-roll", this._onDiceRollClick.bind(this));
		 // Modify Roll Type
		html.find('select[name="rollMode"]').change(this._onChangeRollMode.bind(this));
		 // Single Message Delete
		html.on('click', 'a.message-delete', this._onDeleteMessage.bind(this));
		 // Flush log
		html.find('a.chat-flush').click(this._onFlushLog.bind(this));
		 // Export log
		html.find('a.export-log').click(this._onExportLog.bind(this));
		 // Chat Entry context menu
		this._contextMenu(html);
	}
	 /* -------------------------------------------- */
	 /**
	 * Prepare the data object of chat message data depending on the type of message being posted
	 * @param {string} message      The original string of the message content
	 * @return {Promise<Object>}    A Promise resolving to the prepared chat data object
	 * @private
	 */
	async processMessage(message) {
		const cls = CONFIG.ChatMessage.entityClass;
		 // Set up basic chat data
		const chatData = {
			user: game.user._id,
			speaker: cls.getSpeaker()
		};
		 // Allow for handling of the entered message to be intercepted by a hook
		if ( Hooks.call("chatMessage", this, message, chatData) === false ) return;
		 // Alter the message content, if needed
		message = message.replace(/\n/g, "<br>");
		 // Parse the message to determine the matching handler
		let [command, match] = this.constructor.parse(message);
		 // Special handlers for no command
		if ( command === "invalid" ) throw new Error(game.i18n.format("CHAT.InvalidCommand", {command: match[1]}));
		else if ( command === "none" ) command = chatData.speaker.token ? "ic" : "ooc";
		 // Process message data based on the identified command type
		const createOptions = {};
		switch (command) {
			case "roll": case "gmroll": case "blindroll": case "selfroll":
				this._processDiceCommand(command, match, chatData, createOptions);
				break;
			case "whisper": case "reply": case "gm": case "players":
				this._processWhisperCommand(command, match, chatData, createOptions);
				break;
			case "ic": case "emote": case "ooc":
				this._processChatCommand(command, match, chatData, createOptions);
				break;
		}
		 // Create the message using provided data and options
		return cls.create(chatData, createOptions);
	}
	 /* -------------------------------------------- */
	 /**
	 * Process messages which are posted using a dice-roll command
	 * @param {string} command          The chat command type
	 * @param {RegExpMatchArray} match  The matched RegExp expressions
	 * @param {Object} chatData         The initial chat data
	 * @param {Object} createOptions    Options used to create the message
	 * @private
	 */
	_processDiceCommand(command, match, chatData, createOptions) {
		 // Roll content and flavor text
		let [formula, flavor] = match.slice(2, 4);
		mergeObject(chatData, {
			content: formula,
			flavor: flavor || null,
			type: CONST.CHAT_MESSAGE_TYPES.ROLL
		});
		 // Convert the chat content into a Roll
		const actor = ChatMessage.getSpeakerActor(chatData.speaker) || game.user.character;
		const rollData = actor ? actor.getRollData() : {};
		chatData.roll = Roll.create(formula, rollData).evaluate();
		 // Record additional roll data
		chatData.sound = CONFIG.sounds.dice;
		if ( ["gmroll", "blindroll"].includes(command) ) chatData.whisper = ChatMessage.getWhisperRecipients("GM");
		if ( command === "selfroll" ) chatData.whisper = [game.user._id];
		if ( command === "blindroll" ) chatData.blind = true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Process messages which are posted using a chat whisper command
	 * @param {string} command          The chat command type
	 * @param {RegExpMatchArray} match  The matched RegExp expressions
	 * @param {Object} chatData         The initial chat data
	 * @param {Object} createOptions    Options used to create the message
	 * @private
	 */
	_processWhisperCommand(command, match, chatData, createOptions) {
		 // Prepare whisper data
		chatData.type = CONST.CHAT_MESSAGE_TYPES.WHISPER;
		delete chatData.speaker;
		 // Determine the recipient users
		let users = [];
		let message= "";
		switch(command) {
			case "whisper":
				message = match[3];
				const names = match[2].replace(/[\[\]]/g, "").split(",").map(n => n.trim());
				users = names.reduce((arr, n) => arr.concat(ChatMessage.getWhisperRecipients(n)), []);
				break;
			case "reply":
				message = match[2];
				const w = this._lastWhisper;
				if ( w ) {
					const group = new Set(w.data.whisper);
					group.add(w.data.user);
					group.delete(game.user._id);
					users = Array.from(group).map(id => game.users.get(id));
				}
				break;
			case "gm":
				message = match[2];
				users = ChatMessage.getWhisperRecipients("gm");
				break;
			case "players":
				message = match[2];
				users = ChatMessage.getWhisperRecipients("players");
				break;
		}
		 // Ensure we have valid whisper targets
		if ( !users.length ) throw new Error("No target users exist for this whisper.");
		if ( users.some(u => !u.isGM) && !game.user.can("MESSAGE_WHISPER") ) {
			throw new Error("You do not have permission to send whispered chat messages to other players.");
		}
		 // Update chat data
		chatData.whisper = users.map(u => u._id);
		chatData.content = message;
		chatData.sound = CONFIG.sounds.notification;
	}
	 /* -------------------------------------------- */
	 /**
	 * Process messages which are posted using a chat whisper command
	 * @param {string} command          The chat command type
	 * @param {RegExpMatchArray} match  The matched RegExp expressions
	 * @param {Object} chatData         The initial chat data
	 * @param {Object} createOptions    Options used to create the message
	 * @private
	 */
	_processChatCommand(command, match, chatData, createOptions) {
		if ( ["ic", "emote"].includes(command) && !(chatData.speaker.actor || chatData.speaker.token) ) {
			throw new Error("You cannot chat in-character without an identified speaker");
		}
		chatData.content = match[2];
		 // Augment chat data
		if ( command === "ic" ) {
			chatData.type = CONST.CHAT_MESSAGE_TYPES.IC;
			createOptions.chatBubble = true;
		} else if ( command === "emote" ) {
			chatData.type = CONST.CHAT_MESSAGE_TYPES.EMOTE;
			chatData.content = `${chatData.speaker.alias} ${chatData.content}`;
			createOptions.chatBubble = true;
		}
		else {
			chatData.type = CONST.CHAT_MESSAGE_TYPES.OOC;
			delete chatData.speaker;
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Add a sent message to an array of remembered messages to be re-sent if the user pages up with the up arrow key
	 * @param {string} message    The message text being remembered
	 * @private
	 */
	_remember(message) {
		if ( this._sentMessages.length === 5 ) this._sentMessages.splice(4, 1);
		this._sentMessages.unshift(message);
		this._sentMessageIndex = -1;
	}
	 /* -------------------------------------------- */
	 /**
	 * Recall a previously sent message by incrementing up (1) or down (-1) through the sent messages array
	 * @param {number} direction    The direction to recall, positive for older, negative for more recent
	 * @return {string}             The recalled message, or an empty string
	 * @private
	 */
	_recall(direction) {
		if ( this._sentMessages.length > 0 ) {
			let idx = this._sentMessageIndex + direction;
			this._sentMessageIndex = Math.clamped(idx, -1, this._sentMessages.length-1);
		}
		return this._sentMessages[this._sentMessageIndex] || "";
	}
	 /* -------------------------------------------- */
	 /**
	 * Compendium sidebar Context Menu creation
	 * @param html {jQuery}
	 * @private
	 */
	_contextMenu(html) {
		 // Entry Context
		const entryOptions = this._getEntryContextOptions();
		Hooks.call(`get${this.constructor.name}EntryContext`, html, entryOptions);
		if (entryOptions) new ContextMenu(html, ".message", entryOptions);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the ChatLog entry context options
	 * @return {object[]}   The sidebar entry context options
	 * @private
	 */
	_getEntryContextOptions() {
		return [
			{
				name: "CHAT.PopoutMessage",
				icon: '<i class="fas fa-external-link-alt fa-rotate-180"></i>',
				condition: li => {
					const message = game.messages.get(li.data("messageId"));
					return message.getFlag("core", "canPopout") === true;
				},
				callback: li => {
					const message = game.messages.get(li.data("messageId"));
					new ChatPopout(message).render(true);
				}
			},
			{
				name: "CHAT.RevealMessage",
				icon: '<i class="fas fa-eye"></i>',
				condition: li => {
					const message = game.messages.get(li.data("messageId"));
					const isLimited = message.data.whisper.length || message.data.blind;
					return isLimited && (game.user.isGM || message.isAuthor) && message.isContentVisible;
				},
				callback: li => {
					const message = game.messages.get(li.data("messageId"));
					return message.update({whisper: [], blind: false});
				}
			},
			{
				name: "CHAT.ConcealMessage",
				icon: '<i class="fas fa-eye-slash"></i>',
				condition: li => {
					const message = game.messages.get(li.data("messageId"));
					const isLimited = message.data.whisper.length || message.data.blind;
					return !isLimited && (game.user.isGM || message.isAuthor) && message.isContentVisible;
				},
				callback: li => {
					const message = game.messages.get(li.data("messageId"));
					return message.update({whisper: ChatMessage.getWhisperRecipients("gm").map(u => u.id), blind: false});
				}
			}
		]
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle keydown events in the chat entry textarea
	 * @param {Event} event
	 * @private
	 */
	_onChatKeyDown(event) {
		const code = game.keyboard.getKey(event);
		const textarea = event.currentTarget;
		 // UP/DOWN ARROW -> Recall Previous Messages
		const isArrow = ["ArrowUp", "ArrowDown"].includes(code);
		if ( isArrow ) {
			if ( this._pendingText ) return;
			event.preventDefault();
			textarea.value = this._recall(code === "ArrowUp" ? 1 : -1);
			return;
		}
		 // ENTER -> Send Message
		const isEnter = (code === "Enter") && !event.shiftKey;
		if ( isEnter ) {
			event.preventDefault();
			const message = textarea.value;
			if (!message) return;
			this._pendingText = "";
			 // Prepare chat message data and handle result
			return this.processMessage(message).then(() => {
				textarea.value = "";
				this._remember(message);
			}).catch(error => {
				ui.notifications.error(error);
				throw error;
			});
		}
		 // BACKSPACE -> Remove pending text
		if ( event.key === "Backspace" ) {
			this._pendingText = this._pendingText.slice(0, -1);
			return
		}
		 // Otherwise, record that there is pending text
		this._pendingText = textarea.value + (event.key.length === 1 ? event.key : "");
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle setting the preferred roll mode
	 * @param {Event} event
	 * @private
	 */
	_onChangeRollMode(event) {
		event.preventDefault();
		game.settings.set("core", "rollMode", event.target.value);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle single message deletion workflow
	 * @param {Event} event
	 * @private
	 */
	_onDeleteMessage(event) {
		event.preventDefault();
		const li = event.currentTarget.closest(".message");
		const message = this.collection.get(li.dataset.messageId);
		return message.delete();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle clicking of dice tooltip buttons
	 * @param {Event} event
	 * @private
	 */
	_onDiceRollClick(event) {
		event.preventDefault();
		let roll = $(event.currentTarget),
				tip = roll.find(".dice-tooltip");
		if ( !tip.is(":visible") ) tip.slideDown(200);
		else tip.slideUp(200);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle click events to export the chat log
	 * @param {Event} event
	 * @private
	 */
	_onExportLog(event) {
		event.preventDefault();
		game.messages.export();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle click events to flush the chat log
	 * @param {Event} event
	 * @private
	 */
	_onFlushLog(event) {
		event.preventDefault();
		game.messages.flush();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle scroll events within the chat log container
	 * @param {UIEvent} event   The initial scroll event
	 * @private
	 */
	_onScrollLog(event) {
		if ( !this.rendered ) return;
		const log = event.target;
		const pct = log.scrollTop / log.scrollHeight;
		if ( pct < 0.01 ) {
			return this._renderBatch(CONFIG.ChatMessage.batchSize);
		}
	}
}

/**
 * The combat and turn order tracker tab
 * @type {SidebarTab}
 */
class CombatTracker extends SidebarTab {
	constructor(options) {
		super(options);
		if ( !this.popOut ) game.combats.apps.push(this);
		 /**
		 * Record a reference to the currently highlighted Token
		 * @type {Token|null}
		 * @private
		 */
		this._highlighted = null;
		 /**
		 * Record the currently tracked Combat encounter
		 * @type {Combat|null}
		 */
		this.combat = null;
		 // Initialize the starting encounter
		this.initialize({render: false});
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
			id: "combat",
			template: "templates/sidebar/combat-tracker.html",
			title: "Combat Tracker",
			scrollY: [".directory-list"]
		});
	}
	/* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */
	/** @override */
	createPopout() {
		const pop = super.createPopout();
		pop.initialize({combat: this.combat, render: true});
		return pop;
	}
	/* -------------------------------------------- */
	 /**
	 * Initialize the combat tracker to display a specific combat encounter.
	 * If no encounter is provided, the tracker will be initialized with the first encounter in the viewed scene.
	 * @param {Combat|null} combat    The combat encounter to initialize
	 * @param {boolean} render        Whether to re-render the sidebar after initialization
	 */
	initialize({combat=null, render=true}={}) {
		// Retrieve a default encounter if none was provided
		if ( combat === null ) {
			const view = game.scenes.viewed;
			const combats = view ? game.combats.entities.filter(c => c.data.scene === view._id) : [];
			combat = combats.length ? combats.find(c => c.data.active) || combats[0] : null;
		}
		 // Assign data
		this._highlighted = null;
		this.combat = combat;
		 // Trigger data computation
		if ( combat && !combat.turns ) combat.turns = combat.setupTurns();
		 // Also initialize the popout
		if ( this._popout ) this._popout.initialize({combat, render: false});
		 // Render the tracker
		if ( render ) this.render();
	}
	 /* -------------------------------------------- */
	 /**
	 * Scroll the combat log container to ensure the current Combatant turn is centered vertically
	 */
	scrollToTurn() {
		const combat = this.combat;
		if ( !combat ) return;
		let active = this.element.find(".active")[0];
		if ( !active ) return;
		let container = active.parentElement;
		const nViewable = Math.floor(container.offsetHeight / active.offsetHeight);
		container.scrollTop = (this.combat.turn * active.offsetHeight) - ((nViewable/2) * active.offsetHeight);
	}
	 /* -------------------------------------------- */
	 /** @override */
	async getData(options) {
		 // Get the combat encounters possible for the viewed Scene
		const combat = this.combat;
		const hasCombat = combat !== null;
		const view = canvas?.scene || null;
		const combats = view ? game.combats.entities.filter(c => c.data.scene === view._id) : [];
		const currentIdx = combats.findIndex(c => c === this.combat);
		const previousId = currentIdx > 0 ? combats[currentIdx-1].id : null;
		const nextId = currentIdx < combats.length - 1 ? combats[currentIdx+1].id : null;
		const settings = game.settings.get("core", Combat.CONFIG_SETTING);
		 // Prepare rendering data
		const data = {
			user: game.user,
			combats: combats,
			currentIndex: currentIdx + 1,
			combatCount: combats.length,
			hasCombat: hasCombat,
			combat,
			turns: [],
			previousId,
			nextId,
			started: this.started,
			control: false,
			settings
		};
		if ( !hasCombat ) return data;
		 // Add active combat data
		const combatant = combat.combatant;
		const hasControl = combatant && combatant.players && combatant.players.includes(game.user);
		 // Format transient information about the combatant
		let hasDecimals = false;
		const turns = [];
		for ( let [i, t] of combat.turns.entries() ) {
			if ( !t.visible ) continue;
			 // Thumbnail image for video tokens
			if ( VideoHelper.hasVideoExtension(t.img) ) {
				if ( t.thumb ) t.img = t.thumb;
				else t.img = t.thumb = await game.video.createThumbnail(t.img, {width: 100, height: 100});
			}
			 // Copy the turn data
			const c = duplicate(t);
			if ( Number.isFinite(c.initiative) && !Number.isInteger(c.initiative) ) hasDecimals = true;
			 // Token status effect icons
			c.effects = new Set(c.token?.effects || []);
			if ( c.token?.overlayEffect ) c.effects.add(c.token.overlayEffect);
			if ( t.actor ) t.actor.temporaryEffects.forEach(e => {
				if ( e.getFlag("core", "statusId") === CONFIG.Combat.defeatedStatusId ) c.defeated = true;
				else if ( e.data.icon ) c.effects.add(e.data.icon);
			});
			 // Track resources
			if ( c.permission < ENTITY_PERMISSIONS.OBSERVER ) c.resource = null;
			 // Rendering states
			c.active = i === combat.turn;
			c.css = [
				c.active ? "active" : "",
				c.hidden ? "hidden" : "",
				c.defeated ? "defeated" : ""
			].join(" ").trim();
			c.hasRolled = c.initiative !== null;
			c.hasResource = c.resource !== null;
			turns.push(c);
		}
		 // Format displayed decimal places in the tracker
		turns.forEach(c => {
			c.initiative = c.initiative ? c.initiative.toFixed(hasDecimals ? CONFIG.Combat.initiative.decimals : 0) : null;
		});
		 // Merge update data for rendering
		return mergeObject(data, {
			round: combat.data.round,
			turn: combat.data.turn,
			turns: turns,
			control: hasControl
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
	 super.activateListeners(html);
	 const tracker = html.find("#combat-tracker");
	 const combatants = tracker.find(".combatant");
		// Create new Combat encounter
		html.find('.combat-create').click(ev => this._onCombatCreate(ev));
		 // Display Combat settings
		html.find('.combat-settings').click(ev => {
			ev.preventDefault();
			new CombatTrackerConfig().render(true);
		});
		 // Cycle the current Combat encounter
		html.find('.combat-cycle').click(ev => this._onCombatCycle(ev));
		// Combat control
		html.find('.combat-control').click(ev => this._onCombatControl(ev));
		 // Combatant control
		html.find('.combatant-control').click(ev => this._onCombatantControl(ev));
		 // Hover on Combatant
		combatants.hover(this._onCombatantHover.bind(this), this._onCombatantHoverOut.bind(this));
		 // Click on Combatant
		combatants.click(this._onCombatantMouseDown.bind(this));
		 // Context on right-click
		if ( game.user.isGM ) this._contextMenu(html);
		 // Intersection Observer for Combatant avatars
		const observer = new IntersectionObserver(this._onLazyLoadImage.bind(this), { root: tracker[0] });
		combatants.each((i, li) => observer.observe(li));
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle new Combat creation request
	 * @param {Event} event
	 * @private
	 */
	async _onCombatCreate(event) {
		event.preventDefault();
		let scene = game.scenes.viewed;
		if ( !scene ) return;
		let cbt = await game.combats.object.create({scene: scene._id});
		await cbt.activate();
		this.initialize(cbt);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a Combat deletion request
	 * @param {Event} event
	 * @private
	 */
	async _onCombatDelete(event) {
		event.preventDefault();
		let btn = event.currentTarget;
		if ( btn.hasAttribute("disabled") ) return;
		let cbt = game.combats.get(btn.getAttribute("data-combat-id"));
		await cbt.delete();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a Combat cycle request
	 * @param {Event} event
	 * @private
	 */
	async _onCombatCycle(event) {
		event.preventDefault();
		const btn = event.currentTarget;
		const combat = game.combats.get(btn.dataset.combatId);
		if ( !combat ) return;
		await combat.activate();
		this.initialize({combat});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle click events on Combat control buttons
	 * @private
	 * @param {Event} event   The originating mousedown event
	 */
	async _onCombatControl(event) {
		event.preventDefault();
		const ctrl = event.currentTarget;
		if ( ctrl.getAttribute("disabled") ) return;
		else ctrl.setAttribute("disabled", true);
		const fn = this.combat[ctrl.dataset.control];
		if ( fn ) await fn.bind(this.combat)();
		ctrl.removeAttribute("disabled");
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a Combatant control toggle
	 * @private
	 * @param {Event} event   The originating mousedown event
	 */
	async _onCombatantControl(event) {
		event.preventDefault();
		event.stopPropagation();
		const btn = event.currentTarget;
		const li = btn.closest(".combatant");
		const c = this.combat.getCombatant(li.dataset.combatantId);
		 // Switch control action
		switch (btn.dataset.control) {
			 // Toggle combatant visibility
			case "toggleHidden":
				await this.combat.updateCombatant({_id: c._id, hidden: !c.hidden});
				break;
			 // Toggle combatant defeated flag
			case "toggleDefeated":
				await this._onToggleDefeatedStatus(c);
				break;
			 // Roll combatant initiative
			case "rollInitiative":
				await this.combat.rollInitiative([c._id]);
				break;
		}
		 // Render tracker updates
		this.render();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle toggling the defeated status effect on a combatant Token
	 * @param {Combatant} c     The combatant data being modified
	 * @return {Promise<void>}
	 * @private
	 */
	async _onToggleDefeatedStatus(c) {
		let isDefeated = !c.defeated;
		await this.combat.updateCombatant({_id: c._id, defeated: isDefeated});
		const token = canvas.tokens.get(c.tokenId);
		if ( !token ) return;
		 // Push the defeated status to the token
		let status = CONFIG.statusEffects.find(e => e.id === CONFIG.Combat.defeatedStatusId);
		let effect = token.actor && status ? status : CONFIG.controlIcons.defeated;
		await token.toggleEffect(effect, {overlay: true, active: isDefeated});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mouse-down event on a combatant name in the tracker
	 * @private
	 * @param {Event} event   The originating mousedown event
	 * @return {Promise}      A Promise that resolves once the pan is complete
	 */
	_onCombatantMouseDown(event) {
		event.preventDefault();
		 const li = event.currentTarget;
		const token = canvas.tokens.get(li.dataset.tokenId);
		if ( !token?.owner ) return;
		const now = Date.now();
		 // Handle double-left click to open sheet
		const dt = now - this._clickTime;
		this._clickTime = now;
		if ( dt <= 250 ) {
			if ( token.actor ) token.actor.sheet.render(true);
		}
		 // Control and pan on single-left
		else {
			token.control({releaseOthers: true});
			return canvas.animatePan({x: token.x, y: token.y});
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mouse-hover events on a combatant in the tracker
	 * @private
	 */
	_onCombatantHover(event) {
		event.preventDefault();
		const li = event.currentTarget;
		const token = canvas.tokens.get(li.dataset.tokenId);
		if ( token && token.isVisible ) {
			if ( !token._controlled ) token._onHoverIn(event);
			this._highlighted = token;
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mouse-unhover events for a combatant in the tracker
	 * @private
	 */
	_onCombatantHoverOut(event) {
		event.preventDefault();
		if ( this._highlighted ) this._highlighted._onHoverOut(event);
		this._highlighted = null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Default folder context actions
	 * @param html {jQuery}
	 * @private
	 */
	_contextMenu(html) {
		const entryOptions = this._getEntryContextOptions();
		Hooks.call(`get${this.constructor.name}EntryContext`, html, entryOptions);
		if (entryOptions) new ContextMenu(html, ".directory-item", entryOptions);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the sidebar directory entry context options
	 * @return {Object}   The sidebar entry context options
	 * @private
	 */
	_getEntryContextOptions() {
		return [
			{
				name: "COMBAT.CombatantUpdate",
				icon: '<i class="fas fa-edit"></i>',
				callback: this._onConfigureCombatant.bind(this)
			},
			{
				name: "COMBAT.CombatantReroll",
				icon: '<i class="fas fa-dice-d20"></i>',
				callback: li => this.combat.rollInitiative(li.data('combatant-id'))
			},
			{
				name: "COMBAT.CombatantRemove",
				icon: '<i class="fas fa-skull"></i>',
				callback: li => this.combat.deleteCombatant(li.data('combatant-id'))
			}
		];
	}
	 /* -------------------------------------------- */
	 /**
	 * Display a dialog which prompts the user to enter a new initiative value for a Combatant
	 * @param {jQuery} li
	 * @private
	 */
	_onConfigureCombatant(li) {
		const combatant = this.combat.getCombatant(li.data('combatant-id'));
		new CombatantConfig(combatant, {
			top: Math.min(li[0].offsetTop, window.innerHeight - 350),
			left: window.innerWidth - 720,
			width: 400
		}).render(true);
	}
}

/**
 * A compendium of knowledge arcane and mystical!
 * @extends {SidebarTab}
 */
class CompendiumDirectory extends SidebarTab {
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 id: "compendium",
			template: "templates/sidebar/compendium.html",
			title: "Compendium Packs"
		});
	}
	/* -------------------------------------------- */
	 /** @override */
	getData(options) {
		 // Filter packs for visibility
		let packs = game.packs.filter(p => game.user.isGM || !p.private);
		 // Sort packs by Entity type
		const packData = packs.sort((a,b) => a.entity.localeCompare(b.entity)).reduce((obj, pack) => {
			let ent = pack.entity;
			if ( !obj.hasOwnProperty(ent) ) obj[ent] = {
				label: ent,
				packs: []
			};
			obj[ent].packs.push(pack);
			return obj;
		}, {});
		 // Sort packs within type
		for ( let [e, p] of Object.entries(packData) ) {
			p.packs = p.packs.sort((a,b) => a.title.localeCompare(b.title));
		}
		 // Return data to the sidebar
		return {
			user: game.user,
			packs: packData
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		// Click to open
	 html.find('.compendium-pack').click(ev => {
		 let li = $(ev.currentTarget),
				pack = game.packs.get(li.data("pack"));
			if ( li.attr("data-open") === "1" ) pack.close();
			else {
				li.attr("data-open", "1");
				li.find("i.folder").removeClass("fa-folder").addClass("fa-folder-open");
				pack.render(true);
			}
		});
		// Options below are GM only
		if ( !game.user.isGM ) return;
		// Create Compendium
		html.find('.create-compendium').click(this._onCreateCompendium.bind(this));
		
		// Compendium context menu
		this._contextMenu(html);
	}
	 /* -------------------------------------------- */
	 /**
	 * Compendium sidebar Context Menu creation
	 * @param html {jQuery}
	 * @private
	 */
	_contextMenu(html) {
		 // Entry Context
		const entryOptions = this._getEntryContextOptions();
		Hooks.call(`get${this.constructor.name}EntryContext`, html, entryOptions);
		if (entryOptions) new ContextMenu(html, ".compendium-pack", entryOptions);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the sidebar directory entry context options
	 * @return {Object}   The sidebar entry context options
	 * @private
	 */
	_getEntryContextOptions() {
		return [
			{
				name: "COMPENDIUM.ToggleVisibility",
				icon: '<i class="fas fa-eye"></i>',
				callback: li => {
					let pack = game.packs.get(li.data("pack"));
					pack.configure({private: !pack.private});
				}
			},
			{
				name: "COMPENDIUM.ToggleLocked",
				icon: '<i class="fas fa-lock"></i>',
				callback: li => {
					let pack = game.packs.get(li.data("pack"));
					const isUnlock = pack.locked;
					if ( isUnlock && (pack.metadata.package !== "world")) {
						return Dialog.confirm({
							title: `${game.i18n.localize("COMPENDIUM.ToggleLocked")}: ${pack.title}`,
							content: `<p><strong>${game.i18n.localize("Warning")}:</strong> ${game.i18n.localize("COMPENDIUM.ToggleLockedWarning")}</p>`,
							yes: () => pack.configure({locked: !pack.locked}),
							options: {
								top: Math.min(li[0].offsetTop, window.innerHeight - 350),
								left: window.innerWidth - 720,
								width: 400
							}
						});
					}
					else return pack.configure({locked: !pack.locked});
				}
			},
			{
				name: "COMPENDIUM.Duplicate",
				icon: '<i class="fas fa-copy"></i>',
				callback: li => {
					let pack = game.packs.get(li.data("pack"));
					const html = `<form>
						<div class="form-group">
								<label>${game.i18n.localize("COMPENDIUM.DuplicateTitle")}</label>
								<input type="text" name="label" value="${pack.title}"/>
								<p class="notes">${game.i18n.localize("COMPENDIUM.DuplicateHint")}</p>
						</div>
					</form>`;
					return Dialog.confirm({
						title: `${game.i18n.localize("COMPENDIUM.ToggleLocked")}: ${pack.title}`,
						content: html,
						yes: html => {
							const label = html.querySelector('input[name="label"]').value;
							return pack.duplicate({label})
						},
						options: {
							top: Math.min(li[0].offsetTop, window.innerHeight - 350),
							left: window.innerWidth - 720,
							width: 400,
							jQuery: false
						}
					});
				}
			},
			{
				name: "COMPENDIUM.ImportAll",
				icon: '<i class="fas fa-download"></i>',
				callback: li => {
					let pack = game.packs.get(li.data("pack"));
					const html = `<form>
						<div class="form-group">
								<label>${game.i18n.localize("FOLDER.Name")}</label>
								<input type="text" name="folderName" value="${pack.metadata.label}"/>
								<p class="notes">${game.i18n.localize("COMPENDIUM.ImportAllHint")}</p>
						</div>
					</form>`;
					return Dialog.confirm({
						title: `${game.i18n.localize("COMPENDIUM.ImportAll")}: ${pack.title}`,
						content: html,
						yes: html => {
							const folderName = html.querySelector('input[name="folderName"]').value;
							return pack.importAll({folderName});
						},
						options: {
							top: Math.min(li[0].offsetTop, window.innerHeight - 350),
							left: window.innerWidth - 720,
							width: 400,
							jQuery: false
						}
					});
				}
			},
			{
				name: "COMPENDIUM.Delete",
				icon: '<i class="fas fa-trash"></i>',
				condition: li => {
					let pack = game.packs.get(li.data("pack"));
					return pack.metadata.package === "world";
				},
				callback: li => {
					let pack = game.packs.get(li.data("pack"));
					this._onDeleteCompendium(pack);
				}
			}
		];
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a Compendium Pack creation request
	 * @param event
	 * @private
	 */
	async _onCreateCompendium(event) {
		event.preventDefault();
		const types = CONST.COMPENDIUM_ENTITY_TYPES;
		const html = await renderTemplate('templates/sidebar/compendium-create.html', {types});
		return Dialog.prompt({
			title: game.i18n.localize("COMPENDIUM.Create"),
			content: html,
			label: game.i18n.localize("COMPENDIUM.Create"),
			callback: html => {
					const form = html.querySelector("#compendium-create");
					const fd = new FormDataExtended(form);
					const data = fd.toObject();
					if ( !data.label ) {
						const err = new Error(game.i18n.localize("COMPENDIUM.ErrorRequireTitle"));
						return ui.notifications.warn(err.message);
					}
					Compendium.create(data).then(() => this.render());
				},
			options: { jQuery: false }
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a Compendium Pack deletion request
	 * @param {Object} pack   The pack object requested for deletion
	 * @private
	 */
	_onDeleteCompendium(pack) {
		return Dialog.confirm({
			title: `${game.i18n.localize("COMPENDIUM.Delete")}: ${pack.metadata.label}`,
			content: game.i18n.localize("COMPENDIUM.DeleteHint"),
			yes: () => pack.delete(),
			defaultYes: false
		})
	}
}

/**
 * A directory of Item entities in the Sidebar
 * @extends {SidebarDirectory}
 */
class ItemDirectory extends SidebarDirectory {
	 /** @override */
	static get entity() {
	 return "Item";
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get collection() {
		return game.items;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_canDragStart(selector) {
		return true;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_canDragDrop(selector) {
		return game.user.can("ITEM_CREATE");
	}
	 /* -------------------------------------------- */
	 /** @override */
	_getEntryContextOptions() {
		const options = super._getEntryContextOptions();
		return [
			{
				name: "ITEM.ViewArt",
				icon: '<i class="fas fa-image"></i>',
				condition: li => {
					const item = game.items.get(li.data("entityId"));
					return item.data.img !== CONST.DEFAULT_TOKEN;
				},
				callback: li => {
					const item = game.items.get(li.data("entityId"));
					new ImagePopout(item.data.img, {
						title: item.name,
						shareable: true,
						uuid: item.uuid
					}).render(true);
				}
			}
		].concat(options);
	}
}
	/**
 * A directory list of JournalEntry entities in the Sidebar
 * @extends {SidebarDirectory}
 */
class JournalDirectory extends SidebarDirectory {
	 /** @override */
	static get defaultOptions() {
	 const options = super.defaultOptions;
	 options.id = "journal";
	 options.template = "templates/sidebar/journal-directory.html";
	 return options;
	}
	/* -------------------------------------------- */
	 /** @override */
	get title() {
		return game.i18n.localize("JOURNAL.Title");
	}
	/* -------------------------------------------- */
	 /** @override */
	static get entity() {
	 return "JournalEntry";
	}
	/* -------------------------------------------- */
	 /** @override */
	static get collection() {
		return game.journal;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_getEntryContextOptions() {
		const options = super._getEntryContextOptions();
		return options.concat([
			{
				name: "SIDEBAR.JumpPin",
				icon: '<i class="fas fa-crosshairs"></i>',
				condition: li => {
					const entry = game.journal.get(li.data("entity-id"));
					return !!entry.sceneNote;
				},
				callback: li => {
					const entry = game.journal.get(li.data("entity-id"));
					entry.panToNote();
				}
			}
		]);
	}
}
	/**
 * A directory list of Macro entities. Unlike other directories, this app is only rendered in pop-out mode.
 * @extends {SidebarDirectory}
 *
 * @see {@link Macros}        The EntityCollection of Macro Entities
 * @see {@link Macro}         The Macro Entity
 * @see {@link MacroConfig}   The Macro Configuration Sheet
 */
class MacroDirectory extends SidebarDirectory {
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 id: "macros",
			template: "templates/sidebar/macro-directory.html",
			canDrag: true,
			height: 680
		});
	}
	/* -------------------------------------------- */
	 /** @override */
	static get entity() {
	 return "Macro";
	}
	/* -------------------------------------------- */
	 /** @override */
	static get collection() {
		return game.macros;
	}
	/* -------------------------------------------- */
	 /** @override */
	async _render(...args) {
	 if ( this._popout ) return this._popout.render(...args);
	 else return super._render(...args);
	}
	/* -------------------------------------------- */
	 /** @override */
	async _onCreate(event) {
		event.preventDefault();
		const name = game.i18n.format("ENTITY.New", {entity: game.i18n.localize("ENTITY.Macro")});
		const macro = await Macro.create({name, type: "chat", scope: "global"}, {temporary: true});
		macro.sheet.render(true);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_canDragStart(selector) {
		return true;
	}
}

/**
 * A directory listing of audio playlists
 * @extends {SidebarDirectory}
 */
class PlaylistDirectory extends SidebarDirectory {
	constructor(options) {
		super(options);
		 /**
		 * Track the playlist IDs which are currently expanded in their display
		 * @type {Set}
		 */
		this._expanded = new Set(this.playing.map(p => p._id));
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.dragDrop[0].dragSelector = ".playlist-name";
		options.renderUpdateKeys = ["name", "playing", "mode"];
		return options;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get entity() {
		return "Playlist";
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get collection() {
		return game.playlists;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return an Array of the Playlist entities which are currently playing
	 * @return {Playlist[]}
	 */
	get playing() {
		return this.entities.filter(p => p.data.playing || p.data.sounds.some(s => s.playing));
	}
	 /* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */
	 /**
	 * Prepare the data used to render the AudioList application
	 * @return {Object}
	 */
	getData() {
		 // Reduce the set of playlists to only ones that are visible
		let isGM = game.user.isGM;
		let visible = game.playlists.entities.filter(p => isGM || p.sounds.some(s => s.playing));
		let playlists = visible.map(p => duplicate(p.data));
		 // Configure display for each playlist
		for (let p of playlists) {
			p.modeIcon = this._getModeIcon(p.mode);
			p.modeTooltip = this._getModeTooltip(p.mode);
			p.disabled = p.mode === CONST.PLAYLIST_MODES.DISABLED;
			p.controlCSS = isGM && !p.disabled ? "" : "disabled";
			p.expanded = this._expanded.has(p._id);
			 // Reduce the visible sounds to those currently playing
			p.sounds = p.sounds.filter(s => s.playing || isGM).map(s => {
				s.lvolume = AudioHelper.volumeToInput(s.volume);
				s.controlCSS = isGM ? "" : "disabled";
				return s;
			});
		}
		 // Return Playlist data for rendering
		return {
			user: game.user,
			isGM: isGM,
			entities: playlists,
			playlistModifier: AudioHelper.volumeToInput(game.settings.get("core", "globalPlaylistVolume")),
			ambientModifier: AudioHelper.volumeToInput(game.settings.get("core", "globalAmbientVolume")),
			interfaceModifier: AudioHelper.volumeToInput(game.settings.get("core", "globalInterfaceVolume")),
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Given a constant playback mode, provide the FontAwesome icon used to display it
	 * @param {number} mode
	 * @return {string}
	 * @private
	 */
	_getModeIcon(mode) {
		return {
			[CONST.PLAYLIST_MODES.DISABLED]: '<i class="fas fa-ban"></i>',
			[CONST.PLAYLIST_MODES.SEQUENTIAL]: '<i class="far fa-arrow-alt-circle-right"></i>',
			[CONST.PLAYLIST_MODES.SHUFFLE]: '<i class="fas fa-random"></i>',
			[CONST.PLAYLIST_MODES.SIMULTANEOUS]: '<i class="fas fa-compress-arrows-alt"></i>',
		}[mode];
	}
	 /* -------------------------------------------- */
	 /**
	 * Given a constant playback mode, provide the string tooltip used to describe it
	 * @param {number} mode
	 * @return {string}
	 * @private
	 */
	_getModeTooltip(mode) {
		return {
			[CONST.PLAYLIST_MODES.DISABLED]: game.i18n.localize("PLAYLIST.ModeDisabled"),
			[CONST.PLAYLIST_MODES.SEQUENTIAL]: game.i18n.localize("PLAYLIST.ModeSequential"),
			[CONST.PLAYLIST_MODES.SHUFFLE]: game.i18n.localize("PLAYLIST.ModeShuffle"),
			[CONST.PLAYLIST_MODES.SIMULTANEOUS]: game.i18n.localize("PLAYLIST.ModeSimultaneous")
		}[mode];
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
		super.activateListeners(html);
		 // Global volume sliders
		html.find('.global-volume-slider').change(event => this._onGlobalVolume(event));
		 // Control Track Volume
		html.find('.sound-volume').change(event => this._onSoundVolume(event));
		 // Collapse/Expand Playlist
		html.find(".playlist-name").click(event => this._onPlaylistCollapse(event));
		 // All options below require a GM user
		if (!game.user.isGM) return;
		 // Playlist Control Events
		html.on("click", "a.sound-control", event => {
			event.preventDefault();
			let btn = event.currentTarget,
				action = btn.dataset.action;
			if (!action || btn.classList.contains("disabled")) return;
			 // Delegate to Playlist and Sound control handlers
			switch (action) {
				case "playlist-add":
					this._onPlaylistAddTrack(event);
					break;
				case "playlist-delete":
					this._onPlaylistDelete(event);
					break;
				case "playlist-edit":
					this._onPlaylistEdit(event);
					break;
				case "playlist-mode":
					this._onPlaylistToggleMode(event);
					break;
				case "playlist-play":
				case "playlist-stop":
					this._onPlaylistPlay(event, action === "playlist-play");
					break;
				case "sound-delete":
					this._onSoundDelete(event);
					break;
				case "sound-edit":
					this._onSoundEdit(event);
					break;
				case "sound-play":
				case "sound-stop":
					this._onSoundPlay(event, action === "sound-play");
					break;
				case "sound-repeat":
					this._onSoundToggleMode(event);
					break;
			}
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle global volume change for the playlist sidebar
	 * @private
	 */
	_onGlobalVolume(event) {
		event.preventDefault();
		let slider = event.currentTarget,
			volume = AudioHelper.inputToVolume(slider.value);
		game.settings.set("core", slider.name, volume);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle Playlist collapse toggle
	 * @private
	 */
	_onPlaylistCollapse(event) {
		event.preventDefault();
		let li = $(event.currentTarget).parents(".playlist"),
			expanded = this._expanded.has(li[0].dataset.entityId);
		this._collapse(li, expanded);
	}
	 /* -------------------------------------------- */
	 /**
	 * Helper method to render the expansion or collapse of playlists
	 * @param {HTMLElement} li
	 * @param {boolean} collapse
	 * @param {number} speed
	 * @private
	 */
	_collapse(li, collapse, speed = 250) {
		li = $(li);
		let playlistId = li[0].dataset.entityId,
			ol = li.children(".playlist-sounds"),
			icon = li.find(".playlist-name i.fa");
		 // Collapse the Playlist
		if (collapse) {
			ol.slideUp(speed, () => {
				li.addClass("collapsed");
				icon.removeClass("fa-angle-down").addClass("fa-angle-up");
				this._expanded.delete(playlistId);
			});
		}
		 // Expand the Playlist
		else {
			ol.slideDown(speed, () => {
				li.removeClass("collapsed");
				icon.removeClass("fa-angle-up").addClass("fa-angle-down");
				this._expanded.add(playlistId);
			});
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle Playlist edit action
	 * @private
	 */
	_onPlaylistEdit(event) {
		let li = $(event.currentTarget).parents(".playlist"),
			playlist = game.playlists.get(li[0].dataset.entityId),
			config = new PlaylistConfig(playlist);
		config.render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle Playlist deletion requests
	 * Confirm the deletion with a yes/no dialog prompt
	 * @private
	 */
	_onPlaylistDelete(event) {
		let playlistId = $(event.currentTarget).parents('.playlist').attr("data-entity-id"),
			playlist = game.playlists.get(playlistId);
		new Dialog({
			title: `Delete ${playlist.name}`,
			content: "<h3>Are you sure?</h3><p>This Playlist and its Tracks will be deleted.</p>",
			buttons: {
				yes: {
					icon: '<i class="fas fa-trash"></i>',
					label: "Delete",
					callback: () => {
						playlist.stopAll();
						playlist.delete();
					}
				},
				no: {
					icon: '<i class="fas fa-times"></i>',
					label: "Cancel"
				}
			},
			default: 'yes'
		}).render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle Playlist track addition request
	 * @private
	 */
	_onPlaylistAddTrack(event) {
		const li = $(event.currentTarget).parents('.playlist');
		const playlist = game.playlists.get(li.data("entityId"));
		new PlaylistSoundConfig(playlist, {}, {top: li[0].offsetTop - 30, left: window.innerWidth - 670}).render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle Playlist playback state changes
	 * @private
	 */
	_onPlaylistPlay(event, playing) {
		 // Get the target playlist
		const playlistId = event.currentTarget.closest(".playlist").dataset.entityId;
		const playlist = game.playlists.get(playlistId);
		 // Play or stop the playlist
		if (playing) {
			this._expanded.add(playlistId);
			playlist.playAll();
		} else {
			this._expanded.delete(playlistId);
			playlist.stopAll();
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle cycling the playback mode for a Playlist
	 * @param {Event} event   The initial click event
	 * @private
	 */
	_onPlaylistToggleMode(event) {
		const li = event.currentTarget.closest(".playlist");
		const playlist = game.playlists.get(li.dataset.entityId);
		playlist.cycleMode();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle editing a Sound within a PLaylist
	 * @param {Event} event   The initial click event
	 * @private
	 */
	_onSoundEdit(event) {
		const li = event.currentTarget.closest(".sound");
		const ol = li.closest(".playlist");
		const playlist = game.playlists.get(ol.dataset.entityId);
		const sound = playlist.getEmbeddedEntity("PlaylistSound", li.dataset.soundId);
		new PlaylistSoundConfig(playlist, sound, {top: li.offsetTop - 30, left: window.innerWidth - 670}).render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Modify the playback state of a Sound within a Playlist
	 * @param {Event} event   The initial click event
	 * @private
	 */
	_onSoundPlay(event, playing) {
		const li = event.currentTarget.closest(".sound");
		const ol = li.closest(".playlist");
		const playlist = game.playlists.get(ol.dataset.entityId);
		playlist.updateEmbeddedEntity("PlaylistSound", {_id: li.dataset.soundId, playing: playing});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle volume adjustments to sounds within a Playlist
	 * @param {Event} event   The initial change event
	 * @private
	 */
	_onSoundVolume(event) {
		event.preventDefault();
		const slider = event.currentTarget;
		const li = slider.closest(".sound");
		const ol = li.closest(".playlist");
		const playlist = game.playlists.get(ol.dataset.entityId);
		 // Only push the update if the user is a GM
		const volume = AudioHelper.inputToVolume(slider.value);
		if (game.user.isGM) playlist.updateEmbeddedEntity("PlaylistSound", {_id: li.dataset.soundId, volume: volume});
		 // Otherwise simply apply a local override
		else {
			let sound = playlist.audio[li.dataset.soundId];
			if (!sound.howl) return;
			sound.howl.volume(volume, sound._id);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle changes to the sound playback mode
	 * @param {Event} event   The initial click event
	 * @private
	 */
	_onSoundToggleMode(event) {
		event.preventDefault();
		const btn = event.currentTarget;
		const playlistId = btn.closest(".playlist").dataset.entityId;
		const soundId = btn.closest(".sound").dataset.soundId;
		const playlist = game.playlists.get(playlistId);
		playlist.updateEmbeddedEntity("PlaylistSound", {_id: soundId, repeat: btn.classList.contains("inactive")});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle Playlist track deletion request
	 * @private
	 */
	_onSoundDelete(event) {
		const li = event.currentTarget.closest(".sound");
		const ol = li.closest(".playlist");
		const playlist = game.playlists.get(ol.dataset.entityId);
		const sound = playlist.getEmbeddedEntity("PlaylistSound", li.dataset.soundId);
		 // Render a confirmation dialog
		new Dialog({
			title: `Delete Sound: ${sound.name}`,
			content: `<p class="notes">This Sound will be deleted from ${playlist.name}.</p>`,
			buttons: {
				yes: {
					icon: '<i class="fas fa-trash"></i>',
					label: "Delete",
					callback: () => playlist.deleteEmbeddedEntity("PlaylistSound", sound._id)
				},
				no: {
					icon: '<i class="fas fa-times"></i>',
					label: "Cancel"
				}
			},
			default: 'yes'
		}).render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle right click context-menu options on a Playlist or a Sound
	 * @private
	 */
	_contextMenu(html) {
		const entryOptions = this._getSoundContextOptions();
		Hooks.call(`get${this.constructor.name}SoundContext`, html, entryOptions);
		new ContextMenu(html, ".playlist .sound", entryOptions);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get context menu options for individual sound effects
	 * @return {Object}   The context options for each sound
	 * @private
	 */
	_getSoundContextOptions() {
		return [
			{
				name: "PLAYLIST.SoundPreload",
				icon: '<i class="fas fa-download"></i>',
				callback: h => {
					const soundId = h.data("sound-id");
					const playlist = game.playlists.get(h.parents('.playlist').data("entity-id"));
					const sound = playlist.getEmbeddedEntity("PlaylistSound", soundId);
					game.audio.preload(sound);
				}
			}
		];
	}
}
/**
 * A directory listing of active game scenes
 * @extends {SidebarDirectory}
 */
class SceneDirectory extends SidebarDirectory {
	 /** @override */
	static get entity() {
	 return "Scene";
	}
	/* -------------------------------------------- */
	 /** @override */
	static get collection() {
		return game.scenes;
	}
	 /* -------------------------------------------- */
	 /** @override */
	async _onCreate(event) {
		const noneActive = !game.scenes.active;
		const cls = this.constructor.cls;
		const createData = {
			name: game.i18n.localize(cls.config.label),
			active: noneActive,
			navigation: true,
			folder: event.currentTarget.dataset.folder
		};
		const scene = await Scene.create(createData, {renderSheet: true});
		if ( noneActive ) canvas.draw();
		return scene;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_getEntryContextOptions() {
		let options = super._getEntryContextOptions();
		options = [
			{
				name: "SCENES.View",
				icon: '<i class="fas fa-eye"></i>',
				condition: li => !canvas.ready || (li.data("entityId") !== canvas.scene._id),
				callback: li => {
					const scene = game.scenes.get(li.data("entityId"));
					scene.view();
				}
			},
			{
				name: "SCENES.Activate",
				icon: '<i class="fas fa-bullseye"></i>',
				condition: li => game.user.isGM && !game.scenes.get(li.data("entityId")).data.active,
				callback: li => {
					const scene = game.scenes.get(li.data("entityId"));
					scene.activate();
				}
			},
			{
				name: "SCENES.Configure",
				icon: '<i class="fas fa-cogs"></i>',
				callback: li => {
					const scene = game.scenes.get(li.data("entityId"));
					scene.sheet.render(true);
				}
			},
			{
				name: "SCENES.Notes",
				icon: '<i class="fas fa-scroll"></i>',
				condition: li => {
					const scene = game.scenes.get(li.data("entityId"));
					return !!scene.journal;
				},
				callback: li => {
					const scene = game.scenes.get(li.data("entityId"));
					const entry = scene.journal;
					if ( entry ) {
						const sheet = entry.sheet;
						sheet.options.sheetMode = "text";
						sheet.render(true);
					}
				}
			},
			{
				name: "SCENES.ToggleNav",
				icon: '<i class="fas fa-compass"></i>',
				condition: li => {
					const scene = game.scenes.get(li.data("entityId"));
					return game.user.isGM && ( !scene.data.active );
				},
				callback: li => {
					const scene = game.scenes.get(li.data("entityId"));
					scene.update({navigation: !scene.data.navigation});
				}
			},
			{
				name: "SCENES.GenerateThumb",
				icon: '<i class="fas fa-image"></i>',
				condition: li => {
					const scene = game.scenes.get(li[0].dataset.entityId);
					return !!scene.data.img || scene.data.tiles.length;
				},
				callback: li => {
					const scene = game.scenes.get(li[0].dataset.entityId);
					scene.createThumbnail().then(data => {
						scene.update({thumb: data.thumb});
						ui.notifications.info(`Regenerated thumbnail image for ${scene.name} background image`);
					});
				}
			}
		].concat(options);
		 // Remove the permissions entry
		let idx = options.findIndex(o => o.name === "PERMISSION.Configure");
		options.splice(idx, 1);
		return options;
	}
}

/**
 * A SidebarTab for providing help messages and settings configurations.
 * The Settings sidebar is the furthest-to-right using a triple-cogs icon.
 * @extends {SidebarTab}
 */
class Settings extends SidebarTab {
	 /** @override */
	static get defaultOptions() {
	 const options = super.defaultOptions;
	 options.id = "settings";
	 options.template = "templates/sidebar/settings.html";
	 options.title = "Settings";
	 return options;
	}
	/* -------------------------------------------- */
	 /** @override */
	getData(options) {
		const canUpdate = game.user.isGM && game.data.coreUpdate;
		return {
			user: game.user,
			system: game.system,
			coreVersion: game.data.version,
			canConfigure: game.user.can("SETTINGS_MODIFY"),
			canSetup: game.user.hasRole("GAMEMASTER"),
			coreUpdate: canUpdate ? game.i18n.format("SETUP.UpdateAvailable", game.data.coreUpdate) : false,
			modules: game.data.modules.reduce((n, m) => n + (m.active ? 1 : 0), 0)
		};
	}
	/* -------------------------------------------- */
	 /** @override */
	activateListeners(html) {
	 html.find("button[data-action]").click(this._onSettingsButton.bind(this));
	}
	 /* -------------------------------------------- */
	 /**
	 * Delegate different actions for different settings buttons
	 * @param event
	 * @private
	 */
	_onSettingsButton(event) {
		event.preventDefault();
		const button = event.currentTarget;
		switch (button.dataset.action) {
			case "configure":
				game.settings.sheet.render(true);
				break;
			case "modules":
				new ModuleManagement().render(true);
				break;
			case "players":
				return ui.menu.items.players.onClick();
			case "setup":
				return game.shutDown();
			case "controls":
				new ControlsReference().render(true);
				break;
			case "docs":
				new FrameViewer("https://foundryvtt.com/kb", {
					title: "Foundry VTT Documentation"
				}).render(true);
				break;
			case "wiki":
				new FrameViewer("https://foundryvtt.wiki/", {
					title: "Foundry VTT Community Wiki"
				}).render(true);
				break;
			case "invitations":
				new InvitationLinks().render(true);
				break;
			case "logout":
				return ui.menu.items.logout.onClick();
		}
	}
}
	/* -------------------------------------------- */
	/**
 * A simple window application which shows the built documentation pages within an iframe
 * @type {Application}
 */
class FrameViewer extends Application {
	constructor(url, options) {
		super(options);
		this.url = url;
	}
	/* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
	 const options = super.defaultOptions;
		// Default positioning
	 let h = window.innerHeight * 0.9,
				w = Math.min(window.innerWidth * 0.9, 1200);
		options.height = h;
		options.width = w;
		options.top = (window.innerHeight - h) / 2;
		options.left = (window.innerWidth - w) / 2;
		options.id = "documentation";
		options.template = "templates/apps/documentation.html";
		return options;
	}
	/* -------------------------------------------- */
	 /** @override */
	async getData(options) {
		return {
			src: this.url
		};
	}
	 /* -------------------------------------------- */
	 /** @override */
	async close(options) {
		this.element.find("#docs").remove();
		return super.close(options);
	}
}

/* -------------------------------------------- */

/**
 * A directory list of RollTable entities in the Sidebar
 * @type {SidebarDirectory}
 */
class RollTableDirectory extends SidebarDirectory {
	static get defaultOptions() {
	 const options = super.defaultOptions;
	 options.id = "tables";
	 options.template = "templates/sidebar/roll-table-directory.html";
	 options.title = "Rollable Tables Directory";
	 return options;
	}
	/* -------------------------------------------- */
	 /**
	 * Reference named Entity class which this directory lists
	 * @return {string}
	 */
	static get entity() {
	 return "RollTable";
	}
	/* -------------------------------------------- */
	 /**
	 * Reference the EntityCollection of Entity instances which this directory lists
	 * @return {RollTables}
	 */
	static get collection() {
		return game.tables;
	}
}
	/**
 * An iterable container of Entity objects within the Foundry Virtual Tabletop framework.
 * Each Entity type has it's own subclass of EntityCollection, which defines the abstract interface.
 * @abstract
 * @interface
 * @extends {Collection}
 *
 * @param {object[]} data      An Array of Entity data from which to create instances
 */
class EntityCollection extends Collection {
	constructor(data) {
		super();
		 /**
		 * The source data is, itself, a mapping of IDs to data objects
		 * @type {object[]}
		 */
		this._source = data;
		 /**
		 * An Array of application references which will be automatically updated when the collection content changes
		 * @type {Application[]}
		 */
		this.apps = [];
		 // Initialize data
		this._initialize(data);
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize the Map object and all its contained entities
	 * @param {Entity[]} data
	 * @private
	 */
	_initialize(data) {
		this.clear();
		for ( let d of data ) {
			this.set(d._id, new this.object(d));
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * An array of all the Entities in the EntityCollection.
	 * @alias {Collection#entries}
	 * @return {Entity[]}
	 */
	get entities() {
		return this.entries;
	}
	 /* -------------------------------------------- */
	 /**
	 * Render any Applications associated with this EntityCollection
	 * @return {this}     A reference to the rendered EntityCollection
	 */
	render(...args) {
		for (let a of this.apps) a.render(...args);
		return this;
	}
	 /* -------------------------------------------- */
	/*  EntityCollection Properties                       */
	/* -------------------------------------------- */
	 /**
	 * The EntityCollection name
	 * @type {string}
	 */
	get name() {
		return this.constructor.name;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a reference to the SidebarDirectory application for this EntityCollection, or null if it has not yet been created.
	 * @type {SidebarDirectory|null}
	 */
	get directory() {
		return ui[this.name.toLowerCase()] || null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a reference to the base Entity name which is contained within this EntityCollection.
	 * @type {string}
	 * @abstract
	 */
	get entity() {
		throw new Error("An EntityCollection subclass must define the entity property.");
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a reference to the singleton instance of this EntityCollection, or null if it has not yet been created.
	 * @type {EntityCollection|null}
	 */
	static get instance() {
		return game[this.name.toLowerCase()] || null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a reference to the Entity subclass which should be used when creating elements of this EntityCollection.
	 * This should always be an explicit reference to the class which is used in this game to represent the entity,
	 * and not the base implementation of that entity type.
	 * @type {Entity}
	 */
	get object() {
		return CONFIG[this.entity].entityClass;
	}
	 /* -------------------------------------------- */
	/*  EntityCollection Management Methods         */
	/* -------------------------------------------- */
	 /**
	 * Add a new Entity to the EntityCollection, asserting that they are of the correct type.
	 * @param entity {Entity}   The entity instance to add to the collection
	 */
	insert(entity) {
		if (!(entity instanceof this.object)) {
			throw new Error(`You may only push instances of ${this.entity} to the ${this.name} collection`);
		}
		this._source.push(entity.data);
		this.set(entity.id, entity);
	}
	 /* -------------------------------------------- */
	 /**
	 * Remove an Entity from the EntityCollection by its ID.
	 * @param id {string}   The entity ID which should be removed
	 */
	remove(id) {
		this._source.findSplice(e => e._id === id);
		this.delete(id);
	}
	 /* -------------------------------------------- */
	 /**
	 * Import an Entity from a compendium collection, adding it to the current World.
	 * @param {string} collection     The name of the pack from which to import
	 * @param {string} entryId        The ID of the compendium entry to import
	 * @param {Object} [updateData]   Optional additional data used to modify the imported Entity before it is created
	 * @param {Object} [options]      Optional arguments passed to the Entity.create method
	 * @return {Promise.<Entity>}     A Promise containing the imported Entity
	 */
	async importFromCollection(collection, entryId, updateData={}, options={}) {
		const entName = this.object.entity;
		const pack = game.packs.get(collection);
		if (pack.metadata.entity !== entName) return;
		 // Prepare the source data from which to create the Entity
		const source = await pack.getEntity(entryId);
		const createData = mergeObject(this.fromCompendium(source.data), updateData);
		delete createData._id;
		 // Create the Entity
		console.log(`${vtt} | Importing ${entName} ${source.name} from ${collection}`);
		this.directory.activate();
		return await this.object.create(createData, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Apply data transformations when importing an Entity from a Compendium pack
	 * @param {Object} data           The original Compendium entry data
	 * @return {Object}               The processed data ready for Entity creation
	 */
	fromCompendium(data) {
		const nullKeys = ["_id", "folder", "sort"];
		for ( let k of nullKeys ) {
			data[k] = null;
		}
		data.permissions = {[game.user._id]: ENTITY_PERMISSIONS.OWNER};
		return data;
	}
	 /* -------------------------------------------- */
	 /**
	 * Update all objects in this EntityCollection with a provided transformation.
	 * Conditionally filter to only apply to Entities which match a certain condition.
	 * @param {Function|object} transformation    An object of data or function to apply to all matched objects
	 * @param {Function|null}  condition          A function which tests whether to target each object
	 * @param {object} [options]                  Additional options passed to Entity.update
	 * @return {Promise<Data[]>}                  An array of updated data once the operation is complete
	 */
	async updateAll(transformation, condition=null, options={}) {
		const hasTransformer = transformation instanceof Function;
		if ( !hasTransformer && (getType(transformation) !== "Object") ) {
			throw new Error("You must provide a data object or transformation function");
		}
		const hasCondition = condition instanceof Function;
		const updates = this.reduce((arr, obj) => {
			if ( hasCondition && !condition(obj) ) return arr;
			const update = hasTransformer ? transformation(obj) : duplicate(transformation);
			update._id = obj.id;
			arr.push(update);
			return arr;
		},[]);
		return this.object.update(updates, options);
	}
}

/**
 * The Compendium class provides an interface for interacting with compendium packs which are 
 * collections of similar Entities which are stored outside of the world database but able to
 * be easily imported into an active session.
 * 
 * When the game session is initialized, each available compendium pack is constructed and 
 * added to the ``game.packs``.
 *
 * Each Compendium is distinctly referenced using its canonical "collection" name which is a 
 * unique string that contains the package name which provides the compendium as well as the
 * name of the pack within that package. For example, in the DnD5e system, the compendium pack
 * which provides the spells available within the SRD has the collection name "dnd5e.spells".
 *
 * @type {Application}
 *
 * @param metadata {Object}   The compendium metadata, an object provided by game.data
 * @param options {Object}    Application rendering options
 *
 * @example
 * // Let's learn the collection names of all the compendium packs available within a game
 * game.packs.keys();
 *
 * // Suppose we are working with a particular pack named "dnd5e.spells"
 * const pack = game.packs.get("dnd5e.spells");
 * 
 * // We can load the index of the pack which contains all entity IDs, names, and image icons
 * pack.getIndex().then(index => console.log(index));
 * 
 * // We can find a specific entry in the compendium by its name
 * let entry = pack.index.find(e => e.name === "Acid Splash");
 * 
 * // Given the entity ID of "Acid Splash" we can load the full Entity from the compendium
 * pack.getEntity(entry.id).then(spell => console.log(spell));
 * 
 * @example
 * // We often may want to programmatically create new Compendium content
 * // Let's start by creating a custom spell as an Item instance
 * let itemData = {name: "Custom Death Ray", type: "Spell"};
 * let item = new Item(itemData);
 * 
 * // Once we have an entity for our new Compendium entry we can import it, if the pack is unlocked
 * pack.importEntity(item);
 * 
 * // When the entity is imported into the compendium it will be assigned a new ID, so let's find it
 * pack.getIndex().then(index => {
 *   let entry = index.find(e => e.name === itemData.name));
 *   console.log(entry);
 * });
 *
 * // If we decide to remove an entry from the compendium we can do that by the entry ID
 * pack.removeEntry(entry.id);
 */
class Compendium extends Application {
	constructor(metadata, options) {
		super(options);
		 /**
		 * The compendium metadata which defines the compendium content and location
		 * @type {Object}
		 */
		this.metadata = metadata;
		 /**
		 * Track whether the compendium pack is locked for editing
		 * @type {boolean}
		 */
		this.locked = metadata.package !== "world";
		 /**
		 * Track whether the compendium pack is private
		 * @type {boolean}
		 */
		this.private = false;
		 /**
		 * The most recently retrieved index of the Compendium content
		 * This index is not guaranteed to be current - call getIndex() to reload the index
		 * @type {object[]}
		 */
		this.index = [];
	}
	/* -------------------------------------------- */
	 /** @override */
	static get defaultOptions() {
	 return mergeObject(super.defaultOptions, {
		 template: "templates/apps/compendium.html",
			width: 350,
			height: window.innerHeight - 100,
			top: 70,
			left: 120,
			scrollY: [".directory-list"],
			dragDrop: [{ dragSelector: ".directory-item", dropSelector: ".directory-list" }],
			filters: [{inputSelector: 'input[name="search"]', contentSelector: ".directory-list"}]
		});
	}
	 /* ----------------------------------------- */
	 /** @override */
	get title() {
		return [this.metadata.label, this.locked ? "[Locked]" : null].filterJoin(" ");
	}
	 /* ----------------------------------------- */
	 /**
	 * The canonical Compendium name - comprised of the originating package and the pack name
	 * @return {string}     The canonical collection name
	 */
	get collection() {
		return `${this.metadata.package}.${this.metadata.name}`
	}
	 /* ----------------------------------------- */
	 /**
	 * The Entity type which is allowed to be stored in this collection
	 * @type {string}
	 */
	get entity() {
		return this.metadata.entity;
	}
	 /* ----------------------------------------- */
	 /**
	 * A reference to the Entity class object contained within this Compendium pack
	 * @return {*}
	 */
	get cls() {
		return CONFIG[this.entity].entityClass;
	}
	 /* ----------------------------------------- */
	/*  Rendering                                */
	/* ----------------------------------------- */
	 /** @override */
	async getData(options) {
		await this.getIndex();
		return {
			collection: this.collection,
			cssClass: this.entity.toLowerCase(),
			index: this.index.map(i => {
				i.img = i.img || CONST.DEFAULT_TOKEN;
				return i;
			})
		};
	}
	 /* -------------------------------------------- */
	 /** @override */
	async close(options) {
		await super.close(options);
		let li = $(`.compendium-pack[data-pack="${this.collection}"]`);
		li.attr("data-open", "0");
		li.find("i.folder").removeClass("fa-folder-open").addClass("fa-folder");
	}
	 /* ----------------------------------------- */
	/*  Methods
	/* ----------------------------------------- */
	 /**
	 * Create a new Compendium pack using provided
	 * @param {Object} metadata   The compendium metadata used to create the new pack
	 * @param {Options} options   Additional options which modify the Compendium creation request
	 * @return {Promise.<Compendium>}
	 */
	static async create(metadata, options={}) {
		if ( !game.user.isGM ) return ui.notifications.error("You do not have permission to modify this compendium pack");
		const response = await SocketInterface.dispatch("manageCompendium", {
			action: "create",
			data: metadata,
			options: options
		});
		 // Add the new pack to the World
		game.data.packs.push(response.result);
		game.initializePacks().then(() => ui.compendium.render());
		return new Compendium(response.result);
	}
	 /* ----------------------------------------- */
	 /**
	 * Assign configuration metadata settings to the compendium pack
	 * @param {Object} settings   The object of compendium settings to define
	 * @return {Promise}          A Promise which resolves once the setting is updated
	 */
	configure(settings={}) {
		this._assertUserCanModify({requireUnlocked: false});
		const config = game.settings.get("core", this.constructor.CONFIG_SETTING);
		const pack = config[this.collection] || {private: false, locked: this.metadata.package !== "world"};
		config[this.collection] = mergeObject(pack, settings);
		return game.settings.set("core", this.constructor.CONFIG_SETTING, config);
	}
	 /* ----------------------------------------- */
	 /**
	 * Delete a world Compendium pack
	 * This is only allowed for world-level packs by a GM user
	 * @return {Promise.<Compendium>}
	 */
	async delete() {
		this._assertUserCanModify();
		await SocketInterface.dispatch("manageCompendium", {
			action: "delete",
			data: this.metadata.name
		});
		 // Remove the pack from the game World
		game.data.packs.findSplice(p => (p.package === "world") && (p.name === this.metadata.name) );
		game.initializePacks().then(() => ui.compendium.render());
		return this;
	}
	 /* ----------------------------------------- */
	 /**
	 * Duplicate a compendium pack to the current World
	 * @param label
	 * @return {Promise<Compendium>}
	 */
	async duplicate({label}={}) {
		this._assertUserCanModify({requireUnlocked: false});
		label = label || this.metadata.label;
		const metadata = mergeObject(this.metadata, {
			name: label.slugify({strict: true}),
			label: label
		}, {inplace: false});
		return this.constructor.create(metadata, {source: this.collection});
	}
	 /* ----------------------------------------- */
	 /**
	 * Get the Compendium index
	 * Contains names and IDs of all data in the compendium
	 *
	 * @return {Promise}    A Promise containing an index of all compendium entries
	 */
	async getIndex() {
		const response = await SocketInterface.dispatch("modifyCompendium", {
			type: this.collection,
			action: "get",
			data: {},
			options: {returnType: "index"}
		});
		return this.index = response.result;
	}
	 /* ----------------------------------------- */
	 /**
	 * Get the complete set of content for this compendium, loading all entries in full
	 * Returns a Promise that resolves to an Array of entries
	 *
	 * @return {Promise.<Array>}
	 */
	async getContent() {
		const response = await SocketInterface.dispatch("modifyCompendium", {
			type: this.collection,
			action: "get",
			data: {},
			options: {returnType: "content"}
		});
		return response.result.map(entry => this._toEntity(entry));
	}
	 /* ----------------------------------------- */
	 /**
	 * Get a single Compendium entry as an Object
	 * @param {string} entryId          The compendium entry ID to retrieve
	 * @return {Promise.<Object|null>}  A Promise containing the return entry data, or null
	 */
	async getEntry(entryId) {
		const response = await SocketInterface.dispatch("modifyCompendium", {
			type: this.collection,
			action: "get",
			data: {_id: entryId},
			options: {returnType: "entry"}
		});
		return response.result[0];
	}
	 /* ----------------------------------------- */
	 /**
	 * Get a single Compendium entry as an Entity instance
	 * @param {string} entryId          The compendium entry ID to load and instantiate
	 * @return {Promise.<Entity|null>}   A Promise containing the returned Entity, if it exists, otherwise null
	 */
	async getEntity(entryId) {
		const entry = await this.getEntry(entryId);
		return entry ? this._toEntity(entry) : null;
	}
	 /* ----------------------------------------- */
	 /**
	 * Fully import the contents of a Compendium pack into a World folder.
	 * @param {string|null} [folderId]  An existing Folder _id to use.
	 * @param {string} [folderName]     A new Folder name to create.
	 * @return {Promise<*>}
	 */
	async importAll({folderId=null, folderName=""}={}) {
		 // Step 1 - optionally, create a folder
		if ( FOLDER_ENTITY_TYPES.includes(this.entity) ) {
			const f = folderId ? game.folders.get(folderId, {strict: true}) : await Folder.create({
				name: folderName || this.metadata.label,
				type: this.entity,
				parent: null
			});
			folderId = f.id;
			folderName = f.name;
		}
		 // Step 2 - load all content
		const entities = await this.getContent();
		ui.notifications.info(game.i18n.format("COMPENDIUM.ImportAllStart", {
			number: entities.length,
			type: this.entity,
			folder: folderName
		}));
		 // Step 3 - import all content
		const created = await this.cls.create(entities.map(e => {
			e.data.folder = folderId;
			return e.data;
		}));
		ui.notifications.info(game.i18n.format("COMPENDIUM.ImportAllFinish", {
			number: created.length,
			type: this.entity,
			folder: folderName
		}));
		return created;
	}
	 /* ----------------------------------------- */
	 /**
	 * Cast entry data to an Entity class
	 * @param {Object} entryData
	 * @private
	 */
	_toEntity(entryData={}) {
		return new this.cls(entryData, {compendium: this});
	}
	 /* ----------------------------------------- */
	 /**
	 * Import a new Entity into a Compendium pack
	 * @param {Entity} entity     The Entity instance you wish to import
	 * @return {Promise}          A Promise which resolves to the created Entity once the operation is complete
	 */
	async importEntity(entity) {
		if ( entity.entity !== this.entity ) {
			let err = "You are attempting to import the wrong type of entity into this pack";
			ui.notifications.error(err);
			throw new Error(err);
		}
		 // Get the data to import
		const data = await entity.toCompendium();
		return this.createEntity(data);
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a new Entity within this Compendium Pack using provided data
	 * @param {Object} data       Data with which to create the entry
	 * @param {Options} options   Additional options which modify the creation
	 * @return {Promise}          A Promise which resolves to the created Entity once the operation is complete
	 */
	async createEntity(data, options={}) {
		this._assertUserCanModify();
		data = data instanceof Array ? data : [data];
		 // Dispatch the Socket request
		const response = await SocketInterface.dispatch("modifyCompendium", {
			action: "create",
			type: this.collection,
			data: data,
			options: options
		});
		this.render(false);
		 // Return the created entities
		const results = response.result.map(r => this._toEntity(r));
		return data.length > 1 ? results : results[0];
	}
	 /* -------------------------------------------- */
	 /**
	 * Update a single Compendium entry programmatically by providing new data with which to update
	 * @param {Object} data       The incremental update with which to update the Entity. Must contain the _id
	 * @param {Object} options    Additional options which modify the update request
	 * @return {Promise}          A Promise which resolves with the updated Entity once the operation is complete
	 */
	async updateEntity(data, options={}) {
		this._assertUserCanModify();
		if ( !data._id ) throw new Error("You must specify the _id attribute for the data you wish to update");
		 // Reference an existing Entity which is already rendered
		const entity = options["entity"] || null;
		delete options.entity;
		 // Prepare data for update
		data = data instanceof Array ? data : [data];
		const updates = data.reduce((arr, d) => {
			if ( !d._id ) throw new Error(`You must provide an _id for every Compendium entry in the data Array.`);
			d = expandObject(d);
			arr.push(d);
			return arr;
		}, []);
		if ( !updates.length ) return [];
		 // Dispatch the Socket request
		const response = await SocketInterface.dispatch("modifyCompendium", {
			action: "update",
			type: this.collection,
			data: updates,
			options: options
		});
		 // Render updates
		this.render(false);
		if ( entity ) {
			const update = response.result.find(r => r._id === entity.id);
			mergeObject(entity.data, update);
			entity._onUpdate(update, options, response.userId);
		}
		 // Return the update entities
		return response.result;
	}
	 /* ----------------------------------------- */
	 /**
	 * Delete a single Compendium entry by its provided _id
	 * @param {string} id         The entry ID to delete
	 * @param {Object} options    Additional options which modify the deletion request
	 * @return {Promise}          A Promise which resolves to the deleted entry ID once the operation is complete
	 */
	async deleteEntity(id, options={}) {
		this._assertUserCanModify();
		const ids = id instanceof Array ? id : [id];
		const response = await SocketInterface.dispatch("modifyCompendium", {
			action: "delete",
			type: this.collection,
			data: ids,
			options: options
		});
		this.render(false);
		return response.result;
	}
	 /* -------------------------------------------- */
	 /**
	 * Request that a Compendium pack be migrated to the latest System data template
	 * @return {Promise.<Compendium>}
	 */
	async migrate(options) {
		this._assertUserCanModify();
		ui.notifications.info(`Beginning migration for Compendium pack ${this.collection}, please be patient.`);
		const response = await SocketInterface.dispatch("manageCompendium", {
			type: this.collection,
			action: "migrate",
			data: this.collection,
			options: options
		});
		ui.notifications.info(`Successfully migrated Compendium pack ${this.collection}.`);
		return response;
	}
	 /* ----------------------------------------- */
	 /**
	 * Validate that the current user is able to modify content of this Compendium pack
	 * @return {boolean}
	 * @private
	 */
	_assertUserCanModify({requireGM=true, requireUnlocked=true}={}) {
		let err = null;
		if ( requireGM && !game.user.isGM ) err = new Error("You do not have permission to modify this compendium pack");
		if ( this.locked && requireUnlocked ) {
			err = new Error(`You cannot modify content in this compendium pack because it is locked.`);
		}
		if ( err ) {
			ui.notifications.error(err.message);
			throw err;
		}
		return true;
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /**
	 * Register event listeners for Compendium directories
	 * @private
	 */
	activateListeners(html) {
		super.activateListeners(html);
		const directory = html.find('.directory-list');
		const entries = directory.find('.directory-item');
		 // Open sheets
		html.find('.entry-name').click(ev => {
			let li = ev.currentTarget.parentElement;
			this._onEntry(li.dataset.entryId);
		});
		 // Context menu for each entry
		this._contextMenu(html);
		 // Intersection Observer for Compendium avatars
		const observer = new IntersectionObserver(SidebarTab.prototype._onLazyLoadImage.bind(this), {root: directory[0]});
		entries.each((i, li) => observer.observe(li));
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onSearchFilter(event, query, html) {
		const rgx = new RegExp(RegExp.escape(query), "i");
		for (let li of html.children) {
			const name = li.querySelector(".entry-name").textContent;
			li.style.display = rgx.test(name) ? "flex" : "none";
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle opening a single compendium entry by invoking the configured entity class and its sheet
	 * @param {string} entryId      The compendium ID of the entry to display
	 * @private
	 */
	async _onEntry(entryId) {
		const entity = await this.getEntity(entryId);
		let sheet = entity.sheet;
		sheet = Object.values(ui.windows).find(app => app.id === sheet.id) ?? sheet;
		if ( sheet._minimized ) return sheet.maximize();
		sheet.render(true);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_canDragStart(selector) {
		if ( this.cls.entity === "Item" ) return true;
		return this.cls.can(game.user, "create");
	}
	 /* -------------------------------------------- */
	 /** @override */
	_canDragDrop(selector) {
		return game.user.isGM;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragStart(event) {
		 // Get the Compendium pack
		const li = event.currentTarget;
		const packName = li.parentElement.parentElement.getAttribute("data-pack");
		const pack = game.packs.get(packName);
		if ( !pack ) return;
		 // Set the transfer data
		event.dataTransfer.setData("text/plain", JSON.stringify({
			type: pack.entity,
			pack: pack.collection,
			id: li.dataset.entryId
		}));
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle data being dropped into a Compendium pack
	 * @private
	 */
	async _onDrop(event) {
		 // Try to extract the data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData('text/plain'));
		}
		catch (err) {
			return false;
		}
		 // Ensure an entity type was indicated
		if ( !data.type ) throw new Error("You must define the type of entity data being dropped");
		if ( data.pack === this.collection ) return false;
		 // Get the dropped Entity
		const entity = await this.cls.fromDropData(data);
		 // Import the Entity as a new Compendium entry
		return this.importEntity(entity);
	}
	 /* -------------------------------------------- */
	 /**
	 * Render the ContextMenu which applies to each compendium entry
	 * @private
	 */
	_contextMenu(html) {
		new ContextMenu(html, ".directory-item", [
			{
				name: "COMPENDIUM.ImportEntry",
				icon: '<i class="fas fa-download"></i>',
				callback: li => {
					const entryId = li.attr('data-entry-id');
					const entities = this.cls.collection;
					return entities.importFromCollection(this.collection, entryId, {}, {renderSheet: true});
				}
			},
			{
				name: "COMPENDIUM.DeleteEntry",
				icon: '<i class="fas fa-trash"></i>',
				callback: li => {
					let entryId = li.attr('data-entry-id');
					this.getEntity(entryId).then(entry => {
						return Dialog.confirm({
							title: `${game.i18n.localize("COMPENDIUM.DeleteEntry")} ${entry.name}`,
							content: game.i18n.localize("COMPENDIUM.DeleteConfirm"),
							yes: () => this.deleteEntity(entryId),
						});
					});
				}
			}
		]);
	}
}

Compendium.CONFIG_SETTING = "compendiumConfiguration";
/**
 * An abstract class implementation for an EmbeddedEntity object within a parent Entity
 * @abstract
 * @interface
 */
class EmbeddedEntity {
	constructor(data, parent) {
		 /**
		 * The embedded entity data object
		 * @type {Data}
		 */
		this.data = data;
		 /**
		 * The parent Entity to which this belongs
		 * @type {Entity}
		 */
		this.parent = parent;
	}
	 /* -------------------------------------------- */
	 /**
	 * A reference to the _id attribute of the EmbeddedEntity data
	 * @type {string}
	 */
	get id() {
		return this.data._id;
	}
	 /* -------------------------------------------- */
	 /**
	 * Data preparation steps taken by the EmbeddedEntity instance when it's underlying data changes
	 */
	prepareData() {}
	 /* -------------------------------------------- */
	 /**
	 * Get the value of a "flag" for this PlaceableObject
	 * See the setFlag method for more details on flags
	 *
	 * @param {string} scope    The flag scope which namespaces the key
	 * @param {string} key      The flag key
	 * @return {*}              The flag value
	 */
	getFlag(scope, key) {
		const scopes = SetupConfiguration.getPackageScopes();
		if ( !scopes.includes(scope) ) throw new Error(`Invalid scope for flag ${key}`);
		key = `${scope}.${key}`;
		return getProperty(this.data.flags, key);
	}
	 /* -------------------------------------------- */
	 /**
	 * Assign a "flag" to this Entity.
	 * Flags represent key-value type data which can be used to store flexible or arbitrary data required by either
	 * the core software, game systems, or user-created modules.
	 *
	 * Each flag should be set using a scope which provides a namespace for the flag to help prevent collisions.
	 *
	 * Flags set by the core software use the "core" scope.
	 * Flags set by game systems or modules should use the canonical name attribute for the module
	 * Flags set by an individual world should "world" as the scope.
	 *
	 * Flag values can assume almost any data type. Setting a flag value to null will delete that flag.
	 *
	 * @param {string} scope    The flag scope which namespaces the key
	 * @param {string} key      The flag key
	 * @param {*} value         The flag value
	 *
	 * @return {Promise}        A Promise resolving to the updated PlaceableObject
	 */
	async setFlag(scope, key, value) {
		const scopes = SetupConfiguration.getPackageScopes();
		if ( !scopes.includes(scope) ) throw new Error(`Invalid scope for flag ${key}`);
		key = `flags.${scope}.${key}`;
		return this.update({[key]: value});
	}
	 /* -------------------------------------------- */
	 /**
	 * Remove a flag assigned to the Entity
	 * @param {string} scope    The flag scope which namespaces the key
	 * @param {string} key      The flag key
	 * @return {Promise}        A Promise resolving to the updated Entity
	 */
	async unsetFlag(scope, key) {
		const scopes = SetupConfiguration.getPackageScopes();
		if ( !scopes.includes(scope) ) throw new Error(`Invalid scope for flag ${key}`);
		key = `flags.${scope}.-=${key}`;
		return this.update({[key]: null});
	}
}
/**
 * An abstract class pattern for all primary data entities within the Foundry VTT Framework. An entity represents a
 * primary data concept, for example: Actor, Item, Scene, or ChatMessage. Each Entity type in Foundry Virtual
 * Tabletop extends this base Entity class which ensures similar behavior and workflow across all entity types.
 *
 * Documentation for this class is provided for reference, but developers should not extend this class directly,
 * instead work with or extend the Entity implementations that are referenced in this section of the API documentation.
 *
 * Entities are instantiated by providing their base data, and an optional Array of Application instances which should
 * be automatically refreshed when the Entity experiences an update.
 * @abstract
 * @interface
 *
 * @see {@link EntityCollection} The EntityCollection abstract class which contains Entity instances.
 * @see {@link Actor} The Actor Entity.
 * @see {@link Combat} The Combat Encounter Entity.
 * @see {@link Folder} The Folder Entity.
 * @see {@link Item} The Item Entity.
 * @see {@link JournalEntry} The Journal Entry Entity.
 * @see {@link ChatMessage} The Chat Message Entity.
 * @see {@link Playlist} The Audio Playlist Entity.
 * @see {@link Scene} The Scene Entity.
 * @see {@link RollTable} The Rollable Table Entity.
 * @see {@link User} The User Entity.
 * @see {@link Compendium} The Compendium which may contain Entities in a compendium pack.
 *
 * @param {Object} data       The data Object with which to create the Entity
 * @param {Object} options    Additional options which modify the created Entity behavior
 * @param {Compendium} [options.compendium] A reference to the Compendium pack from which this Entity was drawn.
 *
 * @example
 * let actorData = {name: "John Doe", type: "character", img: "icons/svg/mystery-man.svg"};
 * let actor = new Actor(actorData);
 */
class Entity {
	constructor(data, options) {
		 /**
		 * The original source data for the Entity provided upon initialization.
		 * This reflects the database state of the Entity before any transformations are applied.
		 * @type {Object}
		 */
		this._data = data || {};
		 /**
		 * The effective data for the Entity.
		 * This data object may have transformations applied to it.
		 * @type {Object}
		 */
		this.data = this._data;
		 /**
		 * The options object that was used to configure the Entity upon initialization.
		 * @type {Object}
		 */
		this.options = options || {};
		 /**
		 * A collection of Application instances which should be re-rendered whenever this Entity experiences an update to
		 * its data. The keys of this object are the application ids and the values are Application instances. Each
		 * Application in this object will have its render method called by {@link Entity#render}.
		 * @type {Object.<Application>}
		 * @see {Entity#render}
		 */
		this.apps = {};
		 /**
		 * The Entity may optionally belong to a parent Compendium pack. If so this attribute will contain a reference
		 * to that Compendium object. Otherwise null.
		 * @type {Compendium|null}
		 */
		this.compendium = this.options.compendium || null;
		 // Safely initialize Entity data
		this._initialize();
	}
	/* -------------------------------------------- */
	 /**
	 * Safely Initialize data structure for the Entity.
	 * Errors that occur here should be captured and logged, but should not break construction of the Entity instance.
	 */
	_initialize() {
		try {
			this.prepareData();
		} catch(err) {
			err.message = `Failed to initialize data for ${this.constructor.name} ${this.id} (${this.name}): ${err.message}}`;
			console.error(err);
		}
	}
	/* -------------------------------------------- */
	 /**
	 * Configure the attributes of this Entity class
	 * @type {Object}
	 * @property {Entity} baseEntity       The parent class which directly inherits from the Entity interface.
	 * @property {EntityCollection} collection   The EntityCollection instance to which Entities of this type belong.
	 * @property {string[]} embeddedEntities  The names of any Embedded Entities within the Entity data structure.
	 */
	static get config() {
		throw new Error(`The ${this.name} subclass must define the Entity.config object`);
		return {
			baseEntity: null,
			embeddedEntities: {},
			label: "ENTITY.Entity",
			permissions: {}
		}
	}
	/* -------------------------------------------- */
	 /**
	 * A Universally Unique Identifier (uuid) for this Entity instance
	 * @type {string}
	 */
	get uuid() {
		if ( this.compendium ) return `Compendium.${this.compendium.collection}.${this.id}`;
		return `${this.entity}.${this.id}`;
	}
	/* -------------------------------------------- */
	 /**
	 * Return a string which represents a dynamic link to this Entity.
	 * @return {string}
	 */
	get link() {
		if (this.compendium) return `@Compendium[${this.compendium.collection}.${this.id}]{${this.name}}`;
		return `@${this.entity}[${this.id}]{${this.name}}`;
	}
	/* -------------------------------------------- */
	 /**
	 * Prepare data for the Entity whenever the instance is first created or later updated.
	 * This method can be used to derive any internal attributes which are computed in a formulaic manner.
	 * For example, in a d20 system - computing an ability modifier based on the value of that ability score.
	 */
	prepareData() {
		// Prepare Entity data
		const data = this.data;
	 if ( data.hasOwnProperty("name") && !data.name ) {
		 data.name = "New " + this.entity;
		}
		// Prepare Embedded Entities
		this.prepareEmbeddedEntities();
		// Return prepared data
	 return data;
	}
	/* -------------------------------------------- */
	 /**
	 * Prepare Embedded Entities which exist within this parent Entity.
	 * For example, in the case of an Actor, this method is responsible for preparing the Owned Items the Actor contains.
	 */
	prepareEmbeddedEntities() {
	 const ee = this.constructor.config.embeddedEntities;
	 if ( ee && !isObjectEmpty(ee) ) {
			throw new Error("An Entity which includes embedded entities must define the prepareEmbeddedEntities() method");
		}
	}
	/* -------------------------------------------- */
	 /**
	 * Obtain a reference to the Array of source data within the data object for a certain Embedded Entity name
	 * @param {string} embeddedName   The name of the Embedded Entity type
	 * @return {object[]}             The Array of source data where Embedded Entities of this type are stored
	 */
	getEmbeddedCollection(embeddedName) {
		const collection = this.constructor.config.embeddedEntities[embeddedName];
		if ( !collection ) {
			throw new Error(`${embeddedName} is not a valid Embedded Entity in a ${this.constructor.name}`);
		}
		return this._data[collection];
	}
	/* -------------------------------------------- */
	 /**
	 * Render all of the Application instances which are connected to this Entity by calling their respective
	 * {@link Application#render} methods.
	 * @param {boolean} force     Force rendering
	 * @param {Options} context   Optional context
	 */
	render(force, context={}) {
		const permChange = context.data && ("permission" in context.data);
		for ( let app of Object.values(this.apps) ) {
			if ( permChange ) app.options.editable = this.owner;
			app.render(force, context);
		}
	}
	/* -------------------------------------------- */
	/*  Properties
	/* -------------------------------------------- */
	 /**
	 * Return a reference to the EntityCollection instance which stores Entity instances of this type. This property is
	 * available as both a static and instance method and should be overridden by subclass Entity implementations.
	 * @type {EntityCollection}
	 * @static
	 */
	static get collection() {
	 if ( !this.config.collection ) {
		 throw new Error(`An Entity subclass must configure the EntityCollection it belongs to.`);
		}
	 return this.config.collection;
	}
	/* -------------------------------------------- */
	 /** @alias {Entity.collection} */
	get collection() {
	 return this.constructor.collection;
	}
	/* -------------------------------------------- */
	 /**
	 * The class name of the base Entity type, for example "Actor". This is useful in cases where there is an inheritance
	 * chain. Many places throughout the framework rely upon the canonical entity name which may not always be equal
	 * to the class name. This property is available as both a static and instance method.
	 * @type {string}
	 *
	 * @example
	 * class Actor2ndGen extends Actor {...}
	 * Actor2ndGen.entity // "Actor"
	 */
	static get entity() {
	 if ( !this.config.baseEntity ) throw new Error(`An Entity subclass must configure the baseEntity it represents.`);
	 return this.config.baseEntity.name;
	}
	/* -------------------------------------------- */
	 /** @alias {Entity.entity} */
	get entity() {
	 return this.constructor.entity;
	}
	/* -------------------------------------------- */
	 /**
	 * A convenience accessor for the _id attribute of the Entity data object.
	 * @type {string}
	 */
	get id() {
	 return this.data._id;
	}
	/* -------------------------------------------- */
	 /** @alias {Entity#id} */
	get _id() {
	 return this.data._id;
	}
	/* -------------------------------------------- */
	 /**
	 * A convenience accessor for the name attribute of the Entity data object
	 * @type {string}
	 */
	get name() {
	 return this.data.name;
	}
	/* -------------------------------------------- */
	 /**
	 * A property which gets or creates a singleton instance of the sheet class used to render and edit data for this
	 * particular entity type.
	 * @type {BaseEntitySheet|null}
	 *
	 * @example <caption>A subclass of the Actor entity</caption>
	 * let actor = game.entities.actors[0];
	 * actor.sheet; // ActorSheet
	 */
	get sheet() {
	 const cls = this._sheetClass;
	 if ( !cls ) return null;
	 let sheet = Object.values(this.apps).find(app => app.constructor === cls);
	 const editable = this.owner && (!this.compendium  || !this.compendium.locked );
	 if ( !sheet ) sheet = new cls(this, {editable});
	 return sheet;
	}
	/* -------------------------------------------- */
	 /**
	 * Obtain a reference to the BaseEntitySheet implementation which should be used to render the Entity instance
	 * configuration sheet.
	 * @private
	 */
	get _sheetClass() {
		const cfg = CONFIG[this.entity];
		let cls = null;
		if ( !cfg ) return null;
		 // Case 1 - Dynamic Sheet Classes are supported
		if ( cfg.sheetClasses ) {
			const type = this.data.type || CONST.BASE_ENTITY_TYPE;
			const sheets = cfg.sheetClasses[type] || {};
			const override = this.getFlag("core", "sheetClass");
			if ( sheets[override] ) cls = sheets[override].cls;
			else {
				let classes = Object.values(sheets);
				let def = classes.find(s => s.default) || classes.pop();
				if ( def ) cls = def.cls;
			}
			if ( !cls ) throw new Error(`No valid ${this.entity} sheet found for type ${type}`);
		}
		 // Case 2 - Static sheets only
		else cls = cfg.sheetClass;
		return cls;
	}
	/* -------------------------------------------- */
	 /**
	 * Return a reference to the Folder which this Entity belongs to, if any.
	 * @type {Folder|null}
	 *
	 * @example <caption>Entities may belong to Folders</caption>
	 * let folder = game.folders.entities[0];
	 * let actor = await Actor.create({name: "New Actor", folder: folder.id});
	 * console.log(actor.data.folder); // folder.id;
	 * console.log(actor.folder); // folder;
	 */
	get folder() {
		if ( !this.data.folder ) return null;
		return game.folders.get(this.data.folder);
	}
	/* -------------------------------------------- */
	 /**
	 * Return the permission level that the current game User has over this Entity.
	 * See the CONST.ENTITY_PERMISSIONS object for an enumeration of these levels.
	 * @type {number}
	 *
	 * @example
	 * game.user.id; // "dkasjkkj23kjf"
	 * entity.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
	 * entity.permission; // 2
	 */
	get permission() {
		if ( game.user.isGM ) return CONST.ENTITY_PERMISSIONS.OWNER;
		return this.data.permission[game.user._id] ?? this.data.permission["default"];
	}
	 /* -------------------------------------------- */
	 /**
	 * A boolean indicator for whether or not the current game User has ownership rights for this Entity.
	 * This property has a setter which allows for ownership rights to be temporarily overridden on a per-instance basis.
	 * @type {boolean}
	 */
	get owner() {
		return this.hasPerm(game.user, "OWNER");
	}
	 /* -------------------------------------------- */
	 /**
	 * A boolean indicator for whether or not the current game User has at least limited visibility for this Entity.
	 * @type {boolean}
	 */
	get visible() {
		return this.hasPerm(game.user, "LIMITED", false);
	}
	 /* -------------------------------------------- */
	 /**
	 * A boolean indicator for whether the current game user has ONLY limited visibility for this Entity.
	 * Note that a GM user's perspective of an Entity is never limited.
	 * @type {boolean}
	 */
	get limited() {
		if ( game.user.isGM ) return false;
		return this.hasPerm(game.user, "LIMITED", true);
	}
	/* -------------------------------------------- */
	/*  Permission Controls                         */
	/* -------------------------------------------- */
	 /**
	 * Return an array of User entities who have a certain permission level or greater to the Entity.
	 * @param {string|number} permission    The permission level or level name to test
	 * @param {boolean} exact               Tests for an exact permission level match, by default this method tests for
	 *                                      an equal or greater permission level
	 * @returns {User[]}                    An array of User entities who match the permission level
	 */
	getUsers(permission, exact=false) {
		return game.users.filter(u => this.hasPerm(u, permission, exact));
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether a provided User a specific permission level (or greater) over the Entity instance
	 * @param {User} user                   The user to test for permission
	 * @param {string|number} permission    The permission level or level name to test
	 * @param {boolean} exact               Tests for an exact permission level match, by default this method tests for
	 *                                      an equal or greater permission level.
	 * @return {boolean}                    Whether or not the user has the permission for this Entity.
	 *
	 * @example <caption>Test whether a specific user has a certain permission</caption>
	 * // These two are equivalent
	 * entity.hasPerm(game.user, "OWNER");
	 * entity.owner;
	 * // These two are also equivalent
	 * entity.hasPerm(game.user, "LIMITED", true);
	 * entity.limited;
	 */
	hasPerm(user, permission, exact=false) {
		const perms = this.data.permission;
		 // If the entity does not have a permission object (e.g. Folder), only GM has any permission
		if ( !perms ) return user.isGM;
		const level = perms[user._id] ?? perms["default"];
		 // Get the user's permission level
		if ( typeof permission === "string" ) {
			permission = CONST.ENTITY_PERMISSIONS[permission] ?? CONST.ENTITY_PERMISSIONS.OWNER;
		}
		 // Test permission against the target level
		if ( exact ) return level === permission;
		else if ( user.isGM ) return true;
		return level >= permission;
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether a given User has permission to perform some action on this Entity
	 * @param {User} user           The User requesting creation
	 * @param {string} action       The attempted action
	 * @param {Entity} target       The targeted Entity
	 * @return {boolean}            Does the User have permission?
	 */
	static can(user, action, target) {
		const permissions = this.config.permissions || {};
		switch ( action ) {
			case "create":
				return (permissions.create && user.can(permissions.create)) || user.isGM;
			case "update":
				return target.hasPerm(user, "OWNER");
			case "delete":
				return (permissions.delete && user.can(permissions.delete)) || user.isGM;
			default:
				return false;
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether a given User has permission to perform some action on this Entity
	 * @alias Entity.can
	 */
	can(user, action) {
		return this.constructor.can(user, action, this);
	}
	 /* -------------------------------------------- */
	 /**
	 * Test for whether this Entity can be owned by any non-gamemaster player.
	 * @return {boolean}
	 */
	get hasPlayerOwner() {
		if ( this.data.permission["default"] >= CONST.ENTITY_PERMISSIONS.OWNER ) return true;
		for ( let u of game.users.entities ) {
			if ( u.isGM ) continue;
			if ( this.data.permission[u.id] >= CONST.ENTITY_PERMISSIONS.OWNER ) return true;
		}
		return false;
	}
	/* -------------------------------------------- */
	/*  Entity Management Methods                   */
	/* -------------------------------------------- */
	 /**
	 * Activate the Socket event listeners used to receive responses from events which modify database documents
	 * @param {Socket} socket   The active game socket
	 */
	static activateSocketListeners(socket) {
		 // Document Management
		socket.on("modifyDocument", response => {
			const { request } = response;
			if ( !CONST.ENTITY_TYPES.includes(request.type ) ) return;
			const cls = CONFIG[request.type].entityClass;
			switch ( request.action ) {
				case "create":
					return cls._handleCreate(response);
				case "update":
					return cls._handleUpdate(response);
				case "delete":
					return cls._handleDelete(response);
				default:
					return;
			}
		});
		 // Embedded Document Management
		socket.on("modifyEmbeddedDocument", response => {
			const { request } = response;
			const cls = CONFIG[request.parentType].entityClass;
			switch ( request.action ) {
				case "create":
					return cls._handleCreateEmbeddedEntity(response);
				case "update":
					return cls._handleUpdateEmbeddedEntity(response);
				case "delete":
					return cls._handleDeleteEmbeddedEntity(response);
				default:
					return;
			}
		});
	}
	/* -------------------------------------------- */
	 /**
	 * Create one or multiple new entities using provided input data.
	 * Data may be provided as a single object to create one Entity, or as an Array of Objects.
	 * Entities may be temporary (unsaved to the database) by passing the temporary option as true.
	 * @static
	 *
	 * @param {Data|Data[]} data            A Data object or array of Data
	 * @param {Options} options             Additional options which customize the creation workflow
	 * @param {boolean} [options.temporary]     Create a temporary entity which is not saved to the world database. Default is false.
	 * @param {boolean} [options.renderSheet]   Display the sheet for the created entity once it is created. Default is false.
	 * @param {boolean} [options.noHook]        Block the dispatch of preCreate hooks for this operation.
	 *
	 * @return {Promise<Entity|Entity[]>}   The created Entity or array of Entities
	 *
	 * @example
	 * const data = {name: "New Entity", type: "character", img: "path/to/profile.jpg"};
	 * const created = await Entity.create(data); // Returns one Entity, saved to the database
	 * const temp = await Entity.create(data, {temporary: true}); // Not saved to the database
	 *
	 * @example
	 * const data = [{name: "Tim", type: "npc"], [{name: "Tom", type: "npc"}];
	 * const created = await Entity.create(data); // Returns an Array of Entities, saved to the database
	 * const created = await Entity.create(data, {temporary: true}); // Not saved to the database
	 */
	static async create(data, options={}) {
		const entityName = this.entity;
		const cls = CONFIG[entityName].entityClass;
		const user = game.user;
		options = mergeObject({temporary: false, renderSheet: false}, options);
		 // Dispatch pre-creation hooks for each pending data
		data = data instanceof Array ? data : [data];
		if ( !(options.temporary || options.noHook) ) {
			for (let d of data) {
				const allowed = Hooks.call(`preCreate${entityName}`, d, options, user._id);
				if (allowed === false) {
					console.debug(`${vtt} | ${entityName} creation prevented by preCreate hook`);
					return null;
				}
			}
		}
		 // Trigger the Socket workflow
		const response = await SocketInterface.dispatch("modifyDocument", {
			type: entityName,
			action: "create",
			data: data,
			options: options
		});
		 // Call the response handler and return the created Entities
		const entities = cls._handleCreate(response);
		return data.length === 1 ? entities[0] : entities;
	}
	/* -------------------------------------------- */
	 /**
	 * Handle a SocketResponse from the server when one or multiple Entities are created
	 * @param {SocketRequest} request     The initial request
	 * @param {Data[]} result             An Array of created Entity data
	 * @param {string} userId             The id of the requesting User
	 * @return {Entity[]}                 An Array of constructed Entity instances
	 * @private
	 */
	static _handleCreate({request, result=[], userId}={}) {
		const { type, options } = request;
		const { temporary } = options;
		 // Prepare created Entities
		const entities = result.map(data => {
			 // Create the Entity instance
			let entity = new this(data);
			if ( temporary ) return entity;
			 // Add it to the EntityCollection
			this.collection.insert(entity);
			 // Trigger follow-up actions and return
			entity._onCreate(data, options, userId);
			Hooks.callAll(`create${type}`, entity, options, userId);
			return entity;
		});
		 // Log creation
		let msg = ( entities.length === 1 ) ? `Created ${type}` : `Created ${entities.length} ${type}s`;
		if ( entities.length === 1 ) msg += ` with id ${entities[0].id}`;
		else if ( entities.length <= 5 ) msg += ` with ids: [${entities.map(d => d.id)}]`;
		console.log(`${vtt} | ${msg}`);
		 // Re-render the parent EntityCollection
		if ( options.render !== false ) {
			this.collection.render(false, {entityType: this.entity, action: "create", entities: entities, data: result});
		}
		 // Return the created Entities
		return entities;
	}
	 /* -------------------------------------------- */
	 /**
	 * Entity-specific actions that should occur when the Entity is first created
	 * @private
	 */
	_onCreate(data, options, userId) {
		if ( options.renderSheet && (userId === game.user._id) ) {
			if ( this.sheet ) this.sheet.render(true, {
				action: "create",
				data: data
			});
		}
	}
	/* -------------------------------------------- */
	 /**
	 * Update one or multiple existing entities using provided input data.
	 * Data may be provided as a single object to update one Entity, or as an Array of Objects.
	 * @static
	 *
	 * @param {Data|Data[]} data            A Data object or array of Data. Each element must contain the _id of an existing Entity.
	 * @param {Options} options             Additional options which customize the update workflow
	 * @param {boolean} [options.diff]          Difference the provided data against the current to eliminate unnecessary changes.
	 * @param {boolean} [options.noHook]        Block the dispatch of preUpdate hooks for this operation.
	 *
	 * @return {Promise<Entity|Entity[]>}   The updated Entity or array of Entities
	 *
	 * @example
	 * const data = {_id: "12ekjf43kj2312ds", name: "New Name"}};
	 * const updated = await Entity.update(data); // Updated entity saved to the database
	 *
	 * @example
	 * const data = [{_id: "12ekjf43kj2312ds", name: "New Name 1"}, {_id: "kj549dk48k34jk34", name: "New Name 2"}]};
	 * const updated = await Entity.update(data); // Returns an Array of Entities, updated in the database
	 */
	static async update(data, options={}) {
		const entityName = this.entity;
		const collection = this.collection;
		const user = game.user;
		options = mergeObject({diff: true}, options);
		 // Iterate over requested update data
		data = data instanceof Array ? data : [data];
		const updates = data.reduce((arr, d) => {
			 // Get the Entity being updated
			if ( !d._id ) throw new Error(`You must provide an _id for every ${entityName} in the data Array.`);
			const entity = collection.get(d._id, {strict: true});
			 // Diff the update against the current source data
			if ( options.diff ) {
				d = diffObject(entity._data, expandObject(d));
				if ( isObjectEmpty(d) ) return arr;
				d["_id"] = entity.id;
			}
			 // Call pre-update hooks to ensure the update is allowed to proceed
			if ( !options.noHook ) {
				const allowed = Hooks.call(`preUpdate${entityName}`, entity, d, options, user._id);
				if (allowed === false) {
					console.debug(`${vtt} | ${entityName} update prevented by preUpdate hook`);
					return arr;
				}
			}
			 // Stage the update
			arr.push(d);
			return arr;
		}, []);
		if ( !updates.length ) return [];
		 // Trigger the Socket workflow
		const response = await SocketInterface.dispatch("modifyDocument", {
			type: entityName,
			action: "update",
			data: updates,
			options: options
		});
		 // Call the response handler and return the created Entities
		const entities = this._handleUpdate(response);
		return data.length === 1 ? entities[0] : entities;
	}
	/* -------------------------------------------- */
	 /**
	 * Handle a SocketResponse from the server when one or multiple Entities are updated
	 * @param {SocketRequest} request     The initial request
	 * @param {Data[]} result             An Array of updated Entity data
	 * @param {string} userId             The id of the requesting User
	 * @return {Entity[]}                 An Array of constructed Entity instances
	 * @private
	 */
	static _handleUpdate({request, result=[], userId}={}) {
		const { type, options } = request;
		const collection = this.collection;
		 // Prepare updated Entities
		const entities = result.map(data => {
			 // Get and update the Entity data
			const entity = collection.get(data._id, {strict: true});
			mergeObject(entity._data, data, options);
			 // Trigger follow-up actions and return
			entity._onUpdate(data, options, userId);
			Hooks.callAll(`update${type}`, entity, data, options, userId);
			return entity;
		});
		 // Re-render the parent EntityCollection
		if ( options.render !== false ) {
			this.collection.render(false, {entityType: this.entity, action: "update", entities: entities, data: result});
		}
		 // Return the updated Entities
		return entities;
	}
	/* -------------------------------------------- */
	 /**
	 * Entity-specific actions that should occur when the Entity is updated
	 * @private
	 */
	_onUpdate(data, options, userId) {
		this.prepareData();
		this.render(false, {
			action: "update",
			data: data
		});
	}
	/* -------------------------------------------- */
		 /**
	 * Update the current Entity using provided input data.
	 * Data must be provided as a single object which updates the Entity data.
	 * @see {Entity.update}
	 *
	 * @param {Data} data                   A Data object which updates the Entity
	 * @param {Options} options             Additional options which customize the update workflow
	 * @return {Promise<Entity>}            The updated Entity
	 */
	async update(data, options={}) {
		data._id = this._id;
		 // Delegate Compendium updates to the relevant pack
		if ( this.compendium ) {
			options.entity = this;
			return this.compendium.updateEntity(data, options);
		}
		 // Perform World entity updates
		return this.constructor.update(data, options);
	}
	/* -------------------------------------------- */
	 /**
	 * Delete one or multiple existing entities using provided ids.
	 * The target ids may be a single string or an Array of strings.
	 * @static
	 *
	 * @param {string|string[]} data            A single id or Array of ids
	 * @param {Options} options                 Additional options which customize the deletion workflow
	 * @param {boolean} [options.noHook]        Block the dispatch of preDelete hooks for this operation.
	 *
	 * @return {Promise<Entity|Entity[]>}       The deleted Entity or array of Entities
	 *
	 * @example
	 * const id = "12ekjf43kj2312ds";
	 * const deleted = await Entity.delete(id); // A single deleted entity from the database
	 *
	 * @example
	 * const ids = ["12ekjf43kj2312ds", "kj549dk48k34jk34"];
	 * const deleted = await Entity.delete(ids); // Returns an Array of deleted Entities
	 */
	static async delete(data, options={}) {
		const entityName = this.entity;
		const user = game.user;
		options = mergeObject({temporary: false, renderSheet: false}, options);
		 // Iterate over entity IDs to delete
		data = data instanceof Array ? data : [data];
		if ( !options.noHook ) {
			for (let d of data) {
				const e = this.collection.get(d, {strict: true});
				const allowed = Hooks.call(`preDelete${entityName}`, e, options, user._id);
				if (allowed === false) {
					console.debug(`${vtt} | ${entityName} deletion prevented by preCreate hook`);
					return null;
				}
			}
		}
		 // Trigger the Socket workflow
		const response = await SocketInterface.dispatch("modifyDocument", {
			type: entityName,
			action: "delete",
			data: data,
			options: options
		});
		 // Call the response handler and return the deleted Entities
		const entities = this._handleDelete(response);
		return data.length === 1 ? entities[0] : entities;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a SocketResponse from the server when one or multiple Entities are deleted
	 * @param {SocketRequest} request     The initial request
	 * @param {string[]} result           An Array of deleted Entity ids
	 * @param {string} userId             The id of the requesting User
	 * @return {Entity[]}                 An Array of deleted Entity instances
	 * @private
	 */
	static _handleDelete({request, result=[], userId}={}) {
		const {type, options} = request;
		const collection = this.collection;
		 // Handle deleting all
		result = options.deleteAll ? Array.from(collection.keys()) : result;
		 // Prepare deleted Entities
		const entities = result.map(id => {
			 // Get and update the Entity data
			const entity = collection.get(id, {strict: true});
			collection.remove(id);
			 // Trigger follow-up actions and return
			entity._onDelete(options, userId);
			Hooks.callAll(`delete${request.type}`, entity, options, userId);
			return entity;
		});
		 // Log deletion
		let msg = ( entities.length === 1 ) ? `Deleted ${type}` : `Deleted ${entities.length} ${type}s`;
		if ( entities.length === 1 ) msg += ` with id ${entities[0].id}`;
		else if ( entities.length <= 5 ) msg += ` with ids: [${entities.map(d => d.id)}]`;
		console.log(`${vtt} | ${msg}`);
		 // Re-render the parent EntityCollection
		if ( options.render !== false ) {
			this.collection.render(false, {entityType: this.entity, action: "delete", entities: entities, data: result});
		}
		 // Return the deleted Entities
		return entities;
	}
	 /* -------------------------------------------- */
	 /**
	 * Entity-specific actions that should occur when the Entity is deleted
	 * @private
	 */
	_onDelete(options, userId) {
		Object.values(this.apps).forEach(a => a.close({submit: false}));
	}
	/* -------------------------------------------- */
		 /**
	 * Delete the current Entity.
	 * @see {Entity.delete}
		* @param {Options} options             Options which customize the deletion workflow
	 * @return {Promise<Entity>}            The deleted Entity
	 */
	async delete(options={}) {
		if ( this.compendium ) return this.compendium.deleteEntity(this._id, {entity: this});
		return this.constructor.delete(this._id, options);
	}
	/* -------------------------------------------- */
	/*  Embedded Entity Management                  */
	/* -------------------------------------------- */
	 /**
	 * Get an Embedded Entity by it's id from a named collection in the parent Entity.
	 *
	 * @param {string} embeddedName   The name of the Embedded Entity type to retrieve
	 * @param {string} id             The numeric ID of the child to retrieve
	 * @param {boolean} strict        Throw an Error if the requested id does not exist, otherwise return null. Default false.
	 * @return {Object|null}          Retrieved data for the requested child, or null
	 */
	getEmbeddedEntity(embeddedName, id, {strict=false}={}) {
		const collection = this.getEmbeddedCollection(embeddedName);
		const child = collection.find(c => c._id === id);
		if ( !child && strict ) {
			throw new Error(`The ${embeddedName} ${id} does not exist in ${this.constructor.name} ${this._id}`);
		}
		return child || null;
	}
	/* -------------------------------------------- */
	 /**
	 * Create one or multiple EmbeddedEntities within this parent Entity.
	 * Data may be provided as a single Object to create one EmbeddedEntity or as an Array of Objects to create many.
	 * Entities may be temporary (unsaved to the database) by passing the temporary option as true.
	 *
	 * @param {string} embeddedName   The name of the Embedded Entity class to create
	 * @param {Data|Data[]} data      A Data object or an Array of Data objects to create
	 * @param {Options} options       Additional creation options which modify the request
	 * @param {boolean} [options.temporary]     Create a temporary entity which is not saved to the world database. Default is false.
	 * @param {boolean} [options.renderSheet]   Display the sheet for each created Embedded Entities once created.
	 * @param {boolean} [options.noHook]        Block the dispatch of preUpdate hooks for this operation.
	 *
	 * @return {Promise<Data|Data[]>} A Promise which resolves to the created embedded Data once the creation request is successful
	 *
	 * @example
	 * const actor = game.actors.get("dfv934kj23lk6h9k");
	 * const data = {name: "Magic Sword", type: "weapon", img: "path/to/icon.png"};
	 * const created = await actor.createEmbeddedEntity("OwnedItem", data); // Returns one EmbeddedEntity, saved to the Actor
	 * const temp = await actor.createEmbeddedEntity("OwnedItem", data, {temporary: true}); // Not saved to the Actor
	 *
	 * @example
	 * const actor = game.actors.get("dfv934kj23lk6h9k");
	 * const data = [{name: "Mace of Crushing", type: "weapon"}, {name: "Shield of Defense", type: "armor"}];
	 * const created = await actor.createEmbeddedEntity("OwnedItem", data); // Returns an Array of EmbeddedEntities, saved to the Actor
	 * const temp = await actor.createEmbeddedEntity("OwnedItem", data, {temporary: true}); // Not saved to the Actor
	 */
	async createEmbeddedEntity(embeddedName, data, options={}) {
		this.getEmbeddedCollection(embeddedName); // Do this to validate the collection exists
		const user = game.user;
		options = mergeObject({temporary: false, renderSheet: false}, options);
		 // Iterate over data to create
		data = data instanceof Array ? data : [data];
		if ( !(options.temporary || options.noHook) ) {
			for (let d of data) {
				const allowed = Hooks.call(`preCreate${embeddedName}`, this, d, options, user._id);
				if (allowed === false) {
					console.debug(`${vtt} | ${embeddedName} creation prevented by preCreate hook`);
					return null;
				}
			}
		}
		 // Trigger the Socket workflow
		const response = await SocketInterface.dispatch("modifyEmbeddedDocument", {
			action: "create",
			type: embeddedName,
			parentType: this.entity,
			parentId: this.id,
			data: data,
			options: options
		});
		 // Call the response handler and return the created Entities
		const embedded = this.constructor._handleCreateEmbeddedEntity(response);
		return data.length === 1 ? embedded[0] : embedded;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a SocketResponse from the server when one or multiple Embedded Entities are created
	 * @param {SocketRequest} request     The initial request
	 * @param {Data[]} result             An Array of created Entity data
	 * @param {string} userId             The id of the requesting User
	 * @return {Data[]}                   An Array of constructed EmbeddedDocument data
	 * @private
	 */
	static _handleCreateEmbeddedEntity({request, result=[], userId}={}) {
		const { type, parentType, parentId, options } = request;
		const { temporary } = options;
		const parent = this.collection.get(parentId);
		const collection = parent.getEmbeddedCollection(type);
		 // Return temporary data directly
		if ( temporary ) return result;
		 // Add the created data into the collection
		collection.push(...result);
		 // Trigger follow-up actions for each created EmbeddedEntity
		for ( let r of result ) {
			parent._onCreateEmbeddedEntity(type, r, options, userId);
			Hooks.callAll(`create${type}`, parent, r, options, userId);
		}
		parent._onModifyEmbeddedEntity(type, result, options, userId, {action: "create"});
		 // Log creation
		let msg = ( result.length === 1 ) ? `Created ${type}` : `Created ${result.length} ${type}s`;
		if ( result.length === 1 ) msg += ` ${result[0]._id}`;
		else if ( result.length <= 5 ) msg += ` [${result.map(d => d._id)}]`;
		msg += ` in parent ${parentType} ${parent.id}`;
		console.log(`${vtt} | ${msg}`);
		 // Return the created results
		return result;
	}
	/* -------------------------------------------- */
	 /**
	 * Handle Embedded Entity creation within this Entity with specific callback steps.
	 * This function is triggered once per EmbeddedEntity which is updated.
	 * It therefore may run multiple times per creation workflow.
	 * Any steps defined here should run on a per-EmbeddedEntity basis.
	 * Steps that should run once for the whole batch should go in _onModifyEmbeddedEntity()
	 * @private
	 */
	_onCreateEmbeddedEntity(embeddedName, child, options, userId) {}
	/* -------------------------------------------- */
	 /**
	 * Update one or multiple existing entities using provided input data.
	 * Data may be provided as a single object to update one Entity, or as an Array of Objects.
	 * @static
	 *
	 * @param {string} embeddedName   The name of the Embedded Entity class to create
	 * @param {Data|Data[]} data            A Data object or array of Data. Each element must contain the _id of an existing Entity.
	 * @param {Options} options             Additional options which customize the update workflow
	 * @param {boolean} [options.diff]      Difference the provided data against the current to eliminate unnecessary changes.
	 * @param {boolean} [options.noHook]        Block the dispatch of preUpdate hooks for this operation.
	 *
	 * @return {Promise<Entity|Entity[]>}   The updated Entity or array of Entities
	 *
	 * @example
	 * const actor = game.actors.get("dfv934kj23lk6h9k");
	 * const item = actor.data.items.find(i => i.name === "Magic Sword");
	 * const update = {_id: item._id, name: "Magic Sword +1"};
	 * const updated = await actor.updateEmbeddedEntity("OwnedItem", update); // Updates one EmbeddedEntity
	 *
	 * @example
	 * const actor = game.actors.get("dfv934kj23lk6h9k");
	 * const weapons = actor.data.items.filter(i => i.type === "weapon");
	 * const updates = weapons.map(i => {
	 *   return {_id: i._id, name: i.name + "+1"};
	 * }
	 * const updated = await actor.createEmbeddedEntity("OwnedItem", updates); // Updates multiple EmbeddedEntity objects
	 */
	async updateEmbeddedEntity(embeddedName, data, options={}) {
		const collection = this.getEmbeddedCollection(embeddedName);
		const user = game.user;
		options = mergeObject({diff: true}, options);
		 // Structure the update data
		const pending = new Map();
		data = data instanceof Array ? data : [data];
		for ( let d of data ) {
			if ( !d._id ) throw new Error("You must provide an id for every Embedded Entity in an update operation");
			pending.set(d._id, d);
		}
		 // Difference each update against existing data
		const updates = collection.reduce((arr, d) => {
			if ( !pending.has(d._id) ) return arr;
			let update = pending.get(d._id);
			 // Diff the update against current data
			if ( options.diff ) {
				update = diffObject(d, expandObject(update));
				if ( isObjectEmpty(update) ) return arr;
				update["_id"] = d._id;
			}
			 // Call pre-update hooks to ensure the update is allowed to proceed
			if ( !options.noHook ) {
				const allowed = Hooks.call(`preUpdate${embeddedName}`, this, d, update, options, user._id);
				if (allowed === false) {
					console.debug(`${vtt} | ${embeddedName} update prevented by preUpdate hook`);
					return arr;
				}
			}
			 // Stage the update
			arr.push(update);
			return arr;
		}, []);
		if ( !updates.length ) return [];
		 // Trigger the Socket workflow
		const response = await SocketInterface.dispatch("modifyEmbeddedDocument", {
			action: "update",
			type: embeddedName,
			parentType: this.entity,
			parentId: this.id,
			data: updates,
			options: options
		});
		 // Call the response handler and return the created Entities
		const embedded = this.constructor._handleUpdateEmbeddedEntity(response);
		return data.length === 1 ? embedded[0] : embedded;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a SocketResponse from the server when one or multiple Embedded Entities are updated
	 * @param {SocketRequest} request     The initial request
	 * @param {Data[]} result             An Array of updated Entity data
	 * @param {string} userId             The id of the requesting User
	 * @return {Data[]}                   An Array of updated EmbeddedDocument data
	 * @private
	 */
	static _handleUpdateEmbeddedEntity({request, result=[], userId}={}) {
		const { type, parentId, options } = request;
		const parent = this.collection.get(parentId);
		const collection = parent.getEmbeddedCollection(type);
		 // Structure the pending updates
		const pending = new Map(result.map(d => [d._id, d]));
		 // Update children in the collection
		for ( let doc of collection ) {
			 // Update the data
			if ( !pending.has(doc._id) ) continue;
			const update = pending.get(doc._id);
			mergeObject(doc, update, options);
			 // Trigger follow-up actions
			parent._onUpdateEmbeddedEntity(type, doc, update, options, userId);
			Hooks.callAll(`update${type}`, parent, doc, update, options, userId);
		}
		 // Trigger overall modification of the parent
		parent._onModifyEmbeddedEntity(type, result, options, userId, {action: "update"});
		 // Return the created results
		return result;
	}
	/* -------------------------------------------- */
	 /**
	 * Handle Embedded Entity updates within this Entity with specific callback steps.
	 * This function is triggered once per EmbeddedEntity which is updated.
	 * It therefore may run multiple times per creation workflow.
	 * Any steps defined here should run on a per-EmbeddedEntity basis.
	 * Steps that should run once for the whole batch should go in _onModifyEmbeddedEntity()
	 * @private
	 */
	_onUpdateEmbeddedEntity(embeddedName, child, updateData, options, userId) {}
	/* -------------------------------------------- */
	 /**
	 * Delete one or multiple existing EmbeddedEntity objects using provided input data.
	 * Data may be provided as a single id to delete one object or as an Array of string ids.
	 * @static
	 *
	 * @param {string} embeddedName         The name of the Embedded Entity class to create
	 * @param {string|string[]} data        A Data object or array of Data. Each element must contain the _id of an existing Entity.
	 * @param {Options} options             Additional options which customize the update workflow
	 * @param {boolean} [options.noHook]        Block the dispatch of preUpdate hooks for this operation.
	 *
	 * @return {Promise<Data|Data[]>}       The deleted Embedded Entities
	 *
	 * @example
	 * const actor = game.actors.get("dfv934kj23lk6h9k");
	 * const item = actor.data.items.find(i => i.name === "Magic Sword");
	 * const deleted = await actor.deleteEmbeddedEntity("OwnedItem", item._id); // Deletes one EmbeddedEntity
	 *
	 * @example
	 * const actor = game.actors.get("dfv934kj23lk6h9k");
	 * const weapons = actor.data.items.filter(i => i.type === "weapon");
	 * const deletions = weapons.map(i => i._id);
	 * const deleted = await actor.deleteEmbeddedEntity("OwnedItem", deletions); // Deletes multiple EmbeddedEntity objects
		*/
	async deleteEmbeddedEntity(embeddedName, data, options={}) {
		const collection = this.getEmbeddedCollection(embeddedName);
		const user = game.user;
		 // Structure the input data
		data = data instanceof Array ? data : [data];
		const ids = new Set(data);
		 // Iterate over elements of the collection
		const deletions = collection.reduce((arr, d) => {
			if ( !ids.has(d._id) ) return arr;
			 // Call pre-update hooks to ensure the update is allowed to proceed
			if ( !options.noHook ) {
				const allowed = Hooks.call(`preDelete${embeddedName}`, this, d, options, user._id);
				if (allowed === false) {
					console.debug(`${vtt} | ${embeddedName} update prevented by preUpdate hook`);
					return arr;
				}
			}
			 // Add the id to the pending array
			arr.push(d._id);
			return arr;
		}, []);
		if ( !deletions.length ) return [];
		 // Trigger the Socket workflow
		const response = await SocketInterface.dispatch("modifyEmbeddedDocument", {
			action: "delete",
			type: embeddedName,
			parentType: this.entity,
			parentId: this.id,
			data: deletions,
			options: options
		});
		 // Call the response handler and return the created Entities
		const embedded = this.constructor._handleDeleteEmbeddedEntity(response);
		return deletions.length === 1 ? embedded[0] : embedded;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a SocketResponse from the server when one or multiple Embedded Entities are deleted
	 * @param {SocketRequest} request     Th2e initial request
	 * @param {string[]} result           An Array of deleted EmbeddedEntity ids
	 * @param {string} userId             The id of the requesting User
	 * @return {Data[]}                   An Array of deleted EmbeddedDocument data
	 * @private
	 */
	static _handleDeleteEmbeddedEntity({request, result=[], userId}={}) {
		const { type, parentType, parentId, options } = request;
		const parent = this.collection.get(parentId);
		const collection = parent.getEmbeddedCollection(type);
		 // Structure the pending updates
		const deletions = new Set(result);
		 // Update children in the collection
		const [deleted, surviving] = collection.partition(doc => {
			if ( !deletions.has(doc._id) ) return true;
			parent._onDeleteEmbeddedEntity(type, doc, options, userId);
			Hooks.callAll(`delete${type}`, parent, doc, options, userId);
			return false;
		});
		 // Assign the updated collection
		const collectionName = this.config.embeddedEntities[type];
		parent._data[collectionName] = surviving;
		 // Trigger overall modification of the parent
		parent._onModifyEmbeddedEntity(type, result, options, userId, {action: "update"});
		 // Log deletion
		let msg = ( deleted.length === 1 ) ? `Deleted ${type}` : `Deleted ${result.length} ${type}s`;
		if ( deleted.length === 1 ) msg += ` ${result[0]}`;
		else if ( !options.deleteAll && (deleted.length <= 5) ) msg += ` [${result}]`;
		msg += ` from parent ${parentType} ${parent.id}`;
		console.log(`${vtt} | ${msg}`);
		return deleted;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle Embedded Entity deletion within this Entity with specific callback steps.
	 * This function is triggered once per EmbeddedEntity which is updated.
	 * It therefore may run multiple times per creation workflow.
	 * Any steps defined here should run on a per-EmbeddedEntity basis.
	 * Steps that should run once for the whole batch should go in _onModifyEmbeddedEntity()
	 * @private
	 */
	_onDeleteEmbeddedEntity(embeddedName, child, options, userId) {}
	/* -------------------------------------------- */
	 /**
	 * A generic helper since we take the same actions for every type of Embedded Entity update
	 * Unlike the specific _onCreate, _onUpdate, and _onDelete methods this only runs once per updated batch
	 * @private
	 */
	_onModifyEmbeddedEntity(embeddedName, changes, options, userId, context={}) {
		this.prepareData();
		this.render(false, context);
	}
	 /* -------------------------------------------- */
	/*  Data Flags                                  */
	/* -------------------------------------------- */
	 /**
	 * Get the value of a "flag" for this Entity
	 * See the setFlag method for more details on flags
	 *
	 * @param {string} scope    The flag scope which namespaces the key
	 * @param {string} key      The flag key
	 * @return {*}              The flag value
	 */
	getFlag(scope, key) {
		const scopes = SetupConfiguration.getPackageScopes();
		if ( !scopes.includes(scope) ) throw new Error(`Invalid scope for flag ${key}`);
		key = `${scope}.${key}`;
		return getProperty(this.data.flags, key);
	}
	 /* -------------------------------------------- */
	 /**
	 * Assign a "flag" to this Entity.
	 * Flags represent key-value type data which can be used to store flexible or arbitrary data required by either
	 * the core software, game systems, or user-created modules.
	 *
	 * Each flag should be set using a scope which provides a namespace for the flag to help prevent collisions.
	 *
	 * Flags set by the core software use the "core" scope.
	 * Flags set by game systems or modules should use the canonical name attribute for the module
	 * Flags set by an individual world should "world" as the scope.
	 *
	 * Flag values can assume almost any data type. Setting a flag value to null will delete that flag.
	 *
	 * @param {string} scope    The flag scope which namespaces the key
	 * @param {string} key      The flag key
	 * @param {*} value         The flag value
	 *
	 * @return {Promise.<Entity>} A Promise resolving to the updated Entity
	 */
	async setFlag(scope, key, value) {
		const scopes = SetupConfiguration.getPackageScopes();
		if ( !scopes.includes(scope) ) throw new Error(`Invalid scope for flag ${key}`);
		key = `flags.${scope}.${key}`;
		return this.update({[key]: value});
	}
	 /* -------------------------------------------- */
	 /**
	 * Remove a flag assigned to the Entity
	 * @param {string} scope      The flag scope which namespaces the key
	 * @param {string} key        The flag key
	 * @return {Promise<Entity>}  The updated Entity instance
	 */
	async unsetFlag(scope, key) {
		const scopes = SetupConfiguration.getPackageScopes();
		if ( !scopes.includes(scope) ) throw new Error(`Invalid scope for flag ${key}`);
		key = `flags.${scope}.-=${key}`;
		return this.update({[key]: null});
	}
	 /* -------------------------------------------- */
	/*  Sorting                                     */
	/* -------------------------------------------- */
	 /**
	 * Sort this Entity relative a target by providing the target, an Array of siblings and other options.
	 * If the Entity has an rendered sheet, record the sort change as part of a form submission
	 * See SortingHelper.performIntegerSort for more details
	 */
	async sortRelative({target=null, siblings=[], sortKey="sort", sortBefore=true, updateData={}}={}) {
		const updates = SortingHelpers.performIntegerSort(this, {target, siblings, sortKey, sortBefore});
		for ( let u of updates ) {
			const ent = u.target;
			const update = mergeObject(updateData, u.update, {inplace: false});
			if ( ent.sheet && ent.sheet.rendered ) await ent.sheet.submit({updateData: update});
			else await ent.update(update);
		}
	}
	 /* -------------------------------------------- */
	/*  Saving and Loading
	/* -------------------------------------------- */
	 /**
	 * Clone an Entity, creating a new Entity using the current data as well as provided creation overrides.
	 *
	 * @param {Object} createData     Additional data which overrides current Entity data at the time of creation
	 * @param {Object} options        Additional creation options passed to the Entity.create method
	 * @returns {Promise.<Entity>}    A Promise which resolves to the created clone Entity
	 */
	async clone(createData={}, options={}) {
		createData = mergeObject(this._data, createData, {inplace: false});
		return this.constructor.create(createData, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Serializing an Entity should simply serialize it's inner data, not the entire instance
	 * @return {Object}
	 */
	toJSON() {
		return this._data;
	}
	 /* -------------------------------------------- */
	 /**
	 * Export entity data to a JSON file which can be saved by the client and later imported into a different session
	 */
	exportToJSON() {
		 // Prepare export data
		const data = duplicate(this._data);
		delete data.folder;
		delete data.permission;
		 // Flag some metadata about where the entity was exported some - in case migration is needed later
		data.flags["exportSource"] = {
			world: game.world.id,
			system: game.system.id,
			coreVersion: game.data.version,
			systemVersion: game.system.data.version
		};
		 // Trigger file save procedure
		const filename = `fvtt-${this.entity}-${this.name.replace(/\s/g, "_")}.json`;
		saveDataToFile(JSON.stringify(data, null, 2), "text/json", filename);
	}
	 /* -------------------------------------------- */
	 /**
	 * A helper function to handle obtaining the dropped Entity data from a dropped event. Entity drop data could have:
	 * 1. A compendium pack and entry id
	 * 2. A World Entity _id
	 * 3. A data object explicitly provided
	 *
	 * @param {object} data     The data object extracted from a DataTransfer event
	 * @return {Entity}         The Entity data that should be handled by the drop handler
	 */
	static async fromDropData(data) {
		let entity = null;
		 // Case 1 - Data explicitly provided
		if (data.data) {
			return new this(data.data);
		}
		 // Case 2 - Import from a Compendium pack
		if (data.pack) {
			const pack = game.packs.get(data.pack);
			if (pack.metadata.entity !== this.entity) return;
			entity = await pack.getEntity(data.id);
		}
		 // Case 3 - Import from World entity
		else {
			entity = this.collection.get(data.id);
		}
		 // Flag the source GUID
		if ( !entity.getFlag("core", "sourceId") ) {
			setProperty(entity, "data.flags.core.sourceId", entity.uuid);
		}
		 // Return the extracted entity
		return entity;
	}
	 /* -------------------------------------------- */
	 /**
	 * Import data and update this entity
	 * @param {string} json         JSON data string
	 * @return {Promise.<Entity>}   The updated Entity
	 */
	async importFromJSON(json) {
		const data = JSON.parse(json);
		delete data._id;
		return this.update(data);
	}
	 /* -------------------------------------------- */
	 /**
	 * Render an import dialog for updating the data related to this Entity through an exported JSON file
	 * @return {Promise.<void>}
	 */
	async importFromJSONDialog() {
		new Dialog({
			title: `Import Data: ${this.name}`,
			content: await renderTemplate("templates/apps/import-data.html", {entity: this.entity, name: this.name}),
			buttons: {
				import: {
					icon: '<i class="fas fa-file-import"></i>',
					label: "Import",
					callback: html => {
						const form = html.find("form")[0];
						if ( !form.data.files.length ) return ui.notifications.error("You did not upload a data file!");
						readTextFromFile(form.data.files[0]).then(json => this.importFromJSON(json));
					}
				},
				no: {
					icon: '<i class="fas fa-times"></i>',
					label: "Cancel"
				}
			},
			default: "import"
		}, {
			width: 400
		}).render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Transform the Entity data to be stored in a Compendium pack.
	 * Remove any features of the data which are world-specific.
	 * This function is asynchronous in case any complex operations are required prior to exporting.
	 *
	 * @return {Object}   A data object of cleaned data ready for compendium import
	 */
	async toCompendium() {
		const data = duplicate(this._data);
		const deleteKeys = ["_id", "permission", "folder", "sort", "active"];
		for ( let k of deleteKeys ) {
			delete data[k];
		}
		return data;
	}
	 /* -------------------------------------------- */
	 /**
	 * Provide a Dialog form to create a new Entity of this type.
	 * Choose a name and a type from a select menu of types.
	 * @param {object} data       Initial data with which to populate the creation form
	 * @param {object} options    Initial positioning and sizing options for the dialog form
	 * @return {Promise<Entity>}  A Promise which resolves to the created Entity
	 */
	static async createDialog(data={}, options={}) {
		 // Collect data
		const types = game.system.entityTypes[this.entity];
		const folders = game.folders.filter(f => (f.data.type === this.entity) && f.displayed);
		const label = game.i18n.localize(this.config.label);
		const title = game.i18n.format("ENTITY.Create", {entity: label});
		 // Render the entity creation form
		const html = await renderTemplate(`templates/sidebar/entity-create.html`, {
			name: data.name || game.i18n.format("ENTITY.New", {entity: label}),
			folder: data.folder,
			folders: folders,
			hasFolders: folders.length > 1,
			type: data.type || types[0],
			types: types.reduce((obj, t) => {
				const label = CONFIG[this.entity]?.typeLabels?.[t] ?? t;
				obj[t] = game.i18n.has(label) ? game.i18n.localize(label) : t;
				return obj;
			}, {}),
			hasTypes: types.length > 1
		});
		 // Render the confirmation dialog window
		return Dialog.prompt({
			title: title,
			content: html,
			label: title,
			callback: html => {
				const form = html[0].querySelector("form");
				const fd = new FormDataExtended(form);
				data = mergeObject(data, fd.toObject());
				if ( types.length === 1 ) data.type = types[0];
				return this.create(data, {renderSheet: true});
			},
			options: options
		});
	}
}

/**
 * The EntityCollection of Actor entities.
 * @extends {EntityCollection}
 *
 * @see {@link Actor} The Actor entity.
 * @see {@link ActorDirectory} All Actors which exist in the world are rendered within the ActorDirectory sidebar tab.
 *
 * @example <caption>Retrieve an existing Actor by its id</caption>
 * let actor = game.actors.get(actorId);
 */
class Actors extends EntityCollection {
	constructor(...args) {
		super(...args);
		 /**
		 * A mapping of synthetic Token Actors which are currently active within the viewed Scene.
		 * Each Actor is referenced by the Token.id.
		 * @type {Object}
		 */
		this.tokens = {};
	}
	 /* -------------------------------------------- */
	 /** @override */
	get entity() {
		return "Actor";
	}
	 /* -------------------------------------------- */
	/*  Sheet Registration Methods                  */
	/* -------------------------------------------- */
	 /**
	 * Register an Actor sheet class as a candidate which can be used to display Actors of a given type
	 * See EntitySheetConfig.registerSheet for details
	 * @static
	 *
	 * @example <caption>Register a new ActorSheet subclass for use with certain Actor types.</caption>
	 * Actors.registerSheet("dnd5e", ActorSheet5eCharacter, { types: ["character"], makeDefault: true });
	 */
	static registerSheet(...args) {
		EntitySheetConfig.registerSheet(Actor, ...args);
	}
	 /* -------------------------------------------- */
	 /**
	 * Unregister an Actor sheet class, removing it from the list of avaliable sheet Applications to use
	 * See EntitySheetConfig.unregisterSheet for details
	 * @static
	 *
	 * @example <caption>Deregister the default ActorSheet subclass to replace it with others.</caption>
	 * Actors.unregisterSheet("core", ActorSheet);
	 */
	static unregisterSheet(...args) {
		EntitySheetConfig.unregisterSheet(Actor, ...args)
	}
	 /* -------------------------------------------- */
	 /**
	 * Return an Array of currently registered sheet classes for this Entity type
	 * @type {ActorSheet[]}
	 */
	static get registeredSheets() {
		const sheets = new Set();
		for (let t of Object.values(CONFIG.Actor.sheetClasses)) {
			for (let s of Object.values(t)) {
				sheets.add(s.cls);
			}
		}
		return Array.from(sheets);
	}
}
	/* -------------------------------------------- */
	/**
 * The Actor Entity which represents the protagonists, characters, enemies, and more that inhabit and take actions
 * within the World.
 * @extends {Entity}
 *
 * @see {@link Actors} Each Actor belongs to the Actors collection.
 * @see {@link ActorSheet} Each Actor is edited using the ActorSheet application or a subclass thereof.
 * @see {@link ActorDirectory} All Actors which exist in the world are rendered within the ActorDirectory sidebar tab.
 *
 *
 * @example <caption>Create a new Actor</caption>
 * let actor = await Actor.create({
 *   name: "New Test Actor",
 *   type: "character",
 *   img: "artwork/character-profile.jpg",
 *   folder: folder.data._id,
 *   sort: 12000,
 *   data: {},
 *   token: {},
 *   items: [],
 *   flags: {}
 * });
 *
 * @example <caption>Retrieve an existing Actor</caption>
 * let actor = game.actors.get(actorId);
 */
class Actor extends Entity {
	constructor(...args) {
		super(...args);
		 /**
		 * A reference to a placed Token which creates a synthetic Actor
		 * @type {Token}
		 */
		this.token = this.options.token || null;
		 /**
		 * Construct the Array of Item instances for the Actor
		 * Items are prepared by the Actor.prepareEmbeddedEntities() method
		 * @type {Collection<string,OwnedItem>}
		 */
		this.items = this.items || [];
		 /**
		 * A set that tracks which keys in the data model were modified by active effects
		 * @type {Data}
		 */
		this.overrides = this.overrides || {};
		 /**
		 * Cache an Array of allowed Token images if using a wildcard path
		 * @type {string[]}
		 * @private
		 */
		this._tokenImages = null;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get config() {
		return {
			baseEntity: Actor,
			collection: game.actors,
			embeddedEntities: {
				"ActiveEffect": "effects",
				"OwnedItem": "items"
			},
			label: "ENTITY.Actor",
			permissions: {
				create: "ACTOR_CREATE"
			}
		};
	}
	 /* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /**
	 * A convenient reference to the file path of the Actor's profile image
	 * @type {string}
	 */
	get img() {
		return this.data.img;
	}
	 /* -------------------------------------------- */
	 /**
	 * Classify Owned Items by their type
	 * @type {Object<string,Array>}
	 */
	get itemTypes() {
		const types = Object.fromEntries(game.system.entityTypes.Item.map(t => [t, []]));
		for ( let i of this.items.values() ) {
			types[i.data.type].push(i);
		}
		return types;
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether an Actor entity is a synthetic representation of a Token (if true) or a full Entity (if false)
	 * @type {boolean}
	 */
	get isToken() {
		if (!this.token) return false;
		return !this.token.data.actorLink;
	}
	 /* -------------------------------------------- */
	 /**
	 * An array of ActiveEffect instances which are present on the Actor which have a limited duration.
	 * @return {ActiveEffect[]}
	 */
	get temporaryEffects() {
		return this.effects.filter(e => e.isTemporary && !e.data.disabled);
	}
	 /* -------------------------------------------- */
	/*  Data Preparation                            */
	/* -------------------------------------------- */
	 /** @override */
	prepareData() {
		this.data = duplicate(this._data);
		if (!this.data.img) this.data.img = CONST.DEFAULT_TOKEN;
		if ( !this.data.name ) this.data.name = "New " + this.entity;
		this.prepareBaseData();
		this.prepareEmbeddedEntities();
		this.applyActiveEffects();
		this.prepareDerivedData();
	}
	 /* -------------------------------------------- */
	 /**
	 * First prepare any derived data which is actor-specific and does not depend on Items or Active Effects
	 */
	prepareBaseData() {}
	 /* -------------------------------------------- */
	 /**
	 * Apply final transformations to the Actor data after all effects have been applied
	 */
	prepareDerivedData() {}
	 /* -------------------------------------------- */
	 /** @override */
	prepareEmbeddedEntities() {
		this.items = this._prepareOwnedItems(this.data.items || []);
		this.effects = this._prepareActiveEffects(this.data.effects || []);
	}
	 /* -------------------------------------------- */
	 /**
	 * Prepare a Collection of OwnedItem instances which belong to this Actor.
	 * @param {object[]} items  The raw array of item objects
	 * @return {Collection<string,Item>} The prepared owned items collection
	 * @private
	 */
	_prepareOwnedItems(items) {
		const prior = this.items;
		const c = new Collection();
		for ( let i of items ) {
			let item = null;
			 // Prepare item data
			try {
				if (prior && prior.has(i._id)) {
					item = prior.get(i._id);
					item._data = i;
					item.prepareData();
				}
				else item = Item.createOwned(i, this);
				c.set(i._id, item);
			}
			 // Handle preparation failures gracefully
			catch(err) {
				err.message = `Owned Item preparation failed for ${item.id} (${item.name}) in Actor ${this.id} (${this.name})`;
				console.error(err);
			}
		}
		return c;
	}
	 /* -------------------------------------------- */
	 /**
	 * Prepare a Collection of ActiveEffect instances which belong to this Actor.
	 * @param {object[]} effects  The raw array of active effect objects
	 * @return {Collection<string,ActiveEffect>}  The prepared active effects collection
	 * @private
	 */
	_prepareActiveEffects(effects) {
		const prior = this.effects;
		const c = new Collection();
		for ( let e of effects ) {
			let effect = null;
			 // Prepare effect data
			try {
				if (prior && prior.has(e._id)) {
					effect = prior.get(e._id);
					effect.data = e;
					effect.prepareData();
				} else effect = ActiveEffect.create(e, this);
				c.set(e._id, effect);
			}
			 // Handle preparation failures gracefully
			catch (err) {
				err.message = `Active Effect preparation failed for ${effect.id} in Actor ${this.id} (${this.name})`;
				console.error(err);
			}
		}
		return c;
	}
	 /* -------------------------------------------- */
	 /**
	 * Apply any transformations to the Actor data which are caused by ActiveEffects.
	 */
	applyActiveEffects() {
		const overrides = {};
		 // Organize non-disabled effects by their application priority
		const changes = this.effects.reduce((changes, e) => {
			if ( e.data.disabled ) return changes;
			return changes.concat(e.data.changes.map(c => {
				c = duplicate(c);
				c.effect = e;
				c.priority = c.priority ?? (c.mode * 10);
				return c;
			}));
		}, []);
		changes.sort((a, b) => a.priority - b.priority);
		 // Apply all changes
		for ( let change of changes ) {
			const result = change.effect.apply(this, change);
			if ( result !== null ) overrides[change.key] = result;
		}
		 // Expand the set of final overrides
		this.overrides = expandObject(overrides);
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /**
	 * Create a synthetic Actor using a provided Token instance
	 * If the Token data is linked, return the true Actor entity
	 * If the Token data is not linked, create a synthetic Actor using the Token's actorData override
	 * @param {Token} token
	 * @return {Actor}
	 */
	static fromToken(token) {
		let actor = game.actors.get(token.data.actorId);
		if (!actor) return null;
		if (!token.data._id) return actor;
		if (!token.data.actorLink) actor = actor.constructor.createTokenActor(actor, token);
		return actor;
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a synthetic Token Actor instance which is used in place of an actual Actor.
	 * Cache the result in Actors.tokens.
	 * @param {Actor} baseActor
	 * @param {Token} token
	 * @return {Actor}
	 */
	static createTokenActor(baseActor, token) {
		let actor = this.collection.tokens[token.id];
		if ( actor ) return actor;
		const actorData = mergeObject(baseActor._data, token.data.actorData, {inplace: false});
		actor = new this(actorData, {token: token});
		 // Override embedded entity CRUD methods
		for ( let m of ["update", "createEmbeddedEntity", "updateEmbeddedEntity", "deleteEmbeddedEntity"] ) {
			actor[m] = ActorTokenHelpers.prototype[m].bind(actor);
		}
		 // Add the synthetic Actor to the collection and return
		return this.collection.tokens[token.id] = actor;
	}
	 /* -------------------------------------------- */
	 /**
	 * Retrieve an Array of active tokens which represent this Actor in the current canvas Scene.
	 * If the canvas is not currently active, or there are no linked actors, the returned Array will be empty.
	 *
	 * @param [linked] {boolean}  Only return tokens which are linked to the Actor. Default (false) is to return all
	 *                            tokens even those which are not linked.
	 *
	 * @return {Token[]}          An array of tokens in the current Scene which reference this Actor.
	 */
	getActiveTokens(linked = false) {
		if (!canvas?.tokens) return [];
		return canvas.tokens.placeables.filter(t => {
			if (!(t instanceof Token)) return false;
			if (linked) return t.data.actorLink && t.data.actorId === this._id;
			return t.data.actorId === this._id
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Prepare a data object which defines the data schema used by dice roll commands against this Actor
	 * @return {Object}
	 */
	getRollData() {
		return duplicate(this.data.data);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get an Array of Token images which could represent this Actor
	 * @return {Promise<string[]>}
	 */
	async getTokenImages() {
		if (!this.data.token.randomImg) return [this.data.token.img];
		if (this._tokenImages) return this._tokenImages;
		let source = "data";
		let pattern = this.data.token.img;
		const browseOptions = { wildcard: true };
		 // Support S3 matching
		if ( /\.s3\./.test(pattern) ) {
			source = "s3";
			const {bucket, keyPrefix} = FilePicker.parseS3URL(pattern);
			if ( bucket ) {
				browseOptions.bucket = bucket;
				pattern = keyPrefix;
			}
		}
		 // Retrieve wildcard content
		try {
			const content = await FilePicker.browse(source, pattern, browseOptions);
			this._tokenImages = content.files;
		} catch(err) {
			this._tokenImages = [];
			ui.notifications.error(err);
		}
		return this._tokenImages;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle how changes to a Token attribute bar are applied to the Actor.
	 * This allows for game systems to override this behavior and deploy special logic.
	 * @param {string} attribute    The attribute path
	 * @param {number} value        The target attribute value
	 * @param {boolean} isDelta     Whether the number represents a relative change (true) or an absolute change (false)
	 * @param {boolean} isBar       Whether the new value is part of an attribute bar, or just a direct value
	 * @return {Promise<Actor>}     The updated Actor entity
	 */
	async modifyTokenAttribute(attribute, value, isDelta=false, isBar=true) {
		const current = getProperty(this.data.data, attribute);
		 // Determine the updates to make to the actor data
		let updates;
		if ( isBar ) {
			if (isDelta) value = Math.clamped(0, Number(current.value) + value, current.max);
			updates = {[`data.${attribute}.value`]: value};
		} else {
			if ( isDelta ) value = Number(current) + value;
			updates = {[`data.${attribute}`]: value};
		}
		 // Call a hook to handle token resource bar updates
		const allowed = Hooks.call("modifyTokenAttribute", {attribute, value, isDelta, isBar}, updates);
		return allowed !== false ? this.update(updates) : this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Roll initiative for all Combatants in the currently active Combat encounter which are associated with this Actor.
	 * If viewing a full Actor entity, all Tokens which map to that actor will be targeted for initiative rolls.
	 * If viewing a synthetic Token actor, only that particular Token will be targeted for an initiative roll.
	 *
	 * @param {object} options                Configuration for how initiative for this Actor is rolled.
	 * @param {boolean} [options.createCombatants]      Create new Combatant entries for Tokens associated with this actor.
	 * @param {boolean} [options.rerollInitiative]      Re-roll the initiative for this Actor if it has already been rolled.
	 * @param {object} [options.initiativeOptions]      Additional options passed to the Combat#rollInitiative method.
	 * @return {Promise<Combat|null>}         A promise which resolves to the Combat entity once rolls are complete.
	 */
	async rollInitiative({createCombatants=false, rerollInitiative=false, initiativeOptions={}}={}) {
		 // Obtain (or create) a combat encounter
		let combat = game.combat;
		if ( !combat ) {
			if ( game.user.isGM && canvas.scene ) {
				combat = await game.combats.object.create({scene: canvas.scene._id, active: true});
			}
			else {
				ui.notifications.warn(game.i18n.localize("COMBAT.NoneActive"));
				return null;
			}
		}
		 // Create new combatants
		if ( createCombatants ) {
			const tokens = this.isToken ? [this.token] : this.getActiveTokens();
			const createData = tokens.reduce((arr, t) => {
				if ( t.inCombat ) return arr;
				arr.push({tokenId: t.id, hidden: t.data.hidden});
				return arr;
			}, []);
			await combat.createEmbeddedEntity("Combatant", createData);
		}
		 // Iterate over combatants to roll for
		const combatantIds = combat.combatants.reduce((arr, c) => {
			if ( (c.actor.id !== this.id) || (this.isToken && (c.tokenId !== this.token.id)) ) return arr;
			if ( c.initiative && !rerollInitiative ) return arr;
			arr.push(c._id);
			return arr;
		}, []);
		return combatantIds.length ? combat.rollInitiative(combatantIds, initiativeOptions) : combat;
	}
	 /* -------------------------------------------- */
	/*  Socket Listeners and Handlers
	/* -------------------------------------------- */
	 /** @override */
	async update(data, options = {}) {
		if ( data.img && !hasProperty(data, "token.img") ) {
			if ( !this.data.token.img || (this.data.token.img === CONST.DEFAULT_TOKEN) ) {
				data["token.img"] = data.img;
			}
		}
		return super.update(data, options);
	}
	 /* -------------------------------------------- */
	 /** @override */
	async delete(options) {
		if ( this.isToken ) return this.token.delete(options);
		return super.delete(options);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onUpdate(data, options, userId, context) {
		 // Get the changed attributes
		const keys = Object.keys(data).filter(k => k !== "_id");
		const changed = new Set(keys);
		 // Re-prepare Actor data
		if (changed.has("items")) this.prepareEmbeddedEntities();
		this.prepareData();
		 // Render associated applications
		this.render(false, context);
		 // Additional options only apply to Actors which are not synthetic Tokens
		if (this.isToken) return;
		 // Update default token data
		const token = this.data.token;
		if (data.img && data.img !== token.img && (!token.img || token.img === CONST.DEFAULT_TOKEN)) {
			data["token.img"] = data.img;
		}
		if (data.name && data.name !== token.name && (!token.name || token.name === "New Actor")) {
			data["token.name"] = data.name;
		}
		 // If the prototype token was changed, expire any cached token images
		if (changed.has("token")) this._tokenImages = null;
		 // Update Token representations of this Actor
		this.getActiveTokens().forEach(token => token._onUpdateBaseActor(this.data, data));
		 // If ownership changed for an actor with an active token, re-initialize sight
		if (changed.has("permission")) {
			if (this.getActiveTokens().length) {
				canvas.tokens.releaseAll();
				canvas.tokens.cycleTokens(1, true);
			}
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	async createEmbeddedEntity(embeddedName, data, options={}) {
		const created = await super.createEmbeddedEntity(embeddedName, data, options);
		if ( created && (embeddedName === "OwnedItem") ) await this._createItemActiveEffects(created, options);
		return created;
	}
	 /* -------------------------------------------- */
	 /**
	 * When Owned Items are created process each item and extract Active Effects to transfer to the Actor.
	 * @param {Data[]} created        Created owned Item data objects
	 * @param {boolean} [temporary]   Is this a temporary item creation?
	 * @return {Data[]}               An array of effects to transfer to the Actor
	 * @private
	 */
	async _createItemActiveEffects(created, {temporary=false}={}) {
		if ( temporary ) return;
		created = created instanceof Array ? created : [created];
		const transferred = [];
		 // Identify transferred effects
		for ( let item of created ) {
			if ( !item.effects?.length ) continue;
			for ( let e of item.effects ) {
				if ( !e.transfer ) continue;
				e = duplicate(e);
				e.origin = `Actor.${this.id}.OwnedItem.${item._id}`;
				e.duration.startTime = game.time.worldTime;
				if ( game.combat ) {
					e.duration.startRound = game.combat.round;
					e.duration.startTurn = game.combat.turn;
				}
				transferred.push(e);
			}
		}
		 // Create the transferred effects
		if ( !transferred.length ) return;
		return this.createEmbeddedEntity("ActiveEffect", transferred);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onCreateEmbeddedEntity(embeddedName, child, options, userId) {
		if ( embeddedName === "OwnedItem" ) {
			const item = Item.createOwned(child, this);
			this.items.set(item.id, item);
			if (options.renderSheet && (userId === game.user._id)) {
				item.sheet.render(true, {
					renderContext: "create" + embeddedName,
					renderData: child
				});
			}
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	async deleteEmbeddedEntity(embeddedName, data, options={}) {
		const deleted = await super.deleteEmbeddedEntity(embeddedName, data, options);
		if ( embeddedName === "OwnedItem" ) await this._deleteItemActiveEffects(deleted);
		return deleted;
	}
	 /* -------------------------------------------- */
	 /**
	 * When Owned Items are created process each item and extract Active Effects to transfer to the Actor.
	 * @param {Data[]} deleted   The array of deleted owned Item data
	 * @private
	 */
	_deleteItemActiveEffects(deleted) {
		deleted = deleted instanceof Array ? deleted : [deleted];
		const deletedUUIDs = deleted.map(d => `Actor.${this.id}.OwnedItem.${d._id}`);
		const effects = [];
		for (let e of this.effects) {
			if (deletedUUIDs.includes(e.data.origin)) effects.push(e.id);
		}
		if ( !effects.length ) return;
		return this.deleteEmbeddedEntity("ActiveEffect", effects);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDeleteEmbeddedEntity(embeddedName, child, options, userId) {
		if ( embeddedName === "OwnedItem" ) {
			const item = this.getOwnedItem(child._id);
			this.items.delete(item.id);
			item.sheet.close({submit: false});
		}
	}
	/* -------------------------------------------- */
	 /** @override */
	_onModifyEmbeddedEntity(embeddedName, ...args) {
		super._onModifyEmbeddedEntity(embeddedName, ...args);
		 // Active effect updates
		if ( embeddedName === "ActiveEffect" ) {
			this.getActiveTokens().forEach(t => {
				t.drawEffects();    // Update active effect icons
				t.drawBars();       // The active effect may have changed token bar values
				if ( t.inCombat ) ui.combat.render();
				if ( t.hasActiveHUD ) canvas.tokens.hud.render();
			});
		}
	}
	 /* -------------------------------------------- */
	/*  Owned Item Management                       */
	/* -------------------------------------------- */
	 /**
	 * Get an Item instance corresponding to the Owned Item with a given id
	 * @param {string} itemId   The owned Item id to retrieve
	 * @return {Item}           An Item instance representing the Owned Item within the Actor entity
	 */
	getOwnedItem(itemId) {
		return this.items.get(itemId);
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a new item owned by this Actor. This redirects its arguments to the createEmbeddedEntity method.
	 * @see {Entity#createEmbeddedEntity}
	 *
	 * @param {Object} itemData     Data for the newly owned item
	 * @param {Object} options      Item creation options
	 * @param {boolean} options.renderSheet Render the Item sheet for the newly created item data
	 * @return {Promise.<Object>}   A Promise resolving to the created Owned Item data
	 */
	async createOwnedItem(itemData, options = {}) {
		return this.createEmbeddedEntity("OwnedItem", itemData, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Update an owned item using provided new data. This redirects its arguments to the updateEmbeddedEntity method.
	 * @see {Entity#updateEmbeddedEntity}
	 *
	 * @param {Object} itemData     Data for the item to update
	 * @param {Object} options      Item update options
	 * @return {Promise.<Object>}   A Promise resolving to the updated Owned Item data
	 */
	async updateOwnedItem(itemData, options = {}) {
		return this.updateEmbeddedEntity("OwnedItem", itemData, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Delete an owned item by its id. This redirects its arguments to the deleteEmbeddedEntity method.
	 * @see {Entity#deleteEmbeddedEntity}
	 *
	 * @param {string} itemId       The ID of the item to delete
	 * @param {Object} options      Item deletion options
	 * @return {Promise.<Object>}   A Promise resolving to the deleted Owned Item data
	 */
	async deleteOwnedItem(itemId, options = {}) {
		return this.deleteEmbeddedEntity("OwnedItem", itemId, options);
	}
	 /* -------------------------------------------- */
	/*  DEPRECATED                                  */
	/* -------------------------------------------- */
	 /**
	 * @deprecated since 0.7.0
	 */
	importItemFromCollection(collection, entryId) {
		console.warn(`The Actor#importItemFromCollection helper method is deprecated without replacement. Please use the Compendium#getEntry and Actor#createOwnedItem methods as appropriate.`);
		const pack = game.packs.get(collection);
		if (pack.metadata.entity !== "Item") return;
		return pack.getEntity(entryId).then(ent => {
			console.log(`${vtt} | Importing Item ${ent.name} from ${collection}`);
			delete ent.data._id;
			return this.createOwnedItem(ent.data);
		});
	}
	 /**
	 * @deprecated since 0.7.2
	 * @see {@link Entity#hasPlayerOwner}
	 */
	get isPC() {
		console.warn("The Actor#isPC attribute has been deprecated in favor of the more general Entity#hasPlayerOwner attribute");
		return this.hasPlayerOwner;
	}
}
	/**
 * A collection of replacement functions which are used in Actor socket workflows to replace default behaviors.
 * These methods are factored out in order to keep the main Actor update workflow clean.
 * @ignore
 */
class ActorTokenHelpers {
	 /** @override */
	async update(data, options={}) {
		const token = this.token;
		data = expandObject(data);
		const changed = ( options.diff !== false ) ? diffObject(this.data, data) : data;
		if ( isObjectEmpty(changed ) ) return this;
		return token.update({actorData: changed}, options);
	}
	 /* -------------------------------------------- */
	 /** @override */
	async createEmbeddedEntity(embeddedName, data, options={}) {
		const target = Actor.config.embeddedEntities[embeddedName];
		if (!target) return;
		 // Update the Token's actor data overrides
		let created = await Entity.prototype.createEmbeddedEntity.call(this, embeddedName, data, {temporary: true});
		if ( options.temporary ) return created;
		const collection = duplicate(this._data[target]).concat(created instanceof Array ? created : [created]);
		await this.token.update({[`actorData.${target}`]: collection}, options);
		 // Create transferred active effects
		if ( embeddedName === "OwnedItem" ) await this._createItemActiveEffects(created, options);
		return created.length === 1 ? created[0] : created;
	}
	 /* -------------------------------------------- */
	 /** @override */
	async updateEmbeddedEntity(embeddedName, data, options={}) {
		const target = Actor.config.embeddedEntities[embeddedName];
		if (!target) return;
		const collection = duplicate(this._data[target]);
		data = data instanceof Array ? data : [data];
		const updates = [];
		for ( let update of data ) {
			const obj = collection.find(i => i._id === update._id);
			updates.push(mergeObject(obj, update, {inplace: true}));
		}
		await this.token.update({[`actorData.${target}`]: collection}, options);
		return updates.length === 1 ? updates[0] : updates;
	}
	 /* -------------------------------------------- */
	 /** @override */
	async deleteEmbeddedEntity(embeddedName, data, options={}) {
		const target = Actor.config.embeddedEntities[embeddedName];
		if (!target) return;
		data = data instanceof Array ? data : [data];
		const [deleted, kept] = this._data[target].partition(c => !data.includes(c._id));
		await this.token.update({[`actorData.${target}`]: kept}, options);
		if ( embeddedName === "OwnedItem" ) await this._deleteItemActiveEffects(deleted);
		return deleted.length === 1 ? deleted[0] : deleted;
	}
}
/**
 * The EntityCollection of Combat entities
 * @type {EntityCollection}
 */
class CombatEncounters extends EntityCollection {
	 /** @override */
	get entity() {
		return "Combat";
	}
	 /* -------------------------------------------- */
	 /**
	 * Provide the settings object which configures the Combat entity
	 * @return {object}
	 */
	get settings() {
		return game.settings.get("core", Combat.CONFIG_SETTING);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get an Array of Combat instances which apply to the current canvas scene
	 * @type {Combat[]}
	 */
	get combats() {
		let scene = game.scenes.active;
		if ( !scene ) return [];
		return this.entities.filter(c => c.data.scene === scene._id);
	}
	 /* -------------------------------------------- */
	 /**
	 * The currently active Combat instance
	 * @return {Combat}
	 */
	get active() {
		return this.combats.find(c => c.data.active);
	}
	/* -------------------------------------------- */
	 /**
	 * The currently viewed Combat encounter
	 * @return {Combat|null}
	 */
	get viewed() {
		return ui.combat.combat;
	}
	/* -------------------------------------------- */
	 /** @override */
	static get instance() {
		return game.combats;
	}
	 /* -------------------------------------------- */
	 /**
	 * When a Token is deleted, remove it as a combatant from any combat encounters which included the Token
	 * @param {string} sceneId
	 * @param {string} tokenId
	 * @private
	 */
	async _onDeleteToken(sceneId, tokenId) {
		const combats = game.combats.entities.filter(c => c.data.scene === sceneId);
		for ( let c of combats ) {
			const combatants = c.data.combatants.filter(x => x.tokenId === tokenId).map(x => x._id);
			await c.deleteCombatant(combatants);
		}
	}
}
	/* -------------------------------------------- */
/*  Combat Entity
/* -------------------------------------------- */

/**
 * @typedef {{
 *   token: Token|null,
 *   actor: Actor|null,
 *   name: string,
 *   players: User[],
 *   owner: boolean,
 *   visible: boolean
 * }} Combatant
 */

/**
 * The Combat Entity defines a particular combat encounter which can occur within the game session
 * Combat instances belong to the CombatEncounters collection
 * @extends {Entity}
 */
class Combat extends Entity {
	constructor(...args) {
		super(...args);
		 /**
		 * Track the sorted turn order of this combat encounter
		 * @type {Combatant[]}
		 */
		this.turns = this.turns || [];
		 /**
		 * Record the current round, turn, and tokenId to understand changes in the encounter state
		 * @type {{round: number|null, turn: number|null, tokenId: string|null}}
		 * @private
		 */
		this.current = this.current || {
			round: null,
			turn: null,
			tokenId: null
		};
		 /**
		 * Track the previous round, turn, and tokenId to understand changes in the encounter state
		 * @type {{round: number|null, turn: number|null, tokenId: string|null}}
		 * @private
		 */
		this.previous = this.previous || {
			round: null,
			turn: null,
			tokenId: null
		};
		 /**
		 * Track whether a sound notification is currently being played to avoid double-dipping
		 * @type {boolean}
		 * @private
		 */
		this._soundPlaying = false;
	}
	 /* -------------------------------------------- */
	 /**
	 * The configuration setting used to record Combat preferences
	 * @type {string}
	 */
	static CONFIG_SETTING = "combatTrackerConfig";
	 /* -------------------------------------------- */
	 /** @override */
	static get config() {
		return {
			baseEntity: Combat,
			collection: game.combats,
			embeddedEntities: { "Combatant": "combatants" },
			label: "ENTITY.Combat"
		};
	}
	/* -------------------------------------------- */
	 /**
	 * Prepare Embedded Entities which exist within the parent Combat.
	 * For example, in the case of an Actor, this method is responsible for preparing the Owned Items the Actor contains.
	 */
	prepareEmbeddedEntities() {
	 this.turns = this.setupTurns();
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the Array of combatants sorted into initiative order, breaking ties alphabetically by name.
	 * @return {Combatant[]}
	 */
	setupTurns() {
		const combatants = this.data.combatants;
		const scene = game.scenes.get(this.data.scene);
		const players = game.users.players;
		const settings = game.settings.get("core", Combat.CONFIG_SETTING);
		 // Determine the turn order and the current turn
		const turns = combatants.map(c => this._prepareCombatant(c, scene, players, settings)).sort(this._sortCombatants);
		this.data.turn = Math.clamped(this.data.turn, 0, turns.length-1);
		// Update state tracking
		let c = turns[this.data.turn];
		this.current = {round: this.data.round, turn: this.data.turn, tokenId: c ? c.tokenId : null};
		return this.turns = turns;
	}
	 /* -------------------------------------------- */
	 /**
	 * Prepare turn data for one specific combatant.
	 * @private
	 */
	_prepareCombatant(c, scene, players, settings={}) {
		 // Populate data about the combatant
		c.token = scene.getEmbeddedEntity("Token", c.tokenId);
		c.actor = c.token ? Actor.fromToken(new Token(c.token, scene)) : null;
		c.name = c.name || c.token?.name || c.actor?.name || game.i18n.localize("COMBAT.UnknownCombatant");
		 // Permissions and visibility
		c.permission = c.actor?.permission ?? 0;
		c.players = c.actor ? players.filter(u => c.actor.hasPerm(u, "OWNER")) : [];
		c.owner = game.user.isGM || (c.actor ? c.actor.owner : false);
		c.resource = c.actor ? getProperty(c.actor.data.data, settings.resource) : null;
		 // Combatant thumbnail image
		c.img = c.img ?? c.token?.img ?? c.actor?.img ?? CONST.DEFAULT_TOKEN;
		 // Set state information
		c.initiative = Number.isNumeric(c.initiative) ? Number(c.initiative) : null;
		c.visible = c.owner || !c.hidden;
		return c;
	}
	 /* -------------------------------------------- */
	 /**
	 * Define how the array of Combatants is sorted in the displayed list of the tracker.
	 * This method can be overridden by a system or module which needs to display combatants in an alternative order.
	 * By default sort by initiative, falling back to name
	 * @private
	 */
	_sortCombatants(a, b) {
		const ia = Number.isNumeric(a.initiative) ? a.initiative : -9999;
		const ib = Number.isNumeric(b.initiative) ? b.initiative : -9999;
		let ci = ib - ia;
		if ( ci !== 0 ) return ci;
		let [an, bn] = [a.token?.name || "", b.token?.name || ""];
		let cn = an.localeCompare(bn);
		if ( cn !== 0 ) return cn;
		return a.tokenId - b.tokenId;
	}
	 /* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /**
	 * A convenience reference to the Array of combatant data within the Combat entity
	 * @type {object[]}
	 */
	get combatants() {
		return this.data.combatants;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the data object for the Combatant who has the current turn
	 * @type {Combatant}
	 */
	get combatant() {
		return this.turns[this.data.turn];
	}
	 /* -------------------------------------------- */
	 /**
	 * The numeric round of the Combat encounter
	 * @type {number}
	 */
	get round() {
		return Math.max(this.data.round, 0);
	}
	 /* -------------------------------------------- */
	 /**
	 * The numeric turn of the combat round in the Combat encounter
	 * @type {number}
	 */
	get turn() {
		return Math.max(this.data.turn, 0);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the Scene entity for this Combat encounter
	 * @return {Scene}
	 */
	get scene() {
		return game.scenes.get(this.data.scene);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the object of settings which modify the Combat Tracker behavior
	 * @return {object}
	 */
	get settings() {
		return this.collection.settings;
	}
	 /* -------------------------------------------- */
	 /**
	 * Has this combat encounter been started?
	 * @type {boolean}
	 */
	get started() {
		return ( this.turns.length > 0 ) && ( this.round > 0 );
	}
	 /* -------------------------------------------- */
	/*  Combat Control Methods                      */
	/* -------------------------------------------- */
	 /**
	 * Set the current Combat encounter as active within the Scene.
	 * Deactivate all other Combat encounters within the viewed Scene and set this one as active
	 * @return {Promise<Combat>}
	 */
	async activate() {
		const scene = game.scenes.viewed;
		const updates = this.collection.entities.reduce((arr, c) => {
			if ( (c.data.scene === scene.id) && c.data.active ) arr.push({_id: c.data._id, active: false});
			return arr;
		}, []);
		updates.push({_id: this.id, active: true});
		return this.constructor.update(updates);
	}
	 /* -------------------------------------------- */
	 /**
	 * Begin the combat encounter, advancing to round 1 and turn 1
	 * @return {Promise<Combat>}
	 */
	async startCombat() {
		return this.update({round: 1, turn: 0});
	}
	 /* -------------------------------------------- */
	 /**
	 * Advance the combat to the next turn
	 * @return {Promise<Combat>}
	 */
	async nextTurn() {
		let turn = this.turn;
		let skip = this.settings.skipDefeated;
		 // Determine the next turn number
		let next = null;
		if ( skip ) {
			for ( let [i, t] of this.turns.entries() ) {
				if ( i <= turn ) continue;
				if ( t.defeated ) continue;
				if ( t.actor?.effects.find(e => e.getFlag("core", "statusId") === CONFIG.Combat.defeatedStatusId ) ) continue;
				next = i;
				break;
			}
		}
		else next = turn + 1;
		 // Maybe advance to the next round
		let round = this.round;
		if ( (this.round === 0) || (next === null) || (next >= this.turns.length) ) {
			return this.nextRound();
		}
		 // Update the encounter
		const advanceTime = CONFIG.time.turnTime;
		this.update({round: round, turn: next}, {advanceTime});
	}
	 /* -------------------------------------------- */
	 /**
	 * Rewind the combat to the previous turn
	 * @return {Promise<Combat>}
	 */
	async previousTurn() {
		if ( this.turn === 0 && this.round === 0 ) return Promise.resolve();
		else if ( this.turn === 0 ) return this.previousRound();
		const advanceTime = -1 * CONFIG.time.turnTime;
		return this.update({turn: this.turn - 1}, {advanceTime});
	 }
	 /* -------------------------------------------- */
	 /**
	 * Advance the combat to the next round
	 * @return {Promise<Combat>}
	 */
	async nextRound() {
		let turn = 0;
		if ( this.settings.skipDefeated ) {
			turn = this.turns.findIndex(t => {
				return !(t.defeated ||
				t.actor?.effects.find(e => e.getFlag("core", "statusId") === CONFIG.Combat.defeatedStatusId ));
			});
			if (turn === -1) {
				ui.notifications.warn(game.i18n.localize("COMBAT.NoneRemaining"));
				turn = 0;
			}
		}
		let advanceTime = Math.max(this.turns.length - this.data.turn, 1) * CONFIG.time.turnTime;
		advanceTime += CONFIG.time.roundTime;
		return this.update({round: this.round+1, turn: turn}, {advanceTime});
	}
	 /* -------------------------------------------- */
	 /**
	 * Rewind the combat to the previous round
	 * @return {Promise<Combat>}
	 */
	async previousRound() {
		let turn = ( this.round === 0 ) ? 0 : this.turns.length - 1;
		const round = Math.max(this.round - 1, 0);
		let advanceTime = -1 * this.data.turn * CONFIG.time.turnTime;
		if ( round > 0 ) advanceTime -= CONFIG.time.roundTime;
		return this.update({round, turn}, {advanceTime});
	}
	 /* -------------------------------------------- */
	 /**
	 * Reset all combatant initiative scores, setting the turn back to zero
	 * @return {Promise<Combat>}
	 */
	async resetAll() {
		const updates = this.data.combatants.map(c => { return {
			_id: c._id,
			initiative: null
		}});
		await this.updateEmbeddedEntity("Combatant", updates);
		return this.update({turn: 0});
	}
	 /* -------------------------------------------- */
	 /**
	 * Display a dialog querying the GM whether they wish to end the combat encounter and empty the tracker
	 * @return {Promise<void>}
	 */
	async endCombat() {
		return Dialog.confirm({
			title: "End Combat Encounter?",
			content: "<p>End this combat encounter and empty the turn tracker?</p>",
			yes: () => this.delete()
		});
	}
	 /* -------------------------------------------- */
	/*  Combatant Management Methods                */
	/* -------------------------------------------- */
	 /** @override */
	getCombatant(id) {
		return this.getEmbeddedEntity("Combatant", id);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get a Combatant using its Token id
	 * @param {string} tokenId   The id of the Token for which to acquire the combatant
	 */
	getCombatantByToken(tokenId) {
		return this.turns.find(c => c.tokenId === tokenId);
	}
	 /* -------------------------------------------- */
	 /**
	 * Set initiative for a single Combatant within the Combat encounter.
	 * Turns will be updated to keep the same combatant as current in the turn order
	 * @param {string} id         The combatant ID for which to set initiative
	 * @param {number} value      A specific initiative value to set
	 */
	async setInitiative(id, value) {
		const currentId = this.combatant._id;
		await this.updateCombatant({_id: id, initiative: value}, {});
		await this.update({turn: this.turns.findIndex(c => c._id === currentId)});
	}
	 /* -------------------------------------------- */
	 /**
	 * Roll initiative for one or multiple Combatants within the Combat entity
	 * @param {string|string[]} ids     A Combatant id or Array of ids for which to roll
	 * @param {string|null} [formula]   A non-default initiative formula to roll. Otherwise the system default is used.
	 * @param {boolean} [updateTurn]    Update the Combat turn after adding new initiative scores to keep the turn on
	 *                                  the same Combatant.
	 * @param {object} [messageOptions] Additional options with which to customize created Chat Messages
	 * @return {Promise<Combat>}        A promise which resolves to the updated Combat entity once updates are complete.
	 */
	async rollInitiative(ids, {formula=null, updateTurn=true, messageOptions={}}={}) {
		 // Structure input data
		ids = typeof ids === "string" ? [ids] : ids;
		const currentId = this.combatant._id;
		 // Iterate over Combatants, performing an initiative roll for each
		const [updates, messages] = ids.reduce((results, id, i) => {
			let [updates, messages] = results;
			 // Get Combatant data
			const c = this.getCombatant(id);
			if ( !c || !c.owner ) return results;
			 // Roll initiative
			const cf = formula || this._getInitiativeFormula(c);
			const roll = this._getInitiativeRoll(c, cf);
			updates.push({_id: id, initiative: roll.total});
			 // Determine the roll mode
			let rollMode = messageOptions.rollMode || game.settings.get("core", "rollMode");
			if (( c.token.hidden || c.hidden ) && (rollMode === "roll") ) rollMode = "gmroll";
			 // Construct chat message data
			let messageData = mergeObject({
				speaker: {
					scene: canvas.scene._id,
					actor: c.actor ? c.actor._id : null,
					token: c.token._id,
					alias: c.token.name
				},
				flavor: `${c.token.name} rolls for Initiative!`,
				flags: {"core.initiativeRoll": true}
			}, messageOptions);
			const chatData = roll.toMessage(messageData, {create:false, rollMode});
			 // Play 1 sound for the whole rolled set
			if ( i > 0 ) chatData.sound = null;
			messages.push(chatData);
			 // Return the Roll and the chat data
			return results;
		}, [[], []]);
		if ( !updates.length ) return this;
		 // Update multiple combatants
		await this.updateEmbeddedEntity("Combatant", updates);
		 // Ensure the turn order remains with the same combatant
		if ( updateTurn ) {
			await this.update({turn: this.turns.findIndex(t => t._id === currentId)});
		}
		 // Create multiple chat messages
		await CONFIG.ChatMessage.entityClass.create(messages);
		 // Return the updated Combat
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Acquire the default dice formula which should be used to roll initiative for a particular combatant.
	 * Modules or systems could choose to override or extend this to accommodate special situations.
	 * @private
	 *
	 * @param {object} combatant      Data for the specific combatant for whom to acquire an initiative formula. This
	 *                                is not used by default, but provided to give flexibility for modules and systems.
	 * @return {string}               The initiative formula to use for this combatant.
	 */
	_getInitiativeFormula(combatant) {
		return CONFIG.Combat.initiative.formula || game.system.data.initiative;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get a Roll object which represents the initiative roll for a given combatant.
	 * @private
	 * @param {object} combatant      Data for the specific combatant for whom to acquire an initiative formula. This
	 *                                is not used by default, but provided to give flexibility for modules and systems.
	 * @param {string} formula        An explicit Roll formula to use for the combatant.
	 * @return {Roll}                 The Roll instance to use for the combatant.
	 */
	_getInitiativeRoll(combatant, formula) {
		const rollData = combatant.actor ? combatant.actor.getRollData() : {};
		return Roll.create(formula, rollData).roll();
	}
	 /* -------------------------------------------- */
	 /**
	 * Roll initiative for all non-player actors who have not already rolled
	 * @param {...*}  args    Additional arguments forwarded to the Combat.rollInitiative method
	 */
	async rollNPC(...args) {
		const npcs = this.turns.filter(t => (!t.actor || !t.players.length) && !t.initiative);
		return this.rollInitiative(npcs.map(t => t._id), ...args);
	}
	 /* -------------------------------------------- */
	 /**
	 * Roll initiative for all combatants which have not already rolled
	 * @param {...*} args     Additional arguments forwarded to the Combat.rollInitiative method
	 */
	async rollAll(...args) {
		const unrolled = this.turns.filter(t => t.owner && !t.initiative);
		return this.rollInitiative(unrolled.map(t => t._id), ...args);
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a new Combatant embedded entity
	 * @see {@link Combat#createEmbeddedEntity}
	 */
	async createCombatant(data, options) {
		return this.createEmbeddedEntity("Combatant", data, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Update an existing Combatant embedded entity
	 * @see {@link Combat#updateEmbeddedEntity}
	 */
	async updateCombatant(data, options) {
		return this.updateEmbeddedEntity("Combatant", data, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Delete an existing Combatant embedded entity
	 * @see {@link Combat#deleteEmbeddedEntity}
	 */
	async deleteCombatant(id, options) {
		return this.deleteEmbeddedEntity("Combatant", id, options);
	}
	 /* -------------------------------------------- */
	/*  Socket Events and Handlers
	/* -------------------------------------------- */
	 /** @override */
	_onCreate(...args) {
		if ( !this.collection.viewed ) ui.combat.initialize({combat: this});
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onUpdate(data, ...args) {
	 super._onUpdate(data, ...args);
		this.previous = this.current;
		// If the Combat was set as active, initialize the sidebar
		if ( (data.active === true) && ( this.data.scene === game.scenes.viewed._id ) ) {
			ui.combat.initialize({combat: this});
		}
		 // Render the sidebar
		if ( ["combatants", "round", "turn"].some(k => data.hasOwnProperty(k)) ) {
			if ( data.combatants ) this.setupTurns();
			ui.combat.scrollToTurn();
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDelete(...args) {
		if ( this.collection.viewed === this ) ui.combat.initialize();
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDeleteEmbeddedEntity(embeddedName, child, options, userId) {
		super._onDeleteEmbeddedEntity(embeddedName, child, options, userId);
		const deletedTurn = this.turns.findIndex(t => t._id === child._id);
		if ( deletedTurn <= this.turn ) return this.update({turn: this.turn - 1});
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onModifyEmbeddedEntity(...args) {
		this.setupTurns();
		if ( this === this.collection.viewed ) this.collection.render();
	}
}

/**
 * The Folders EntityCollection
 * @extends {EntityCollection}
 */
class Folders extends EntityCollection {
	constructor(...args) {
		super(...args);
		 /**
		 * This tracks which folders are currently expanded in the UI
		 * @private
		 */
		this._expanded = {};
	}
	 /* -------------------------------------------- */
	 /** @override */
	get entity() {
		return "Folder";
	}
	 /* -------------------------------------------- */
	 /** @override */
	render(force, context) {
	 if ( context && context.entities.length ) {
			const folder = context.entities[0];
			const collection = folder.collection;
			collection.render(force, context);
			if ( collection.entity === "JournalEntry" ) {
				this._refreshJournalEntrySheets();
			}
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Refresh the display of any active JournalSheet instances where the folder list will change.
	 * @private
	 */
	_refreshJournalEntrySheets() {
		for ( let app of Object.values(ui.windows) ) {
			if ( !(app instanceof JournalSheet) ) continue;
			app.submit();
		}
	}
}
	/* -------------------------------------------- */
	/**
 * The Folder Entity
 * @extends {Entity}
 */
class Folder extends Entity {
	 /** @override */
	static get config() {
		return {
			baseEntity: Folder,
			collection: game.folders,
			embeddedEntities: {},
			label: "ENTITY.Folder"
		};
	}
	 /* -------------------------------------------- */
	 /**
	 * Return whether the folder is displayed in the sidebar to the current user
	 * @type {boolean}
	 */
	get displayed() {
		return game.user.isGM || !!this.content.length || this.children.some(c => c.displayed);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return whether the folder is currently expanded within the sidebar interface
	 * @type {boolean}
	 */
	get expanded() {
		return game.folders._expanded[this.id] || false;
	}
	 /* -------------------------------------------- */
	 /**
	 * A reference to the parent Folder if one is set, otherwise null
	 * @type {Folder|null}
	 */
	get parent() {
		return this.constructor.collection.get(this.data.parent);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the named Entity type for elements in this folder.
	 * @return {string}
	 */
	get type() {
		return this.data.type;
	}
	 /* -------------------------------------------- */
	 /**
	 * A reference to the EntityCollection of Entities for this folder type.
	 * @return {EntityCollection}
	 */
	get collection() {
		return Object.values(game).find(c => c.object && c.object.entity === this.type);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return an Array of the Entities which are contained within this Folder
	 * @type {Entity[]}
	 */
	get entities() {
		const cls = CONFIG[this.data.type].entityClass;
		return cls.collection.entities.filter(e => e.data.folder === this._id);
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a new Folder by rendering a dialog window to provide basic creation details
	 * @param {object} data       Initial data with which to populate the creation form
	 * @param {object} options    Initial positioning and sizing options for the dialog form
	 * @return {FolderConfig}     An active FolderConfig instance for creating the new Folder entity
	 */
	static createDialog(data={}, options={}) {
		const folder = new Folder(mergeObject({sorting: "a"}, data));
		return new FolderConfig(folder, options).render(true);
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /**
	 * Export all Entities contained in this Folder to a given Compendium pack.
	 * Optionally update existing Entities within the Pack by name, otherwise append all new entries.
	 * @param {Compendium} pack       A Compendium pack to which the entities will be exported
	 * @param {boolean} updateByName  Update existing entries in the Compendium pack, matching by name
	 * @return {Promise<Compendium>}  The updated Compendium Pack
	 */
	async exportToCompendium(pack, {updateByName=false}={}) {
		const index = await pack.getIndex();
		const entities = this.entities;
		ui.notifications.info(`Exporting ${entities.length} ${this.type} entities to Compendium ${pack.collection}.`);
		for ( let e of this.entities ) {
			const data = await e.toCompendium();
			let existing = updateByName ? index.find(i => i.name === e.name) : index.find(i => i._id === e.id);
			if ( existing ) data._id = existing._id;
			if ( data._id ) await pack.updateEntity(data);
			else await pack.createEntity(data);
			console.log(`Exported ${e.name} to ${pack.collection}`);
		}
		ui.notifications.info(`Finished exporting ${this.type}s to Compendium ${pack.collection}.`);
		return pack;
	}
	 /* -------------------------------------------- */
	 /**
	 * Provide a dialog form that allows for exporting the contents of a Folder into an eligible Compendium pack.
	 * @param {string} pack       A pack ID to set as the default choice in the select input
	 * @param {object} options    Additional options passed to the Dialog.prompt method
	 * @return {Promise<void>}    A Promise which resolves or rejects once the dialog has been submitted or closed
	 */
	async exportDialog(pack, options={}) {
		 // Get eligible pack destinations
		const packs = game.packs.filter(p => (p.entity === this.type) && !p.locked);
		if ( !packs.length ) {
			return ui.notifications.warn(game.i18n.format("FOLDER.ExportWarningNone", {type: this.type}));
		}
		 // Render the HTML form
		const html = await renderTemplate("templates/sidebar/apps/folder-export.html", {
			packs: packs.reduce((obj, p) => {
				obj[p.collection] = p.title;
				return obj;
			}, {}),
			pack: options.pack ?? null,
			merge: options.merge ?? true
		});
		 // Display it as a dialog prompt
		return Dialog.prompt({
			title: game.i18n.localize("FOLDER.ExportTitle") + `: ${this.name}`,
			content: html,
			label: game.i18n.localize("FOLDER.ExportTitle"),
			callback: html => {
				const form = html[0].querySelector("form");
				const pack = game.packs.get(form.pack.value);
				return this.exportToCompendium(pack, {updateByName: form.merge.checked});
			},
			options
		});
	}
	 /* -------------------------------------------- */
	/*  Socket Workflows                            */
	/* -------------------------------------------- */
	 /** @override */
	static _handleDelete({request, result, userId}) {
		const {deleted, newParent, deleteFolderIds, moveFolderIds, deleteEntityIds, moveEntityIds} = result;
		const folders = this.collection;
		const folder = folders.get(deleted);
		const entities = folder.collection;
		 // Move Entities
		for (let id of moveEntityIds) {
			let ent = entities.get(id);
			ent.data.folder = newParent;
		}
		 // Move Folders
		for (let id of moveFolderIds) {
			let f = folders.get(id);
			f.data.parent = newParent;
		}
		 // Delete Entities
		if ( deleteEntityIds.length ) {
			entities.object._handleDelete({
				request: {type: entities.object.entity, options: {render: false}},
				result: deleteEntityIds,
				userId: userId
			});
		}
		 // Delete Folders
		if ( deleteFolderIds.length ) {
			super._handleDelete({
				request: request,
				result: deleteFolderIds,
				userId: userId
			})
		}
		 // Return the deleted Folder
		return folder;
	}
}

/**
 * The EntityCollection of Item entities
 * The items collection is accessible within the game as game.items
 *
 * @type {EntityCollection}
 */
class Items extends EntityCollection {
	 /** @override */
	get entity() {
		return "Item";
	}
	 /* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */
	 /**
	 * Register an Actor sheet class as a candidate which can be used to display Actors of a given type
	 * See EntitySheetConfig.registerSheet for details
	 */
	static registerSheet(...args) {
		EntitySheetConfig.registerSheet(Item, ...args);
	}
	 /* -------------------------------------------- */
	 /**
	 * Unregister an Actor sheet class, removing it from the list of avaliable sheet Applications to use
	 * See EntitySheetConfig.unregisterSheet for details
	 */
	static unregisterSheet(...args) {
		EntitySheetConfig.unregisterSheet(Item, ...args)
	}
	 /* -------------------------------------------- */
	 /**
	 * Return an Array of currently registered sheet classes for this Entity type
	 * @type {ItemSheet[]}
	 */
	static get registeredSheets() {
		const sheets = new Set();
		for (let t of Object.values(CONFIG.Item.sheetClasses)) {
			for (let s of Object.values(t)) {
				sheets.add(s.cls);
			}
		}
		return Array.from(sheets);
	}
}
	/* -------------------------------------------- */
	/**
 * The Item entity.
 * This base Item refers primarily to items which are not currently owned.
 * @implements {Entity}
 */
class Item extends Entity {
	 /** @override */
	static get config() {
		return {
			baseEntity: Item,
			collection: game.items,
			embeddedEntities: {
				"ActiveEffect": "effects"
			},
			label: "ENTITY.Item",
			permissions: {
				create: "ITEM_CREATE"
			}
		};
	}
	/* -------------------------------------------- */
	 /** @override */
	get uuid() {
		if ( this.actor ) return `Actor.${this.actor.id}.OwnedItem.${this.id}`;
		return super.uuid;
	}
	 /* -------------------------------------------- */
	 /** @override */
	prepareData() {
		this.data = duplicate(this._data);
		if (!this.data.img) this.data.img = CONST.DEFAULT_TOKEN;
		if (!this.data.name) this.data.name = "New " + this.entity;
		this.prepareEmbeddedEntities();
	}
	 /* -------------------------------------------- */
	 /** @override */
	prepareEmbeddedEntities() {
		this.effects = this._prepareActiveEffects(this.data.effects || []);
	}
	 /* -------------------------------------------- */
	 /**
	 * Prepare a Collection of ActiveEffect instances which belong to this Item.
	 * @param {object[]} effects      The raw array of active effect objects
	 * @return {Collection<string,ActiveEffect>}  The prepared active effects collection
	 * @private
	 */
	_prepareActiveEffects(effects) {
		const prior = this.effects;
		const c = new Collection();
		for ( let e of effects ) {
			let effect = null;
			if ( prior && prior.has(e._id) ) {
				effect = prior.get(e._id);
				effect.data = e;
				effect.prepareData();
			}
			else effect = ActiveEffect.create(e, this);
			c.set(e._id, effect);
		}
		return c;
	}
	 /* -------------------------------------------- */
	 /**
	 * Prepare a data object which defines the data schema used by dice roll commands against this Item
	 * @return {Object}
	 */
	getRollData() {
		return duplicate(this.data.data);
	}
	 /* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /**
	 * A convenience reference to the Actor entity which owns this item, if any
	 * @type {Actor|null}
	 */
	get actor() {
		return this.options.actor || null;
	}
	 /* -------------------------------------------- */
	 /**
	 * A convenience reference to the image path (data.img) used to represent this Item
	 * @type {string}
	 */
	get img() {
		return this.data.img;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return an array of the Active Effect instances which originated from this Item.
	 * If the Item is owned, the returned instances are the ActiveEffect instances which exist on the owning Actor.
	 * If the Item is unowned, the returned instances are the ActiveEffect instances which exist on the Item itself.
	 * @type {ActiveEffect[]}
	 */
	get transferredEffects() {
		if ( this.isOwned ) {
			return this.actor.effects.filter(e => e.data.origin === this.uuid);
		} else {
			return this.effects.filter(e => e.data.transfer === true);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * A convenience reference to the item type (data.type) of this Item
	 * @type {string}
	 */
	get type() {
		return this.data.type;
	}
	 /* -------------------------------------------- */
	 /**
	 * A boolean indicator for whether the current game user has ONLY limited visibility for this Entity.
	 * @return {boolean}
	 */
	get limited() {
		if (this.isOwned) return this.actor.limited;
		else return super.limited;
	}
	 /* -------------------------------------------- */
	 /**
	 * A flag for whether the item is owned by an Actor entity
	 * @return {boolean}
	 */
	get isOwned() {
		return this.actor !== null;
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /**
	 * Override the standard permission test for Item entities as we need to apply a special check for owned items
	 * OwnedItems have permission that the player has for the parent Actor.
	 * @return {boolean}            Whether or not the user has the permission for this item
	 */
	hasPerm(...args) {
		if (this.actor) return this.actor.hasPerm(...args);
		else return super.hasPerm(...args);
	}
	 /* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */
	 /** @override */
	async update(data, options) {
		 // Case 1 - Update an OwnedItem within an Actor
		if (this.isOwned) {
			data._id = this.data._id;
			return this.actor.updateEmbeddedEntity("OwnedItem", data, options);
		}
		 // Case 2 - Standard Entity update procedure
		else return super.update(data, options);
	}
	 /* -------------------------------------------- */
	 /** @override */
	async delete(options) {
		if ( this.isOwned ) return this.actor.deleteEmbeddedEntity("OwnedItem", this.data._id, options);
		return super.delete(options);
	}
	 /* -------------------------------------------- */
	 /**
	 * A convenience constructor method to create an Item instance which is owned by an Actor
	 * @param {Object} itemData
	 * @param {Actor} actor
	 */
	static createOwned(itemData, actor) {
		let Item = CONFIG.Item.entityClass;
		return new Item(itemData, {actor: actor});
	}
}

/**
 * The Journal collection
 * @extends {EntityCollection}
 */
class Journal extends EntityCollection {
	 /** @override */
	get entity() {
		return "JournalEntry";
	}
	 /* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */
	 /**
	 * Open Socket listeners which transact JournalEntry data
	 * @private
	 */
	static socketListeners(socket) {
		socket.on("showEntry", this._showEntry.bind(this));
		socket.on("shareImage", ImagePopout._handleShareImage);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a received request to show a JournalEntry to the current client
	 * @param {string} entryId      The ID of the journal entry to display for other players
	 * @param {string} mode         The JournalEntry mode to display
	 * @param {boolean} force       Display the entry to all players regardless of normal permissions
	 * @private
	 */
	static async _showEntry(entryId, mode="text", force=true) {
		let entry = await fromUuid(entryId);
		if ( entry.entity !== "JournalEntry" ) return;
		if ( !force && !entry.visible ) return;
		 // Don't show an entry that has no content
		if ( mode === "image" && !entry.data.img ) return;
		else if ( mode === "text" && !entry.data.content ) return;
		 // Show the sheet with the appropriate mode
		entry.sheet.render(true, {sheetMode: mode});
	}
}
	/* -------------------------------------------- */
	/**
 * The JournalEntry class
 * @extends {Entity}
 */
class JournalEntry extends Entity {
	 /** @override */
	static get config() {
		return {
			baseEntity: JournalEntry,
			collection: game.journal,
			embeddedEntities: {},
			label: "ENTITY.JournalEntry",
			permissions: {
				create: "JOURNAL_CREATE"
			}
		};
	}
	 /* -------------------------------------------- */
	 /**
	 * A boolean indicator for whether or not the JournalEntry is visible to the current user in the directory sidebar
	 * @return {boolean}
	 */
	get visible() {
		return this.hasPerm(game.user, "OBSERVER", false);
	}
	/* -------------------------------------------- */
	 /**
	 * Return a reference to the Note instance for this JournalEntry in the current Scene, if any
	 * @type {Note}
	 */
	get sceneNote() {
	 return canvas.notes.placeables.find(n => n.data.entryId === this._id);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onCreate(data, options, userId) {
		if ( options.renderSheet && (userId === game.user._id) ) {
			const sheet = this.sheet;
			sheet._render(true, {action: "create", data}).then(() => sheet.activateEditor("content"));
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onUpdate(data, ...args) {
	 super._onUpdate(data, ...args);
		 // If permissions changed for an entry with corresponding map Notes, redraw them
		if ( ["name", "permission"].some(k => k in data) ) {
			canvas.notes.placeables.filter(n => n.data.entryId === this._id).forEach(n => n.draw());
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDelete(...args) {
		super._onDelete(...args);
		 // Remove the entry reference from any active Journal Notes.
		for ( let n of canvas.notes.placeables ) {
			if ( n.data.entryId === this.id ) {
				n.entry = null;
			}
		}
	}
	 /* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */
	 /**
	 * Show the JournalEntry to connected players.
	 * By default the entry will only be shown to players who have permission to observe it.
	 * If the parameter force is passed, the entry will be shown to all players regardless of normal permission.
	 *
	 * @param {string} mode     Which JournalEntry mode to display? Default is text.
	 * @param {boolean} force   Display the entry to all players regardless of normal permissions
	 * @return {Promise<void>}  A Promise that resolves back to the shown entry once the request is processed
	 */
	async show(mode="text", force=false) {
		if ( !this.owner ) throw new Error("You may only request to show Journal Entries which you own.");
		return new Promise((resolve) => {
			game.socket.emit("showEntry", this.uuid, mode, force, entry => {
				Journal._showEntry(this.uuid, mode, true);
				ui.notifications.info(game.i18n.format("JOURNAL.ActionShowSuccess", {
					mode: mode,
					title: this.name,
					which: force ? "all" : "authorized"
				}));
				return resolve();
			});
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * If the JournalEntry has a pinned note on the canvas, this method will animate to that note
	 * The note will also be highlighted as if hovered upon by the mouse
	 */
	panToNote({scale=1.5, duration=250}={}) {
		const note = this.sceneNote;
		if ( !note ) return;
		if ( note.visible && !canvas.notes._active ) canvas.notes.activate();
		canvas.animatePan({x: note.x, y: note.y, scale, duration}).then(() => {
			if ( canvas.notes._hover ) canvas.notes._hover._onMouseOut(new Event("mouseout"));
			note._onMouseOver(new Event("mouseover"));
		});
	}
}

/**
 * The EntityCollection of Macro entities
 * @extends {EntityCollection}
 */
class Macros extends EntityCollection {
	 /** @override */
	get entity() {
		return "Macro";
	}
	/* -------------------------------------------- */
	 /** @override */
	static get instance() {
		return game.macros;
	}
	/* -------------------------------------------- */
	 /** @override */
	get directory() {
		return ui.macros;
	}
	/* -------------------------------------------- */
	 /**
	 * Determine whether a given User is allowed to use JavaScript macros
	 * @param {User} user   The User entity to test
	 * @return {boolean}    Can the User use scripts?
	 */
	static canUseScripts(user) {
		return game.user.can("MACRO_SCRIPT");
	}
	 /* -------------------------------------------- */
	 /** @override */
	fromCompendium(data) {
		data = super.fromCompendium(data);
		data.author = game.user._id;
		return data;
	}
}
	/* -------------------------------------------- */
	/**
 * The Macro entity which implements a triggered chat or script expression which can be quickly activated by the user.
 * All users have permission to create and use chat-based Macros, but users must be given special permission to use
 * script-based macros.
 *
 * @extends {Entity}
 *
 * @see {@link Macros}        The EntityCollection of Macro entities
 * @see {@link MacroConfig}   The Macro Configuration sheet
 * @see {@link Hotbar}        The Hotbar interface application
 */
class Macro extends Entity {
	 /** @override */
	static get config() {
		return {
			baseEntity: Macro,
			collection: game.macros,
			embeddedEntities: {},
			label: "ENTITY.Macro"
		};
	}
	 /* -------------------------------------------- */
	 /**
	 * Is the current User the author of this macro?
	 * @type {boolean}
	 */
	get isAuthor() {
		return game.user._id === this.data.author;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static can(user, action, target) {
		switch ( action ) {
			case "create":
				return true;
			case "update":
				return game.user.isGM || target.isAuthor;
			case "delete":
				return game.user.isGM || target.isAuthor;
			default:
				return false;
		}
	}
	/* -------------------------------------------- */
	 /**
	 * Execute the Macro command
	 * @return {*}
	 */
	execute() {
		 // Chat macros
		if ( this.data.type === "chat" ) {
			ui.chat.processMessage(this.data.command).catch(err => {
				ui.notifications.error("There was an error in your chat message syntax.");
				console.error(err);
			});
		}
		 // Script macros
		else if ( this.data.type === "script" ) {
			if ( !Macros.canUseScripts(game.user) ) {
				return ui.notifications.warn(`You are not allowed to use JavaScript macros.`);
			}
			const speaker = ChatMessage.getSpeaker();
			const actor = game.actors.get(speaker.actor);
			const token = canvas.tokens.get(speaker.token);
			const character = game.user.character;
			try {
				eval(this.data.command);
			} catch (err) {
				ui.notifications.error(`There was an error in your macro syntax. See the console (F12) for details`);
				console.error(err);
			}
		}
	}
}

/**
 * A :class:`EntityCollection` of class:`ChatMessage` entities
 * The Messages collection is accessible within the game as `game.messages`.
 *
 * @type {EntityCollection}
 */
class Messages extends EntityCollection {
	 /** @override */
	get entity() {
		return "ChatMessage";
	}
	 /* -------------------------------------------- */
	 /** @override */
	render(force=false) {}
	 /* -------------------------------------------- */
	 /**
	 * If requested, dispatch a Chat Bubble UI for the newly created message
	 * @param {ChatMessage} message     The ChatMessage entity to say
	 * @private
	 */
	sayBubble(message) {
		const {content, type, speaker} = message.data;
		if ( speaker.scene === canvas.scene._id ) {
			const token = canvas.tokens.get(speaker.token);
			if ( token ) canvas.hud.bubbles.say(token, content, {
				emote: type === CONST.CHAT_MESSAGE_TYPES.EMOTE
			});
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle export of the chat log to a text file
	 * @private
	 */
	export() {
		const log = this.entities.map(m => m.export()).join("\n---------------------------\n");
		let date = new Date().toDateString().replace(/\s/g, "-");
		const filename = `fvtt-log-${date}.txt`;
		saveDataToFile(log, "text/plain", filename);
	}
	 /* -------------------------------------------- */
	 /**
	 * Allow for bulk deletion of all chat messages, confirm first with a yes/no dialog.
	 * @see {@link Dialog.confirm}
	 */
	async flush() {
		return Dialog.confirm({
			title: game.i18n.localize("CHAT.FlushTitle"),
			content: game.i18n.localize("CHAT.FlushWarning"),
			yes: () => this.object.delete([], {deleteAll: true}),
			options: {
				top: window.innerHeight - 150,
				left: window.innerWidth - 720
			}
		});
	}
}
	/* -------------------------------------------- */
	/**
 * The Chat Message class is a type of :class:`Entity` which represents individual messages in the chat log.
 * @extends {Entity}
 */
class ChatMessage extends Entity {
	constructor(...args) {
		super(...args);
		 /**
		 * Get a reference to the user who sent the chat message
		 */
		this.user = game.users.get(this.data.user);
		 /**
		 * If the Message contains a dice roll, store it here
		 */
		this._roll = null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Configure the attributes of the ChatMessage Entity
	 *
	 * @returns {Entity} baseEntity       The parent class which directly inherits from the Entity interface.
	 * @returns {EntityCollection} collection   The EntityCollection class to which Entities of this type belong.
	 * @returns {string[]} embeddedEntities  The names of any Embedded Entities within the Entity data structure.
	 */
	static get config() {
		return {
			baseEntity: ChatMessage,
			collection: game.messages,
			embeddedEntities: {},
			label: "ENTITY.ChatMessage"
		};
	}
	 /* -------------------------------------------- */
	/*  Properties and Attributes
	/* -------------------------------------------- */
	 /**
	 * Return the recommended String alias for this message.
	 * The alias could be a Token name in the case of in-character messages or dice rolls.
	 * Alternatively it could be a User name in the case of OOC chat or whispers.
	 * @type {string}
	 */
	get alias() {
		const speaker = this.data.speaker;
		if ( speaker.alias ) return speaker.alias;
		else if ( speaker.actor ) return game.actors.get(speaker.actor).name;
		else return this.user ? this.user.name : "";
	}
	 /* -------------------------------------------- */
	 /** @override */
	static can(user, action, target) {
		if ( action === "delete" ) return target.isAuthor || user.isGM;
		return super.can(user, action, target);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return whether the ChatMessage is visible to the current user
	 * Messages may not be visible if they are private whispers
	 * @type {boolean}
	 */
	get visible() {
		if ( this.data.whisper.length ) {
			if ( this.data.type === CONST.CHAT_MESSAGE_TYPES.ROLL ) return true;
			return (this.data.user === game.user._id) || (this.data.whisper.indexOf(game.user._id ) !== -1 );
		}
		return true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Is the current User the author of this message?
	 * @type {boolean}
	 */
	get isAuthor() {
		return game.user._id === this.user._id;
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether the chat message contains a dice roll
	 * @type {boolean}
	 */
	get isRoll() {
		return this.data.type === CONST.CHAT_MESSAGE_TYPES.ROLL;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return whether the content of the message is visible to the current user
	 * @type {boolean}
	 */
	get isContentVisible() {
		if ( this.isRoll ) {
			const whisper = this.data.whisper || [];
			const isBlind = whisper.length && this.data.blind;
			if ( whisper.length ) return whisper.includes(game.user._id) || (this.isAuthor && !isBlind);
			return true;
		}
		else return this.visible;
	}
	 /* -------------------------------------------- */
	 /** @override */
	get permission() {
		if ( game.user.isGM || this.isAuthor ) return CONST.ENTITY_PERMISSIONS.OWNER;
		else return CONST.ENTITY_PERMISSIONS.LIMITED;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the Roll instance contained in this chat message, if one is present
	 * @type {Roll}
	 */
	get roll() {
		if ( this._roll === null ) {
			try {
				this._roll = Roll.fromJSON(this.data.roll);
			} catch(err) {
				this._roll = false;
			}
		}
		return this._roll;
	}
	 /* -------------------------------------------- */
	/*  HTML Rendering
	/* -------------------------------------------- */
	 /**
	 * Render the HTML for the ChatMessage which should be added to the log
	 * @return {Promise.<HTMLElement>}
	 */
	async render(force, options) {
		 // Determine some metadata
		const data = duplicate(this.data);
		const isWhisper = this.data.whisper.length;
		const isVisible = this.isContentVisible;
		 // Construct message data
		const messageData = {
			message: data,
			user: game.user,
			author: this.user,
			alias: this.alias,
			cssClass: [
				this.data.type === CONST.CHAT_MESSAGE_TYPES.IC ? "ic" : null,
				this.data.type === CONST.CHAT_MESSAGE_TYPES.EMOTE ? "emote" : null,
				isWhisper ? "whisper" : null,
				this.data.blind ? "blind": null
			].filter(c => c !== null).join(" "),
			isWhisper: this.data.whisper.some(id => id !== game.user._id),
			whisperTo: this.data.whisper.map(u => {
				let user = game.users.get(u);
				return user ? user.name : null;
			}).filter(n => n !== null).join(", ")
		};
		 // Enrich some data for dice rolls
		if ( this.isRoll ) {
			 // Render public rolls if they do not already start with valid HTML
			const hasHTMLContent = data.content.slice(0, 1) === "<";
			if ( isVisible && !hasHTMLContent ) {
				data.content = await this.roll.render();
			}
			 // Conceal some private roll information
			if ( !isVisible ) {
				data.content = await this.roll.render({isPrivate: !isVisible});
				data.flavor = `${this.user.name} privately rolled some dice`;
				messageData.isWhisper = false;
				messageData.alias = this.user.name;
			}
		}
		 // Define a border color
		if ( this.data.type === CONST.CHAT_MESSAGE_TYPES.OOC ) {
			messageData.borderColor = this.user.color;
		}
		 // Render the chat message
		let html = await renderTemplate(CONFIG.ChatMessage.template, messageData);
		html = $(html);
		 // Call a hook for the rendered ChatMessage data
		Hooks.call("renderChatMessage", this, html, messageData);
		return html;
	}
	 /* -------------------------------------------- */
	/*  Socket Listeners and Handlers
	/* -------------------------------------------- */
	 /**
	 * @inheritdoc
	 * @see {@link Entity.create}
	 */
	static async create(data, options={}) {
		data = data instanceof Array ? data : [data];
		data = data.map(d => this._preprocessCreateData(d, options));
		return super.create(data, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Preprocess the data object used to create a new Chat Message to automatically convert some Objects to the
	 * data format expected by the database handler.
	 * @param {Object} data       Single ChatMessage creation data
	 * @param {string} [rollMode] The visibility mode applied to all dice rolls
	 * @return {Object}           Processed message creation data
	 * @private
	 */
	static _preprocessCreateData(data, {rollMode=null}={}) {
		 // Message creator
		if ( data.user instanceof User ) data.user = data.user._id;
		if ( (data.user !== game.user._id) && !game.user.isGM ) data.user = null;
		if ( !data.user ) data.user = game.user._id;
		 // Ensure to pass IDs rather than objects
		if ( data.speaker && data.speaker.actor instanceof Actor ) data.speaker.actor = data.speaker.actor._id;
		if ( data.speaker && data.speaker.scene instanceof Scene ) data.speaker.scene = data.speaker.scene._id;
		if ( data.speaker && data.speaker.token instanceof Token ) data.speaker.token = data.speaker.token.id;
		 // Whisper targets
		if ( data.whisper ) data.whisper = data.whisper.map(w => w instanceof User ? w._id : w);
		 // Serialize Roll data and apply roll modes
		if ( data.roll ) {
			data.roll =  (data.roll instanceof Roll) ? JSON.stringify(data.roll) : data.roll;
			rollMode = rollMode || data.rollMode || game.settings.get("core", "rollMode");
			if ( rollMode ) ChatMessage.applyRollMode(data, rollMode);
		}
		 // Enrich message content
		const actor = this.getSpeakerActor(data.speaker) || game.users.get(data.user).character;
		const rollData = actor ? actor.getRollData() : {};
		data.content = TextEditor.enrichHTML(data.content, {rollData});
		 // Return the ChatMessage creation data
		return data;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onCreate(data, options, userId) {
	 super._onCreate(data, options, userId);
	 ui.chat.postOne(this, true);
		if ( options.chatBubble && canvas.ready ) {
			this.collection.sayBubble(this);
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onUpdate(data, options, userId) {
	 if ( "roll" in data ) this._roll = null;
		ui.chat.updateMessage(this);
		super._onUpdate(data, options, userId);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDelete(...args) {
		ui.chat.deleteMessage(this.id, ...args);
	 super._onDelete(...args);
	}
	 /* -------------------------------------------- */
	/*  Saving and Loading
	/* -------------------------------------------- */
	 /**
	 * Export the content of the chat message into a standardized log format
	 * @return {string}
	 */
	export() {
		let content = [];
		 // Handle Roll content
		if ( this.isRoll ) {
			let r = this.roll;
			if ( this.data.content && (this.data.content !== "undefined")) {
				content.push($(`<div>${this.data.content}</div>`).text().trim());
			}
			let flavor = this.data.flavor;
			if ( flavor && flavor !== r.formula ) content.push(flavor);
			content.push(`${r.formula} = ${r.result} = ${r.total}`);
		}
		 // Handle HTML content
		else {
			const html = $("<article>").html(this.data["content"].replace(/<\/div>/g, "</div>|n"));
			const text = html.length ? html.text() : this.data["content"];
			const lines = text.replace(/\n/g, "").split("  ").filter(p => p !== "").join(" ");
			content = lines.split("|n").map(l => l.trim());
		}
		 // Author and timestamp
		const time = new Date(this.data.timestamp).toLocaleDateString('en-US', {
			hour: "numeric",
			minute: "numeric",
			second: "numeric"
		});
		 // Format logged result
		return `[${time}] ${this.alias}\n${content.filterJoin("\n")}`;
	}
	 /* -------------------------------------------- */
	 /**
	 * Transform a provided object of ChatMessage data by applying a certain rollMode to the data object.
	 * @param {object} chatData     The object of ChatMessage data prior to applying a rollMode preference
	 * @param {string} rollMode     The rollMode preference to apply to this message data
	 * @returns {object}            The modified ChatMessage data with rollMode preferences applied
	 */
	static applyRollMode(chatData, rollMode) {
		if ( ["gmroll", "blindroll"].includes(rollMode) ) chatData.whisper = ChatMessage.getWhisperRecipients("GM");
		else if ( rollMode === "selfroll" ) chatData.whisper = [game.user.id];
		if ( rollMode === "blindroll" ) chatData.blind = true;
		return chatData;
	}
	 /* -------------------------------------------- */
	 /**
	 * Given a string whisper target, return an Array of the user IDs which should be targeted for the whisper
	 *
	 * @param {string} name   The target name of the whisper target
	 * @return {User[]}       An array of User instances
	 */
	static getWhisperRecipients(name) {
		 // Whisper to groups
		if (["GM", "DM"].includes(name.toUpperCase())) {
			return game.users.entities.filter(u => u.isGM);
		}
		else if (name.toLowerCase() === "players") {
			return game.users.players;
		}
		 // Match against lowercase name
		const lname = name.toLowerCase();
		 // Whisper to a single person
		let user = game.users.entities.find(u => u.name.toLowerCase() === lname);
		if (user) return [user];
		let actor = game.users.entities.find(a => a.character && a.character.name.toLowerCase() === lname);
		if (actor) return [actor];
		 // Otherwise return an empty array
		return [];
	}
	 /* -------------------------------------------- */
	 /**
	 * Attempt to determine who is the speaking character (and token) for a certain Chat Message
	 * First assume that the currently controlled Token is the speaker
	 *
	 * @param {Scene} [scene]     The Scene in which the speaker resides
	 * @param {Actor} [actor]     The Actor whom is speaking
	 * @param {Token} [token]     The Token whom is speaking
	 * @param {string} [alias]     The name of the speaker to display
	 *
	 * @returns {Object}  The identified speaker data
	 */
	static getSpeaker({scene, actor, token, alias}={}) {
		 // CASE 1 - A Token is explicitly provided
		if ( token instanceof Token ) return this._getSpeakerFromToken({token, alias});
		const hasActor = actor instanceof Actor;
		if ( hasActor && actor.isToken ) return this._getSpeakerFromToken({token: actor.token, alias});
		 // CASE 2 - An Actor is explicitly provided
		if ( hasActor ) {
			alias = alias || actor.name;
			const tokens = actor.getActiveTokens();
			if ( !tokens.length ) return this._getSpeakerFromActor({scene, actor, alias});
			const controlled = tokens.filter(t => t._controlled);
			token = controlled.length ? controlled.shift() : tokens.shift();
			return this._getSpeakerFromToken({token, alias});
		}
		 // CASE 3 - Not the viewed Scene
		else if ( ( scene instanceof Scene ) && !scene.isView ) {
			const char = game.user.character;
			if ( char ) return this._getSpeakerFromActor({scene, actor: char, alias});
			return this._getSpeakerFromUser({scene, user: game.user, alias});
		}
		 // CASE 4 - Infer from controlled tokens
		let controlled = canvas.tokens.controlled;
		if ( controlled.length ) return this._getSpeakerFromToken({token: controlled.shift(), alias});
		 // CASE 5 - Infer from impersonated Actor
		const char = game.user.character;
		if ( char ) {
			const tokens = char.getActiveTokens();
			if ( tokens.length ) return this._getSpeakerFromToken({token: tokens.shift(), alias});
			return this._getSpeakerFromActor({actor: char, alias});
		}
		 // CASE 6 - From the alias and User
		return this._getSpeakerFromUser({scene, user: game.user, alias});
	}
	 /* -------------------------------------------- */
	 /**
	 * A helper to prepare the speaker object based on a target Token
	 * @private
	 */
	static _getSpeakerFromToken({token, alias}) {
		return {
			scene: token.scene?.id || null,
			token: token.id,
			actor: token.actor?.id || null,
			alias: alias || token.name
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * A helper to prepare the speaker object based on a target Actor
	 * @private
	 */
	static _getSpeakerFromActor({scene, actor, alias}) {
		return {
			scene: (scene || canvas.scene)?.id || null,
			actor: actor.id,
			token: null,
			alias: alias || actor.name
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * A helper to prepare the speaker object based on a target User
	 * @private
	 */
	static _getSpeakerFromUser({scene, user, alias}) {
		return {
			scene: (scene || canvas.scene)?.id || null,
			actor: null,
			token: null,
			alias: alias || user.name
		}
	}
	 /* -------------------------------------------- */
	/*  Roll Data Preparation                       */
	/* -------------------------------------------- */
	 /**
	 * Obtain a data object used to evaluate any dice rolls associated with this particular chat message
	 * @return {Object}
	 */
	getRollData() {
		const actor = this.constructor.getSpeakerActor(this.data.speaker);
		return actor ? actor.getRollData() : {};
	}
	 /* -------------------------------------------- */
	 /**
	 * Obtain an Actor instance which represents the speaker of this message (if any)
	 * @param {Object} speaker    The speaker data object
	 * @return {Actor|null}
	 */
	static getSpeakerActor(speaker) {
		if ( !speaker ) return null;
		let actor = null;
		 // Case 1 - Token actor
		if ( speaker.scene && speaker.token ) {
			const scene = game.scenes.get(speaker.scene);
			const tokenData = scene ? scene.getEmbeddedEntity("Token", speaker.token) : null;
			const token = tokenData ? new Token(tokenData) : null;
			actor = token ? token.actor : null;
		}
		 // Case 2 - explicit actor
		if ( speaker.actor && !actor ) {
			actor = game.actors.get(speaker.actor);
		}
		return actor || null;
	}
}

/**
 * The EntityCollection of Playlist entities.
 * @extends {EntityCollection}
 */
class Playlists extends EntityCollection {
	constructor(...args) {
		super(...args);
		Hooks.on("preUpdateScene", this._onUpdateScene.bind(this));
	}
	 /* -------------------------------------------- */
	 /** @override */
	get entity() {
		return "Playlist";
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the subset of Playlist entities which are currently playing
	 * @type {Playlist[]}
	 */
	get playing() {
		return this.entities.filter(s => s.data.playing);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle changes to a Scene to determine whether to trigger changes to Playlist entities.
	 * @param {Scene} scene       The Scene entity being updated
	 * @param {Object} data       Incremental update data
	 * @param {Object} options    Update options
	 * @private
	 */
	_onUpdateScene(scene, data, options) {
		const currentScene = game.scenes.active;
		scene = scene instanceof Scene ? scene : game.scenes.get(data._id); // this is a kind of temporary workaround
		const activeChange = data.active === true;
		const playlistChange = data.hasOwnProperty("playlist");
		if ( activeChange || (scene.data.active && playlistChange) ) {
			const currentPlaylist = currentScene && currentScene.playlist ? currentScene.playlist : null;
			const newPlaylist = playlistChange ? this.get(data.playlist) : scene.playlist;
			if ( (currentPlaylist === newPlaylist) && currentPlaylist && currentPlaylist.playing ) return;
			if ( currentPlaylist ) currentPlaylist.stopAll();
			if ( newPlaylist ) newPlaylist.playAll();
		}
	}
}
	/* -------------------------------------------- */
	/**
 * The Playlist Entity.
 * Each Playlist is a collection of Sounds which are used to provide background music and sound effects.
 * @extends {Entity}
 */
class Playlist extends Entity {
	constructor(...args) {
		super(...args);
		 /**
		 * Each sound which is played within the Playlist has a created Howl instance.
		 * The keys of this object are the sound IDs and the values are the Howl instances.
		 * @type {Object}
		 */
		this.audio = this.audio || {};
		 /**
		 * Playlists may have a playback order which defines the sequence of Playlist Sounds
		 * @type {string[]}
		 */
		this.playbackOrder = [];
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get config() {
		return {
			baseEntity: Playlist,
			collection: game.playlists,
			embeddedEntities: {"PlaylistSound": "sounds"},
			label: "ENTITY.Playlist"
		};
	}
	 /* -------------------------------------------- */
	 /** @override */
	prepareEmbeddedEntities() {
		this.audio = {};
		this.data.sounds.forEach(s => this._createAudio(s));
	}
	 /* -------------------------------------------- */
	 /**
	 * Set up the Howl object by calling the core AudioHelper utility
	 * @param {Object} sound    The PlaylistSound for which to create an audio object
	 * @return {Object}         The created audio object
	 * @private
	 */
	_createAudio(sound) {
		let howl = game.audio.create({src: sound.path, html5: sound.streaming});
		this.audio[sound._id] = {
			howl: howl,
			id: undefined,
			sound: sound._id
		};
		howl.on("end", () => this._onEnd(sound._id));
		 // Handle sounds which are currently playing
		if (sound.playing) {
			if (Howler.state === "suspended") game.audio.pending.push(() => this.playSound(sound));
			else this.playSound(sound);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * This callback triggers whenever a sound concludes playback
	 * Mark the concluded sound as no longer playing and possibly trigger playback for a subsequent sound depending on
	 * the playlist mode.
	 *
	 * @param {string} soundId  The sound ID of the track which is ending playback
	 * @private
	 */
	async _onEnd(soundId) {
		if (!game.user.isGM) return;
		 // Retrieve the sound object whose reference may have changed
		const sound = this.getEmbeddedEntity("PlaylistSound", soundId);
		if (sound.repeat) return;
		 // Conclude playback for the current sound
		const isPlaying = this.data.playing;
		await this.updateEmbeddedEntity("PlaylistSound", {_id: sound._id, playing: false});
		 // Sequential or shuffled playback -- begin playing the next sound
		if (isPlaying && [CONST.PLAYLIST_MODES.SEQUENTIAL, CONST.PLAYLIST_MODES.SHUFFLE].includes(this.mode)) {
			let next = this._getNextSound(sound._id);
			if (next) await this.updateEmbeddedEntity("PlaylistSound", {_id: next._id, playing: true});
			else await this.update({playing: false});
		}
		 // Simultaneous playback - check if all have finished
		else if (isPlaying && this.mode === CONST.PLAYLIST_MODES.SIMULTANEOUS) {
			let isComplete = !this.sounds.some(s => s.playing);
			if (isComplete) {
				await this.update({playing: false});
			}
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Generate a new playback order for the playlist.
	 * Use a seed for randomization to (hopefully) guarantee that all clients generate the same random order.
	 * The seed is based on the first 9 characters of the UTC datetime multiplied by the index order of the playlist.
	 * @private
	 */
	_getPlaybackOrder() {
		const idx = this.collection.entities.findIndex(e => e._id === this.data._id);
		const seed = Number(new Date().getTime().toString().substr(0, 9)) * idx;
		const mt = new MersenneTwister(seed);
		 // Draw a random order
		let shuffle = this.sounds.reduce((shuffle, s) => {
			shuffle[s._id] = mt.random();
			return shuffle;
		}, {});
		 // Return the playback order
		return this.sounds.map(s => s._id).sort((a, b) => shuffle[a] - shuffle[b]);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the next sound which should be played in the Playlist after the current sound completes
	 * @param {string} soundId    The ID of the currently playing sound
	 * @return {Object}           The sound data for the next sound to play
	 * @private
	 */
	_getNextSound(soundId) {
		 // Get the playback order
		let order;
		if (this.mode === CONST.PLAYLIST_MODES.SHUFFLE) {
			if (!this.playbackOrder.length) this.playbackOrder = this._getPlaybackOrder();
			order = this.playbackOrder;
		} else order = this.sounds.map(s => s._id);
		 // Cycle the playback index
		let idx = order.indexOf(soundId);
		if (idx === order.length - 1) idx = -1;
		 // Return the next sound
		return this.getEmbeddedEntity("PlaylistSound", order[idx + 1]);
	}
	 /* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /**
	 * An Array of the sound data contained within this Playlist entity
	 * @type {object[]}
	 */
	get sounds() {
		return this.data.sounds;
	}
	 /* -------------------------------------------- */
	 /**
	 * The playback mode for the Playlist instance
	 * @type {number}
	 */
	get mode() {
		return this.data.mode;
	}
	 /* -------------------------------------------- */
	 /**
	 * An indicator for whether any Sound within the Playlist is currently playing
	 * @type {boolean}
	 */
	get playing() {
		return this.sounds.some(s => s.playing);
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /**
	 * Play (or stop) a single sound from the Playlist
	 * @param sound {Object}       The sound object to begin playback
	 */
	playSound(sound) {
		 // Get the audio data
		const audio = this.audio[sound._id];
		 // Start playing
		if (sound.playing) {
			if (audio.howl.state() !== "loaded") audio.howl.load();
			if ( !audio.howl.playing(audio.id) ) audio.id = audio.howl.play(audio.id);
			let vol = sound.volume * game.settings.get("core", "globalPlaylistVolume");
			audio.howl.volume(vol, audio.id);
			audio.howl.loop(sound.repeat, audio.id);
		}
		 // End playback
		else audio.howl.stop(audio.id);
	}
	 /* -------------------------------------------- */
	 /**
	 * Begin simultaneous playback for all sounds in the Playlist.
	 * @returns {Promise<Playlist>} The updated Playlist entity
	 */
	async playAll() {
		const updateData = {};
		 // Handle different playback modes
		switch (this.mode) {
			 // Soundboard Only
			case CONST.PLAYLIST_MODES.DISABLED:
				updateData.playing = false;
				break;
			 // Sequential Playback
			case CONST.PLAYLIST_MODES.SEQUENTIAL:
				updateData.sounds = duplicate(this.data.sounds).map((s, i) => {
					s.playing = i === 0;
					return s;
				});
				updateData.playing = updateData.sounds.length > 0;
				break;
			 // Simultaneous - play all tracks
			case CONST.PLAYLIST_MODES.SIMULTANEOUS:
				updateData.sounds = duplicate(this.data.sounds).map(s => {
					s.playing = true;
					return s;
				});
				updateData.playing = updateData.sounds.length > 0;
				break;
			 // Shuffle - play random track
			case CONST.PLAYLIST_MODES.SHUFFLE:
				this.playbackOrder = this._getPlaybackOrder();
				updateData.sounds = duplicate(this.data.sounds).map(s => {
					s.playing = s._id === this.playbackOrder[0];
					return s;
				});
				updateData.playing = updateData.sounds.length > 0;
				break;
		}
		 // Update the Playlist
		return this.update(updateData);
	}
	 /* -------------------------------------------- */
	 /**
	 * End playback for any/all currently playing sounds within the Playlist.
	 * @returns {Promise<Playlist>} The updated Playlist entity
	 */
	async stopAll() {
		const sounds = duplicate(this.data.sounds).map(s => {
			s.playing = false;
			return s;
		});
		return this.update({playing: false, sounds: sounds});
	}
	 /* -------------------------------------------- */
	 /**
	 * Cycle the playlist mode
	 * @return {Promise.<Playlist>}   A promise which resolves to the updated Playlist instance
	 */
	async cycleMode() {
		 // Cycle the playback mode
		const modes = Object.values(CONST.PLAYLIST_MODES);
		let mode = this.mode + 1;
		mode = mode > Math.max(...modes) ? modes[0] : mode;
		 // Stop current playback
		let sounds = this.data.sounds.map(s => {
			s.playing = false;
			return s;
		});
		 // Update the playlist
		return this.update({sounds: sounds, mode: mode});
	}
	 /* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */
	 /** @override */
	_onUpdate(response) {
		// Modify playback for individual sounds
		this.sounds.forEach(s => this.playSound(s));
		return super._onUpdate(response);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onCreateEmbeddedEntity(embeddedName, child, options, userId) {
		this._createAudio(child);
		return super._onCreateEmbeddedEntity(embeddedName, child, options, userId);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onUpdateEmbeddedEntity(embeddedName, child, updateData, options, userId) {
		const changed = Object.keys(updateData);
		 // If the path was changed, we need to re-create the audio object
		if ( changed.includes("path") ) {
			const audio = this.audio[child._id];
			audio.howl.stop(audio.id);
			this._createAudio(child);
		}
		 // Otherwise update the playing state
		else this.playSound(child);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDeleteEmbeddedEntity(embeddedName, child, options, userId) {
		child.playing = false;
		this.playSound(child);
		delete this.audio[child._id];
		return super._onDeleteEmbeddedEntity(embeddedName, child, options, userId);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onModifyEmbeddedEntity(...args) {
		this.collection.render();
	}
	 /* -------------------------------------------- */
	/*  Importing and Exporting                     */
	/* -------------------------------------------- */
	 /** @override */
	async toCompendium() {
		const data = await super.toCompendium();
		data.playing = false;
		for ( let s of data.sounds ) {
			s.playing = false;
		}
		return data;
	}
}

/**
 * The collection of Scene entities
 */
class Scenes extends EntityCollection {
	 /** @override */
	get entity() {
		return "Scene";
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a reference to the Scene which is currently active
	 * @return {Scene}
	 */
	get active() {
		return this.entities.find(s => s.active);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a reference to the Scene which is currently viewed
	 * @return {Scene}
	 */
	get viewed() {
		return this.entities.find(s => s.isView);
	}
	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */
	 /** @override */
	static socketListeners(socket) {
		socket.on('modifyDocument', this._resetFog.bind(this));
		socket.on('preloadScene', sceneId => this.instance.preload(sceneId));
		socket.on('pullToScene', this._pullToScene);
	}
	 /* -------------------------------------------- */
	 /**
	 * Augment the standard modifyDocument listener to flush fog exploration
	 * @private
	 */
	static _resetFog(response) {
		const { request, result } = response;
		if ( (request.type === "FogExploration") && ( request.action === "delete" ) && result.reset && (result.scene === canvas.scene._id) ) {
			return canvas.sight._onResetFog(result);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle pre-loading the art assets for a Scene
	 * @param {string} sceneId    The Scene id to begin loading
	 * @param {boolean} push      Trigger other connected clients to also pre-load Scene resources
	 */
	preload(sceneId, push=false) {
		if ( push ) return game.socket.emit('preloadScene', sceneId, () => this.preload(sceneId));
		let scene = this.get(sceneId);
		return TextureLoader.loadSceneTextures(scene);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle requests pulling the current User to a specific Scene
	 * @param {string} sceneId
	 * @private
	 */
	static _pullToScene(sceneId) {
		const scene = game.scenes.get(sceneId);
		if ( scene ) scene.view();
	}
	 /* -------------------------------------------- */
	 /** @override */
	fromCompendium(data) {
		data = super.fromCompendium(data);
		data.active = false;
		data.navigation = false;
		return data;
	}
}
	/* -------------------------------------------- */
/*  The Scene Entity                            */
/* -------------------------------------------- */
	/**
 * The Scene Entity.
 * Scenes represent the locations and settings which Actors will explore within the World.
 * @extends {Entity}
 */
class Scene extends Entity {
	constructor(...args) {
		super(...args);
		 /**
		 * Track whether the scene is the active view
		 * @type {boolean}
		 */
		this._view = this.data.active;
		 /**
		 * Track the viewed position of each scene (while in memory only, not persisted)
		 * When switching back to a previously viewed scene, we can automatically pan to the previous position.
		 * Object with keys: x, y, scale
		 * @type {Object}
		 */
		this._viewPosition = {};
	}
	 /* -------------------------------------------- */
	 /** @extends {EntityCollection.config} */
	static get config() {
		return {
			baseEntity: Scene,
			collection: game.scenes,
			embeddedEntities: {
				"AmbientLight": "lights",
				"AmbientSound": "sounds",
				"Drawing": "drawings",
				"Note": "notes",
				"MeasuredTemplate": "templates",
				"Tile": "tiles",
				"Token": "tokens",
				"Wall": "walls"
			},
			label: "ENTITY.Scene"
		};
	}
	/* -------------------------------------------- */
	 /** @override */
	prepareData() {
		super.prepareData();
		this.data.shiftX = Math.round(this.data.shiftX);
		this.data.shiftY = Math.round(this.data.shiftY);
		this.data.size = Math.round(this.data.size);
		return this.data;
	}
	/* -------------------------------------------- */
	 /** @override */
	prepareEmbeddedEntities() {}
	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /**
	 * A convenience accessor for the background image of the Scene
	 * @type {string}
	 */
	get img() {
	 return this.data.img;
	}
	/* -------------------------------------------- */
	 /**
	 * A convenience accessor for whether the Scene is currently active
	 * @type {boolean}
	 */
	get active() {
	 return this.data.active;
	}
	/* -------------------------------------------- */
	 /**
	 * A convenience accessor for whether the Scene is currently viewed
	 * @type {boolean}
	 */
	get isView() {
	 return this._view;
	}
	/* -------------------------------------------- */
	 /**
	 * A reference to the JournalEntry entity associated with this Scene, or null
	 * @return {JournalEntry|null}
	 */
	get journal() {
		return this.data.journal ? game.journal.get(this.data.journal) : null;
	}
	/* -------------------------------------------- */
	 /**
	 * A reference to the Playlist entity for this Scene, or null
	 * @type {Playlist|null}
	 */
	get playlist() {
		return this.data.playlist ? game.playlists.get(this.data.playlist) : null;
	}
	/* -------------------------------------------- */
	 /**
	 * Set this scene as the current view
	 * @return {Promise<void>}
	 */
	async view() {
		// Do not switch if the loader is still running
		if ( canvas.loading ) {
			return ui.notifications.warn(`You cannot switch Scenes until resources finish loading for your current view.`);
		}
		 // Switch the viewed scene
		this.collection.entities.forEach(scene => {
			scene._view = scene._id === this._id;
		});
		 // Re-draw the canvas if the view is different
		if ( canvas.id !== this._id ) {
			console.log(`Foundry VTT | Viewing Scene ${this.name}`);
			await canvas.draw();
		}
		 // Render apps for the collection
		this.collection.render();
		ui.combat.initialize();
	}
	/* -------------------------------------------- */
	 /**
	 * Set this scene as currently active
	 * @return {Promise<Scene>}  A Promise which resolves to the current scene once it has been successfully activated
	 */
	async activate() {
	 if ( this.active ) return this;
	 return this.update({active: true});
	}
	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */
	 /** @override */
	async clone(createData={}, options={}) {
		createData["active"] = false;
		createData["navigation"] = false;
		return super.clone(createData, options);
	}
	/* -------------------------------------------- */
	 /** @override */
	static async create(data, options={}) {
		if ( (getType(data) === "Object") && !canvas?.scene && (data.active ?? true)) {
			data.active = true; // Automatically set the first Scene as active
		}
		return super.create(data, options);
	}
	/* -------------------------------------------- */
	 /** @override */
	async update(data, options={}) {
		// Determine what type of change has occurred
		const hasDefaultDims = (this.data.width === 4000 ) && ( this.data.height === 3000 );
		const hasImage = data.img || this.data.img;
		const changedBackground = (data.img !== undefined) && (data.img !== this.data.img);
		const clearedDims = (data.width === null) || (data.height === null);
		const needsThumb = changedBackground || !this.data.thumb;
		const needsDims = data.img && (clearedDims || hasDefaultDims);
		 // Update thumbnail and image dimensions
		if ( hasImage && (needsThumb || needsDims) ) {
			let td = {};
			try {
				td = await this.createThumbnail({img: data.img ?? this.data.img});
			} catch(err) {
				ui.notifications.error("Thumbnail generation for Scene failed: " + err.message);
			}
			if ( needsThumb ) data.thumb = td.thumb || null;
			if ( needsDims ) {
				data.width = td.width;
				data.height = td.height;
			}
		}
		 // Warn the user if Scene dimensions are changing
		if ( options["fromSheet"] === true ) {
			const delta = diffObject(this.data, data);
			const changed = Object.keys(delta);
			if ( ["width", "height", "padding", "shiftX", "shiftY", "size"].some(k => changed.includes(k)) ) {
				const confirm = await Dialog.confirm({
					title: game.i18n.localize("SCENES.DimensionChangeTitle"),
					content: `<p>${game.i18n.localize("SCENES.DimensionChangeWarning")}</p>`
				});
				if ( !confirm ) return;
			}
			delete options["fromSheet"];
		}
		 // Call the Entity update
		return super.update(data, options);
	}
	/* -------------------------------------------- */
	 /** @override */
	_onCreate(data, ...args) {
		super._onCreate(data, ...args);
		if ( data.active === true ) this._onActivate(true);
	}
	/* -------------------------------------------- */
	 /** @override */
	_onUpdate(data, options, userId, context) {
		super._onUpdate(data, options, userId, context);
		 // Get the changed attributes
		let changed = new Set(Object.keys(data).filter(k => k !== "_id"));
		 // If the Scene became active, go through the full activation procedure
		if ( changed.has("active") ) this._onActivate(data.active);
		 // If the Thumbnail was updated, bust the image cache
		if ( changed.has("thumb") && this.data.thumb ) {
			this.data.thumb = this.data.thumb.split("?")[0] + `?${Date.now()}`;
		}
		 // If the scene is already active, maybe re-draw the canvas
		if ( canvas.scene === this ) {
			const redraw = [
				"backgroundColor", "drawings", "gridType", "grid", "gridAlpha", "gridColor", "gridDistance", "gridUnits",
				"shiftX", "shiftY", "width", "height", "img", "padding", "tokenVision", "fogExploration",
				"lights", "sounds", "templates", "tiles", "tokens", "walls", "weather"
			];
			if ( redraw.some(k => changed.has(k)) ) return canvas.draw();
			 // Modify global illumination
			if ( changed.has("globalLight") ) canvas.initializeSources();
			 // Progress darkness level
			if ( changed.has("darkness") ) {
				if ( options.animateDarkness ) canvas.lighting.animateDarkness(data.darkness);
				else canvas.lighting.refresh(data.darkness);
			}
		}
	}
	/* -------------------------------------------- */
	 /** @override */
	_onDelete(...args) {
		super._onDelete(...args);
		if ( canvas.scene?._id === this._id ) canvas.draw(null);
	}
	/* -------------------------------------------- */
	 /**
	 * Handle Scene activation workflow if the active state is changed to true
	 * @private
	 */
	_onActivate(active) {
		const collection = this.collection;
		if ( active ) {
			collection.entities.forEach(scene => scene.data.active = scene._id === this._id);
			return this.view();
		}
		else canvas.draw(null);
	}
	/* -------------------------------------------- */
	 /** @override */
	_onCreateEmbeddedEntity(embeddedName, child, options, userId) {
		if ( !canvas.ready || !this.isView ) return;
		const layer = canvas.getLayerByEmbeddedName(embeddedName);
		const object = layer.createObject(child);
		object._onCreate(options, userId);
		if ( options.renderSheet && object.sheet ) object.sheet.render(true);
	}
	/* -------------------------------------------- */
	 /** @override */
	_onUpdateEmbeddedEntity(embeddedName, child, updateData, options, userId) {
		if ( !canvas.ready || !this.isView ) return;
		const layer = canvas.getLayerByEmbeddedName(embeddedName);
		const object = layer.get(child._id);
		object.data = this.getEmbeddedEntity(embeddedName, child._id);
		object._onUpdate(updateData, options, userId);
	}
	/* -------------------------------------------- */
	 /** @override */
	_onDeleteEmbeddedEntity(embeddedName, child, options, userId) {
		if ( !canvas.ready || !this.isView ) return;
		const layer = canvas.getLayerByEmbeddedName(embeddedName);
		const object = layer.get(child._id);
		layer.objects.removeChild(object);
		object._onDelete(options, userId);
		object.destroy({children: true});
	}
	/* -------------------------------------------- */
	 /** @override */
	_onModifyEmbeddedEntity(...args) {
		if ( canvas.ready ) canvas.triggerPendingOperations();
	}
	 /* -------------------------------------------- */
	/*  History Storage Handlers                    */
	/* -------------------------------------------- */
	 /** @override */
	static _handleCreateEmbeddedEntity({request, result=[], userId}={}) {
		const { type, parentId, options } = request;
		if ( canvas.ready && !options.isUndo && (canvas.scene._id === parentId) ) {
			const layer = canvas.getLayerByEmbeddedName(type);
			layer.storeHistory("create", result);
		}
		return super._handleCreateEmbeddedEntity({request, result, userId});
	}
	 /* -------------------------------------------- */
	 /** @override */
	static _handleUpdateEmbeddedEntity({request, result=[], userId}={}) {
		const { type, parentId, options } = request;
		if ( canvas.ready && !options.isUndo && (canvas.scene._id === parentId) ) {
			const layer = canvas.getLayerByEmbeddedName(type);
			const scene = this.collection.get(parentId);
			const updatedIds = new Set(result.map(r => r._id));
			const originals = duplicate(scene.getEmbeddedCollection(type)).filter(o => updatedIds.has(o._id));
			layer.storeHistory("update", originals);
		}
		return super._handleUpdateEmbeddedEntity({request, result, userId});
	}
	 /* -------------------------------------------- */
	 /** @override */
	static _handleDeleteEmbeddedEntity({request, result=[], userId}={}) {
		const { type, parentId, options } = request;
		if ( canvas.ready && !options.isUndo && (canvas.scene._id === parentId) ) {
			const layer = canvas.getLayerByEmbeddedName(type);
			const scene = this.collection.get(parentId);
			const originals = scene.getEmbeddedCollection(type).filter(o => result.includes(o._id));
			layer.storeHistory("delete", originals);
		}
		return super._handleDeleteEmbeddedEntity({request, result, userId});
	}
	 /* -------------------------------------------- */
	/*  Importing and Exporting                     */
	/* -------------------------------------------- */
	 /** @override */
	async toCompendium() {
		const data = await super.toCompendium();
		data.active = false;
		data.navigation = false;
		data.navOrder = null;
		data.fogReset = null;
		if ( data.img ) {
			const t = await this.createThumbnail({img: data.img});
			data.thumb = t.thumb;
		}
		return data;
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a 300px by 100px thumbnail image for this scene background
	 * @param {string} [string|null]  A background image to use for thumbnail creation, otherwise the current scene
	 *                          background is used.
	 * @param {number} [width]        The desired thumbnail width. Default is 300px
	 * @param {number} [height]       The desired thumbnail height. Default is 100px;
	 * @return {Promise<object>}      The created thumbnail data.
	 */
	async createThumbnail({img, width=300, height=100}={}) {
		const tiles = this.data.tiles;
		const newImage = img !== undefined;
		 // Load required textures to create the thumbnail
		const toLoad = tiles.filter(t => t.img).map(t => t.img);
		img = img ?? this.data.img;
		if ( img ) toLoad.push(img);
		await TextureLoader.loader.load(toLoad);
		 // First load the background texture to get dimensions
		const bg = img ? await loadTexture(img) : null;
		 // Get the target dimensions for the canvas
		const dims = duplicate(this.data);
		if ( newImage ) {
			dims.width = bg.width;
			dims.height = bg.height;
		}
		const d = Canvas.getDimensions(dims);
		 // Create a container and add a transparent graphic to enforce the size
		const c = new PIXI.Container();
		const g = c.addChild(new PIXI.Graphics());
		g.beginFill(0xFFFFFF, 0.0).drawRect(0, 0, d.sceneWidth, d.sceneHeight);
		 // Add the background image
		if ( bg ) {
			const s = new PIXI.Sprite(bg);
			s.width = d.sceneWidth;
			s.height = d.sceneHeight;
			c.addChild(s);
		}
		 // Create a container with each tile
		const drawing = [];
		for ( let data of tiles ) {
			if ( data.hidden ) continue;
			const tile = new Tile(data, this);
			drawing.push(tile.draw());
			c.addChild(tile);
			tile.position.set(-d.paddingX, -d.paddingY);
		}
		await Promise.all(drawing);
		 // Render the container to a thumbnail
		return ImageHelper.createThumbnail(c, {width, height});
	}
}

/**
 * The EntityCollection of RollTable entities
 * @extends {EntityCollection}
 */
class RollTables extends EntityCollection {
	 /* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /** @override */
	get entity() {
		return "RollTable";
	}
	/* -------------------------------------------- */
	 /** @override */
	static get instance() {
		return game.tables;
	}
	/* -------------------------------------------- */
	 /** @override */
	get directory() {
		return ui.tables;
	}
	/* -------------------------------------------- */
	 /**
	 * Register world settings related to RollTable entities
	 */
	static registerSettings() {
		 // Show Player Cursors
		game.settings.register("core", "animateRollTable", {
			name: "TABLE.AnimateSetting",
			hint: "TABLE.AnimateSettingHint",
			scope: "world",
			config: true,
			default: true,
			type: Boolean
		});
	}
}
	/* -------------------------------------------- */
	/**
 * The RollTable entity which implements randomized rollable tables
 * @implements {Entity}
 */
class RollTable extends Entity {
	 /** @override */
	static get config() {
		return {
			baseEntity: RollTable,
			collection: game.tables,
			embeddedEntities: {"TableResult": "results"},
			label: "ENTITY.RollTable"
		};
	}
	/* -------------------------------------------- */
	 /** @override */
	prepareEmbeddedEntities() {}
	/* -------------------------------------------- */
	 /**
	 * A convenience accessor for the array of TableResult embedded documents
	 * @type {Array.<Object>}
	 */
	get results() {
		return this.data.results;
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /**
	 * Display a result drawn from a RollTable in the Chat Log along.
	 * Optionally also display the Roll which produced the result and configure aspects of the displayed messages.
	 *
	 * @param {object[]} results      An Array of one or more table results which were drawn and should be displayed
	 * @param {Roll} [roll]           An optional Roll instance which produced the drawn results
	 * @param {Object} [messageData]  Additional data which customizes the created messages
	 * @param {Object} [messageOptions] Additional options which customize the created messages
	 */
	async toMessage(results, {roll=null, messageData={}, messageOptions={}}={}) {
		const speaker = ChatMessage.getSpeaker({user: game.user});
		 // Construct chat data
		const nr = results.length > 1 ? `${results.length} results` : "a result";
		messageData = mergeObject({
			flavor: `Draws ${nr} from the ${this.name} table.`,
			user: game.user._id,
			speaker: speaker,
			type: CONST.CHAT_MESSAGE_TYPES.ROLL,
			roll: roll,
			sound: roll ? CONFIG.sounds.dice : null,
			flags: {"core.RollTable": this.id}
		}, messageData);
		 // Render the chat card which combines the dice roll with the drawn results
		messageData.content = await renderTemplate(CONFIG.RollTable.resultTemplate, {
			description: TextEditor.enrichHTML(this.data.description, {entities: true}),
			results: results.map(r => {
				r = duplicate(r);
				r.text = this._getResultChatText(r);
				r.icon = r.img || CONFIG.RollTable.resultIcon;
				return r;
			}),
			rollHTML: this.data.displayRoll ? await roll.render() : null,
			table: this
		});
		 // Create the chat message
		return ChatMessage.create(messageData, messageOptions);
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw a result from the RollTable based on the table formula or a provided Roll instance
	 * @param {Roll|null} [roll]        An existing Roll instance to use for drawing from the table
	 * @param {boolean} [recursive]     Allow drawing recursively from inner RollTable results
	 * @param {object[]} [results]      One or more table results which have been drawn
	 *
	 * @param {boolean} [displayChat]   Whether to automatically display the results in chat
	 * @param {string|null} [rollMode]  The chat roll mode to use when displaying the result
	 *
	 * @return {Promise<{roll: Roll, results: object[]}>}   A Promise which resolves to an object containing the
	 *                                                      executed roll and the produced results
	 */
	async draw({roll=null, recursive=true, results=[], displayChat=true, rollMode=null}={}) {
		 // If an array of results were not already provided, obtain them from the standard roll method
		if ( !results.length ) {
			const r = this.roll({roll, recursive});
			roll = r.roll;
			results = r.results;
		}
		if ( !results.length ) return { roll, results };
		 // Mark results as drawn, if replacement is not used and we are not in a Compendium pack
		if ( !this.data.replacement && !this.compendium) {
			const draws = this._getResultsForRoll(roll.total);
			await this.updateEmbeddedEntity("TableResult", draws.map(r => {
				return {_id: r._id, drawn: true};
			}));
		}
		 // Forward drawn results to create chat messages
		if ( displayChat ) {
			await this.toMessage(results, {
				roll: roll,
				messageOptions: {rollMode: rollMode}
			});
		}
		 // Return the roll and the produced results
		return {roll, results};
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw multiple results from a RollTable, constructing a final synthetic Roll as a dice pool of inner rolls.
	 * @param {number} number           The number of results to draw
	 * @param {Roll} [roll]             An optional pre-configured Roll instance which defines the dice roll to use
	 * @param {boolean} [recursive]     Allow drawing recursively from inner RollTable results
	 * @param {boolean} [displayChat]   Automatically display the drawn results in chat? Default is true
	 * @param {string} [rollMode]       Customize the roll mode used to display the drawn results
	 * @return {Promise<{roll: Roll, results: object[]}>}
	 */
	async drawMany(number, {roll=null, recursive=true, displayChat=true, rollMode=null}={}) {
		let results = [];
		let updates = [];
		const rolls = [];
		 // Roll the requested number of times, marking results as drawn
		for ( let n=0; n<number; n++ ) {
			let draw = this.roll({roll, recursive});
			rolls.push(draw.roll);
			results = results.concat(draw.results);
			 // Mark results as drawn, if replacement is not used and we are not in a Compendium pack
			if ( !this.data.replacement && !this.compendium) {
				updates = updates.concat(draw.results.map(r => {
					r.drawn = true;
					return {_id: r._id, drawn: true};
				}));
			}
		}
		 // Add all rolls to a Dice Pool
		const pool = new DicePool({rolls}).evaluate();
		 // Construct a "synthetic" roll object using the pool - this is a bit hacky
		roll = Roll.create(pool.formula).evaluate();
		roll.terms = [pool]
		roll._dice = pool.dice;
		roll.results = [pool.total];
		roll._total = pool.total;
		roll._rolled = true;
		 // Commit updates to child results
		if ( updates.length ) {
			await this.updateEmbeddedEntity("TableResult", updates, {diff: false});
		}
		 // Forward drawn results to create chat messages
		if ( displayChat ) {
			await this.toMessage(results, {
				roll: roll,
				messageOptions: {rollMode}
			});
		}
		 // Return the Roll and the array of results
		return {roll, results};
	}
	 /* -------------------------------------------- */
	 /**
	 * Normalize the probabilities of rolling each item in the RollTable based on their assigned weights
	 * @return {Promise}
	 */
	async normalize() {
	const results = duplicate(this.data.results);
	const totalWeight = results.reduce((total, result) => total + result.weight, 0);
	let counter = 1;
	for ( let r of results ) {
		r.range = [counter, counter+r.weight-1];
		counter = counter+r.weight;
	}
	return this.update({results: results, formula:`1d${totalWeight}`});
	}
	 /* -------------------------------------------- */
	 /**
	 * Reset the state of the RollTable to return any drawn items to the table
	 * @return {Promise}
	 */
	async reset() {
		const results = duplicate(this.data.results);
		for ( let r of results ) {
			r.drawn = false;
		}
		return this.update({results});
	}
	 /* -------------------------------------------- */
	 /**
	 * Evaluate a RollTable by rolling its formula and retrieving a drawn result.
	 *
	 * Note that this function only performs the roll and identifies the result, the RollTable#draw function should be
	 * called to formalize the draw from the table.
	 *
	 * @param {Roll} [roll]             An alternative dice Roll to use instead of the default formula for the table
	 * @param {boolean} recursive       If a RollTable entity is drawn as a result, recursively roll it
	 * @param {number} _depth           An internal flag used to track recursion depth
	 * @return {{roll: Roll, results: object[]}}   An object containing the executed roll and the produced results
	 *
	 * @example
	 * // Draw results using the default table formula
	 * const defaultResults = table.roll();
	 *
	 * // Draw results using a custom roll formula
	 * const roll = new Roll("1d20 + @abilities.wis.mod", actor.getRollData());
	 * const customResults = table.roll({roll});
	 */
	roll({roll, recursive=true, _depth=0}={}) {
		 // Prevent excessive recursion
		if ( _depth > 5 ) {
			throw new Error(`Maximum recursion depth exceeded when attempting to draw from RollTable ${this._id}`);
		}
		 // Reference the provided roll formula
		roll = roll instanceof Roll ? roll : Roll.create(this.data.formula);
		let results = [];
		 // Ensure that at least one non-drawn result remains
		const available = this.data.results.filter(r => !r.drawn);
		if ( !this.data.formula || !available.length ) {
			ui.notifications.warn("There are no available results which can be drawn from this table.");
			return {roll, results};
		}
		 // Ensure that results are available within the minimum/maximum range
		const minRoll = roll.clone().evaluate({minimize: true}).total;
		const maxRoll = roll.clone().evaluate({maximize: true}).total;
		const availableRange = available.reduce((range, result) => {
			if ( !range[0] || (result.range[0] < range[0]) ) range[0] = result.range[0];
			if ( !range[1] || (result.range[1] > range[1]) ) range[1] = result.range[1];
			return range;
		}, [null, null]);
		if ( (availableRange[0] > maxRoll) || (availableRange[1] < minRoll) ) {
			ui.notifications.warn("No results can possibly be drawn from this table and formula.");
			return {roll, results};
		}
		 // Continue rolling until one or more results are recovered
		let iter = 0;
		while ( !results.length ) {
			if ( iter >= 10000 ) {
				ui.notifications.error(`Failed to draw an available entry from Table ${this.name}, maximum iteration reached`);
				break;
			}
			roll = roll.reroll();
			results = this._getResultsForRoll(roll.total);
			iter++;
		}
		 // Draw results recursively from any inner Roll Tables
		if ( recursive ) {
			results = results.reduce((results, r) => {
				if ((r.type === CONST.TABLE_RESULT_TYPES.ENTITY) && (r.collection === "RollTable")) {
					const innerTable = game.tables.get(r.resultId);
					if (innerTable) {
						let innerRoll = innerTable.roll({_depth: _depth + 1});
						return results.concat(innerRoll.results);
					}
				}
				results.push(r);
				return results;
			}, []);
		}
		 // Return the Roll and the results
		return { roll, results }
	}
	 /* -------------------------------------------- */
	 /**
	 * Get an Array of valid results for a given rolled total
	 * @param {number} value    The rolled value
	 * @return {object[]}       An Array of results
	 * @private
	 */
	_getResultsForRoll(value) {
		return this.data.results.filter(r => !r.drawn && Number.between(value, ...r.range));
	}
	 /* -------------------------------------------- */
	 /**
	 * Get a string representation for the result which (if possible) will be a dynamic link or otherwise plain text
	 * @param {object} result   The result object
	 * @return {string}         The text to display
	 * @private
	 */
	_getResultChatText(result) {
		let text = result.text;
		if ( result.type === CONST.TABLE_RESULT_TYPES.ENTITY ) {
			text = `@${result.collection}[${result.resultId}]{${result.text}}`;
		} else if ( result.type === CONST.TABLE_RESULT_TYPES.COMPENDIUM ) {
			text = `@Compendium[${result.collection}.${result.resultId}]{${result.text}}`;
		}
		return text;
	}
	 /* -------------------------------------------- */
	/*  Table Result Management Methods             */
	/* -------------------------------------------- */
	 /** @extends {Entity.getEmbeddedEntity} */
	getTableResult(id) {
		return this.getEmbeddedEntity("TableResult", id);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onCreateEmbeddedEntity(...args) {
		this.collection.render();
		return super._onCreateEmbeddedEntity(...args);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDeleteEmbeddedEntity(...args) {
		this.collection.render();
		return super._onDeleteEmbeddedEntity(...args);
	}
	 /* -------------------------------------------- */
	/*  Importing and Exporting                     */
	/* -------------------------------------------- */
	 /** @override */
	async toCompendium() {
		const data = await super.toCompendium();
		for ( let r of data.results ) {
			r.drawn = false;
		}
		return data;
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a new RollTable entity using all of the Entities from a specific Folder as new results.
	 * @param {Folder} folder       The Folder entity from which to create a roll table
	 * @param {object} options      Additional options passed to the RollTable.create method
	 * @return {Promise<RollTable>}
	 */
	static async fromFolder(folder, options={}) {
		const results = folder.entities.map((e, i) => {
			return {
				text: e.name,
				type: CONST.TABLE_RESULT_TYPES.ENTITY,
				collection: folder.type,
				resultId: e.id,
				img: e.data.thumb || e.data.img,
				weight: 1,
				range: [i+1, i+1],
				drawn: false
			}
		});
		options.renderSheet = options.renderSheet ?? true;
		return this.create({
			name: folder.name,
			description: `A random table created from the contents of the ${folder.name} Folder.`,
			results: results,
			formula: `1d${results.length}`
		}, options);
	}
}
	/**
 * The collection of User entities which is accessible through game.users.
 * The array of User entities within this collection is accessible through game.users.entities.
 * @type {EntityCollection}
 */
class Users extends EntityCollection {
	constructor(...args) {
		super(...args);
		 /**
		 * The User entity of the currently connected user
		 * @type {User|null}
		 */
		this.current = this.current || null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize the Map object and all its contained entities
	 * @param {Object[]} data
	 * @private
	 */
	_initialize(data) {
		super._initialize(data);
		this.current = this.get(game.data.userId);
		this.current.active = true;
	}
	/* -------------------------------------------- */
	 /** @override */
	get entity() {
		return "User";
	}
	/* -------------------------------------------- */
	 /**
	 * Get the users with player roles
	 * @return {Array.<User>}
	 */
	get players() {
		return this.entities.filter(u => u.isRole("PLAYER") || u.isRole("TRUSTED"));
	}
	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */
	 /** @override */
	static socketListeners(socket) {
		socket.on('userActivity', this._handleUserActivity)
	}
	/* -------------------------------------------- */
	 /**
	 * Handle receipt of activity data from another User connected to the Game session
	 * @param {string} userId         The User id who generated the activity data
	 * @param {Object} activityData   The object of activity data
	 * @private
	 */
	static _handleUserActivity(userId, activityData={}) {
		if ( !game.ready ) return;
		const user = game.users.get(userId);
		let active = "active" in activityData ? activityData.active : true;
		 // User activity
		if ( user.active !== active ) {
			user.active = active;
			game.users.render();
			if ( active === false ) ui.nav.render();
		}
		 // Set viewed scene
		if ( "sceneId" in activityData ) {
			user.viewedScene = activityData.sceneId;
			ui.nav.render();
		}
		 // User control deactivation
		if ( (active === false) || (user.viewedScene !== canvas?.scene.id) ) {
			canvas.controls.updateCursor(user, null);
			canvas.controls.updateRuler(user, null);
			user.updateTokenTargets([]);
			return;
		}
		 // Cursor position
		if ( "cursor" in activityData ) {
			canvas.controls.updateCursor(user, activityData.cursor);
		}
		 // Ruler measurement
		if ( "ruler" in activityData ) {
			canvas.controls.updateRuler(user, activityData.ruler);
		}
		 // Token targets
		if ( "targets" in activityData ) {
			user.updateTokenTargets(activityData.targets);
		}
		 // TODO: Dispatch pings
		if ( activityData.ping ) {}
		 // TODO: Dispatch focus pulls
		if ( activityData.focus ) {}
	}
}
	/* -------------------------------------------- */
	/**
 * The User entity
 * Each player who connects to a Foundry Virtual Tabletop session is a User. 
 * Users represent human beings (or possibly programmatic players) and are the cornerstone of identity in Foundry VTT.
 * @implements {Entity}
 * 
 * @param {Object} data				The source data for the User entity, usually retrieved from the database.
 * @param {string} data._id			The Entity ID, automatically generated by the Database when a new User is created.
 * @param {string} data.password	An access key for the Entity.
 * @param {number} data.role		The role level for the User, from CONST.USER_ROLES
 * @param {Object} data.permissions	An object of key-value permissions for the User which extend the default functionality
									of the User's role.
 * @param {string} data.avatar		A web-accessible file path to an avatar image used to represent the User.
 * @param {string} data.character	The _id of the Actor entity that the User has chosen as their primary character.
 * @param {string} data.color		A color string which represents the visual color associated with this particular User.
 * @param {Object} data.flags		A free-form object of key-value pairs which allows modules and systems the ability 
									to store arbitrary data as part of the User object.    
 * @param {Object} options			Initialization options which modify the construction of a User entity. See the Entity
									class for more detail.
 */
class User extends Entity {
	constructor(data, options) {
		super(data, options);
		 /**
		 * Track whether the user is currently active in the game
		 * @type {boolean}
		 */
		this.active = data.active || false;
		 /**
		 * Track references to the current set of Tokens which are targeted by the User
		 * @type {Set.<Token>}
		 */
		this.targets = new UserTargets(this);
		 /**
		 * Track the ID of the Scene that is currently being viewed by the User
		 * @type {string|null}
		 */
		this.viewedScene = data.viewedScene || null;
		 /**
		 * Define an immutable property for the User's role
		 * @type {number}
		 */
		Object.defineProperty(this, 'role', {value: data.role, writable: false});
	}
	 /* ---------------------------------------- */
	/*  Properties                              */
	/* ---------------------------------------- */
	 /** @override */
	static get config() {
		return {
			baseEntity: User,
			collection: game.users,
			embeddedEntities: {},
			label: "ENTITY.User"
		};
	}
	/* -------------------------------------------- */
	 /**
	 * Return the User avatar icon or the controlled actor's image
	 * @type {string}
	 */
	get avatar() {
		return this.data.avatar || (this.character ? this.character.img : CONST.DEFAULT_TOKEN);
	}
	 /**
	 * Return the Actor instance of the user's impersonated character (or undefined)
	 * @type {Actor}
	 */
	get character() {
		return game.actors.get(this.data.character);
	}
	 /**
	 * A convenience shortcut for the permissions object of the current User
	 * @type {Object}
	 */
	get permissions() {
		return this.data.permissions;
	}
	 /* ---------------------------------------- */
	 /**
	 * A flag for whether the current User is a Trusted Player
	 * @return {boolean}
	 */
	get isTrusted() {
		return this.hasRole("TRUSTED");
	}
	 /* ---------------------------------------- */
	 /**
	 * A flag for whether the current User has Assistant GameMaster or full GameMaster role
	 * @return {boolean}
	 */
	get isGM() {
		return this.hasRole("ASSISTANT");
	}
	 /* ---------------------------------------- */
	 /**
	 * A flag for whether this User is the connected client
	 * @return {boolean}
	 */
	get isSelf() {
		return game.userId === this._id;
	}
	 /* ---------------------------------------- */
	/*  User Methods                            */
	/* ---------------------------------------- */
	 /**
	 * Test whether the User is able to perform a certain permission action. Game Master users are always allowed to
	 * perform every action, regardless of permissions.
	 *
	 * @param {string} permission     The action to test
	 * @return {boolean}              Does the user have the ability to perform this action?
	 */
	can(permission) {
		return this.hasRole("GAMEMASTER") || this.hasPermission(permission);
	}
	/* -------------------------------------------- */
	 /**
	 * Test whether the User has a specific permission entitled .This differs from user#can because it does not always
	 * return true for Game Master users and should be used in cases where a permission could be withheld even from
	 * a GM player (for example cursor display, or A/V audio).
	 *
	 * @param {string} permission     The action to test
	 * @return {boolean}              Does the user have explicit permission to perform this action?
	 */
	hasPermission(permission) {
		if ( permission in this.data.permissions ) return this.data.permissions[permission];
		const rolePerms = game.permissions[permission];
		return rolePerms ? rolePerms.includes(this.role) : false;
	}
	 /* ---------------------------------------- */
	 /**
	 * Test whether the User has at least the permission level of a certain role
	 * @param {string|number} role     The role name from USER_ROLES to test
	 * @return {boolean}               Does the user have at least this role level?
	 */
	hasRole(role) {
		const level = typeof role === "string" ? CONST.USER_ROLES[role] : role;
		return level && (this.role >= level);
	}
	 /* ---------------------------------------- */
	 /**
	 * Test whether the User has exactly the permission level of a certain role
	 * @param {string|number} role     The role name from USER_ROLES to test
	 * @return {boolean}               Does the user have exactly this role level?
	 */
	isRole(role) {
		const level = typeof role === "string" ? CONST.USER_ROLES[role] : role;
		return level && this.role === level;
	}
	/* -------------------------------------------- */
	 /**
	 * Sets a user's permission
	 * Modifies the user permissions to grant or restrict access to a feature.
	 *
	 * @param {string} permission    The permission name from USER_PERMISSIONS
	 * @param {boolean} allowed      Whether to allow or restrict the permission
	 */
	setPermission(permission, allowed) {
		this.update({ permissions: { [permission]: allowed } });
	}
	/* -------------------------------------------- */
	 /**
	 * Submit User activity data to the server for broadcast to other players.
	 * This type of data is transient, persisting only for the duration of the session and not saved to any database.
	 *
	 * @param {Object} activityData             An object of User activity data to submit to the server for broadcast.
	 * @param {Object} activityData.cursor      The coordinates of the user's cursor
	 * @param {boolean} activityData.focus      Is the user pulling focus to the cursor coordinates?
	 * @param {boolean} activityData.ping       Is the user emitting a ping at the cursor coordinates?
	 * @param {string} activityData.ruler       Serialized Ruler coordinate data in JSON format
	 * @param {string} activityData.sceneId     The id of the Scene currently being viewed by the User
	 * @param {string[]} activityData.targets   An id of Token ids which are targeted by the User
	 */
	broadcastActivity(activityData={}) {
		if ( !this.active ) {
			this.active = true;
			ui.players.render();
		}
		if (( "sceneId" in activityData ) && ( this.viewedScene !== activityData.sceneId )) {
			this.viewedScene = activityData.sceneId;
			ui.nav.render();
		}
		game.socket.emit('userActivity', this.id, activityData);
	}
	/* -------------------------------------------- */
	 /**
	 * Assign a Macro to a numbered hotbar slot between 1 and 50
	 * @param {Macro|null} macro  The Macro entity to assign
	 * @param {number} slot       The integer Hotbar slot to fill
	 * @param {number} [fromSlot] An optional origin slot from which the Macro is being shifted
	 * @return {Promise<User>}    A Promise which resolves once the User update is complete
	 */
	async assignHotbarMacro(macro, slot, {fromSlot=null}={}) {
		if ( !(macro instanceof Macro) && (macro !== null) ) throw new Error("Invalid Macro provided");
		const hotbar = this.data.hotbar;
		 // If a slot was not provided, get the first available slot
		slot = slot ? parseInt(slot) : Array.fromRange(50).find(i => !(i in hotbar));
		if ( !slot ) throw new Error("No available Hotbar slot exists");
		if ( slot < 1 || slot > 50 ) throw new Error("Invalid Hotbar slot requested");
		if ( macro && (hotbar[slot] === macro.id) ) return this;
		 // Update the hotbar data
		const update = duplicate(hotbar);
		if ( macro ) update[slot] = macro.id;
		else delete update[slot];
		if ( fromSlot && (fromSlot in hotbar) ) delete update[fromSlot];
		return this.update({hotbar: update}, {diff: false, recursive: false, noHook: true});
	};
	/* -------------------------------------------- */
	 /**
	 * Get an Array of Macro Entities on this User's Hotbar by page
	 * @param {number} page     The hotbar page number
	 * @return {Array.<Object>}
	 */
	getHotbarMacros(page=1) {
		const macros = Array.fromRange(50).map(m => null);
		for ( let [k, v] of Object.entries(this.data.hotbar) ) {
			macros[parseInt(k)-1] = v
		}
		const start = (page-1) * 10;
		return macros.slice(start, start+10).map((m, i) => {
			return {
				slot: start + i + 1,
				macro: m ? game.macros.get(m) : null
			};
		});
	}
	/* -------------------------------------------- */
	 updateTokenTargets(targetIds) {
		const currentIds = this.targets.ids;
		targetIds = targetIds || [];
		if ( currentIds.equals(targetIds) ) return;
		 // Update in the current scene
		if ( this.viewedScene === canvas.scene._id ) {
			const toRemove = Array.from(this.targets).filter(i => !targetIds.includes(i));
			const toAdd = targetIds.filter(i => !toRemove.includes(i)).map(id => canvas.tokens.get(id));
			toRemove.forEach(t => t.setTarget(false, {user: this, releaseOthers: false, groupSelection: true}));
			toAdd.forEach(t => t.setTarget(true, {user: this, releaseOthers: false, groupSelection: true}));
		}
		 // Otherwise remove any current Token targets
		else this.targets.forEach(t => t.setTarget(false, {user: this, releaseOthers: false, groupSelection: true}));
	}
	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */
	 /** @override */
	_onCreate(...args) {}
	/* -------------------------------------------- */
	 /**
	 * Additional updating steps for the User entity when new data is saved which trigger some related updates.
	 *
	 * Re-draw the active cursor and toggle visibility
	 * Re-draw navigation if the active or viewed scenes have changed
	 * Render the players UI if activity status or other player features have changed
	 * Update the canvas if the player's impersonated character has changed
	 *
	 * @private
	 */
	_onUpdate(data, ...args) {
		super._onUpdate(data, ...args);
		 // If the user role changed, we need to re-build the object
		if ( this.data.role !== this.role ) {
			const user = new User(this.data);
			game.users.remove(user.id);
			game.users.insert(user);
			return user._onUpdate(data, ...args);
		}
		 // Get the changed attributes
		let changed = Object.keys(data).filter(k => k !== "_id");
		 // If your own password or role changed - you must re-authenticate
		const isSelf = data._id === game.userId;
		if ( isSelf && changed.some(p => ["password", "role"].includes(p) ) ) return game.logOut();
		if ( !game.ready ) return;
		 // Redraw Navigation
		if ( changed.some(p => ["active", "color", "role"].includes(p)) ) ui.nav.render();
		 // Redraw Players UI
		if ( changed.some(p => ["active", "character", "color", "role"].includes(p)) ) ui.players.render();
		 // Redraw Hotbar
		if ( isSelf && changed.includes("hotbar") ) ui.hotbar.render();
		 // Reconnect to A/V if certain user features changed
		const webrtcChanges = ["avatar", "character", "permissions", "role"];
		if ( game.webrtc ) {
			if (webrtcChanges.some(k => changed.includes(k))) game.webrtc.connect();
		}
		 // Update Canvas
		if ( canvas?.ready ) {
			 // Redraw Cursor
			if ( changed.includes("color") ) {
				canvas.controls.drawCursor(this);
				const ruler = canvas.controls.getRulerForUser(this._id);
				if ( ruler ) ruler.color = colorStringToHex(data.color);
			}
			if ( changed.includes("active") ) canvas.controls.updateCursor(this, null);
			 // Modify impersonated character
			if ( isSelf && changed.includes("character") ) {
				canvas.initializeSources();
				canvas.tokens.cycleTokens(1, true);
			}
		}
	}
	/* -------------------------------------------- */
	 /** @override */
	_onDelete(options, userId) {
		super._onDelete(options, userId);
		if ( this.id === game.user.id ) return game.logOut();
	}
}
	/* -------------------------------------------- */

/**
 * A subclass of Set which manages the Token ids which the User has targeted
 * @extends {Set}
 * @private
 */
class UserTargets extends Set {
	constructor(user) {
		super();
		if ( user.targets ) throw new Error(`User ${user.id} already has a targets set defined`);
		this.user = user;
	}
	 /**
	 * Return the Token IDs which are user targets
	 * @return {Array.<string>}
	 */
	get ids() {
		return Array.from(this).map(t => t.id);
	}
	 /** @override */
	add(token) {
		super.add(token);
		this._hook(token, true);
	}
	 /** @override */
	clear() {
		const tokens = Array.from(this);
		super.clear();
		tokens.forEach(t => this._hook(t, false));
	}
	 /** @override */
	delete(token) {
		super.delete(token);
		this._hook(token, false);
	}
	 /**
	 * Dispatch the targetToken hook whenever the user's target set changes
	 */
	_hook(token, targeted) {
		Hooks.callAll("targetToken", this.user, token, targeted);
	}
}

Users.permissions = CONST.USER_PERMISSIONS;
	/**
 * @typedef {object} ActiveEffectChange
 * @property {string} key             The key
 * @property {*} value                The value of the change
 * @property {number} mode            The mode of the change application
 * @property {number} priority        The priority with which this change is applied
 */

/**
 * @typedef {object} ActiveEffectDuration
 * @property {number} [startTime]     The game time in seconds when the effect started
 * @property {number} [seconds]       The duration of the effect, in seconds
 * @property {string} [combat]        The _id of the Combat entity where the effect began
 * @property {number} [rounds]        The number of combat rounds the effect lasts
 * @property {number} [turns]         The number of combat turns that the effect lasts
 * @property {number} [startRound]    The round of combat in which the effect started
 * @property {number} [startTurn]     The turn of combat in which the effect started
 */

/**
 * @typedef {object} ActiveEffectData
 * @property {string} _id             The EmbeddedEntity id of the Active Effect
 * @property {string} label           The label which describes this effect
 * @property {ActiveEffectDuration} duration    The duration of the effect
 * @property {ActiveEffectChange[]} changes     The changes applied by this effect
 * @property {boolean} [disabled]     Is this effect currently disabled?
 * @property {string} [icon]          An image icon path for this effect
 * @property {string} [tint]          A hex color string to tint the effect icon
 * @property {string} [origin]        The UUID of an Entity or EmbeddedEntity which was the source of this effect
 * @property {boolean} [transfer]     Should this effect transfer automatically to an Actor when its Item becomes owned?
 * @property {object} flags           Additional key/value flags
 */

/**
 * An Active Effect instance within a parent Actor or Item.
 * @implements {EmbeddedEntity}
 * @see {@link Actor#effects}
 * @see {@link Item#effects}
 *
 * @param {ActiveEffectData} data     Data for the Active Effect
 * @param {Actor|Item} parent         The parent Entity which owns the effect
 */
class ActiveEffect extends EmbeddedEntity {
	constructor(...args) {
		super(...args);
		 /**
		 * A cached reference to the source name to avoid recurring database lookups
		 * @type {string|null}
		 */
		this._sourceName = null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Report the active effect duration
	 *
	 */
	get duration() {
		const d = this.data.duration;
		 // Time-based duration
		if ( Number.isNumeric(d.seconds) ) {
			const start = (d.startTime || game.time.worldTime);
			const elapsed = game.time.worldTime - start;
			const remaining = d.seconds - elapsed;
			return {
				type: "seconds",
				duration: d.seconds,
				remaining: remaining,
				label: `${remaining} Seconds`
			};
		}
		 // Turn-based duration
		else if ( d.rounds || d.turns ) {
			 // Determine the current combat duration
			const cbt = game.combat;
			const c = {round: cbt?.round ?? 0, turn: cbt?.turn ?? 0, nTurns: cbt?.turns.length ?? 1};
			 // Determine how many rounds and turns have elapsed
			let elapsedRounds = Math.max(c.round - (d.startRound || 0), 0);
			let elapsedTurns = c.turn - (d.startTurn || 0);
			if ( elapsedTurns < 0 ) {
				elapsedRounds -= 1;
				elapsedTurns += c.nTurns;
			}
			 // Compute the number of rounds and turns that are remaining
			let remainingRounds = (d.rounds || 0) - elapsedRounds;
			let remainingTurns = (d.turns || 0) - elapsedTurns;
			if ( remainingTurns < 0 ) {
				remainingRounds -= 1;
				remainingTurns += c.nTurns;
			} else if ( remainingTurns > c.nTurns ) {
				remainingRounds += Math.floor(remainingTurns / c.nTurns);
				remainingTurns %= c.nTurns;
			}
			 // Total remaining duration
			if ( remainingRounds < 0 ) {
				remainingRounds = 0;
				remainingTurns = 0;
			}
			const duration = (c.rounds || 0) + ((c.turns || 0) / 100)
			const remaining = remainingRounds + (remainingTurns / 100);
			 // Remaining label
			const label = [
				remainingRounds > 0 ? `${remainingRounds} Rounds` : null,
				remainingTurns > 0 ? `${remainingTurns} Turns` : null,
				(remainingRounds + remainingTurns) === 0 ? "None" : null
			].filterJoin(", ");
			return {
				type: "turns",
				duration: duration,
				remaining: remaining,
				label: label
			}
		}
		 // No duration
		else return {
			type: "none",
			duration: null,
			remaining: null,
			label: game.i18n.localize("None")
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Describe whether the ActiveEffect has a temporary duration based on combat turns or rounds.
	 * @type {boolean}
	 */
	get isTemporary() {
		const duration = this.data.duration.seconds ?? (this.data.duration.rounds || this.data.duration.turns) ?? 0;
		return (duration > 0) || this.getFlag("core", "statusId");
	}
	 /* -------------------------------------------- */
	 /**
	 * A cached property for obtaining the source name
	 * @return {string}
	 */
	get sourceName() {
		if ( this._sourceName === null ) this._getSourceName();
		return this._sourceName ?? "Unknown";
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the name of the source of the Active Effect
	 * @type {string}
	 */
	async _getSourceName() {
		if ( this._sourceName ) return this._sourceName;
		if ( !this.data.origin ) return this._sourceName = game.i18n.localize("None");
		const source = await fromUuid(this.data.origin);
		return this._sourceName = source?.name ?? "Unknown";
	}
	 /* -------------------------------------------- */
	 /**
	 * An instance of the ActiveEffectConfig sheet to use for this ActiveEffect instance.
	 * The reference to the sheet is cached so the same sheet instance is reused.
	 * @type {ActiveEffectConfig}
	 */
	get sheet() {
		if ( !this._sheet ) {
			const cls = CONFIG.ActiveEffect.sheetClass;
			this._sheet = new cls(this);
		}
		return this._sheet;
	}
	 /* -------------------------------------------- */
	/*  Effect Application                          */
	/* -------------------------------------------- */
	 /**
	 * Apply this ActiveEffect to a provided Actor.
	 * @param {Actor} actor                 The Actor to whom this effect should be applied
	 * @param {ActiveEffectChange} change   The change data being applied
	 * @return {*}                          The resulting applied value
	 */
	apply(actor, change) {
		const modes = CONST.ACTIVE_EFFECT_MODES;
		switch ( change.mode ) {
			case modes.CUSTOM:
				return this._applyCustom(actor, change);
			case modes.ADD:
				return this._applyAdd(actor, change);
			case modes.MULTIPLY:
				return this._applyMultiply(actor, change);
			case modes.OVERRIDE:
			case modes.UPGRADE:
			case modes.DOWNGRADE:
				return this._applyOverride(actor, change);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Apply an ActiveEffect that uses an ADD application mode.
	 * The way that effects are added depends on the data type of the current value.
	 *
	 * If the current value is null, the change value is assigned directly.
	 * If the current type is a string, the change value is concatenated.
	 * If the current type is a number, the change value is cast to numeric and added.
	 * If the current type is an array, the change value is appended to the existing array if it matches in type.
	 *
	 * @param {Actor} actor                 The Actor to whom this effect should be applied
	 * @param {ActiveEffectChange} change   The change data being applied
	 * @return {*}                          The resulting applied value
	 * @private
	 */
	_applyAdd(actor, change) {
		const {key, value} = change;
		const current = getProperty(actor.data, key) || null;
		const ct = getType(current);
		let update = null;
		 // Handle different types of the current data
		switch ( ct ) {
			case "null":
				update = value;
				break;
			case "string":
				update = current + String(value);
				break;
			case "number":
				if ( Number.isNumeric(value) ) update = current + Number(value);
				break;
			case "Array":
				if ( !current.length || (getType(value) === getType(current[0])) ) update = current.concat([value]);
		}
		if ( update !== null ) setProperty(actor.data, key, update);
		return update;
	}
	 /* -------------------------------------------- */
	 /**
	 * Apply an ActiveEffect that uses a MULTIPLY application mode.
	 * @param {Actor} actor                 The Actor to whom this effect should be applied
	 * @param {ActiveEffectChange} change   The change data being applied
	 * @return {*}                          The resulting applied value
	 * @private
	 */
	_applyMultiply(actor, change) {
		const {key, value} = change;
		const current = getProperty(actor.data, key);
		if ( (typeof(current) !== "number") || (typeof(value) !== "number") ) return null;
		const update = current * value;
		setProperty(actor.data, key, update);
		return update;
	}
	 /* -------------------------------------------- */
	 /**
	 * Apply an ActiveEffect that uses an OVERRIDE, UPGRADE, or DOWNGRADE application mode.
	 * @param {Actor} actor                 The Actor to whom this effect should be applied
	 * @param {ActiveEffectChange} change   The change data being applied
	 * @return {*}                          The resulting applied value
	 * @private
	 */
	_applyOverride(actor, change) {
		const {key, value, mode} = change;
		const current = getProperty(actor.data, key);
		if ( mode === ACTIVE_EFFECT_MODES.UPGRADE ) {
			if ( (typeof(current) === "number") && (current >= Number(value)) ) return null;
		}
		if ( mode === ACTIVE_EFFECT_MODES.DOWNGRADE ) {
			if ( (typeof(current) === "number") && (current < Number(value)) ) return null;
		}
		setProperty(actor.data, key, value);
		return value;
	}
	 /* -------------------------------------------- */
	 /**
	 * Apply an ActiveEffect that uses a CUSTOM application mode.
	 * @param {Actor} actor                 The Actor to whom this effect should be applied
	 * @param {ActiveEffectChange} change   The change data being applied
	 * @return {*}                          The resulting applied value
	 * @private
	 */
	_applyCustom(actor, change) {
		const preHook = getProperty(actor.data, change.key);
		Hooks.call("applyActiveEffect", actor, change);
		const postHook = getProperty(actor.data, change.key);
		return postHook !== preHook ? postHook : null;
	}
	 /* -------------------------------------------- */
	/*  Database Operations                         */
	/* -------------------------------------------- */
	 /**
	 * A convenience method for creating an ActiveEffect instance within a parent Actor or Item.
	 * @see {@link Entity#createEmbeddedEntity}
	 * @param {Options} options     Configuration options which modify the request.
	 * @return {Promise<Data>}      The created ActiveEffect data.
	 */
	async create(options) {
		return this.parent.createEmbeddedEntity("ActiveEffect", this.data, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * A convenience method for updating an ActiveEffect instance in an parent Actor or Item.
	 * @see {@link Entity#updateEmbeddedEntity}
	 * @param {Data} data           Differential data with which to update the ActiveEffect.
	 * @param {Options} options     Configuration options which modify the request.
	 * @return {Promise<Data>}      The updated ActiveEffect data.
	 */
	async update(data, options) {
		data._id = this.id;
		return this.parent.updateEmbeddedEntity("ActiveEffect", data, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * A convenience method for deleting an ActiveEffect instance in an parent Actor or Item.
	 * @see {@link Entity#deleteEmbeddedEntity}
	 * @param {Options} options     Configuration options which modify the request.
	 * @return {Promise<string>}    The deleted ActiveEffect _id.
	 */
	async delete(options) {
		return this.parent.deleteEmbeddedEntity("ActiveEffect", this.id, options);
	}
	 /* -------------------------------------------- */
	/*  Factory Methods                             */
	/* -------------------------------------------- */
	 /**
	 * A factory method which creates an ActiveEffect instance using the configured class.
	 * @param {...*} args     Initialization arguments passed to the ActiveEffect constructor.
	 * @return {ActiveEffect} The constructed ActiveEffect instance.
	 */
	static create(...args) {
		return new CONFIG.ActiveEffect.entityClass(...args);
	}
	 /* -------------------------------------------- */
	 /**
	 * A helper function to handle obtaining dropped ActiveEffect data from a dropped data transfer event.
	 * @param {object} data     The data object extracted from a DataTransfer event
	 * @return {ActiveEffect}   The ActiveEffect instance which contains the dropped effect data
	 */
	static async fromDropData(data) {
		if ( !data.data ) return null;
		return this.create(data.data);
	}
}

/**
 * A helper class providing utility methods for PIXI Canvas animation
 */
class CanvasAnimation {
	static get ticker() {
		return canvas.app.ticker;
	}
	 /* -------------------------------------------- */
	 /**
	 * Apply a linear animation from the current value of some attribute to a new value
	 * Resolve a Promise once the animation has concluded and the attributes have reached their new target
	 * @param {object[]} attributes  An array of attributes to animate. Structure of the Array is shown in the example
	 * @param {Container} context An animation context to use which defines scope
	 * @param {string} name       Provide a unique animation name which may be referenced later
	 * @param {number} duration   The duration in milliseconds over which the animation should occur
	 * @param {Function} ontick   A function which defines additional behaviors to apply every animation frame
	 * @return {Promise}          A Promise which resolves once the linear animation has concluded
	 *
	 * @example
	 * let animation = [
	 *   {
	 *     parent: token,
	 *     attribute: x,
	 *     to: 1000
	 *   },
	 *   {
	 *     parent: token,
	 *     attribute: y,
	 *     to: 2000
	 *   }
	 * ];
	 * CanvasAnimation.animateLinear(attributes, {duration:500, ontick: console.log("ticking")});
	 */
	static async animateLinear(attributes, {context, name=null, duration=1000, ontick}={}) {
		 // Prepare attributes
		attributes = attributes.map(a => {
			a.delta = a.to - a.parent[a.attribute];
			a.done = 0;
			a.remaining = Math.abs(a.delta);
			return a;
		}).filter(a => a.delta !== 0);
		 // Register the request function and context
		context = context || canvas.stage;
		 // Dispatch the animation request and return as a Promise
		return this._animatePromise(this._animateFrame, context, name, attributes, duration, ontick);
	}
	 /* -------------------------------------------- */
	 /**
	 * If an animation using a certain name already exists, terminate it
	 * @param {string} name       The animation name to terminate
	 */
	static terminateAnimation(name) {
		let animation = this.animations[name];
		if ( animation ) {
			this.ticker.remove(...animation);
			delete this.animations[name];
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Asynchronously animate a transition function and resolve a Promise once the animation has completed
	 * @param {Function} fn         A suitable transition function. See PIXI.Ticker for details
	 * @param {Container} context   The Canvas container providing scope for the transition
	 * @param {string} name         Provide a unique animation name which may be referenced later
	 * @param {...*} args           Variable argument passed to the transition function each frame
	 * @return {Promise}            A Promise which resolves once the animation has completed
	 * @private
	 */
	static async _animatePromise(fn, context, name, ...args) {
		let animate;
		 // Check for an existing named animation
		if ( name ) this.terminateAnimation(name);
		 // Add the animation function to the Ticker
		return new Promise((resolve, reject) => {
			animate = dt => fn(dt, resolve, reject, ...args);
			this.ticker.add(animate, context);
			if ( name ) this.animations[name] = [animate, context];
		})
		 // Remove the animation function once resolved or rejected
		.then(() => {
			this.ticker.remove(animate, context);
			if ( name ) delete this.animations[name];
		})
		.catch(err => {
			console.error(err);
			this.ticker.remove(animate, context);
			if ( name ) delete this.animations[name];
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Generic ticker function to implement the animation.
	 * This animation wrapper executes once per frame for the duration of the animation event.
	 * Once the animated attributes have converged to their targets, it resolves the original Promise.
	 * The user-provided ontick function runs each frame update to apply additional behaviors.
	 * @private
	 */
	static _animateFrame(deltaTime, resolve, reject, attributes, duration, ontick) {
		let complete = attributes.length === 0;
		let dt = (duration * PIXI.settings.TARGET_FPMS) / deltaTime;
		 // Update each attribute
		try {
			for (let a of attributes) {
				let da = a.delta / dt;
				a.d = da;
				if ( a.remaining < (Math.abs(da) * 1.25) ) {
					a.parent[a.attribute] = a.to;
					a.done = a.delta;
					a.remaining = 0;
					complete = true;
				} else {
					a.parent[a.attribute] += da;
					a.done += da;
					a.remaining = Math.abs(a.delta) - Math.abs(a.done);
				}
			}
			if (ontick) ontick(dt, attributes);
		}
		catch (err) {
			reject(err);
		}
		 // Resolve the original promise once the animation is complete
		if (complete) resolve();
	}
}
	/**
 * Track an object of active animations by name, context, and function
 * This allows a currently playing animation to be referenced and terminated
 */
CanvasAnimation.animations = {};

/**
 * A generic helper for drawing a standard Control Icon
 * @type {PIXI.Container}
 */
class ControlIcon extends PIXI.Container {
	constructor({texture, size=40, borderColor=0xFF5500, tint=null}={}, ...args) {
		super(...args);
		 // Define arguments
		this.iconSrc = texture;
		this.size = size;
		this.rect = [-2, -2, size+4, size+4];
		this.borderColor = borderColor;
		this.tintColor = tint;
		 // Define hit area
		this.interactive = true;
		this.interactiveChildren = false;
		this.hitArea = new PIXI.Rectangle(...this.rect);
		 // Background
		this.bg = this.addChild(new PIXI.Graphics());
		 // Icon
		this.icon = this.addChild(new PIXI.Sprite());
		 // Border
		this.border = this.addChild(new PIXI.Graphics());
		 // Draw asynchronously
		this.draw();
	}
	 /* -------------------------------------------- */
	 async draw() {
		 // Load the icon texture
		this.texture = this.texture ?? await loadTexture(this.iconSrc);
		 // Draw background
		this.bg.clear().beginFill(0x000000, 0.4).lineStyle(2, 0x000000, 1.0).drawRoundedRect(...this.rect, 5).endFill();
		 // Draw border
		this.border.clear().lineStyle(2, this.borderColor, 1.0).drawRoundedRect(...this.rect, 5).endFill();
		this.border.visible = false;
		 // Draw icon
		this.icon.texture = this.texture;
		this.icon.width = this.icon.height = this.size;
		this.icon.tint = Number.isNumeric(this.tintColor) ? this.tintColor : 0xFFFFFF;
		return this;
	}
	 /* -------------------------------------------- */
	 _onHoverIn(event) {
		this.border.visible = true;
	}
	 _onHoverOut(event) {
		this.border.visible = false;
	}
}
/**
 * A Loader class which helps with loading video and image textures
 */
class TextureLoader {
	constructor() {
		this.cache = new Map();
	}
	 /* -------------------------------------------- */
	 /**
	 * Load all the textures which are required for a particular Scene
	 * @param {Scene} scene     The Scene to load
	 * @return {Promise<void>}
	 */
	static loadSceneTextures(scene) {
		const sd = scene.data;
		let toLoad = [];
		 // Scene background image
		if ( sd.img ) toLoad.push(sd.img);
		 // Placeable tiles
		toLoad = toLoad.concat(sd.tiles.filter(t => t.img).map(t => t.img));
		 // Tokens
		toLoad = toLoad.concat(sd.tokens.filter(t => t.img).map(t => t.img));
		 // Control Icons
		toLoad = toLoad.concat(Object.values(CONFIG.controlIcons)).concat(CONFIG.statusEffects.map(e => e.icon ?? e));
		 // Load files
		const showName = scene.active || scene.visible;
		const loadName = showName ? scene.data.navName || scene.data.name : "...";
		return this.loader.load(toLoad, {message: game.i18n.format("SCENES.Loading", {name: loadName})});
	}
	 /* -------------------------------------------- */
	 /**
	 * Load an Array of provided source URL paths
	 * @param {string[]} sources    The source URLs to load
	 * @param {string} message      The status message to display in the load bar
	 * @return {Promise<void>}      A Promise which resolves once all textures are loaded
	 */
	async load(sources, {message}={}) {
		 // Filter for textures which already exist
		sources = sources.filter(src => {
			let tex = this.getCache(src);
			return !tex || !tex.baseTexture || !tex.baseTexture.valid;
		});
		 // Create an array of Promises
		const progress = {message: message, loaded: 0, failed: 0, total: sources.length, pct: 0};
		const promises = sources.map(src => {
			let promise = VideoHelper.hasVideoExtension(src) ? this.loadVideoTexture(src) : this.loadImageTexture(src);
			return promise.then(tex => this._onProgress(src, progress)).catch(err => this._onError(src, progress, err));
		});
		 // Load all media
		return Promise.all(promises);
	}
	 /* -------------------------------------------- */
	 /**
	 * Load a single texture on-demand from a given source URL path
	 * @param src
	 * @return {Promise<PIXI.Texture>}
	 */
	async loadTexture(src) {
		let tex = this.getCache(src);
		if ( tex && tex.baseTexture && tex.baseTexture.valid ) return tex;
		return VideoHelper.hasVideoExtension(src) ? this.loadVideoTexture(src) : this.loadImageTexture(src);
	}
	 /* -------------------------------------------- */
	 /**
	 * Log texture loading progress in the console and in the Scene loading bar
	 * @private
	 */
	_onProgress(src, progress, message) {
		progress.loaded++;
		progress.pct = Math.round((progress.loaded + progress.failed) * 10 / progress.total) * 10;
		SceneNavigation._onLoadProgress(progress.message, progress.pct);
		console.log(`${vtt} | Loaded ${src} (${progress.pct}%)`);
	}
	 /* -------------------------------------------- */
	 /**
	 * Log failed texture loading
	 * @private
	 */
	_onError(src, progress, error) {
		progress.failed++;
		progress.pct = Math.round((progress.loaded + progress.failed) * 10 / progress.total) * 10;
		SceneNavigation._onLoadProgress(progress.message, progress.pct);
		console.warn(`${vtt} | Loading failed for ${src} (${progress.pct}%): ${error.message}`);
	}
	 /* -------------------------------------------- */
	 /**
	 * Load an image texture from a provided source url
	 * @param {string} src
	 * @return {Promise<PIXI.Texture>}
	 */
	async loadImageTexture(src) {
		 // Create the Image element
		const img = new Image(src);
		img.crossOrigin = "anonymous";
		img.decoding = "async";
		img.loading = "eager";
		 // Wait for the image to load
		return new Promise((resolve, reject) => {
			 // Create the texture on successful load
			img.onload = () => {
				img.height = img.naturalHeight;
				img.width = img.naturalWidth;
				const bt = PIXI.BaseTexture.from(img);
				const tex = new PIXI.Texture(bt);
				this.setCache(src, tex);
				resolve(tex);
			};
			 // Handle errors for valid URLs due to CORS
			img.onerror = () => this._attemptCORSReload(src, resolve, reject);
			img.src = src;
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * If an attempted image load failed, we may attempt a re-load in case the issue was CORS + caching
	 * Cross-origin requests which failed might be CORS, or might be 404, no way to know - so try a 2nd time
	 * @param {string} src        The source URL being attempted
	 * @param {Function} resolve  Resolve the promise
	 * @param {Function} reject   Reject the promise
	 * @private
	 */
	async _attemptCORSReload(src, resolve, reject) {
		const fail = `Failed to load texture ${src}`;
		 // Try to parse the URL
		let url;
		try {
			url = new URL(src);
		} catch(err) {
			return reject(`${fail}: Invalid URL`);
		}
		 // Skip same-origin resources
		if ( url.origin === window.location.origin ) return reject(`${fail}: Invalid URL`);
		 // Skip resource which have already been retried
		if ( /\?cors-retry=/.test(url.search) )  return reject(`${fail}: CORS failure`);
		 // Retry loading a cross-origin resource with a cache-busting parameter
		url.search += `?cors-retry=${Date.now()}`;
		return this.loadImageTexture(url.href).then(tex => {
			this.setCache(src, tex);
			resolve(tex);
		}).catch(err => reject(`${fail}: CORS failure`));
	}
	 /* -------------------------------------------- */
	 /**
	 * Load a video texture from a provided source url
	 * @param {string} src
	 * @return {Promise<PIXI.Texture>}
	 */
	async loadVideoTexture(src) {
		if ( !VideoHelper.hasVideoExtension(src) ) {
			throw new Error(`${src} is not a valid video texture`);
		}
		 // Create a Video element
		const video = document.createElement("VIDEO");
		video.preload = "auto";
		video.autoplay = false;
		video.crossOrigin = "anonymous";
		video.src = src;
		 // Begin loading and resolve or reject
		return new Promise((resolve, reject) => {
			video.oncanplay = () => {
				video.height = video.videoHeight;
				video.width = video.videoWidth;
				const bt = PIXI.BaseTexture.from(video, {resourceOptions: {autoPlay: false}});
				const tex = new PIXI.Texture(bt);
				this.setCache(src, tex);
				resolve(tex);
			};
			video.onerror = reject;
			video.load();
		});
	}
	 /* -------------------------------------------- */
	/*  Cache Controls                              */
	/* -------------------------------------------- */
	 /**
	 * Add an image url to the texture cache
	 * @param {string} src          The source URL
	 * @param {PIXI.Texture} tex    The readied texture
	 */
	setCache(src, tex) {
		this.cache.set(src, tex);
	}
	 /* -------------------------------------------- */
	 /**
	 * Retrieve a texture from the texture cache
	 * @param {string} src          The source URL
	 */
	getCache(src) {
		return this.cache.get(src);
	}
}

/**
 * A global reference to the singleton texture loader
 * @type {TextureLoader}
 */
TextureLoader.loader = new TextureLoader();
	/* -------------------------------------------- */
	/**
 * Test whether a file source exists by performing a HEAD request against it
 * @param {string} src    The source URL or path to test
 * @return {boolean}      Does the file exist at the provided url?
 */
async function srcExists(src) {
	return fetch(src, { method: 'HEAD' }).then(resp => {
		return resp.status < 400;
	}).catch(err => false);
}
	/* -------------------------------------------- */
	/**
 * Get a single texture from the cache
 * @param {string} src
 * @return {PIXI.Texture}
 */
function getTexture(src) {
	let cached = TextureLoader.loader.getCache(src);
	if ( !cached || !cached.valid ) return null;
	return cached;
}
	/* -------------------------------------------- */
	/**
 * Load a single texture and return a Promise which resolves once the texture is ready to use
 * @param {string} src        The requested texture source
 * @param {string} fallback   A fallback texture to use if the requested source is unavailable or invalid
 * @return {PIXI.Texture}
 */
async function loadTexture(src, {fallback=null}={}) {
	let tex = null;
	try {
		tex = await TextureLoader.loader.loadTexture(src);
		if (!tex || !tex.valid) throw new Error("Invalid BaseTexture");
	}
	catch(err) {
		err.message = `The requested texture ${src} could not be loaded: ${err.message}`;
		console.error(err);
		if ( fallback ) tex = await loadTexture(fallback);
	}
	return tex;
}
/**
 * Handle mouse interaction events for a Canvas object.
 * There are three phases of events: hover, click, and drag
 *
 * Hover Events:
 * _handleMouseOver
 *  action: hoverIn
 * _handleMouseOut
 *  action: hoverOut
 *
 * Left Click and Double-Click
 * _handleMouseDown
 *  action: clickLeft
 *  action: clickLeft2
 *
 * Right Click and Double-Click
 * _handleRightDown
 *  action: clickRight
 *  action: clickRight2
 *
 * Drag and Drop
 * _handleMouseMove
 *  action: dragLeftStart
 *  action: dragLeftMove
 *  action: dragRightStart
 *  action: dragLeftMove
 * _handleMouseUp
 *  action: dragLeftDrop
 *  action: dragRightDrop
 * _handleDragCancel
 *  action: dragLeftCancel
 *  action: dragRightCancel
 */
class MouseInteractionManager {
	constructor(object, layer, permissions={}, callbacks={}, options={}) {
		this.object = object;
		this.layer = layer;
		this.permissions = permissions;
		this.callbacks = callbacks;
		this.options = options;
		 /**
		 * The current interaction state
		 * @type {number}
		 */
		this.state = this.states.NONE;
		 /**
		 * Bound handlers which can be added and removed
		 * @type {{string: Function}}
		 */
		this.handlers = {};
		 /**
		 * The drag handling time
		 * @type {number}
		 */
		this.dragTime = 0;
		 /**
		 * The throttling time below which a mouse move event will not be handled
		 * @type {number}
		 * @private
		 */
		this._dragThrottleMS = Math.ceil(1000 / canvas.app.ticker.maxFPS);
		 /**
		 * The time of the last left-click event
		 * @type {number}
		 */
		this.lcTime = 0;
		 /**
		 * The time of the last right-click event
		 * @type {number}
		 */
		this.rcTime = 0;
		 /**
		 * A flag for whether we are right-click dragging
		 * @type {boolean}
		 */
		this._dragRight = false;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the target
	 * @return {*}
	 */
	get target() {
		return this.options.target ? this.object[this.options.target] : this.object;
	}
	 /* -------------------------------------------- */
	 /**
	 * Activate interactivity for the handled object
	 */
	activate() {
		 // Remove existing listeners
		this.state = this.states.NONE;
		this.target.removeAllListeners();
		 // Create bindings for all handler functions
		this.handlers = {
			"mouseover": this._handleMouseOver.bind(this),
			"mouseout": this._handleMouseOut.bind(this),
			"mousedown": this._handleMouseDown.bind(this),
			"rightdown": this._handleRightDown.bind(this),
			"mousemove": this._handleMouseMove.bind(this),
			"mouseup": this._handleMouseUp.bind(this),
			"contextmenu": this._handleDragCancel.bind(this)
		};
		 // Activate hover events to start the workflow
		this._activateHoverEvents();
		 // Set the target as interactive
		this.target.interactive = true;
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether the current user has permission to perform a step of the workflow
	 * @param {string} action     The action being attempted
	 * @param {Event} event       The event being handled
	 * @return {boolean}          Can the action be performed?
	 */
	can(action, event) {
		const fn = this.permissions[action];
		if ( typeof fn === "boolean" ) return fn;
		if ( fn instanceof Function ) return fn.call(this.object, game.user, event);
		return true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Execute a callback function associated with a certain action in the workflow
	 * @param {string} action     The action being attempted
	 * @param {Event} event       The event being handled
	 */
	callback(action, event) {
		const fn = this.callbacks[action];
		if ( fn instanceof Function ) return fn.call(this.object, event);
	}
	 /* -------------------------------------------- */
	 /**
	 * A reference to the possible interaction states which can be observed
	 * @return {Object<string, number>}
	 */
	get states() {
		return this.constructor.INTERACTION_STATES;
	}
	 /* -------------------------------------------- */
	/*  Listener Activation and Deactivation        */
	/* -------------------------------------------- */
	 /**
	 * Activate a set of listeners which handle hover events on the target object
	 * @private
	 */
	_activateHoverEvents() {
		 // Disable and re-register mouseover and mouseout handlers
		this.target.off("mouseover", this.handlers.mouseover).on("mouseover", this.handlers.mouseover);
		this.target.off("mouseout", this.handlers.mouseout).on("mouseout", this.handlers.mouseout);
		 // Add a one-time mousemove event in case our cursor is already over the target element
		this.target.once("mousemove", this.handlers.mouseover);
	}
	 /* -------------------------------------------- */
	 /**
	 * Activate a new set of listeners for click events on the target object
	 * @private
	 */
	_activateClickEvents() {
		this._deactivateClickEvents();
		this.target.on("mousedown", this.handlers.mousedown);
		this.target.on("mouseup", this.handlers.mouseup);
		this.target.on("mouseupoutside", this.handlers.mouseup);
		this.target.on("rightdown", this.handlers.rightdown);
		this.target.on("rightup", this.handlers.mouseup);
		this.target.on("rightupoutside", this.handlers.mouseup);
	}
	 /* -------------------------------------------- */
	 /**
	 * Deactivate event listeners for click events on the target object
	 * @private
	 */
	_deactivateClickEvents() {
		this.target.off("mousedown", this.handlers.mousedown);
		this.target.off("mouseup", this.handlers.mouseup);
		this.target.off("mouseupoutside", this.handlers.mouseup);
		this.target.off("rightdown", this.handlers.rightdown);
		this.target.off("rightup", this.handlers.mouseup);
		this.target.off("rightupoutside", this.handlers.mouseup);
	}
	 /* -------------------------------------------- */
	 /**
	 * Activate events required for handling a drag-and-drop workflow
	 * @private
	 */
	_activateDragEvents() {
		this._deactivateDragEvents();
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | activateDragEvents`);
		this.layer.on("mousemove", this.handlers.mousemove);
		if ( !this._dragRight ) {
			canvas.app.view.addEventListener("contextmenu", this.handlers.contextmenu, {capture: true});
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Deactivate events required for handling drag-and-drop workflow.
	 * @private
	 */
	_deactivateDragEvents() {
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | deactivateDragEvents`);
		this.layer.off("mousemove", this.handlers.mousemove);
		canvas.app.view.removeEventListener("contextmenu", this.handlers.contextmenu, {capture: true});
	}
	 /* -------------------------------------------- */
	/*  Hover In and Hover Out                      */
	/* -------------------------------------------- */
	 /**
	 * Handle mouse-over events which activate downstream listeners and do not stop propagation.
	 * @private
	 */
	_handleMouseOver(event) {
		 // Ignore hover events during a drag workflow
		if ( this.state >= this.states.DRAG ) return;
		 // Handle new hover events
		const action = "hoverIn";
		if ( this.object._controlled === false) this.state = this.states.NONE;
		if ( this.state !== this.states.NONE ) return;
		if ( !this.can(action, event) ) return;
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | ${action}`);
		 // Activate click event listeners
		this._activateClickEvents();
		 // Assign event data and call the provided handler
		event.data.object = this.object;
		this.state = Math.max(this.state || 0, this.states.HOVER);
		 // Callback
		return this.callback(action, event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mouse-out events which terminate hover workflows and do not stop propagation.
	 * @private
	 */
	_handleMouseOut(event) {
		const action = "hoverOut";
		if ( (this.state === this.states.NONE) || (this.state >= this.states.DRAG) )  return;
		 // Downgrade hovers by deactivating events
		if ( this.state === this.states.HOVER ) {
			this.state = this.states.NONE;
			this._deactivateClickEvents();
		}
		 // Handle callback actions if permitted
		if ( !this.can(action, event) ) return;
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | ${action}`);
		return this.callback(action, event);
	}
	 /* -------------------------------------------- */
	/*  Left Click and Double Click                 */
	/* -------------------------------------------- */
	 /**
	 * Handle mouse-down events which activate downstream listeners.
	 * Stop further propagation only if the event is allowed by either single or double-click.
	 * @private
	 */
	_handleMouseDown(event) {
		if ( ![this.states.HOVER, this.states.CLICKED, this.states.DRAG].includes(this.state) ) return;
		 // Only support standard left-click
		if ( event.data.originalEvent.button !== 0 ) return;
		 // Determine double vs single click
		const now = Date.now();
		const isDouble = (now - this.lcTime) <= 250;
		this.lcTime = now;
		 // Update event data
		event.data.object = this.object;
		event.data.origin = event.data.getLocalPosition(this.layer);
		 // Dispatch to double and single-click handlers
		if ( isDouble && this.can("clickLeft2", event) ) return this._handleClickLeft2(event);
		else return this._handleClickLeft(event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mouse-down which trigger a single left-click workflow.
	 * @private
	 */
	_handleClickLeft(event) {
		const action = "clickLeft";
		if ( !this.can(action, event) ) return;
		event.stopPropagation();
		this._dragRight = false;
		 // Upgrade hover to clicked
		if ( this.state === this.states.HOVER ) this.state = this.states.CLICKED;
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | ${action}`);
		 // Trigger callback functions
		this.callback(action, event);
		 // Activate drag handlers
		if ( (this.state < this.states.DRAG) && this.can("dragStart", event) ) {
			this._activateDragEvents();
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mouse-down which trigger a single left-click workflow.
	 * @private
	 */
	_handleClickLeft2(event) {
		event.stopPropagation();
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | clickLeft2`);
		return this.callback("clickLeft2", event);
	}
	 /* -------------------------------------------- */
	/*  Right Click and Double Click                */
	/* -------------------------------------------- */
	 /**
	 * Handle right-click mouse-down events.
	 * Stop further propagation only if the event is allowed by either single or double-click.
	 * @private
	 */
	_handleRightDown(event) {
		if ( ![this.states.HOVER, this.states.CLICKED, this.states.DRAG].includes(this.state) ) return;
		 // Only support standard left-click
		if ( event.data.originalEvent.button !== 2 ) return;
		 // Determine double vs single click
		const now = Date.now();
		const isDouble = (now - this.rcTime) <= 250;
		this.rcTime = now;
		 // Update event data
		event.data.object = this.object;
		event.data.origin = event.data.getLocalPosition(this.layer);
		 // Dispatch to double and single-click handlers
		if ( isDouble && this.can("clickRight2", event) ) return this._handleClickRight2(event);
		else return this._handleClickRight(event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle single right-click actions.
	 * @private
	 */
	_handleClickRight(event) {
		const action = "clickRight";
		if ( !this.can(action, event) ) return;
		event.stopPropagation();
		this._dragRight = true;
		 // Upgrade hover to clicked
		if ( this.state === this.states.HOVER ) this.state = this.states.CLICKED;
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | ${action}`);
		 // Trigger callback function
		this.callback(action, event);
		 // Activate drag handlers
		if ( (this.state < this.states.DRAG) && this.can("dragRight", event) ) {
			this._activateDragEvents();
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle double right-click actions.
	 * @private
	 */
	_handleClickRight2(event) {
		event.stopPropagation();
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | clickRight2`);
		return this.callback("clickRight2", event);
	}
	 /* -------------------------------------------- */
	/*  Drag and Drop                               */
	/* -------------------------------------------- */
	 /**
	 * Handle mouse movement during a drag workflow
	 * @private
	 */
	_handleMouseMove(event) {
		if ( ![this.states.CLICKED, this.states.DRAG].includes(this.state) ) return;
		 // Limit dragging to 60 updates per second
		const now = Date.now();
		if ( (now - this.dragTime) < this._dragThrottleMS ) return;
		this.dragTime = now;
		 // Get the new destination
		event.data.destination = event.data.getLocalPosition(this.layer);
		 // Begin a new drag event
		if ( this.state === this.states.CLICKED ) {
			const dx = event.data.destination.x - event.data.origin.x;
			const dy = event.data.destination.y - event.data.origin.y;
			const dz = Math.hypot(dx, dy);
			const r = this.options.dragResistance || (canvas.dimensions.size / 4);
			if ( dz >= r ) {
				this.state = this.states.DRAG;
				return this._handleDragStart(event);
			}
		}
		 // Continue a drag event
		else return this._handleDragMove(event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the beginning of a new drag start workflow, moving all controlled objects on the layer
	 * @private
	 */
	_handleDragStart(event) {
		const action = this._dragRight ? "dragRightStart" : "dragLeftStart";
		if ( !this.can(action, event) ) return;
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | ${action}`);
		return this.callback(action, event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the continuation of a drag workflow, moving all controlled objects on the layer
	 * @private
	 */
	_handleDragMove(event) {
		const action = this._dragRight ? "dragRightMove" : "dragLeftMove";
		this.state = this.states.DRAG;
		if ( !this.can(action, event) ) return;
		return this.callback(action, event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mouse up events which may optionally conclude a drag workflow
	 * @private
	 */
	_handleMouseUp(event) {
		if ( this.state >= this.states.DRAG ) {
			event.stopPropagation();
			if ( event.type.startsWith("right") && !this._dragRight ) return;
			this._handleDragDrop(event);
		}
		 // Continue a multi-click drag workflow
		if ( event.data.originalEvent.defaultPrevented ) {
			this.state = this.states.DRAG;
			return;
		}
		 // Cancel the workflow
		return this._handleDragCancel(event.data.originalEvent);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the conclusion of a drag workflow, placing all dragged objects back on the layer
	 * @private
	 */
	_handleDragDrop(event) {
		const action = this._dragRight ? "dragRightDrop" : "dragLeftDrop";
		if (!this.can(action, event)) return;
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | ${action}`);
		 // Update event data
		event.data.object = this.object;
		event.data.destination = event.data.getLocalPosition(this.layer);
		this.state = this.states.DROP;
		 // Callback
		this.callback(action, event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the cancellation of a drag workflow, resetting back to the original state
	 * @param {PointerEvent} event
	 * @private
	 */
	_handleDragCancel(event) {
		const endState = this.state;
		if ( endState <= this.states.HOVER ) return;
		 // Dispatch a cancellation callback
		if ( endState >= this.states.DRAG ) {
			const action = this._dragRight ? "dragRightCancel" : "dragLeftCancel";
			if (CONFIG.debug.mouseInteraction) console.log(`${this.object.constructor.name} | ${action}`);
			this.callback(action, event);
		}
		 // Continue a multi-click drag workflow if the default event was prevented in the callback
		if ( event.defaultPrevented ) {
			this.state = this.states.DRAG;
			return;
		}
		 // Deactivate the drag workflow
		this._deactivateDragEvents();
		this.state = this.states.HOVER;
	}
}

/**
 * Enumerate the states of a mouse interaction workflow.
 * 0: NONE - the object is inactive
 * 1: HOVER - the mouse is hovered over the object
 * 2: CLICKED - the object is clicked
 * 3: DRAG - the object is being dragged
 * 4: DROP - the object is being dropped
 * @type {Object<string,number>}
 */
MouseInteractionManager.INTERACTION_STATES = {
	NONE: 0,
	HOVER: 1,
	CLICKED: 2,
	DRAG: 3,
	DROP: 4
};

/**
 * @typedef {{r: Rectangle, t: any, n: Set<Quadtree>}} QuadtreeObject
 */

/**
 * A Quadtree implementation that supports collision detection for rectangles.
 *
 * @param {Rectangle}                       The outer bounds of the region
 * @param {object} options                  Additional options which configure the Quadtree
 * @param {number} options.maxObjects       The maximum number of objects per node
 * @param {number} options.maxDepth         The maximum number of levels within the root Quadtree
 * @param {number} options._depth           The depth level of the sub-tree. For internal use only
 * @param {number} options._depth           Whether this node represents the root of the tree. For internal use.
 */
class Quadtree {
	constructor(bounds, {maxObjects=20, maxDepth=4, _depth=0}={}, ) {
		 /**
		 * The bounding rectangle of the region
		 * @type {Rectangle}
		 */
		this.bounds = bounds;
		 /**
		 * The maximum number of objects allowed within this node before it must split
		 * @type {number}
		 */
		this.maxObjects = maxObjects;
		 /**
		 * The maximum number of levels that the base quadtree is allowed
		 * @type {number}
		 */
		this.maxDepth = maxDepth;
		 /**
		 * The depth of this node within the root Quadtree
		 * @type {number}
		 */
		this.depth = _depth;
		 /**
		 * The objects contained at this level of the tree
		 * @type {QuadtreeObject[]}
		 */
		this.objects = [];
		 /**
		 * Children of this node
		 * @type {Quadtree[]}
		 */
		this.nodes = [];
	}
	 /* -------------------------------------------- */
	 /**
	 * Return an array of all the objects in the Quadtree (recursive)
	 * @return {QuadtreeObject[]}
	 */
	get all() {
		if ( this.nodes.length ) {
			return this.nodes.reduce((arr, n) => arr.concat(n.all), []);
		}
		return this.objects;
	}
	 /* -------------------------------------------- */
	/*  Object Management                           */
	/* -------------------------------------------- */
	 /**
	 * Clear the quadtree of all existing contents
	 * @return {Quadtree}     The cleared Quadtree
	 */
	clear() {
		this.objects = [];
		for ( let n of this.nodes ) {
			n.clear();
		}
		this.nodes = [];
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Add a rectangle object to the tree
	 * @param {QuadtreeObject} obj  The object being inserted
	 * @return {Quadtree[]}         The Quadtree nodes the object was added to.
	 */
	insert(obj) {
		obj.n = obj.n || new Set();
		 // If we will exceeded the maximum objects we need to split
		if ( (this.objects.length === this.maxObjects - 1) && (this.depth < this.maxDepth) ) {
			if ( !this.nodes.length ) this.split();
		}
		 // If this node has children, recursively insert
		if ( this.nodes.length ) {
			let nodes = this.getChildNodes(obj.r);
			return nodes.reduce((arr, n) => arr.concat(n.insert(obj)), []);
		}
		 // Otherwise store the object here
		obj.n.add(this);
		this.objects.push(obj);
		return [this];
	}
	 /* -------------------------------------------- */
	 /**
	 * Remove an object from the quadtree
	 * @param {target}      The quadtree target being removed
	 * @return {Quadtree}   The Quadtree for method chaining
	 */
	remove(target) {
		this.objects.findSplice(o => o.t === target);
		for ( let n of this.nodes ) {
			n.remove(target);
		}
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Split this node into 4 sub-nodes.
	 * @return {Quadtree}     The split Quadtree
	 */
	split() {
		const w = this.bounds.width / 2;
		const h = this.bounds.height / 2;
		const options = {maxObjects: this.maxObjects, maxDepth: this.maxDepth, _depth: this.depth + 1};
		 // Top-left
		this.nodes[Quadtree.INDICES.tl] = new Quadtree({
			x: this.bounds.x,
			y: this.bounds.y,
			width: w,
			height: h
		}, options);
		 // Top-right
		this.nodes[Quadtree.INDICES.tr] = new Quadtree({
			x: this.bounds.x + w,
			y: this.bounds.y,
			width: w,
			height: h
		}, options);
		 // Bottom-left
		this.nodes[Quadtree.INDICES.bl] = new Quadtree({
			x: this.bounds.x,
			y: this.bounds.y + h,
			width: w,
			height: h
		}, options);
		 // Bottom-right
		this.nodes[Quadtree.INDICES.br] = new Quadtree({
			x: this.bounds.x + w,
			y: this.bounds.y + h,
			width: w,
			height: h
		}, options);
		 // Assign current objects to child nodes
		for ( let o of this.objects ) {
			o.n.delete(this);
			this.insert(o);
		}
		this.objects = [];
		return this;
	}
	 /* -------------------------------------------- */
	/*  Target Identification                       */
	/* -------------------------------------------- */
	 /**
	 * Get all the objects which could collide with the provided rectangle
	 * @param {Rectangle} rect  The target rectangle
	 * @param {Set} _s          The existing result set, for internal use.
	 * @returns {Set}           The objects in the Quadtree which represent potential collisions
	 */
	getObjects(rect, _s) {
		const objects = _s || new Set();
		 // Recursively retrieve objects from child nodes
		if ( this.nodes.length ) {
			const nodes = this.getChildNodes(rect);
			for ( let n of nodes ) {
				n.getObjects(rect, objects);
			}
		}
		 // Otherwise retrieve from this node
		else {
			for ( let o of this.objects)  {
				objects.add(o.t);
			}
		}
		 // Return the result set
		return objects;
	}
	 /* -------------------------------------------- */
	 /**
	 * Obtain the leaf nodes to which a target rectangle belongs.
	 * This traverses the quadtree recursively obtaining the final nodes which have no children.
	 * @param {Rectangle} rect  The target rectangle.
	 * @return {Quadtree[]}     The Quadtree nodes to which the target rectangle belongs
	 */
	getLeafNodes(rect) {
		if ( !this.nodes.length ) return [this];
		const nodes = this.getChildNodes(rect);
		return nodes.reduce((arr, n) => arr.concat(n.getLeafNodes(rect)), []);
	}
	 /* -------------------------------------------- */
	 /**
	 * Obtain the child nodes within the current node which a rectangle belongs to.
	 * Note that this function is not recursive, it only returns nodes at the current or child level.
	 * @param {Rectangle} rect  The target rectangle.
	 * @return {Quadtree[]}     The Quadtree nodes to which the target rectangle belongs
	 */
	getChildNodes(rect) {
		 // If this node has no children, use it
		if ( !this.nodes.length ) return [this];
		 // Prepare data
		const nodes = [];
		const hx = this.bounds.x + (this.bounds.width / 2);
		const hy = this.bounds.y + (this.bounds.height / 2);
		 // Determine orientation relative to the node
		const startTop = rect.y <= hy;
		const startLeft = rect.x <= hx;
		const endBottom = (rect.y + rect.height) > hy;
		const endRight = (rect.x + rect.width) > hx;
		 // Top-left
		if ( startLeft && startTop ) nodes.push(this.nodes[Quadtree.INDICES.tl]);
		 // Top-right
		if ( endRight && startTop ) nodes.push(this.nodes[Quadtree.INDICES.tr]);
		 // Bottom-left
		if ( startLeft && endBottom ) nodes.push(this.nodes[Quadtree.INDICES.bl]);
		 // Bottom-right
		if ( endRight && endBottom ) nodes.push(this.nodes[Quadtree.INDICES.br]);
		return nodes;
	}
	 /* -------------------------------------------- */
	 /**
	 * Visualize the nodes and objects in the quadtree
	 * @param {boolean} [objects]    Visualize the rectangular bounds of objects in the Quadtree. Default is false.
	 */
	visualize({objects=false}={}) {
		const debug = canvas.controls.debug;
		debug.lineStyle(2, 0x00FF00, 0.5).drawRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
		if ( objects ) {
			for ( let o of this.objects ) {
				debug.lineStyle(2, 0xFF0000, 0.5).drawRect(o.r.x, o.r.y, Math.max(o.r.width, 1), Math.max(o.r.height, 1));
			}
		}
		for ( let n of this.nodes ) {
			n.visualize({objects});
		}
	}
}

/**
 * A constant that enumerates the index order of the quadtree nodes from top-left to bottom-right.
 * @type {{br: number, tl: number, bl: number, tr: number}}
 */
Quadtree.INDICES = {
	"tl": 0,
	"tr": 1,
	"bl": 2,
	"br": 3
};

/**
 * A ray for the purposes of computing sight and collision
 * Given points A[x,y] and B[x,y]
 *
 * Slope-Intercept form:
 * y = a + bx
 * y = A.y + ((B.y - A.Y) / (B.x - A.x))x
 *
 * Parametric form:
 * R(t) = (1-t)A + tB
 *
 * @param {{x: number, y: number}} A      The origin of the Ray
 * @param {{x: number, y: number}} B      The destination of the Ray
 */
class Ray {
	constructor(A, B) {
		 // Store points
		this.A = A;
		this.B = B;
		 // Origins
		this.y0 = A.y;
		this.x0 = A.x;
		 // Slopes
		this.dx = B.x - A.x;
		this.dy = B.y - A.y;
		 /**
		 * The slope of the ray, dy over dx
		 * @type {number}
		 */
		this.slope = this.dy / this.dx;
		 /**
		 * The normalized angle of the ray in radians on the range (-PI, PI)
		 * @type {number}
		 */
		this.angle = Math.atan2(this.dy, this.dx);
		 /**
		 * The distance of the ray
		 * @type {number}
		 */
		this.distance = Math.hypot(this.dx, this.dy);
	}
	 /* -------------------------------------------- */
	 /**
	 * A bounding rectangle that encompasses the Ray
	 * @type {NormalizedRectangle}
	 */
	get bounds() {
		return new NormalizedRectangle(this.A.x, this.A.y, this.dx, this.dy);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the value of the angle normalized to the range (0, 2*PI)
	 * This is useful for testing whether an angle falls between two others
	 * @type {number}
	 */
	get normAngle() {
		let a = this.angle % (2 * Math.PI);
		return a < 0 ? a + (2 * Math.PI) : a;
	}
		/* -------------------------------------------- */
	 /**
	 * A factory method to construct a Ray from an origin point, an angle, and a distance
	 * @param {number} x          The origin x-coordinate
	 * @param {number} y          The origin y-coordinate
	 * @param {number} radians    The ray angle in radians
	 * @param {number} distance   The distance of the ray in pixels
	 * @return {Ray}              The constructed Ray instance
	 */
	static fromAngle(x, y, radians, distance) {
		const dx = Math.cos(radians);
		const dy = Math.sin(radians);
		const ray = Ray.fromArrays([x ,y], [x + (dx * distance), y + (dy * distance)]);
		ray.angle = radians;
		return ray;
	}
	 /* -------------------------------------------- */
	 /**
	 * A factory method to construct a Ray from points in array format.
	 * @param {number[]} A    The origin point [x,y]
	 * @param {number[]} B    The destination point [x,y]
	 * @return {Ray}          The constructed Ray instance
	 */
	static fromArrays(A, B) {
		return new this({x: A[0], y: A[1]}, {x: B[0], y: B[1]});
	}
	 /* -------------------------------------------- */
	 /**
	 * Project the Array by some proportion of it's initial distance.
	 * Return the coordinates of that point along the path.
	 * @param {number} t    The distance along the Ray
	 * @return {Object}     The coordinates of the projected point
	 */
	project(t) {
		return {
			x: this.A.x + (t * this.dx),
			y: this.A.y + (t * this.dy)
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a new ray which uses the same origin point, but a slightly offset angle and distance
	 * @param {number} offset       An offset in radians which modifies the angle of the original Ray
	 * @param {number} [distance]   A distance the new ray should project, otherwise uses the same distance.
	 * @return {Ray}                A new Ray with an offset angle
	 */
	shiftAngle(offset, distance) {
		return Ray.fromAngle(this.x0, this.y0, this.angle + offset, distance || this.distance);
	}
	 /* -------------------------------------------- */
	 /**
	 * Find the point I[x,y] and distance t* on ray R(t) which intersects another ray
	 * http://paulbourke.net/geometry/pointlineplane/
	 *
	 * @param {number[]} coords     An array of coordinates [x0, y0, x1, y1] which defines a line segment to test
	 *
	 * @return {{x: number, y: number, t0: number, t1: number}|false}
	 *    The point of collision [x,y] the position of that collision point along the Ray (t0) an the tested
	 *    segment (t1). Returns false if no collision occurs.
	 */
	intersectSegment(coords) {
		return this.constructor._getIntersection(this.A.x, this.A.y, this.B.x, this.B.y, ...coords);
	}
	 /* -------------------------------------------- */
	 /**
	 * An internal helper method for computing the intersection between two lines.
	 * @private
	 */
	static _getIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
		let e = 1e-12;
		 // Length 0 === false
		if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {
			return false
		}
		 // Check denominator - avoid parallel lines where d = 0
		let d = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
		if (d === 0) {
			return false
		}
		 // Get vector distances
		let t0 = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / d;
		let t1 = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / d;
		 // Confirm the solution lies within both segments
		const collides = Number.between(t0, 0-e, 1+e) && Number.between(t1, 0-e, 1+e);
		if (!collides) return false;
		 // Return an objects with the point of intersection and the distance from the origin
		return {
			x: x1 + t0 * (x2 - x1),
			y: y1 + t0 * (y2 - y1),
			t0: t0,
			t1: t1
		}
	}
}

/**
 * A PIXI.Rectangle where the width and height are always positive and the x and y are always the top-left
 */
class NormalizedRectangle extends PIXI.Rectangle {
	constructor(x, y, width, height) {
		x = width > 0 ? x : x + width;
		y = height > 0 ? y : y + height;
		super(x, y, Math.abs(width), Math.abs(height));
	}
}

class ResizeHandle extends PIXI.Graphics {
	constructor(offset, ...args) {
		super(...args);
		this.offset = offset;
		this.lineStyle(4, 0x000000, 1.0).beginFill(0xFF9829, 1.0).drawCircle(0, 0, 10);
	}
	 /* -------------------------------------------- */
	 refresh(bounds) {
		this.position.set(bounds.x + (bounds.width * this.offset[0]), bounds.y + (bounds.height * this.offset[1]));
	}
	 /* -------------------------------------------- */
	 updateDimensions(current, origin, destination, {aspectRatio=null}={}) {
		 // Identify the change in dimensions
		const dx = destination.x - origin.x;
		const dy = destination.y - origin.y;
		 // Determine the new width and the new height
		let width = Math.max(origin.width + dx, 24);
		let height = Math.max(origin.height + dy, 24);
		 // Constrain the aspect ratio
		if ( aspectRatio ) {
			if ( width >= height ) width = height * aspectRatio;
			else height = width / aspectRatio;
		}
		 // Adjust the final points
		return {
			x: current.x,
			y: current.y,
			width: width * Math.sign(current.width),
			height: height * Math.sign(current.height)
		};
	}
}
/**
 * A helper class used by the Sight Layer to represent a source of vision or illumination.
 */
class PointSource {
	constructor() {
		 /**
		 * The light or darkness container for this source
		 * @type {PIXI.Container}
		 */
		this.illumination = this._createContainer(StandardIlluminationShader);
		 /**
		 * This visible color container for this source
		 * @type {PIXI.Container}
		 */
		this.coloration = this._createContainer(StandardColorationShader);
		 /**
		 * A flag for whether this source is currently active (rendered) or not
		 * @type {boolean}
		 */
		this.active = false;
		 /**
		 * Internal flag for whether this is a darkness source
		 * @type {boolean}
		 */
		this.darkness = false;
		 /**
		 * Is the light source limited by an angle of emission?
		 * @type {boolean}
		 */
		this.limited = false;
		 /**
		 * The maximum radius of emission for this source
		 * @type {number}
		 */
		this.radius = 0;
		 /**
		 * Internal flag for animation throttling time
		 * @type {number}
		 */
		this._animateTime = 0;
		 /**
		 * An integer seed which de-synchronizes otherwise similar animations
		 * @type {number|null}
		 */
		this._animateSeed = null;
		 /**
		 * A flag for whether to re-initialize illumination shader uniforms the next time the light is rendered.
		 * @type {boolean}
		 */
		this._resetIlluminationUniforms = true;
		 /**
		 * A flag for whether to re-initialize coloration shader uniforms the next time the light is rendered.
		 * @type {boolean}
		 */
		this._resetColorationUniforms = true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Create the structure of a source Container which can be rendered to the sight layer shadow-map
	 * @return {PIXI.Container} The constructed light source container
	 * @private
	 */
	_createContainer(shaderCls) {
		const c = new PIXI.Container();
		 // Create the Mesh used to render the source
		const state = new PIXI.State();
		const light = new PIXI.Mesh(PointSource.GEOMETRY, shaderCls.create(), state);
		c.light = c.addChild(light);
		 // Mask the light using it's FOV polygon
		c.fov = c.addChild(new PIXI.Graphics());
		c.mask = c.fov;
		 // Define container properties
		Object.defineProperty(c, "shader", { get: () => c.light.shader, set: shader => c.light.shader = shader });
		Object.defineProperty(c, "uniforms", { get: () => c.light.shader.uniforms });
		return c;
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize the source with provided object data.
	 *
	 * @param {object} data       Input data which configures the source.
	 * @param {number} data.x          The x-coordinate of the source location
	 * @param {number} data.y          The y-coordinate of the source location
	 * @param {number} [data.z]        An optional z-index sorting for the source
	 * @param {number} data.dim        The allowed radius of dim vision or illumination
	 * @param {number} data.bright     The allowed radius of bright vision or illumination
	 * @param {number} data.angle      The angle of emission for this point source
	 * @param {number} data.rotation   The angle of rotation for this point source
	 * @param {number} data.color      A tint color for the emitted light, if any
	 * @param {number} data.alpha      An opacity for the emitted light, if any
	 * @param {number} data.darknessThreshold  A level of darkness beyond which this light is active
	 * @param {string} data.type       The source type from SOURCE_TYPES
	 * @param {object} data.animation  An animation configuration for the source
	 * @param {number} data.seed       An integer seed to synchronize (or de-synchronize) animations
	 *
	 * @return {PointSource}      A reference to the initialized source
	 */
	initialize(data={}) {
		 // Clean input data
		data.animation = data.animation || {type: null};
		data.angle = data.angle ?? 360;
		data.alpha = data.alpha ?? 0.5;
		data.bright = data.bright ?? 0;
		data.color = typeof data.color === "string" ? colorStringToHex(data.color) : (data.color ?? null);
		data.darknessThreshold = data.darknessThreshold ?? 0;
		data.dim = data.dim ?? 0;
		data.rotation = data.rotation ?? 0;
		data.type = data.type ?? SOURCE_TYPES.LOCAL;
		data.x = data.x ?? 0;
		data.y = data.y ?? 0;
		data.z = data.z ?? null;
		 // Identify changes and assign cleaned data
		const changes = diffObject(this, data);
		mergeObject(this, data);
		 // Derived data attributes
		this.colorRGB = hexToRGB(this.color);
		this.radius = Math.max(Math.abs(this.dim), Math.abs(this.bright));
		this.ratio = Math.clamped(Math.abs(this.bright) / this.radius, 0, 1);
		this.darkness = Math.min(this.dim, this.bright) < 0;
		this.limited = this.angle !== 360;
		this._animateSeed = data.seed ?? this._animateSeed ?? Math.floor(Math.random() * 100000);
		 // Always update polygons for the source as the environment may have changed
		const {fov, los} = SightLayer.computeSight({x: this.x, y: this.y}, this.radius, {
			angle: this.angle,
			rotation: this.rotation,
			unrestricted: this.type === SOURCE_TYPES.UNIVERSAL
		});
		this.fov = fov;
		this.los = los;
		 // Update shaders if the animation type changed
		const updateShaders = "animation" in changes;
		if ( updateShaders ) this._initializeShaders();
		 // Initialize uniforms if the appearance of the light changed
		const uniformAttrs = ["dim", "bright", "color", "alpha", "animation"];
		if ( uniformAttrs.some(k => k in changes) ) {
			this._resetColorationUniforms = true;
			this._resetIlluminationUniforms = true;
		}
		 // Initialize blend modes and sorting
		this._initializeBlending();
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize the shaders used for this animation.
	 * Reset the current shader values back to defaults.
	 * Swap to a different Shader instance if necessary.
	 * @private
	 */
	_initializeShaders() {
		const anim = CONFIG.Canvas.lightAnimations[this.animation.type] || {};
		 // Initialize illumination shader
		const iCls = anim.illuminationShader || StandardIlluminationShader;
		const is = this.illumination.shader;
		if ( is?.constructor.name !== iCls.name ) {
			const shader = iCls.create();
			shader.container = this.illumination;
			this.illumination.shader = shader;
			if ( is ) is.destroy();
		}
		 // Initialize coloration shader
		const cCls = anim.colorationShader || StandardColorationShader;
		const cs = this.coloration.shader;
		if ( cs?.constructor.name !== cCls.name ) {
			const shader = cCls.create();
			shader.container = this.coloration;
			this.coloration.shader = shader;
			if ( cs ) cs.destroy();
		}
		 // Dispatch a hook which allows for modules to apply fine-grained customization to the source
		Hooks.callAll("initializePointSourceShaders", this, this.animation.type);
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize the blend mode and vertical sorting of this source relative to others in the container.
	 * @private
	 */
	_initializeBlending() {
		if ( this.darkness ) {
			this.illumination.light.blendMode = PIXI.BLEND_MODES.MIN_COLOR;
			this.illumination.zIndex = this.z ?? 10;
			this.coloration.light.blendMode = PIXI.BLEND_MODES.MULTIPLY;
			this.coloration.zIndex = this.z ?? 10;
		} else {
			this.illumination.light.blendMode = PIXI.BLEND_MODES.MAX_COLOR;
			this.illumination.zIndex = this.z ?? 0;
			this.coloration.light.blendMode = PIXI.BLEND_MODES.SCREEN;
			this.coloration.zIndex = this.z ?? 0;
		}
	}
	 /* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */
	 /**
	 * Draw the display of this source for the darkness/light container of the SightLayer.
	 * @param {boolean} [updateChannels=false] Is this drawing initiated because lighting channels have changed?
	 * @return {PIXI.Container}         The rendered light container
	 */
	drawLight({updateChannels=false}={}) {
		const iu = this.illumination.shader.uniforms;
		if ( this._resetIlluminationUniforms || updateChannels ) {
			const channels = canvas.lighting.channels;
			iu.colorDim = this.darkness ? channels.dark.rgb : channels.dim.rgb;
			iu.colorBright = this.darkness ? channels.black.rgb : channels.bright.rgb;
		}
		if ( this._resetIlluminationUniforms ) {
			iu.ratio = this.ratio;
			this._resetIlluminationUniforms = false;
		}
		return this._drawContainer(this.illumination);
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw and return a container used to depict the visible color tint of the light source on the LightingLayer
	 * @return {PIXI.Container}           An updated color container for the source
	 */
	drawColor() {
		const hasColor = this.color && (this.alpha > 0);
		if ( !hasColor && !this.darkness ) return null;
		if ( this._resetColorationUniforms ) {
			const cu = this.coloration.shader.uniforms;
			cu.darkness = this.darkness;
			cu.alpha = this.alpha;
			cu.color = this.colorRGB;
			this._resetColorationUniforms = false;
		}
		return this._drawContainer(this.coloration);
	}
	 /* -------------------------------------------- */
	 /**
	 * A common helper function for updating the display of a source container.
	 * Assign the container position, dimensions, and polygons.
	 * @private
	 */
	_drawContainer(c) {
		c.light.position.set(this.x, this.y);
		c.light.width = c.light.height = this.radius * 2;
		c.fov.clear();
		if ( this.radius > 0 ) c.fov.beginFill(0xFFFFFF, 1.0).drawPolygon(this.fov).endFill();
		return c;
	}
	 /* -------------------------------------------- */
	/*  Light Source Animation                      */
	/* -------------------------------------------- */
	 /**
	 * Animate the PointSource, if an animation is enabled and if it currently has rendered containers.
	 * @param {number} dt         Delta time
	 */
	animate(dt) {
		const animation = this.animation;
		if ( !animation.type || (this.radius === 0) ) return;
		const fn = CONFIG.Canvas.lightAnimations[animation.type]?.animation;
		if ( fn ) fn.call(this, dt, animation);
	}
	 /* -------------------------------------------- */
	 /**
	 * A torch animation where the luminosity and coloration decays each frame and is revitalized by flashes
	 * @param {number} dt         Delta time
	 * @param {number} speed      The animation speed, from 1 to 10
	 * @param {number} intensity  The animation intensity, from 1 to 10
	 */
	animateTorch(dt, { speed = 5, intensity = 5 }) {
		const t = canvas.app.ticker.lastTime;
		this._animTime = t / (5000 / speed);
		const iu = this.illumination.uniforms;
		const cu = this.coloration.uniforms;
		const w = 0.5 * (Math.cos(t * 0.01) + 1);
		const wave = (a, b, w) => (a - b) * w + b;
		 // When a "flash" occurs
		if ((t > (this._flashTime || 0))) {
			 // Randomize the next time to flash
			const s = (11 - speed) * 50;
			const deltaMS = Math.random() * s;
			this._flashTime = t + deltaMS;
			 // Randomize the color intensity of the flash
			const mu = this.alpha - cu.alpha;                                 // On average, increase to the normal alpha
			const sigma = intensity * 0.05;                                   // Variance of the spikes
			const epsilon = twist.normal(mu, sigma);
			const maxA = Math.min(this.alpha * 1.1, 0.5 + (this.alpha / 2));  // Maximum alpha that the spike can reach
			cu.alpha = Math.clamped(cu.alpha + epsilon, cu.alpha, maxA);
			const ei = twist.normal(1 - iu.alpha, sigma);
			iu.alpha = Math.clamped(iu.alpha + ei, iu.alpha, 1);
			 // Boost the ratio of bright:dim
			iu.ratio = this.ratio * iu.alpha;
			cu.ratio = iu.ratio;
		}
		 // Animate the dampening process
		const dc = 0.0005 * (speed + intensity);
		const dw = dc / 2;
		const wv = wave(1.0 + dw, 1.0 - dw, w);
		iu.alpha = iu.alpha * (1.0 - dc) * wv;
		iu.ratio = iu.ratio * (1.0 - dc) * wv;
		cu.alpha = cu.alpha * (1.0 - dc) * wv;
		cu.ratio = cu.ratio * (1.0 - dc) * wv;
		cu.time = iu.time = this._animTime;
	}
	 /* -------------------------------------------- */
	 /**
	 * A basic "pulse" animation which expands and contracts.
	 * @param {number} dt         Delta time
	 * @param {number} speed      The animation speed, from 1 to 10
	 * @param {number} intensity  The animation intensity, from 1 to 10
	 */
	animatePulse(dt, { speed = 5, intensity = 5 } = {}) {
		this._animTime = canvas.app.ticker.lastTime / (5000 / speed);
		const i = (10 - intensity) * 0.1;
		const si = Math.sqrt(i);
		const w = 0.5 * (Math.cos(this._animTime * 2.5) + 1);
		const wave = (a, b, w) => (a - b) * w + b;
		 // Pulse coloration
		const co = this.coloration;
		co.uniforms.intensity = intensity;
		co.uniforms.time = this._animTime;
		co.uniforms.alpha = wave(this.alpha, this.alpha * si, w);
		co.uniforms.pulse = wave(1.2, i, w);
		 // Pulse illumination
		const il = this.illumination;
		il.uniforms.intensity = intensity;
		il.uniforms.time = this._animTime;
		il.uniforms.alpha = wave(1.1, 1.1 * si, w);
		il.uniforms.ratio = wave(this.ratio, this.ratio * i, w);
	}
	 /* -------------------------------------------- */
	 /**
	 * Emanate waves of light from the source origin point
	 * @param {number} dt         Delta time
	 * @param {number} speed      The animation speed, from 1 to 10
	 * @param {number} intensity  The animation intensity, from 1 to 10
	 */
	animateTime(dt, {speed=5, intensity=5}={}) {
		this._animTime = (canvas.app.ticker.lastTime / (5000/speed)) + this._animateSeed;
		const co = this.coloration;
		co.uniforms.intensity = intensity;
		co.uniforms.time = this._animTime;
		const il = this.illumination;
		il.uniforms.intensity = intensity;
		il.uniforms.time = this._animTime;
	}
	 /* -------------------------------------------- */
	 /**
	 * Evolve a value using a stochastic AR(1) process
	 * @param {number} y        The current value
	 * @param {number} phi      The decay rate of prior values
	 * @param {number} center   The stationary mean of the series
	 * @param {number} sigma    The volatility of the process - standard deviation of the error term
	 * @param {number|null} max The maximum allowed outcome, or null
	 * @param {number|null} min The minimum allowed outcome, or null
	 * @return {number}         The new value of the process
	 * @private
	 */
	_ar1(y, {phi=0.5, center=0, sigma=0.1, max=null, min=null}={}) {
		let yt = center + (phi * (y - center)) + twist.normal(0, sigma);
		if ( max !== null ) yt = Math.min(yt, max);
		if ( min !== null ) yt = Math.max(yt, min);
		return yt;
	}
}

/* -------------------------------------------- */
/*  Shader Definitions                          */
/* -------------------------------------------- */

/**
 * The default Geometry stored in the GPU for all Point Source meshes.
 * @type {PIXI.Geometry}
 */
PointSource.GEOMETRY = new PIXI.Geometry()
	.addAttribute('aVertexPosition', [-1, -1, 1, -1, 1, 1, -1, 1], 2)
	.addAttribute('aUvs', [0, 0, 1, 0, 1, 1, 0, 1], 2)
	.addIndex([0, 1, 2, 0, 2, 3]);

/**
 * An extension of the default PIXI.Text object which forces double resolution.
 * At default resolution Text often looks blurry or fuzzy.
 */
class PreciseText extends PIXI.Text {
	constructor(...args) {
		super(...args);
		this._autoResolution = false;
		this._resolution = 2;
	}
}
/**
 * A PIXI.Container subclass of CanvasLayer responsible for rendering the scene background image.
 * The singleton instance of this class is accessed through ``canvas.background``. 
 *
 * @type {CanvasLayer}
 */
class BackgroundLayer extends CanvasLayer {
	constructor() {
		super();
		 /**
		 * The background image
		 * @type {PIXI.Sprite}
		 */
		this.img = null;
	}
	 /* -------------------------------------------- */
	/*  Properties and Attributes
	/* -------------------------------------------- */
	 /**
	 * Return the base HTML element which is used to generate the Scene background
	 * @return {HTMLElement}
	 */
	get source() {
		if ( !this.img || !this.img.texture || !this.img.texture.valid ) return null;
		const bt = this.img.texture.baseTexture;
		return bt.resource.source;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a Boolean flag for whether the Scene background texture is a Video element
	 * @return {boolean}
	 */
	get isVideo() {
		let source = this.source;
		return ( source && source.tagName === "VIDEO" );
	}
	 /* -------------------------------------------- */
	/*  Rendering
	/* -------------------------------------------- */
	 /** @override */
	activate() {
		return false;
	}
	 /* -------------------------------------------- */
	 /** @override */
	async tearDown() {
		if ( this.isVideo ) this.source.pause();
		this.img = null;
		return super.tearDown();
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the background image.
	 * We first load the image texture and store it in the PIXI loader.
	 * Once the requested image has been fully loaded we draw it as a PIXI.Sprite
	 *
	 * @return {Promise.<BackgroundLayer>}    Returns the instance of the Background Layer for convenient chaining
	 */
	async draw() {
		if ( !canvas.scene.data.img ) return;
		 // Load the background texture
		let tex = getTexture(canvas.scene.data.img);
		if ( tex === null ) return this;
		 // Validate the texture size is allowed
		const gl = canvas.app.renderer.context.gl;
		const max = gl.getParameter(gl.MAX_TEXTURE_SIZE);
		const {width, height} = tex.orig;
		if ( (width > max) || (height > max) ) {
			const err = new Error(game.i18n.format("ERROR.BackgroundTextureSize", {width, height, max}));
			ui.notifications.error(err.message, {permanent: true});
			throw err;
		}
		 // If the canvas does not have dimensions set - push them and restart the process
		let scene = canvas.scene;
		if ( !scene.data.width || !scene.data.height ) {
			canvas.scene.update({width, height}, true);
		}
		 // Create and configure the background Sprite
		const bg = this.img = this.addChild(new PIXI.Sprite(tex));
		const d = canvas.dimensions;
		bg.position.set(d.paddingX - d.shiftX, d.paddingY - d.shiftY);
		bg.width = d.sceneWidth;
		bg.height = d.sceneHeight;
		 // Ensure playback state for video backgrounds
		if ( this.isVideo ) {
			this.source.loop = true;
			this.source.volume = game.settings.get("core", "globalAmbientVolume");
			game.video.play(this.source);
		}
		 // Return the layer
		return this;
	}
	 /* -------------------------------------------- */
	/*  Deprecated
	/* -------------------------------------------- */
	 /**
	 * @deprecated since 0.7.2
	 * @see {@link createThumbnail}
	 */
	static async createThumbnail(...args) {
		console.warn("You are using the BackgroundLayer.createThumbnail method which has been deprecated in favor of the ImageHelper.createThumbnail() or Scene#createThumbnail() methods.");
		return ImageHelper.createThumbnail(...args);
	}
}

/**
 * The DrawingsLayer subclass of PlaceablesLayer
 *
 * This layer implements a container for drawings which are rendered immediately above the TilesLayer
 * and immediately below the GridLayer.
 *
 * @type {PlaceablesLayer}
 */
class DrawingsLayer extends PlaceablesLayer {
	 /** @override */
	static get layerOptions() {
		return mergeObject(super.layerOptions, {
			canDragCreate: true,
			canDelete: true,
			controllableObjects: true,
			rotatableObjects: true,
			objectClass: Drawing,
			sheetClass: DrawingConfig,
			zIndex: 20
		});
	}
	 /* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /**
	 * Use an adaptive precision depending on the size of the grid
	 * @type {number}
	 */
	get gridPrecision() {
		let size = canvas.dimensions.size;
		if ( size >= 128 ) return 16;
		else if ( size >= 64 ) return 8;
		else if ( size >= 32 ) return 4;
		else if ( size >= 16 ) return 2;
	}
	 /* -------------------------------------------- */
	 /** @override */
	get hud() {
		return canvas.hud.drawing;
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /**
	 * Render a configuration sheet to configure the default Drawing settings
	 */
	configureDefault() {
		const defaults = this._getNewDrawingData({});
		let d = new Drawing(defaults);
		new DrawingConfig(d, {configureDefault: true}).render(true);
	}
	 /* -------------------------------------------- */
	 /**
	 * Override the deactivation behavior of this layer.
	 * Placeables on this layer remain visible even when the layer is inactive.
	 */
	deactivate() {
		super.deactivate();
		if (this.objects) this.objects.visible = true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get initial data for a new drawing.
	 * Start with some global defaults, apply user default config, then apply mandatory overrides per tool.
	 * @param {Object} origin     The initial coordinate
	 * @return {Object}           The new drawing data
	 * @private
	 */
	_getNewDrawingData(origin) {
		const tool = game.activeTool;
		 // Update with User Defaults
		const saved = game.settings.get("core", this.constructor.DEFAULT_CONFIG_SETTING);
		const defaults = mergeObject(CONST.DRAWING_DEFAULT_VALUES, saved, {inplace: false});
		 // Optional client overrides
		const data = mergeObject(defaults, {
			fillColor: game.user.color,
			strokeColor: game.user.color,
			fontFamily: CONFIG.defaultFontFamily
		}, {overwrite: false});
		 // Mandatory additions
		data.x = origin.x;
		data.y = origin.y;
		data.author = game.user._id;
		 // Tool-based settings
		switch ( tool ) {
			case "rect":
				data.type = CONST.DRAWING_TYPES.RECTANGLE;
				break;
			case "ellipse":
				data.type = CONST.DRAWING_TYPES.ELLIPSE;
				break;
			case "polygon":
				data.type = CONST.DRAWING_TYPES.POLYGON;
				data.points = [[0, 0]];
				break;
			case "freehand":
				data.type = CONST.DRAWING_TYPES.FREEHAND;
				data.points = [[0, 0]];
				data.bezierFactor = saved.bezierFactor ?? 0.5;
				break;
			case "text":
				data.type = CONST.DRAWING_TYPES.TEXT;
				data.fillColor = "#FFFFFF";
				data.fillAlpha = 0.10;
				data.strokeColor = "#FFFFFF";
				data.text = data.text || "New Text";
		}
		return data;
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	_onClickLeft(event) {
		const {preview, createState, originalEvent} = event.data;
		 // Continue polygon point placement
		if ( createState >= 1 && preview.isPolygon ) {
			let point = event.data.destination;
			if ( !originalEvent.shiftKey ) point = canvas.grid.getSnappedPosition(point.x, point.y, this.gridPrecision);
			preview._addPoint(point, false);
			preview._chain = true; // Note that we are now in chain mode
			return preview.refresh();
		}
		 // Standard left-click handling
		super._onClickLeft(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onClickLeft2(event) {
		const {createState, preview} = event.data;
		 // Conclude polygon placement with double-click
		if ( createState >= 1 && preview.isPolygon ) {
			event.data.createState = 2;
			return this._onDragLeftDrop(event);
		}
		 // Standard double-click handling
		super._onClickLeft2(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftStart(event) {
		super._onDragLeftStart(event);
		const data = this._getNewDrawingData(event.data.origin);
		const drawing = new Drawing(data);
		event.data.preview = this.preview.addChild(drawing);
		drawing.draw();
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftMove(event) {
		const {preview, createState} = event.data;
		if ( !preview ) return;
		if ( preview.parent === null ) { // In theory this should never happen, but rarely does
			this.preview.addChild(preview);
		}
		if (createState >= 1 ) {
			preview._onMouseDraw(event);
			if ( preview.data.type !== CONST.DRAWING_TYPES.POLYGON ) event.data.createState = 2;
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handling of mouse-up events which conclude a new object creation after dragging
	 * @private
	 */
	_onDragLeftDrop(event) {
		const { createState, destination, origin, preview } = event.data;
		 // Successful drawing completion
		if ( createState === 2 ) {
			const distance = Math.hypot(destination.x - origin.x, destination.y - origin.y);
			const minDistance = distance >= (canvas.dimensions.size / this.gridPrecision);
			const completePolygon = preview.isPolygon && (preview.data.points.length > 2);
			 // Create a completed drawing
			if ( minDistance || completePolygon ) {
				event.data.createState = 0;
				const data = preview.data;
				 // Set default text values
				if (data.type === CONST.DRAWING_TYPES.TEXT) {
					data.fillColor = null;
					data.fillAlpha = 0;
					data.strokeColor = null;
					data.strokeWidth = 0;
				}
				 // Adjust the final data
				const createData = Drawing.normalizeShape(data);
				 // Create the object
				preview._chain = false;
				preview.constructor.create(createData).then(d => {
					d._creating = true;
					d._pendingText = "";
					if ( data.type !== CONST.DRAWING_TYPES.FREEHAND ) d.control({isNew: true});
				});
			}
			 // Cancel the preview
			return this._onDragLeftCancel(event);
		}
		 // In-progress polygon
		if ( (createState === 1) && preview.isPolygon ) {
			event.data.originalEvent.preventDefault();
			if ( preview._chain ) return;
			return this._onClickLeft(event);
		}
		 // Incomplete drawing
		return this._onDragLeftCancel(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftCancel(event) {
		const preview = this.preview.children?.[0] || null;
		if ( preview?._chain ) {
			preview._removePoint();
			preview.refresh();
			if (preview.data.points.length) return event.preventDefault();
		}
		super._onDragLeftCancel(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onClickRight(event) {
		const preview = this.preview.children?.[0] || null;
		if ( preview ) return canvas.mouseInteractionManager._dragRight = false;
		super._onClickRight(event);
	}
}

// Configuration Setting
DrawingsLayer.DEFAULT_CONFIG_SETTING = "defaultDrawingConfig";

/**
 * A CanvasLayer for displaying visual effects like weather, transitions, flashes, or more
 * @type {CanvasLayer}
 */
class EffectsLayer extends CanvasLayer {
	constructor() {
		super();
		 /**
		 * The weather overlay container
		 * @type {PIXI.Container}
		 */
		this.weather = null;
		 /**
		 * The currently active weather effect
		 * @type {SpecialEffect}
		 */
		this.weatherEffect = null;
		 /**
		 * Track any active emitters within this Scene
		 * @type {Object[]}
		 */
		this.emitters = [];
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get layerOptions() {
		return mergeObject(super.layerOptions, { zIndex: 300 });
	}
	 /* -------------------------------------------- */
	 /** @override */
	tearDown() {
		if ( this.weatherEffect ) this.weatherEffect.stop();
		this.weather = this.weatherEffect = null;
		return super.tearDown();
	}
		/* -------------------------------------------- */
	 /** @override */
	async draw() {
		this.drawWeather();
	}
	 /* -------------------------------------------- */
	 drawWeather() {
		if ( this.weatherEffect )	this.weatherEffect.stop();
		if ( !this.weather ) this.weather = this.addChild(new PIXI.Container());
		 // Get the requested weather effect
		const effect = CONFIG.weatherEffects[canvas.scene.data.weather];
		if ( !effect ) return;
		 // Create the effect and begin playback
		this.weatherEffect = new effect(this.weather);
		this.weatherEffect.play();
	}
}

/**
 * The Lighting Layer which displays darkness and light within the rendered Scene.
 * Lighting Layer (Container)
 *   Illumination Container [MULTIPLY]
 *     Background (Graphics)
 *     Light (Container) [LOS Mask]
 *       Source 1, ..., Source N (Container)
 *     Darkness (Container)
 *       Source 1, ..., Source N (Container)
 *   Coloration Container [ADD_NPM]
 * @extends {PlaceablesLayer}
 *
 * @example <caption>The lightingRefresh hook</caption>
 * Hooks.on("lightingRefresh", layer => {});
 */
class LightingLayer extends PlaceablesLayer {
	constructor(...args) {
		super(...args);
		 /**
		 * A mapping of light sources which are active within the rendered Scene
		 * @type {Collection<string,PointSource>}
		 */
		this.sources = new Collection();
		 /**
		 * A mapping of different light level channels
		 * @typedef {{hex: number, rgb: number[]}} LightChannel
		 * @type {{black: LightChannel, dark: LightChannel, dim: LightChannel, bright: LightChannel}}
		 */
		this.channels = {};
		 /**
		 * The currently displayed darkness level, which may override the saved Scene value
		 * @type {number|null}
		 * @private
		 */
		this.darknessLevel = null;
		 /**
		 * The current client setting for whether global illumination is used or not
		 * @type {boolean}
		 */
		this.globalLight = false;
		 /**
		 * The coloration container which visualizes the effect of light sources
		 * @type {PIXI.Container}
		 */
		this.coloration = null;
		 /**
		 * The illumination container which visualizes darkness and light
		 * @type {PIXI.Container}
		 */
		this.illumination = null;
		 /**
		 * A flag for whether the darkness level is currently animating
		 * @type {boolean}
		 */
		this._animating = false;
		 /**
		 * An array of light sources which are currently animated
		 * @type {PointSource[]}
		 */
		this._animatedSources = [];
		 /**
		 * The blur distance for soft shadows
		 * @type {number}
		 */
		this._blurDistance = 0;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get layerOptions() {
		return mergeObject(super.layerOptions, {
			rotatableObjects: true,
			objectClass: AmbientLight,
			quadtree: true,
			sheetClass: LightConfig,
			zIndex: 200
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Configure the lighting channels which are inputs to the ShadowMap
	 * @return {{black: object, dark: object, dim: object, bright: object}}
	 * @private
	 */
	_configureChannels(darkness=null) {
		let {darknessColor, daylightColor, lightLevels, darknessLightPenalty} = CONFIG.Canvas;
		const {dark, dim, bright} = lightLevels;
		darkness = darkness ?? canvas.scene.data.darkness;
		const channels = { canvas: {}, background: {}, black: {}, bright: {}, dark: {}, dim: {} };
		 // The canvas background is a blend between the Scene background color and the darkness level
		const darknessRGB = hexToRGB(darknessColor);
		const sceneRGB = hexToRGB(canvas.backgroundColor);
		channels.canvas.rgb = darknessRGB.map((c, i) => ((1-darkness) + (darkness*c)) *sceneRGB[i]);
		channels.canvas.hex = rgbToHex(channels.canvas.rgb);
		 // The background is based on the darkness color and the darkness level
		const daylightRGB = canvas.scene.data.tokenVision ? hexToRGB(daylightColor) : [1.0, 1.0, 1.0];
		channels.background.rgb = darknessRGB.map((c, i) => (darkness * c) + ((1-darkness) * daylightRGB[i]));
		channels.background.hex = rgbToHex(channels.background.rgb);
		 // Magical darkness and blackness is based on the true darkness color
		channels.dark.rgb = darknessRGB.map(c => (1 + dark) * c);
		channels.dark.hex = rgbToHex(channels.dark.rgb);
		channels.black.rgb = channels.dark.rgb.map(c => 0.5 * c);
		channels.black.hex = rgbToHex(channels.black.rgb);
		 // Bright light is penalized by the darkness level
		const penalty = 1 - (darknessLightPenalty * darkness);
		channels.bright.rgb = [1,1,1].map(c => bright * c * penalty);
		channels.bright.hex = rgbToHex(channels.bright.rgb);
		 // Dim light is halfway between darkness and bright
		channels.dim.rgb = channels.bright.rgb.map((c, i) => (dim * c) + ((1 - dim) * darknessRGB[i]));
		channels.dim.hex = rgbToHex(channels.dim.rgb);
		return channels;
	}
	 /* -------------------------------------------- */
	/*  Rendering
	/* -------------------------------------------- */
	 /** @override */
	async draw() {
		this.globalLight = canvas.scene.data.globalLight;
		this._blurDistance = game.settings.get("core", "softShadows") ? CONFIG.Canvas.blurStrength : 0;
		 // Create containers
		this.lighting = this.addChild(new PIXI.Container());
		this.illumination = this.lighting.addChild(this._drawIlluminationContainer());
		this.coloration = this.lighting.addChild(this._drawColorationContainer());
		 // Draw the objects container
		await super.draw();
		 // Draw the background
		const bgRect = canvas.dimensions.sceneRect.clone().pad(this._blurDistance * 2);
		this.illumination.background.clear().beginFill(0xFFFFFF, 1.0).drawShape(bgRect).endFill();
		 // Mask the containers by the outer rectangle, keep extra padding
		this.msk = this.addChild(new PIXI.Graphics());
		this.msk.beginFill(0xFFFFFF, 1.0).drawShape(canvas.dimensions.sceneRect).endFill();
		this.lighting.mask = this.msk;
		 // Activate animation
		this.activateAnimation();
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the coloration container which is responsible for rendering the visible hue of a light source.
	 * Apply an additive blend to the entire container after each individual light source is blended via screen.
	 * @return {PIXI.Container}
	 * @private
	 */
	_drawColorationContainer() {
		const c = new PIXI.Container();
		c.filter = this._blurDistance ?
			new PIXI.filters.FXAAFilter() :
			new PIXI.filters.AlphaFilter(1.0);
		c.filter.blendMode = PIXI.BLEND_MODES.ADD;
		c.filters = [c.filter];
		c.sortableChildren = true;
		return c;
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the illumination container which is responsible for displaying darkness and light.
	 * @return {PIXI.Container}
	 * @private
	 */
	_drawIlluminationContainer() {
		const c = new PIXI.Container();
		c.background = c.addChild(new PIXI.Graphics());
		c.lights = c.addChild(new PIXI.Container());
		c.lights.sortableChildren = true;
		c.filter = this._blurDistance ?
			new PIXI.filters.BlurFilter(this._blurDistance) :
			new PIXI.filters.AlphaFilter(1.0);
		c.filter.blendMode = PIXI.BLEND_MODES.MULTIPLY;
		c.filters = [c.filter];
		c.filterArea = canvas.app.renderer.screen;
		return c;
	}
	 /* -------------------------------------------- */
	/*  Layer Methods                               */
	/* -------------------------------------------- */
	 /**
	 * Does this scene currently benefit from global illumination?
	 * @returns {boolean}
	 */
	hasGlobalIllumination() {
		const sd = canvas.scene.data;
		return sd.globalLight && (!sd.globalLightThreshold || (this.darknessLevel <= sd.globalLightThreshold));
	}
	 /* -------------------------------------------- */
	 /**
	 * Refresh the active display of the LightingLayer.
	 * Update the scene background color, light sources, and darkness sources
	 * @param darkness
	 */
	refresh(darkness) {
		const darknessChanged = darkness && (darkness !== this.darknessLevel)
		this.darknessLevel = darkness = darkness ?? this.darknessLevel;
		this.channels = this._configureChannels(darkness);
		let refreshVision = false;
		 // Track global illumination
		const globalLight = this.hasGlobalIllumination();
		if ( globalLight !== this.globalLight ) {
			this.globalLight = globalLight;
			canvas.tokens.controlled.forEach(t => t.updateSource({defer: true}));
			refreshVision = true;
		}
		 // Clear currently rendered sources
		const ilm = this.illumination;
		ilm.lights.removeChildren();
		const col = this.coloration;
		col.removeChildren();
		this._animatedSources = [];
		 // Tint the background color
		canvas.app.renderer.backgroundColor = this.channels.canvas.hex;
		ilm.background.tint = this.channels.background.hex;
		 // Render light sources
		for ( let sources of [this.sources, canvas.sight.sources] ) {
			for ( let source of sources ) {
				 // Check the active state of the light source
				const isActive = source.darknessThreshold <= darkness;
				if ( source.active !== isActive ) refreshVision = true;
				source.active = isActive;
				if ( !source.active ) continue;
				 // Draw the light update
				const sc = source.drawLight(darknessChanged);
				ilm.lights.addChild(sc);
				const color = source.drawColor();
				if ( color ) col.addChild(color);
				if ( source.animation?.type ) this._animatedSources.push(source);
			}
		}
		 // Refresh vision if necessary
		if ( refreshVision ) canvas.sight.refresh();
		 // Dispatch a hook that modules can use
		Hooks.callAll("lightingRefresh", this);
	}
	 /* -------------------------------------------- */
	 /** @override */
	tearDown() {
		this.deactivateAnimation();
		return super.tearDown();
	}
	 /* -------------------------------------------- */
	/*  Animation                                   */
	/* -------------------------------------------- */
	 /**
	 * Activate light source animation for AmbientLight objects within this layer
	 */
	activateAnimation() {
		this.deactivateAnimation();
		if ( game.settings.get("core", "lightAnimation") === false ) return;
		this._animateTime = Date.now();
		canvas.app.ticker.add(this._animateSource, this);
	}
	 /* -------------------------------------------- */
	 /**
	 * Deactivate light source animation for AmbientLight objects within this layer
	 */
	deactivateAnimation() {
		canvas.app.ticker.remove(this._animateSource, this);
	}
	 /* -------------------------------------------- */
	 /**
	 * The ticker handler which manages animation delegation
	 * @param {number} dt   Delta time
	 * @private
	 */
	_animateSource(dt) {
		for ( let source of this._animatedSources ) {
			source.animate(dt);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Animate a smooth transition of the darkness overlay to a target value.
	 * Only begin animating if another animation is not already in progress.
	 * @param {number} target     The target darkness level between 0 and 1
	 * @param {number} duration   The desired animation time in milliseconds. Default is 10 seconds
	 * @return {Promise<void>}    A Promise which resolves once the animation is complete
	 */
	async animateDarkness(target=1.0, {duration=10000}={}) {
		if ( this._animating ) return;
		const animationData = [{
			parent: {darkness: this.darknessLevel},
			attribute: "darkness",
			to: Math.clamped(target, 0, 1)
		}];
		 // Trigger the animation function
		this._animating = true;
		return CanvasAnimation.animateLinear(animationData, {
			name: "lighting.animateDarkness",
			duration: duration,
			ontick: (dt, attributes) => {
				this.refresh(attributes[0].parent.darkness)
			}
		}).then(() => this._animating = false);
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	_onDragLeftStart(event) {
		super._onDragLeftStart(event);
		const origin = event.data.origin;
		 // Create the preview source
		const preview = new AmbientLight({x: origin.x, y: origin.y, type: "l"});
		event.data.preview = this.preview.addChild(preview);
		this.sources.set(preview.sourceId, preview.source);
		this.deactivateAnimation();
		return preview.draw();
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftMove(event) {
		const { destination, createState, preview, origin } = event.data;
		if ( createState === 0 ) return;
		 // Update the light radius
		const radius = Math.hypot(destination.x - origin.x, destination.y - origin.y);
		 // Update the preview object data
		preview.data.dim = radius * (canvas.dimensions.distance / canvas.dimensions.size);
		preview.data.bright = preview.data.dim / 2;
		preview.refresh();
		 // Refresh the layer display
		preview.updateSource();
		 // Confirm the creation state
		event.data.createState = 2;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftCancel(event) {
		super._onDragLeftCancel(event);
		this.sources.delete("Light.preview");
		this.refresh();
		this.activateAnimation();
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onMouseWheel(event) {
		 // Identify the hovered light source
		const light = this._hover;
		if ( !light || (light.data.angle === 360) ) return;
		 // Determine the incremental angle of rotation from event data
		let snap = event.shiftKey ? 15 : 3;
		let delta = snap * Math.sign(event.deltaY);
		return light.rotate(light.data.rotation + delta, snap);
	}
	 /* -------------------------------------------- */
	/*  Deprecated                                  */
	/* -------------------------------------------- */
	 /**
	 * @deprecated since 0.7.3
	 * @see {@link LightingLayer#refresh}
	 */
	update(...args) {
		console.warn("You are calling the LightingLayer#update() method which is deprecated in favor of LightingLayer#refresh()");
		return this.refresh(...args);
	}
}

/**
 * The Notes Layer Container
 * @implements {PlaceablesLayer}
 */
class NotesLayer extends PlaceablesLayer {
	 /** @override */
	static get layerOptions() {
		return mergeObject(super.layerOptions, {
			canDragCreate: false,
			objectClass: Note,
			sheetClass: NoteConfig,
			sortActiveTop: true,
			zIndex: 60
		});
	}
	 /* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */
	 /** @override */
	activate() {
		super.activate();
		if ( this.objects ) {
			this.placeables.forEach(p => p.controlIcon.visible = true);
		}
		return this;
	}
	 /* -------------------------------------------- */
	 /** @override */
	deactivate() {
		super.deactivate();
		const isToggled = game.settings.get("core", this.constructor.TOGGLE_SETTING);
		if ( this.objects ) {
			this.objects.visible = isToggled;
			this.placeables.forEach(p => p.controlIcon.visible = isToggled);
		}
		this.interactiveChildren = isToggled;
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Register game settings used by the NotesLayer
	 */
	static registerSettings() {
		game.settings.register("core", this.TOGGLE_SETTING, {
			name: "Map Note Toggle",
			scope: "client",
			type: Boolean,
			config: false,
			default: false
		});
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	_onMouseDown(event) {}
	 /* -------------------------------------------- */
	 /**
	 * Handle JournalEntry entity drop data
	 * @param {Event} event
	 * @param {JournalEntry} data
	 * @private
	 */
	async _onDropData(event, data) {
		 // Acquire Journal entry
		const entry = await JournalEntry.fromDropData(data);
		 // Get the world-transformed drop position
		let t = this.worldTransform;
		const tx = (event.clientX - t.tx) / canvas.stage.scale.x;
		const ty = (event.clientY - t.ty) / canvas.stage.scale.y;
		const [x, y] = canvas.grid.getCenter(tx, ty);
		if ( !canvas.grid.hitArea.contains(x, y) ) return false;
		 // Default Note data
		const noteData = {
			entryId: entry.data._id,
			x: x,
			y: y,
			icon: CONST.DEFAULT_NOTE_ICON,
			iconSize: 40,
			textAnchor: CONST.TEXT_ANCHOR_POINTS.BOTTOM,
			fontSize: 48,
			fontFamily: CONFIG.defaultFontFamily
		};
		 // Create a NoteConfig sheet instance to finalize the creation
		this.activate();
		const note = this.preview.addChild(new Note(noteData));
		await note.draw();
		note.sheet.render(true);
	}
}

NotesLayer.TOGGLE_SETTING = "notesDisplayToggle";
/**
 * The Sight Layer which implements dynamic vision, lighting, and fog of war
 * This layer uses an event-driven workflow to perform the minimal required calculation in response to changes.
 * @see {PointSource}
 * @extends {CanvasLayer}
 *
 * @example <caption>The sightRefresh hook</caption>
 * Hooks.on("sightRefresh", layer => {});
 */
class SightLayer extends CanvasLayer {
	constructor() {
		super();
		 /**
		 * Fog of War data object
		 * @type {Object}
		 */
		this.fogData = {
			_id: null,
			explored: null,
			positions: {}
		};
		 /**
		 * A Collection of vision sources which are currently active within the rendered Scene.
		 * @type {Collection<string,PointSource>}
		 */
		this.sources = new Collection();
		 /**
		 * The canonical line-of-sight polygon which defines current Token visibility.
		 * @type {PIXI.Graphics}
		 */
		this.los = new PIXI.Graphics();
		 /**
		 * The blur distance for soft shadows
		 * @type {number}
		 */
		this._blurDistance = 0;
		 /**
		 * A status flag for whether the layer initialization workflow has succeeded
		 * @type {boolean}
		 * @private
		 */
		this._initialized = false;
		 /**
		 * The downscaling resolution used for the saved fog texture
		 * @type {number}
		 */
		this._fogResolution = 1;
		 /**
		 * A pool of fog of war exploration containers that can be recycled
		 * @type {PIXI.Container[]}
		 */
		this._visionPool = [];
		 /**
		 * Track whether fog of war exploration has been updated and required saving
		 * @type {boolean}
		 * @private
		 */
		this._fogUpdated = false;
		 /**
		 * Track the number of moves which have updated fog of war
		 * @type {number}
		 * @private
		 */
		this._fogUpdates = 0;
		 /**
		 * A debounced function to save fog of war exploration once a stream of updates have stopped
		 * @type {Function}
		 */
		this.debounceSaveFog = debounce(this.saveFog.bind(this), 1000);
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get layerOptions() {
		return mergeObject(super.layerOptions, { zIndex: 210 });
	}
	 /* -------------------------------------------- */
	 /**
	 * Does the currently viewed Scene support Token field of vision?
	 * @type {boolean}
	 */
	get tokenVision() {
		return canvas.scene.data.tokenVision;
	}
	 /* -------------------------------------------- */
	 /**
	 * Does the currently viewed Scene support fog of war exploration?
	 * @type {boolean}
	 */
	get fogExploration() {
		return canvas.scene.data.fogExploration;
	}
	 /* -------------------------------------------- */
	/*  Layer Initialization                        */
	/* -------------------------------------------- */
	 /** @override */
	async tearDown() {
		 // If there are pending fog updates, commit them first
		const wasDeleted = game.scenes.get(canvas.scene._id) === null;
		if ( (this._fogUpdates || this._fogUpdated) && !wasDeleted ) await this.saveFog();
		 // Reset fog data
		this.fogData = {
			_id: null,
			explored: null,
			positions: {}
		};
		 // Reset sources
		this.sources.clear();
		 // Destroy the layer children
		this.removeChildren().forEach(c => {
			c.destroy({children: true, texture: true, baseTexture: true});
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize the Sight Layer. Initialization has the following hierarchical workflow:
	 *
	 * Initialize Layer (reset entire layer)
	 *  InitializeLights (used to reset all lights)
	 *    UpdateLight (update a single light)
	 *  InitializeTokens (reset all tokens)
	 *    UpdateToken (update a single token)
	 *  Initialize Fog (reset FOW state)
	 */
	async initialize() {
		this._initialized = false;
		 // If there are pending fog updates, save them first
		if ( this._fogUpdates || this._fogUpdated ) await this.saveFog();
		 // Initialize Fog
		await this.initializeFog();
		 // If Token vision is not used in this Scene, we can simply hide the layer
		this.visible = this.tokenVision;
		this._initialized = true;
		 // If the player has no vision tokens in a visibility-restricted scene, display a warning on a slight delay
		if ( this.tokenVision && !game.user.isGM && !this.sources.size ) {
			setTimeout(() => ui.notifications.warn("You do not own any Token with vision in this Scene"), 100);
		}
		 // Update vision
		this.refresh();
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize fog of war - resetting it when switching scenes or re-drawing the canvas
	 * @return {Promise<void>}
	 */
	async initializeFog() {
		if ( !this.tokenVision ) return;
		if ( this.fogData._id === null ) await this.loadFog();
	}
	 /* -------------------------------------------- */
	/*  Layer Rendering                             */
	/* -------------------------------------------- */
	 /** @override */
	async draw() {
		await super.draw();
		this.removeChildren();
		 // Internal stored variables
		this._blurDistance = game.settings.get("core", "softShadows") ? CONFIG.Canvas.blurStrength : 0;
		this._fogResolution = this._configureFogResolution();
		 // Create fog of war containers
		this.fog = this.addChild(this._drawFogContainer());
		 // Mask the container to prevent overflow
		this.msk = this.addChild(new PIXI.Graphics);
		this.msk.beginFill(0xFFFFFF, 1.0).drawShape(canvas.dimensions.sceneRect).endFill();
		this.mask = this.msk;
		 // Apply a multiply blend filter to the fog container
		this.filter = this._blurDistance > 0 ?
			new PIXI.filters.BlurFilter(this._blurDistance) :
			new PIXI.filters.AlphaFilter(1.0);
		this.filter.blendMode = PIXI.BLEND_MODES.MULTIPLY;
		this.filter.autoFit = false;
		this.fog.filters = [this.filter];
		this.fog.filterArea = canvas.app.screen;
		 // Return the layer
		this.visible = false;
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the fog of war exploration container
	 * @return {PIXI.Container}
	 * @private
	 */
	_drawFogContainer() {
		const d = canvas.dimensions;
		const fog = new PIXI.Container();
		 // Unexplored area is obscured by darkness. We need a larger rectangle so that the blur filter doesn't clip
		fog.unexplored = fog.addChild(new PIXI.Graphics());
		const r = canvas.dimensions.sceneRect.clone().pad(this._blurDistance+2);
		fog.unexplored.beginFill(0xFFFFFF, 1.0).drawShape(r).endFill();
		 // Explored area is a sub-container
		fog.explored = fog.addChild(new PIXI.Container());
		 // The saved exploration sprite
		fog.saved = fog.explored.addChild(new PIXI.Sprite());
		fog.saved.position.set(d.paddingX, d.paddingY);
		fog.saved.width = d.sceneWidth;
		fog.saved.height = d.sceneHeight;
		 // Pending exploration containers
		fog.pending = fog.explored.addChild(new PIXI.Container());
		fog.current = fog.addChild(this._createVisionContainer());
		return fog;
	}
	 /* -------------------------------------------- */
	 /**
	 * Construct a vision container that is used to render a single view position.
	 * These containers are placed into the _visionPool and recycled as needed.
	 * @return {PIXI.Container}
	 * @private
	 */
	_createVisionContainer() {
		const c = new PIXI.Container();
		c.fov = c.addChild(new PIXI.Graphics());
		c.los = c.addChild(new PIXI.Graphics());
		c.mask = c.los;
		c._explored = false;
		return c;
	}
	 /* -------------------------------------------- */
	 /**
	 * Obtain a vision container from the recycling pool, or create one if no container exists.
	 * Assign the container as the current fog exploration and the current LOS polygon.
	 * @return {PIXI.Container}
	 * @private
	 */
	_getVisionContainer() {
		const c = this._visionPool.length ? this._visionPool.pop() : this._createVisionContainer();
		this.fog.current = this.fog.addChild(c);
		this.los = c.los;
		return c;
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a vision container back to the pool, recycling it for future use.
	 * @param {PIXI.Container} c    The container to recycle
	 * @private
	 */
	_recycleVisionContainer(c) {
		c.los.clear();
		c.fov.clear();
		c.fov.tint = 0xFFFFFF;
		c._explored = false;
		this._visionPool.push(c);
	}
	 /* -------------------------------------------- */
	 /**
	 * Update the display of the sight layer.
	 * Organize sources into rendering queues and draw lighting containers for each source
	 *
	 * @param {boolean} [forceUpdateFog]  Always update the Fog exploration progress for this update
	 * @param {boolean} [noUpdateFog]     Never update the Fog exploration progress for this update
	 */
	refresh({forceUpdateFog=false, noUpdateFog=false}={}) {
		if ( !this._initialized ) return;
		if ( !this.tokenVision ) {
			this.visible = false;
			return this.restrictVisibility()
		}
		 // Recycle the current vision, either adding it to pending fog or returning it to the pool
		const prior = this.fog.removeChild(this.fog.current);
		if ( prior._explored ) {
			prior.fov.tint = CONFIG.Canvas.exploredColor;
			this.fog.pending.addChild(prior);
		}
		else this._recycleVisionContainer(prior);
		 // Obtain a new vision container from the rotating pool
		const vision = this._getVisionContainer();
		 // Draw standard vision sources
		for ( let source of this.sources ) {
			source.active = true;
			vision.fov.beginFill(0xFFFFFF, 1.0).drawPolygon(source.fov).endFill();
			vision.los.beginFill(0xFFFFFF, 1.0).drawPolygon(source.los).endFill();
			if (!noUpdateFog) this.updateFog(source, forceUpdateFog);
		}
		 // Draw global or universal light sources
		for ( let source of canvas.lighting.sources ) {
			if ( !this.sources.size || !source.active ) continue;
			vision.fov.beginFill(0xFFFFFF, 1.0).drawPolygon(source.fov).endFill();
			if ( source.type === CONST.SOURCE_TYPES.LOCAL ) continue;
			vision.los.beginFill(0xFFFFFF, 1.0).drawPolygon(source.fov).endFill();
		}
		 // Asynchronously commit pending fog exploration if enough positions have been explored
		if ( this._fogUpdates >= SightLayer.FOG_COMMIT_THRESHOLD ) this.commitFog();
		if ( this._fogUpdated ) this.debounceSaveFog();
		 // Show or hide the fog
		this.fog.unexplored.tint = CONFIG.Canvas.unexploredColor;
		this.visible = this.sources.size || !game.user.isGM;
		canvas.lighting.illumination.lights.mask = this.visible ? this.los : null;
		canvas.lighting.coloration.mask = this.visible ? this.los : null;
		 // Restrict the visibility of canvas objects
		this.restrictVisibility();
		 // Log debug status
		if ( CONFIG.debug.sight ) {
			const perf = SightLayer._performance;
			let ns = Math.round((performance.now() - perf.start) * 100) / 100;
			console.log(`Rendered Sight Layer update | ${ns}ms | ${perf.rays} rays | ${perf.tests} tests`);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Restrict the visibility of certain canvas assets (like Tokens or DoorControls) based on the visibility polygon
	 * These assets should only be displayed if they are visible given the current player's field of view
	 */
	restrictVisibility() {
		 // Tokens
		for ( let t of canvas.tokens.placeables ) {
			t.visible = ( !this.tokenVision && !t.data.hidden ) || t.isVisible;
		}
		 // Door Icons
		for ( let d of canvas.controls.doors.children ) {
			d.visible = !this.tokenVision || d.isVisible;
		}
		 // Dispatch a hook that modules can use
		Hooks.callAll("sightRefresh", this);
	}
	 /* -------------------------------------------- */
	/*  Fog of War Management                       */
	/* -------------------------------------------- */
	 /**
	 * Once a new Fog of War location is explored, composite the explored container with the current staging sprite
	 * Save that staging Sprite as the rendered fog exploration and swap it out for a fresh staging texture
	 * Do all this asynchronously, so it doesn't block token movement animation since this takes some extra time
	 * @return {Promise<void>}
	 * @private
	 */
	async commitFog() {
		if ( CONFIG.debug.fog ) console.debug("SightLayer | Committing fog exploration to render texture.");
		const fog = this.fog;
		this._fogUpdates = 0;
		 // Protect against an invalid render texture
		if ( !fog.saved.texture.valid ) {
			fog.saved.texture = PIXI.Texture.EMPTY;
		}
		 // Create a staging texture and render the entire fog container to it
		const d = canvas.dimensions;
		const tex = PIXI.RenderTexture.create({
			width: d.sceneWidth,
			height: d.sceneHeight,
			resolution: this._fogResolution
		});
		const transform = new PIXI.Matrix(1, 0, 0, 1, -d.paddingX, -d.paddingY);
		canvas.app.renderer.render(fog.explored, tex, undefined, transform);
		 // Swap the staging texture to the rendered Sprite
		fog.saved.texture.destroy(true);
		fog.saved.texture = tex;
		this.fog.pending.removeChildren().forEach(c => this._recycleVisionContainer(c));
		 // Record that fog was updated
		this._fogUpdated = true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Load existing fog of war data from local storage and populate the initial exploration sprite
	 * @return {Promise<PIXI.Texture>}
	 */
	async loadFog() {
		if ( CONFIG.debug.fog ) console.debug("SightLayer | Loading saved FogExploration for Scene.");
		const fog = this.fog;
		 // Remove the previous render texture if one exists
		if ( fog.saved.texture.valid ) {
			fog.saved.texture.destroy(true);
		}
		 // Take no further action if vision or fog is not used
		if ( !this.tokenVision || !this.fogExploration ) return;
		 // Load existing FOW exploration data
		const response = await SocketInterface.dispatch("modifyDocument", {
			type: "FogExploration",
			action: "get",
			data: {user: game.user.id, scene: canvas.scene.id}
		});
		 // Apply the existing FOW progress
		const fogData = response.result;
		if ( !fogData ) return;
		mergeObject(this.fogData, fogData);
		 // Extract the fog data image
		let render = tex => fog.saved.texture = tex;
		return await new Promise(resolve => {
			let tex = PIXI.Texture.from(fogData.explored);
			if ( tex.baseTexture.valid ) {
				render(tex);
				return resolve(tex);
			}
			else tex.on("update", tex => {
				render(tex);
				resolve(tex);
			});
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Dispatch a request to reset the fog of war exploration status for all users within this Scene.
	 * Once the server has deleted existing FogExploration documents, the _onResetFog handler will re-draw the canvas.
	 */
	async resetFog() {
		if ( CONFIG.debug.fog ) console.debug("SightLayer | Resetting fog of war exploration for Scene.");
		const response = await SocketInterface.dispatch("modifyDocument", {
			type: "FogExploration",
			action: "delete",
			data: {scene: canvas.scene._id},
			options: {reset: true}
		});
		return this._onResetFog(response.result);
	}
	 /* -------------------------------------------- */
	 /**
	 * Save Fog of War exploration data to a base64 string to the FogExploration document in the database.
	 * Assumes that the fog exploration has already been rendered as fog.rendered.texture.
	 * @private
	 */
	async saveFog() {
		if ( !this.tokenVision || !this.fogExploration ) return;
		 // If there are pending fog updates, we need to first commit them
		if ( this._fogUpdates ) await this.commitFog();
		if ( !this._fogUpdated ) return;
		this._fogUpdated = false;
		if ( CONFIG.debug.fog ) console.debug("SightLayer | Saving exploration progress to FogExploration document.");
		 // Use the existing rendered fog to create a Sprite and downsize to save with smaller footprint
		const d = canvas.dimensions;
		const fog = new PIXI.Sprite(this.fog.saved.texture);
		let scl = d.width > 1920 ? 1920 / d.width : 1.0;
		fog.scale.set(scl, scl);
		 // Add the fog to a temporary container to bound it's dimensions and export to base data
		const stage = new PIXI.Container();
		stage.addChild(fog);
		 // Update the fog data to store
		this.fogData.user = game.user._id;
		this.fogData.scene = canvas.scene._id;
		this.fogData.explored = canvas.app.renderer.extract.base64(stage);
		this.fogData.timestmp = Date.now();
		 // Create or update the fog
		const response = await this._createOrUpdateFogExploration(this.fogData);
		stage.destroy({children: true});
		return response;
	}
	 /* -------------------------------------------- */
	 /**
	 * Update the fog layer when a player token reaches a board position which was not previously explored
	 * @param {PointSource} source   The vision source for which the fog layer should update
	 * @param {boolean} force             Force fog to be updated even if the location is already explored
	 */
	updateFog(source, force=false) {
		if ( !this.fogExploration ) return;
		 // Standardize fog coordinate key
		const coords = canvas.grid.getCenter(source.x, source.y).map(Math.round).join("_");
		const pos = this.fogData.positions[coords];
		if ( source.radius <= 0 ) return;
		 // Check whether the position has already been explored
		let explored = pos && (pos.limit !== true) && (pos.radius >= source.radius);
		if ( explored && !force ) return;
		if ( CONFIG.debug.fog ) console.debug("SightLayer | Updating fog exploration for new explored position.");
		 // Update the explored positions
		this.fogData.positions[coords] = {radius: source.radius, limit: source.limited};
		this.fog.current._explored = true;
		this._fogUpdates++;
	}
	 /* -------------------------------------------- */
	 /**
	 * Choose an adaptive fog rendering resolution which downscales the saved fog textures for larger dimension Scenes
	 * @return {number}
	 * @private
	 */
	_configureFogResolution() {
		const d = canvas.dimensions;
		let res = 1.0;
		if ((d.width * d.height) > (16000**2)) res = 0.25;
		else if ((d.width * d.height) > (8000**2)) res = 0.5;
		return res;
	}
	 /* -------------------------------------------- */
	 /**
	 * Trigger a server-side update (or creation) of fog exploration status for a certain Scene
	 * @param fogData
	 * @return {Promise<object>}
	 * @private
	 */
	async _createOrUpdateFogExploration(fogData) {
		const response = await SocketInterface.dispatch("modifyDocument", {
			type: "FogExploration",
			action: fogData._id ? "update" : "create",
			data: fogData,
			options: {broadcast: false}
		});
		console.log(`Saved Fog of War exploration progress in Scene ${canvas.scene._id}`);
		this.fogData._id = response.result[0]._id;
		return response;
	}
	 /* -------------------------------------------- */
	 /**
	 * If fog of war data is reset from the server, re-draw the canvas
	 * @param {Object} resetData    Fog reset data sent by the server
	 * @return {Promise<Canvas>}
	 */
	async _onResetFog(resetData) {
		if ( (resetData.scene !== canvas.scene.id) || !resetData.reset ) return;
		ui.notifications.info(`Fog of War exploration progress was reset for this Scene`);
		this._fogUpdated = false;
		this._fogUpdates = 0;
		return canvas.draw();
	}
	 /* -------------------------------------------- */
	/*  Sight Computation                           */
	/* -------------------------------------------- */
	 /**
	 * Compute line-of-sight and field-of-vision polygons for a given origin position and visibility radius.
	 * The line-of-sight polygon defines the unrestricted area of visibility for the source.
	 * The field-of-vision polygon defines the restricted area of visibility for the source.
	 *
	 * @param {Point} origin            An point with coordinates x and y representing the origin of the test
	 * @param {number} radius           A distance in canvas pixels which reflects the visible range
	 * @param {number} [angle]          An optional limited angle of emission with which to restrict polygons
	 * @param {number} [density]        The desired radial density of emission for rays, in degrees
	 * @param {Point[]} [endpoints]     An array of explicit endpoints against which to compute sight
	 * @param {boolean} [unrestricted]  Compute sight that is unrestricted by walls
	 *
	 * @returns {{rays: Ray[], los: PIXI.Polygon, fov: PIXI.Polygon}}   The computed rays and polygons
	 */
	static computeSight(origin, radius, {angle=360, density=6, rotation=0, unrestricted=false}={}) {
		 // The maximum ray distance needs to reach all areas of the canvas
		let d = canvas.dimensions;
		let {x, y} = origin;
		const dx = Math.max(origin.x, d.width - origin.x);
		const dy = Math.max(origin.y, d.height - origin.y);
		const distance = Math.max(radius, Math.hypot(dx, dy));
		const limit = radius / distance;
		 // Determine the direction of facing, the angle of vision, and the angles of boundary rays
		const limitAngle = angle.between(0, 360, false);
		const aMin = limitAngle ? normalizeRadians(toRadians(rotation + 90 - (angle / 2))) : -Math.PI;
		const aMax = limitAngle ? aMin + toRadians(angle) : Math.PI;
		 // For high wall count maps, restrict to a subset of endpoints using quadtree bounds
		// Target wall endpoints within the vision radius or within 10 grid units, whichever is larger
		let endpoints = unrestricted ? [] : canvas.walls.endpoints;
		let bounds = null;
		if ( endpoints.length > SightLayer.EXACT_VISION_THRESHOLD ) {
			const rb2 = Math.max(d.size * 10, radius);
			bounds = new NormalizedRectangle(origin.x - rb2, origin.y - rb2, (2 * rb2), (2 * rb2));
			let walls = canvas.walls.quadtree.getObjects(bounds);
			endpoints = WallsLayer.getUniqueEndpoints(walls, {bounds, blockMovement: false, blockSenses: true});
		}
		 // Cast sight rays at target endpoints using the full unrestricted line-of-sight distance
		const rays = this._castRays(x, y, distance, {density, endpoints, limitAngle, aMin, aMax});
		 // Partition rays by node
		const quadMap = new Map();
		for ( let r of rays ) {
			r._cs = null;
			r._c = null;
			const nodes = canvas.walls.quadtree.getLeafNodes(r.bounds);
			for ( let n of nodes ) {
				let s = quadMap.get(n);
				if ( !s ) {
					s = new Set();
					quadMap.set(n, s);
				}
				s.add(r);
			}
		}
		 // Start with the node that contains the sight origin
		let nodes = new Set(canvas.walls.quadtree.getLeafNodes({x: origin.x, y: origin.y, width: 0, height: 0}));
		const testedNodes = new Set();
		const nodeQueue = new Set(nodes);
		if ( unrestricted ) nodeQueue.clear();
		const rayQueue = new Set(rays);
		 // Iterate until there are no nodes remaining to test
		while ( nodeQueue.size ) {
			const batch = Array.from(nodeQueue);
			for (let n of batch) {
				for (let o of n.objects) {
					const w = o.t;
					if ((w.data.door > CONST.WALL_DOOR_TYPES.NONE) && (w.data.ds === CONST.WALL_DOOR_STATES.OPEN)) continue;
					if (w.data.sense === CONST.WALL_SENSE_TYPES.NONE) continue;
					 // Iterate over rays
					const rays = quadMap.get(n) || [];
					for (let r of rays) {
						if ( r._c ) continue;
						 // Test collision for the ray
						if (!w.canRayIntersect(r)) continue;
						const x = WallsLayer.testWall(r, w);
						if ( this._performance ) this._performance.tests++;
						if (!x) continue;
						 // Flag the collision
						r._cs = r._cs || {};
						const pt = `${Math.round(x.x)},${Math.round(x.y)}`;
						const c = r._cs[pt];
						if ( c ) {
							c.sense = Math.min(w.data.sense, c.sense);
							for ( let n of o.n ) c.nodes.push(n);
						}
						else {
							x.sense = w.data.sense;
							x.nodes = Array.from(o.n);
							r._cs[pt] = x;
						}
					}
				}
				 // Cascade outward to sibling nodes
				testedNodes.add(n);
				nodeQueue.delete(n);
				const siblings = canvas.walls.quadtree.getLeafNodes({
					x: n.bounds.x - 1,
					y: n.bounds.y - 1,
					width: n.bounds.width + 2,
					height: n.bounds.height + 2
				});
				for (let s of siblings) {
					if (!testedNodes.has(s)) nodeQueue.add(s);
				}
			}
			 // After completing a tier of nodes, test each ray for completion
			for ( let r of rayQueue ) {
				if ( !r._cs ) continue;
				const c = Object.values(r._cs);
				const closest = WallsLayer.getClosestCollision(c);
				if ( closest && closest.nodes.every(n => testedNodes.has(n)) ) {
					rayQueue.delete(r);
					r._c = closest;
				}
			}
			if ( !rayQueue.size ) break;
		}
		 // Construct visibility polygons
		const losPoints = [];
		const fovPoints = [];
		for ( let r of rays ) {
			r.los = r._c || { x: r.B.x, y: r.B.y, t0: 1, t1: 0};
			losPoints.push(r.los);
			r.fov = r.los.t0 <= limit ? r.los : r.project(limit);
			fovPoints.push(r.fov)
		}
		const los = new PIXI.Polygon(...losPoints);
		const fov = new PIXI.Polygon(...fovPoints);
		 // Visualize vision rendering
		if ( CONFIG.debug.sightRays ) this._visualizeSight(bounds, endpoints, rays, los, fov);
		if ( CONFIG.debug.sight ) this._performance.rays = rays.length;
		 // Return rays and polygons
		return {rays, los, fov};
	}
	 /* -------------------------------------------- */
	 /**
	 * A helper method responsible for casting rays at wall endpoints.
	 * Rays are restricted by limiting angles.
	 *
	 * @param {number} x                  The origin x-coordinate
	 * @param {number} y                  The origin y-coordinate
	 * @param {number} distance           The ray distance
	 * @param {number} density            The desired radial density
	 * @param {PointArray[]} endpoints    An array of endpoints to target
	 * @param {boolean} limitAngle        Whether the rays should be cast subject to a limited angle of emission
	 * @param {number} aMin               The minimum bounding angle
	 * @param {number} aMax               The maximum bounding angle
	 *
	 * @returns {Ray[]}                   An array of Ray objects
	 */
	static _castRays(x, y, distance, {density=4, endpoints, limitAngle=false, aMin, aMax}={}) {
		const rOffset = 0.02;
		 // Enforce that all rays increase in angle from minimum towards maximum
		const rMin = limitAngle ? Ray.fromAngle(x, y, aMin, distance) : null;
		const rMax = limitAngle ? Ray.fromAngle(x, y, aMax, distance) : null;
		 // Define de-duping cast function
		const cast = (ray, tol=50) => {
			let a = Math.round(ray.angle * tol) / tol;
			if ( angles.has(a) ) return;
			rays.push(ray);
			angles.add(a);
		};
		 // Track rays and unique emission angles
		const angles = new Set();
		const rays = [];
		 // First prioritize rays which are cast directly at wall endpoints
		for ( let e of endpoints ) {
			const ray = Ray.fromAngle(x, y, Math.atan2(e[1]-y, e[0]-x), distance);
			if ( limitAngle ) {
				ray.angle = this._adjustRayAngle(aMin, ray.angle);  // Standardize the angle
				if (!Number.between(ray.angle, aMin, aMax)) continue;
			}
			cast(ray);
		}
		 // Next cast rays at any non-duplicate offset angles
		const nr = rays.length;
		for ( let i=0; i<nr; i++ ) {
			const r = rays[i];
			cast(r.shiftAngle(rOffset));
			cast(r.shiftAngle(-rOffset));
		}
		 // Add additional limiting and central rays
		if ( limitAngle ) {
			const aCenter = aMin + ((aMax - aMin) / 2) + Math.PI;
			const rCenter = Ray.fromAngle(x, y, aCenter, 0);
			rCenter._isCenter = true;
			cast(rMin);
			cast(rCenter);
			cast(rMax);
		}
		 // Add additional approximate rays to reach a desired radial density
		if ( !!density ) {
			const rDensity = toRadians(density);
			const nFill = Math.ceil((aMax - aMin) / rDensity);
			for ( let a of Array.fromRange(nFill) ) {
				cast(Ray.fromAngle(x, y, aMin + (a * rDensity), distance), 10);
			}
		}
		 // Sort rays counter-clockwise (increasing radians)
		rays.sort((r1, r2) => r1.angle - r2.angle);
		return rays;
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether a point on the Canvas is visible based on the current vision and LOS polygons
	 *
	 * @param {Point} point           The point in space to test, an object with coordiantes x and y.
	 * @param {number} tolerance      A numeric radial offset which allows for a non-exact match. For example, if
	 *                                tolerance is 2 then the test will pass if the point is within 2px of a vision
	 *                                polygon.
	 * @param {PIXI.DisplayObject} [object]   An optional reference to the object whose visibility is being tested
	 *
	 * @return {boolean}              Whether the point is currently visible.
	 */
	testVisibility(point, {tolerance=2, object=null}={}) {
		 // If there are no vision sources - visibility is GM only
		if ( !this.sources.size ) return game.user.isGM;
		 // Determine the array of offset points to test
		const t = tolerance;
		const offsets = t > 0 ? [[0, 0],[-t,0],[t,0],[0,-t],[0,t],[-t,-t],[-t,t],[t,t],[t,-t]] : [[0,0]];
		const points = offsets.map(o => new PIXI.Point(point.x + o[0], point.y + o[1]));
		 // Test that any point falls inside a line-of-sight polygon
		const los = points.some(p => this.los.geometry.containsPoint(p));
		if ( !los ) return false;
		 // Test the that the point is within some light source FOV polygon
		return canvas.lighting.illumination.lights.children.some(l => {
			return points.some(p => l.fov.geometry.containsPoint(p));
		});
	}
	 /* -------------------------------------------- */
	/*  Helper Functions                            */
	/* -------------------------------------------- */
	 /**
	 * Normalize an angle to ensure it is baselined to be the smallest angle that is greater than a minimum.
	 * @param {number} aMin       The lower-bound minimum angle
	 * @param {number} angle      The angle to adjust
	 * @return {number}           The adjusted angle which is greater than or equal to aMin.
	 * @private
	 */
	static _adjustRayAngle(aMin, angle) {
		while ( angle < aMin ) {
			angle += (2*Math.PI);
		}
		return angle;
	}
	 /* -------------------------------------------- */
	 /**
	 * Visualize the sight layer to understand algorithm performance.
	 * @param {Rectangle} bounds        The initial rectangular bounds of the vision check
	 * @param {PointArray[]} endpoints  The wall endpoints being tested
	 * @param {Ray[]} rays              The array of cast vision Rays
	 * @param {PIXI.Polygon} los        The resulting line-of-sight polygon
	 * @param {PIXI.Polygon} fov        The resulting field-of-vision polygon
	 */
	static _visualizeSight(bounds, endpoints, rays, los, fov) {
		const debug = canvas.controls.debug;
		debug.clear();
		 // Relevant polygons
		if ( bounds ) debug.lineStyle(0).beginFill(0x66FFFF, 0.1).drawShape(bounds);
		debug.beginFill(0x66FFFF, 0.1).drawShape(los);
		debug.beginFill(0xFF66FF, 0.1).drawShape(fov).endFill();
		 // Tested endpoints
		endpoints.forEach(pt => debug.beginFill(0x00FFFF, 1.0).drawCircle(pt[0], pt[1], 6));
		 // Cast rays
		for ( let r of rays ) {
			debug.lineStyle(1, 0x00FF00).moveTo(r.A.x, r.A.y).lineTo(r.los.x, r.los.y)
				.lineStyle(2, 0xFF0000).drawCircle(r.fov.x, r.fov.y, 4).drawCircle(r.los.x, r.los.y, 4);
		}
	}
	 /* -------------------------------------------- */
	/*  PENDING DEPRECATION                         */
	/* -------------------------------------------- */
	 /**
	 * @deprecated since 0.7.3
	 * @see {@link Canvas#initializeSources}
	 */
	initializeTokens({defer=false}={}) {
		console.warn(`You are calling the SightLayer#initializeTokens method which has been deprecated. Consider using the Canvas#initializeSources method instead.`);
	}
	 /* -------------------------------------------- */
	 /**
	 * @deprecated since 0.7.3
	 * @see {@link SightLayer#refresh}
	 */
	update(options) {
		console.warn(`You are calling the SightLayer#update method which has been renamed to SightLayer#refresh to be consistent with other PIXI objects.`);
		return this.refresh(options);
	}
	 /* -------------------------------------------- */
	 /**
	 * @deprecated since 0.7.3
	 * @see {@link Token#updateSource}
	 */
	updateToken(token, options) {
		console.warn("SightLayer#updateToken() is deprecated in favor of Token#updateSource()");
		return token.updateSource(options);
	}
	 /* -------------------------------------------- */
	 /**
	 * @deprecated since 0.7.3
	 * @see {@link AmbientLight#updateSource}
	 */
	updateLight(light, options) {
		console.warn("SightLayer#updateLight() is deprecated in favor of AmbientLight#updateSource()");
		return light.updateSource(options);
	}
}

/**
 * Define the threshold value for the number of distinct Wall endpoints.
 * Below this threshold, exact vision computation is used by casting a Ray at every endpoint.
 * Above this threshold, approximate vision computation is used by culling to only nearby endpoints.
 * @type {number}
 */
SightLayer.EXACT_VISION_THRESHOLD = 500;

/**
 * Define the number of positions that are explored before a set of fog updates are pushed to the server.
 * @type {number}
 */
SightLayer.FOG_COMMIT_THRESHOLD = 10;
/**
 * This Canvas Layer provides a container for AmbientSound objects.
 * @extends {PlaceablesLayer}
 * @see {@link AmbientSound}
 */
class SoundsLayer extends PlaceablesLayer {
	constructor(...args) {
		super(...args);
		 /**
		 * A status flag for whether the layer initialization workflow has succeeded
		 * @type {boolean}
		 * @private
		 */
		this._initialized = false;
		 /**
		 * A debounced refresh function for the sounds layer
		 * @type {Function}
		 */
		this.refresh = debounce(this.update.bind(this), 50);
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get layerOptions() {
		return mergeObject(super.layerOptions, {
			objectClass: AmbientSound,
			sheetClass: AmbientSoundConfig,
			zIndex: 200
		});
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /** @override */
	async tearDown() {
		this._initialized = false;
		this.stopAll();
		return super.tearDown();
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize the field of "view" for all AmbientSound effects in the layer
	 */
	initialize() {
		this.placeables.forEach(s => s.refresh());
		this._initialized = true;
		if ( Howler.state === "suspended" ) game.audio.pending.push(() => this.update());
		else this.update();
	}
	 /* -------------------------------------------- */
	 /**
	 * Update all AmbientSound effects in the layer by toggling their playback status
	 */
	update(playOptions={}) {
		if ( !this._initialized ) return;
		 // Get the tokens against which to check hearing
		const tokens = game.user.isGM ? canvas.tokens.controlled : canvas.tokens.ownedTokens;
		 // Classify distinct sounds as audible or not
		const audible = this.placeables.reduce((obj, sound) => {
			let p = sound.data.path,
					r = sound.radius;
			 // Get the tokens which can hear this sound
			let audible = tokens.filter(t => {
				let c = t.center;
				return sound.fov.contains(c.x, c.y);
			});
			 // Get or create the record
			if ( !obj.hasOwnProperty(p) ) obj[p] = {
				sound: sound,
				audible: false,
				volume: 0
			};
			 // Flag audible status
			if ( !audible.length ) return obj;
			obj[p].audible = true;
			 // Determine the loudest audible volume
			if ( sound.data.easing ) {
				let distance = Math.min(...audible.map(t => {
					let c = t.center;
					return Math.hypot(c.x - sound.x, c.y - sound.y);
				}));
				const scale = Math.clamped((r - distance) / r, 0.20, 1.0);
				obj[p].volume = sound.data.volume * scale;
			} else {
				obj[p].volume = sound.data.volume;
			}
			 // Return the updated sound
			return obj;
		}, {});
		 // Play each sound
		Object.values(audible).forEach(a => {
			a.sound.play(a.audible, a.volume, playOptions);
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Terminate playback of all ambient audio sources
	 */
	stopAll() {
		this.placeables.forEach(s => s.play(false));
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	_onDragLeftStart(event) {
		super._onDragLeftStart(event);
		const origin = event.data.origin;
		const sound = new AmbientSound({x: origin.x, y: origin.y, type: "l"});
		event.data.preview = this.preview.addChild(sound);
		this.preview._creating = false;
		sound.draw();
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftMove(event) {
		const { destination, createState, preview, origin } = event.data;
		if ( createState === 0 ) return;
		 // Update the preview Sound
		const radius = Math.hypot(destination.x - origin.x, destination.y - origin.y);
		preview.data.radius = radius * (canvas.dimensions.distance / canvas.dimensions.size);
		preview.refresh();
		 // Confirm the creation state
		event.data.createState = 2;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftDrop(event) {
		const { createState, destination, origin, preview } = event.data;
		if ( createState !== 2 ) return;
		 // Render the preview sheet for confirmation
		const radius = Math.hypot(destination.x - origin.x, destination.y - origin.y);
		if ( radius < (canvas.dimensions.size / 2) ) return;
		 // Clean the data and render the creation sheet
		["x", "y"].forEach(k => preview.data[k] = Math.floor(preview.data[k]));
		preview.data["radius"] = Math.floor(preview.data["radius"] * 100) / 100;
		preview.sheet.render(true);
		preview.sheet.preview = this.preview;
		this.preview._creating = true;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftCancel(event) {
		if ( this.preview._creating ) return;
		return super._onDragLeftCancel(event);
	}
}

/**
 * This Canvas Layer provides a container for MeasuredTemplate objects.
 * @extends {PlaceablesLayer}
 * @see {@link MeasuredTemplate}
 */
class TemplateLayer extends PlaceablesLayer {
	 /** @override */
	static get layerOptions() {
		return mergeObject(super.layerOptions, {
			canDragCreate: true,
			canDelete: true,
			rotatableObjects: true,
			objectClass: MeasuredTemplate,
			sheetClass: MeasuredTemplateConfig,
			sortActiveTop: true,
			zIndex: 50
		});
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /** @override */
	activate() {
		super.activate();
		if ( this.objects ) {
			this.placeables.forEach(p => {
				try {
					p.controlIcon.visible = true;
					p.ruler.visible = true;
				} catch(err) {
					console.error(err);
				}
			});
		}
		return this;
	}
	 /* -------------------------------------------- */
	 /** @override */
	deactivate() {
		super.deactivate();
		if ( this.objects ) {
			this.objects.visible = true;
			this.placeables.forEach(p => {
				try {
					p.controlIcon.visible = false;
					p.ruler.visible = false;
				} catch(err) {
					console.error(err);
				}
			});
		}
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Register game settings used by the TemplatesLayer
	 */
	static registerSettings() {
		game.settings.register("core", "coneTemplateType", {
			name: "TEMPLATE.ConeTypeSetting",
			hint: "TEMPLATE.ConeTypeSettingHint",
			scope: "world",
			config: true,
			default: "round",
			type: String,
			choices: {
				"flat": "TEMPLATE.ConeTypeFlat",
				"round": "TEMPLATE.ConeTypeRound"
			},
			onChange: () => canvas.templates.placeables.filter(t => t.data.t === "cone").forEach(t => t.draw())
		});
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	_onDragLeftStart(event) {
		super._onDragLeftStart(event);
		 // Create the new preview template
		const tool = game.activeTool;
		const origin = event.data.origin;
		 // Create the template
		const data = {
			user: game.user._id,
			t: tool,
			x: origin.x,
			y: origin.y,
			distance: 0,
			direction: 0,
			fillColor: game.user.data.color || "#FF0000"
		};
		 // Apply some type-specific defaults
		const defaults = CONFIG.MeasuredTemplate.defaults;
		if ( tool === "cone") data["angle"] = defaults.angle;
		else if ( tool === "ray" ) data["width"] = (defaults.width * canvas.dimensions.distance);
		 // Create and assign the preview
		const template = new MeasuredTemplate(data);
		event.data.preview = this.preview.addChild(template);
		template.draw();
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftMove(event) {
		const { destination, createState, preview, origin } = event.data;
		if ( createState === 0 ) return;
		 // Snap the destination to the grid
		event.data.destination = canvas.grid.getSnappedPosition(destination.x, destination.y, this.gridPrecision);
		 // Compute the ray
		const ray = new Ray(origin, destination);
		const ratio = (canvas.dimensions.size / canvas.dimensions.distance);
		 // Update the preview object
		preview.data.direction = toDegrees(ray.angle);
		preview.data.distance = ray.distance / ratio;
		preview.refresh();
		 // Confirm the creation state
		event.data.createState = 2;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onMouseWheel(event) {
		 // Determine whether we have a hovered template?
		const template = this._hover;
		if ( !template ) return;
		 // Determine the incremental angle of rotation from event data
		let snap = event.shiftKey ? 15 : 5;
		let delta = snap * Math.sign(event.deltaY);
		return template.rotate(template.data.direction + delta, snap);
	}
}

/**
 * The Tiles canvas layer which provides a container for {@link Tile} objects which are rendered immediately above the
 * {@link BackgroundLayer} and below the {@link GridLayer}.
 *
 * @extends {PlaceablesLayer}
 *
 * @see {@link Tile}
 * @see {@link TileHUD}
 */
class TilesLayer extends PlaceablesLayer {
	 /** @override */
	static get layerOptions() {
		return mergeObject(super.layerOptions, {
			zIndex: 10,
			controllableObjects: true,
			objectClass: Tile,
			rotatableObjects: true,
			sheetClass: TileConfig
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Tile objects on this layer utilize the TileHUD
	 * @type {TileHUD}
	 */
	get hud() {
		return canvas.hud.tile;
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /** @override */
	deactivate() {
		super.deactivate();
		if ( this.objects ) this.objects.visible = true;
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	_onDragLeftStart(event) {
		super._onDragLeftStart(event);
		const tile = Tile.createPreview(event.data.origin);
		event.data.preview = this.preview.addChild(tile);
		this.preview._creating = false;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftMove(event) {
		const { destination, createState, preview, origin, originalEvent } = event.data;
		if ( createState === 0 ) return;
		 // Determine the drag distance
		const dx = destination.x - origin.x;
		const dy = destination.y - origin.y;
		const dist = Math.min(Math.abs(dx), Math.abs(dy));
		 // Update the preview object
		preview.data.width = (originalEvent.altKey ? dist * Math.sign(dx) : dx);
		preview.data.height = (originalEvent.altKey ? dist * Math.sign(dy) : dy);
		if ( !originalEvent.shiftKey ) {
			const half = canvas.dimensions.size / 2;
			preview.data.width = preview.data.width.toNearest(half);
			preview.data.height = preview.data.height.toNearest(half);
		}
		preview.refresh();
		 // Confirm the creation state
		event.data.createState = 2;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftDrop(event) {
		const { createState, preview } = event.data;
		if ( createState !== 2 ) return;
		 // Require a minimum created size
		const distance = Math.hypot(preview.width, preview.height);
		if (distance < (canvas.dimensions.size / 2) ) return;
		preview.data.width = Math.round(preview.data.width);
		preview.data.height = Math.round(preview.data.height);
		 // Render the preview sheet for confirmation
		preview.sheet.render(true);
		preview.sheet.preview = this.preview;
		this.preview._creating = true;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftCancel(event) {
		if ( this.preview._creating ) return;
		return super._onDragLeftCancel(event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle drop events for Tile data on the Tiles Layer
	 * @param {DragEvent} event     The concluding drag event
	 * @param {object} data         The extracted Tile data
	 * @private
	 */
	async _onDropTileData(event, data) {
		if ( !data.img ) return;
		if ( !this._active ) this.activate();
		 // Determine the tile size
		const tex = await loadTexture(data.img);
		const ratio = canvas.dimensions.size / (data.tileSize || canvas.dimensions.size);
		data.width = tex.baseTexture.width * ratio;
		data.height = tex.baseTexture.height * ratio;
		 // Validate that the drop position is in-bounds and snap to grid
		if ( !canvas.grid.hitArea.contains(data.x, data.y) ) return false;
		data.x = data.x - (data.width / 2);
		data.y = data.y - (data.height / 2);
		if ( !event.shiftKey ) mergeObject(data, canvas.grid.getSnappedPosition(data.x, data.y));
		 // Create the tile as hidden if the ALT key is pressed
		if ( event.altKey ) data.hidden = true;
		 // Create the Tile
		return this.constructor.placeableClass.create(data);
	}
}

/**
 * The Tokens Container
 * @type {PlaceablesLayer}
 */
class TokenLayer extends PlaceablesLayer {
	constructor() {
		super();
		 /**
		 * The current index position in the tab cycle
		 * @type {number|null}
		 * @private
		 */
		this._tabIndex = null;
		 /**
		 * Remember the last drawn wildcard token image to avoid repetitions
		 * @type {string}
		 */
		this._lastWildcard = null;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get layerOptions() {
		return mergeObject(super.layerOptions, {
			canDragCreate: false,
			controllableObjects: true,
			rotatableObjects: true,
			gridPrecision: 1,
			objectClass: Token,
			sheetClass: TokenConfig,
			zIndex: 100
		});
	}
	 /* -------------------------------------------- */
	/*  Properties
	/* -------------------------------------------- */
	 /**
	 * Token objects on this layer utilize the TokenHUD
	 */
	get hud() {
		return canvas.hud.token;
	}
	 /**
	 * An Array of tokens which belong to actors which are owned
	 * @type {Token[]}
	 */
	get ownedTokens() {
		return this.placeables.filter(t => t.actor && t.actor.owner);
	}
	 /* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */
	 /** @override */
	async tearDown() {
		 // Conclude token animation
		this.concludeAnimation();
		 // Reset the synthetic token collection
		game.actors.tokens = {};
		 // Release tokens and destroy the layer
		return super.tearDown();
	}
	 /* -------------------------------------------- */
	 /** @override */
	activate() {
		super.activate();
		if ( canvas.controls ) canvas.controls.doors.visible = true;
		this._tabIndex = null;
	}
	 /* -------------------------------------------- */
	 /** @override */
	deactivate() {
		super.deactivate();
		if ( this.objects ) this.objects.visible = true;
		if ( canvas.controls ) canvas.controls.doors.visible = false;
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize the TokenLayer by preparing all Token sources which appear in the Scene.
	 */
	initialize() {
		for ( let token of this.placeables ) {
			token.updateSource();
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	controlAll(options={}) {
		options.updateSight = false;
		super.controlAll(options);
		canvas.initializeSources();
	}
	 /* -------------------------------------------- */
	 /** @override */
	releaseAll(options={}) {
		options.updateSight = false;
		const released = super.releaseAll(options);
		if ( released > 0 ) canvas.initializeSources();
		return released;
	}
	 /* -------------------------------------------- */
	 /** @override */
	selectObjects({x, y, width, height, releaseOptions={}, controlOptions={}}={}) {
		releaseOptions = { updateSight: false };
		controlOptions = { releaseOthers: false, updateSight: false };
		const changed = super.selectObjects({x, y, width, height, releaseOptions, controlOptions});
		if ( changed ) canvas.initializeSources();
		return changed;
	}
	 /* -------------------------------------------- */
	 /**
	 * Target all Token instances which fall within a coordinate rectangle.
	 *
	 * @param {number} x                The top-left x-coordinate of the selection rectangle
	 * @param {number} y                The top-left y-coordinate of the selection rectangle
	 * @param {number} width            The width of the selection rectangle
	 * @param {number} height           The height of the selection rectangle
	 * @param {boolean} releaseOthers   Whether or not to release other targeted tokens
	 * @return {number}                 The number of Token instances which were targeted.
	 */
	targetObjects({x, y, width, height}, {releaseOthers=true}={}) {
		const user = game.user;
		 // Get the set of targeted tokens
		const targets = this.placeables.filter(obj => {
			if ( !obj.visible ) return false;
			let c = obj.center;
			return Number.between(c.x, x, x+width) && Number.between(c.y, y, y+height);
		});
		 // Maybe release other targets
		if ( releaseOthers ) {
			for ( let t of user.targets ) {
				if ( !targets.includes(t) ) t.setTarget(false, {releaseOthers: false, groupSelection: true});
			}
		}
		 // Acquire targets for tokens which are not yet targeted
		targets.forEach(t => {
			if ( !user.targets.has(t) ) t.setTarget(true, {releaseOthers: false, groupSelection: true});
		});
		 // Broadcast the target change
		user.broadcastActivity({targets: user.targets.ids});
		 // Return the number of targeted tokens
		return user.targets.size;
	}
	 /* -------------------------------------------- */
	 /**
	 * Cycle the controlled token by rotating through the list of Owned Tokens that are available within the Scene
	 * Tokens are currently sorted in order of their TokenID
	 *
	 * @param {boolean} forwards  Which direction to cycle. A truthy value cycles forward, while a false value
	 *                            cycles backwards.
	 * @param {boolean} reset     Restart the cycle order back at the beginning?
	 * @return {Token|null}       The Token object which was cycled to, or null
	 */
	cycleTokens(forwards, reset) {
		let next = null;
		if ( reset ) this._tabIndex = null;
		const order = this._getCycleOrder();
		 // If we are not tab cycling, try and jump to the currently controlled or impersonated token
		if ( this._tabIndex === null ) {
			this._tabIndex = 0;
			 // Determine the ideal starting point based on controlled tokens or the primary character
			let current = this.controlled.length ? order.find(t => this.controlled.includes(t)) : null;
			if ( !current && game.user.character ) {
				const actorTokens = game.user.character.getActiveTokens();
				current = actorTokens.length ? order.find(t => actorTokens.includes(t)) : null;
			}
			current = current || order[this._tabIndex] || null;
			 // Either start cycling, or cancel
			if ( !current ) return null;
			next = current;
		}
		 // Otherwise, cycle forwards or backwards
		else {
			if ( forwards ) this._tabIndex = this._tabIndex < (order.length - 1) ? this._tabIndex + 1 : 0;
			else this._tabIndex = this._tabIndex > 0 ? this._tabIndex - 1 : order.length - 1;
			next = order[this._tabIndex];
			if ( !next ) return null;
		}
		 // Pan to the token and control it
		next.control();
		canvas.animatePan({x: next.center.x, y: next.center.y, duration: 250});
		return next;
	}
	 /* -------------------------------------------- */
	 /**
	 * Add or remove the set of currently controlled Tokens from the active combat encounter
	 * @param {boolean} state         The desired combat state which determines if each Token is added (true) or
	 *                                removed (false)
	 * @param {Combat|null} combat    A Combat encounter from which to add or remove the Token
	 * @param {Token|null} [token]    A specific Token which is the origin of the group toggle request
	 * @return {Promise<Combat>}      The updated Combat encounter
	 */
	async toggleCombat(state=true, combat=null, {token=null}={}) {
		 // Reference the combat encounter displayed in the Sidebar if none was provided
		combat = combat ?? ui.combat.combat;
		if ( !combat ) {
			if ( game.user.isGM ) {
				combat = await game.combats.object.create({scene: canvas.scene._id, active: true});
			}
			else return ui.notifications.warn(game.i18n.localize("COMBAT.NoneActive"));
		}
		 // Process each controlled token, as well as the reference token
		const tokens = this.controlled.filter(t => t.inCombat !== state);
		if ( token && !token._controlled && (token.inCombat !== state) ) tokens.push(token);
		 // Add tokens to the Combat encounter
		if ( state ) {
			const createData = tokens.map(t => {return {tokenId: t.id, hidden: t.data.hidden}});
			return combat.createEmbeddedEntity("Combatant", createData);
		}
		 // Remove Tokens from combat
		if ( !game.user.isGM ) return;
		const tokenIds = new Set(tokens.map(t => t.id));
		const combatantIds = combat.combatants.reduce((ids, c) => {
			if (tokenIds.has(c.tokenId)) ids.push(c._id);
			return ids;
		}, []);
		return combat.deleteEmbeddedEntity("Combatant", combatantIds);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the tab cycle order for tokens by sorting observable tokens based on their distance from top-left.
	 * @return {Token[]}
	 * @private
	 */
	_getCycleOrder() {
		const observable = this.placeables.filter(t => {
			return game.user.isGM || (t.actor && t.actor.hasPerm(game.user, "OBSERVER"));
		});
		observable.sort((a, b) => {
			return Math.hypot(a.x, a.y) - Math.hypot(b.x, b.y);
		});
		return observable;
	}
	 /* -------------------------------------------- */
	 /**
	 * Immediately conclude the animation of any/all tokens
	 */
	concludeAnimation() {
		this.placeables.filter(t => t._movement).forEach(t => {
			let ray = t._movement;
			t._movement = null;
			t.stopAnimation();
			t.position.set(ray.B.x, ray.B.y);
		});
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /**
	 * Handle dropping of Actor data onto the Scene canvas
	 * @private
	 */
	async _onDropActorData(event, data) {
		 // Ensure the user has permission to drop the actor and create a Token
		if ( !game.user.can("TOKEN_CREATE") ) {
			return ui.notifications.warn(`You do not have permission to create new Tokens!`);
		}
		 // Acquire dropped data and import the actor
		let actor = await Actor.fromDropData(data);
		if ( !actor.owner ) {
			return ui.notifications.warn(`You do not have permission to create a new Token for the ${actor.name} Actor.`);
		}
		if ( actor.compendium ) actor = await Actor.create(actor.data);
		 // Prepare the Token data
		const token = await Token.fromActor(actor, {x: data.x, y: data.y, hidden: event.altKey});
		const td = token.data;
		 // Adjust token position
		const hg = canvas.dimensions.size / 2;
		td.x -= td.width * hg;
		td.y -= td.height * hg;
		if ( !event.shiftKey ) mergeObject(td, canvas.grid.getSnappedPosition(td.x, td.y));
		if ( !canvas.grid.hitArea.contains(td.x, td.y) ) return false;
		 // Submit the Token creation request and activate the Tokens layer (if not already active)
		this.activate();
		return Token.create(td);
	}
}

/**
 * The Walls canvas layer which provides a container for Wall objects within the rendered Scene.
 * @extends {PlaceablesLayer}
 * @see {@link Wall}
 */
class WallsLayer extends PlaceablesLayer {
	constructor() {
		super();
		 /**
		 * A graphics layer used to display chained Wall selection
		 * @type {PIXI.Graphics}
		 */
		this.chain = null;
		 /**
		 * An array of all the unique perception-blocking endpoints which are present in the layer
		 * We keep this array cached for faster sight polygon computations
		 * @type {PointArray[]}
		 */
		this.endpoints = [];
		 /**
		 * Track whether we are currently within a chained placement workflow
		 * @type {boolean}
		 */
		this._chain = false;
		 /**
		 * Track whether the layer is currently toggled to snap at exact grid precision
		 * @type {boolean}
		 */
		this._forceSnap = false;
		 /**
		 * Track the most recently created or updated wall data for use with the clone tool
		 * @type {Object|null}
		 * @private
		 */
		this._cloneType = null;
		 /**
		 * Reference the last interacted wall endpoint for the purposes of chaining
		 * @type {{id: string|null, point: PointArray}}
		 * @private
		 */
		this.last = {
			id: null,
			point: null
		};
	}
	 /* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /** @override */
	static get layerOptions() {
		return mergeObject(super.layerOptions, {
			controllableObjects: true,
			objectClass: Wall,
			quadtree: true,
			sheetClass: WallConfig,
			sortActiveTop: true,
			zIndex: 40
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * An Array of Wall instances in the current Scene which currently block Token vision.
	 * This array includes doors regardless of their current door state.
	 * @type {Wall[]}
	 */
	get blockVision() {
		return this.objects.children.filter(w => w.data.sense !== CONST.WALL_SENSE_TYPES.NONE);
	}
	 /* -------------------------------------------- */
	 /**
	 * An Array of Wall instances in the current Scene which block Token movement.
	 * This array includes doors regardless of their current door state.
	 * @type {Wall[]}
	 */
	get blockMovement() {
		return this.objects.children.filter(w => w.data.move !== CONST.WALL_MOVEMENT_TYPES.NONE);
	}
	 /* -------------------------------------------- */
	 /**
	 * An Array of Wall instances in the current Scene which act as Doors.
	 * @type {Wall[]}
	 */
	get doors() {
		return this.objects.children.filter(w => w.data.door > CONST.WALL_DOOR_TYPES.NONE);
	}
	 /* -------------------------------------------- */
	 /**
	 * Gate the precision of wall snapping to become less precise for small scale maps.
	 * @type {number}
	 */
	get gridPrecision() {
		if ( this._forceSnap ) return 1;
		let size = canvas.dimensions.size;
		if ( size >= 128 ) return 16;
		else if ( size >= 64 ) return 8;
		else if ( size >= 32 ) return 4;
		return 1;
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /** @override */
	async draw() {
		await super.draw();
		this.last = {id: null, point: null};
		this.chain = this.addChildAt(new PIXI.Graphics(), 0);
		this.highlightControlledSegments();
		this.initialize();
		return this;
	}
	 /* -------------------------------------------- */
	 /** @override */
	deactivate() {
		super.deactivate();
		if ( this.chain ) this.chain.clear();
		 // Re-initialize perception layers
		this.initialize();
		canvas.sight.initialize().then(() => {
			canvas.sounds.initialize();
		});
		return this;
	}
	 /* -------------------------------------------- */
	 initialize() {
		this.endpoints = WallsLayer.getUniqueEndpoints(this.objects.children, {
			blockMovement: false,
			blockSenses: true
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Given a point and the coordinates of a wall, determine which endpoint is closer to the point
	 * @param {Point} point         The origin point of the new Wall placement
	 * @param {Wall} wall           The existing Wall object being chained to
	 * @return {PointArray}         The [x,y] coordinates of the starting endpoint
	 */
	static getClosestEndpoint(point, wall) {
		const a = wall.data.c.slice(0, 2);
		const b = wall.data.c.slice(2);
		 // Exact matches
		if ( a.equals([point.x, point.y]) ) return a;
		else if ( b.equals([point.x, point.y]) ) return b;
		 // Closest match
		const da = Math.hypot(point.x - a[0], point.y - a[1]);
		const db = Math.hypot(point.x - b[0], point.y - b[1]);
		return da < db ? a : b;
	}
	 /* -------------------------------------------- */
	 /**
	 * Given an array of Wall instances, identify the unique endpoints across all walls.
	 * @param {Wall[]} walls            An array of Wall instances
	 * @param {Rectangle} bounds        An optional bounding rectangle within which the endpoint must lie.
	 * @param {boolean} blockMovement   Filter for walls that block movement, default is true.
	 * @param {boolean} blockSenses     Filter for walls that block perception, default is true.
	 * @return {PointArray[]}           An array of endpoints
	 */
	static getUniqueEndpoints(walls, {bounds=null, blockMovement=true, blockSenses=true}={}) {
		const unique = new Set();
		const endpoints = [];
		 // Define the adding function
		const set = pt => {
			if ( bounds && !bounds.contains(pt[0], pt[1]) ) return;
			let k = pt.join(",");
			if ( unique.has(k) ) return;
			endpoints.push(pt);
			unique.add(k);
		};
		 // Iterate over provided walls
		for (let w of walls) {
			if ( blockMovement && (w.data.move === CONST.WALL_MOVEMENT_TYPES.NONE) ) continue;
			if ( blockSenses && (w.data.sense === CONST.WALL_SENSE_TYPES.NONE) ) continue;
			set(w.data.c.slice(0, 2));
			set(w.data.c.slice(2));
		}
		return endpoints;
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether movement along a given Ray collides with a Wall.
	 * @param {Ray} ray   The attempted movement
	 * @return {boolean}  Does a collision occur?
	 */
	checkCollision(ray, {blockMovement=true, blockSenses=false, mode="any"}={}) {
		if ( !canvas.grid.hitArea.contains(ray.B.x, ray.B.y) ) return true;
		if ( !canvas.scene.data.walls.length ) return false;
		return this.constructor.getRayCollisions(ray, {blockMovement, blockSenses, mode});
	}
	 /* -------------------------------------------- */
	 /**
	 * Highlight the endpoints of Wall segments which are currently group-controlled on the Walls layer
	 */
	highlightControlledSegments() {
		if ( !this.chain ) return;
		const drawn = new Set();
		const c = this.chain.clear();
		 // Determine circle radius and line width
		let lw = 2;
		if ( canvas.dimensions.size > 150 ) lw = 4;
		else if ( canvas.dimensions.size > 100 ) lw = 3;
		const  cr = lw * 2;
		let cr2 = cr * 2;
		let cr4 = cr * 4;
		 for ( let p of Object.values(this._controlled) ) {
			let p1 = p.coords.slice(0, 2);
			if ( !drawn.has(p1.join(".")) ) c.lineStyle(cr, 0xFF9829).drawRoundedRect(p1[0] - cr2, p1[1] - cr2, cr4, cr4, cr);
			let p2 = p.coords.slice(2);
			if ( !drawn.has(p2.join(".")) ) c.lineStyle(cr, 0xFF9829).drawRoundedRect(p2[0] - cr2, p2[1] - cr2, cr4, cr4, cr);
			c.lineStyle(cr2, 0xFF9829).moveTo(...p1).lineTo(...p2);
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	releaseAll() {
		this.chain.clear();
		return super.releaseAll();
	}
	 /* -------------------------------------------- */
	 /** @override */
	async pasteObjects(position, options) {
		if ( !this._copy.length ) return;
		const cls = this.constructor.placeableClass;
		 // Transform walls to reference their upper-left coordinates as {x,y}
		const [xs, ys] = this._copy.reduce((arr, w) => {
			arr[0].push(Math.min(w.data.c[0], w.data.c[2]));
			arr[1].push(Math.min(w.data.c[1], w.data.c[3]));
			return arr;
		}, [[], []]);
		 // Get the top-left most coordinate
		const topX = Math.min(...xs);
		const topY = Math.min(...ys);
		 // Get the magnitude of shift
		const dx = Math.floor(topX - position.x);
		const dy = Math.floor(topY - position.y);
		const shift = [dx, dy, dx, dy];
		 // Iterate over objects
		const toCreate = [];
		for ( let w of this._copy ) {
			let data = duplicate(w.data);
			data.c = data.c.map((c, i) => c - shift[i]);
			delete data._id;
			toCreate.push(data);
		}
		 // Call paste hooks
		Hooks.call(`paste${cls.name}`, this._copy, toCreate);
		 // Create all objects
		let created = await canvas.scene.createEmbeddedEntity("Wall", toCreate);
		ui.notifications.info(`Pasted data for ${toCreate.length} ${cls.name} objects.`);
		created = created instanceof Array ? created : [created];
		return created.map(c => this.get(c._id));
	}
	 /* -------------------------------------------- */
	 /**
	 * Pan the canvas view when the cursor position gets close to the edge of the frame
	 * @param {MouseEvent} event    The originating mouse movement event
	 * @param {number} x            The x-coordinate
	 * @param {number} y            The y-coordinate
	 * @private
	 */
	_panCanvasEdge(event, x, y) {
		 // Throttle panning by 20ms
		const now = Date.now();
		if ( now - (event.data.panTime || 0) <= 100 ) return;
		event.data.panTime = now;
		 // Determine the amount of shifting required
		const pad = 50;
		const shift = 500 / canvas.stage.scale.x;
		 // Shift horizontally
		let dx = 0;
		if ( x < pad ) dx = -shift;
		else if ( x > window.innerWidth - pad ) dx = shift;
		 // Shift vertically
		let dy = 0;
		if ( y < pad ) dy = -shift;
		else if ( y > window.innerHeight - pad ) dy = shift;
		 // Enact panning
		if (( dx || dy ) && !this._panning ) {
			return canvas.animatePan({x: canvas.stage.pivot.x + dx, y: canvas.stage.pivot.y + dy}, {duration: 100});
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the endpoint coordinates for a wall placement, snapping to grid at a specified precision
	 * Require snap-to-grid until a redesign of the wall chaining system can occur.
	 * @param {Object} point          The initial candidate point
	 * @param {boolean} [snap=true]   Whether to snap to grid
	 * @return {number[]}             The endpoint coordinates [x,y]
	 * @private
	 */
	_getWallEndpointCoordinates(point, {snap=true}={}) {
		if ( snap ) point = canvas.grid.getSnappedPosition(point.x, point.y, this.gridPrecision);
		return [point.x, point.y].map(Math.floor);
	}
	 /* -------------------------------------------- */
	 /**
	 * The Scene Controls tools provide several different types of prototypical Walls to choose from
	 * This method helps to translate each tool into a default wall data configuration for that type
	 * @param {string} tool     The active canvas tool
	 * @private
	 */
	_getWallDataFromActiveTool(tool) {
		 // Using the clone tool
		if ( tool === "clone" && this._cloneType ) return this._cloneType;
		 // Using a wall type
		const wallData = {};
		wallData.move = ( tool === "ethereal" ) ? CONST.WALL_MOVEMENT_TYPES.NONE : CONST.WALL_MOVEMENT_TYPES.NORMAL;
		wallData.sense = ( tool === "invisible" ) ? CONST.WALL_SENSE_TYPES.NONE : CONST.WALL_SENSE_TYPES.NORMAL;
		if ( tool === "terrain" ) wallData.sense = CONST.WALL_SENSE_TYPES.LIMITED;
		else if ( tool === "doors" ) wallData.door = CONST.WALL_DOOR_TYPES.DOOR;
		else if ( tool === "secret" ) wallData.door = CONST.WALL_DOOR_TYPES.SECRET;
		return wallData;
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	_onClickLeft(event) {
		const {createState} = event.data;
		 // Conclude a chained wall creation
		if ( this._chain && (createState === 2) ) return this._onDragLeftDrop(event);
		this._chain = game.keyboard.isCtrl(event);
		 // Begin a new wall creation
		super._onClickLeft(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftStart(event) {
		const { origin, originalEvent } = event.data;
		const tool = game.activeTool;
		event.data.createState = 0;
		 // Construct new wall data
		const data = this._getWallDataFromActiveTool(tool);
		const snap = this._forceSnap || !originalEvent.shiftKey;
		 // Determine the starting coordinates
		const pt = (this._chain && this.last.id) ? this.last.point : this._getWallEndpointCoordinates(origin, {snap});
		data.c = pt.concat(pt);
		 // Create the preview Wall
		const wall = new Wall(data);
		wall.draw();
		 // Update event data
		event.data.createState = 1;
		event.data.preview = this.preview.addChild(wall);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftMove(event) {
		const { destination, preview } = event.data;
		if ( !preview ) return;
		if ( preview.parent === null ) { // In theory this should never happen, but rarely does
			this.preview.addChild(preview);
		}
		preview.data.c = preview.data.c.slice(0, 2).concat([destination.x, destination.y]);
		preview.refresh();
		event.data.createState = 2;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftDrop(event) {
		const { createState, destination, originalEvent, preview } = event.data;
		 // Prevent default to allow chaining to continue
		const isCtrl = game.keyboard.isCtrl(event);
		if ( isCtrl ) {
			originalEvent.preventDefault();
			this._chain = true;
			if ( createState !== 2 ) return;
		} else this._chain = false;
		 // Successful wall completion
		if ( createState === 2 ) {
			event.data.createState = 0;
			 // Get final endpoint location
			const snap = this._forceSnap || !originalEvent.shiftKey;
			let dest = this._getWallEndpointCoordinates(destination, {snap});
			const coords = preview.data.c.slice(0, 2).concat(dest);
			preview.data.c = coords;
			 // Ignore walls which are collapsed
			if ( (coords[0] === coords[2]) && (coords[1] === coords[3]) ) return this._onDragLeftCancel(originalEvent);
			 // Create the Wall
			const cls = this.constructor.placeableClass;
			this.last = {id: "preview", point: dest};
			cls.create(preview.data).then(w => this.last.id = w.data._id);
			this.preview.removeChild(preview);
			 // Maybe chain
			if (this._chain) {
				event.data.origin = {x: dest[0], y: dest[1]};
				return this._onDragLeftStart(event);
			}
		}
		 // Partial wall completion
		return this._onDragLeftCancel(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftCancel(event) {
		this._chain = false;
		super._onDragLeftCancel(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onClickRight(event) {
		if ( event.data.createState > 0 ) return this._onDragLeftCancel(event);
	}
	 /* -------------------------------------------- */
	/*  New Collision Work
	/* -------------------------------------------- */
	 /**
	 * Test a single Ray against a single Wall
	 * @param {Ray} ray           The Ray being cast
	 * @param {Wall} wall         The Wall against which to test
	 * @return {RayIntersection}  An intersection, if one occurred
	 */
	static testWall(ray, wall) {
		let i = ray.intersectSegment(wall.data.c);
		if ( i && i.t0 > 0 ) {
			i.sense = wall.data.sense;
			return i;
		}
		return null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Identify the closest collision point from an array of collisions
	 * @param {RayIntersection[]} collisions  An array of intersection points
	 * @return {RayIntersection}              The closest blocking intersection
	 */
	static getClosestCollision(collisions) {
		if ( !collisions.length ) return null;
		collisions.sort((a, b) => a.t0 - b.t0);
		let closest = ( collisions[0].sense === CONST.WALL_SENSE_TYPES.LIMITED ) ? collisions[1] : collisions[0];
		return closest || null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the set of wall collisions for a given Ray
	 * @param {Ray} ray                   The Ray being tested
	 * @param {boolean} [blockMovement]   Test against walls which block movement?
	 * @param {boolean} [blockSenses]     Test against walls which block senses?
	 * @param {string} [mode]             The return mode of the test, one of "all", "closest", or "any"
	 * @param {object} _performance       An internal performance object used for debugging
	 *
	 * @return {object[]|object|boolean}  An array of collisions, if mode is "all"
	 *                                    The closest collision, if mode is "closest"
	 *                                    Whether any collision occurred if mode is "any"
	 */
	static getRayCollisions(ray, {blockMovement=true, blockSenses=true, mode="all", _performance}={}) {
		 // Define inputs
		const angleBounds = [ray.angle - (Math.PI/2), ray.angle + (Math.PI/2)];
		const isClosest = mode === "closest";
		const isAny = mode === "any";
		 // Track collisions
		const collisions = {};
		let collided = false;
		 // Track quadtree nodes and walls which have already been tested
		const testedNodes = new Set();
		const testedWalls = new Set();
		 // Expand the ray outward from the origin, identifying candidate walls as we go
		const stages = 4;
		for ( let i=1; i<=stages; i++ ) {
			 // Determine and iterate over the (unordered) set of nodes to test at this level of projection
			const limit = i < stages ? ray.project(i / stages) : ray.B;
			const bounds = new NormalizedRectangle(ray.A.x, ray.A.y, limit.x - ray.A.x, limit.y - ray.A.y);
			const nodes = canvas.walls.quadtree.getLeafNodes(bounds);
			for ( let n of nodes ) {
				if ( testedNodes.has(n) ) continue;
				testedNodes.add(n);
				 // Iterate over walls in the node to test
				const objects = n.objects;
				for ( let o of objects ) {
					const w = o.t;
					if (testedWalls.has(w)) continue;
					testedWalls.add(w);
					 // Skip walls which don't fit the criteria
					if ((w.data.door > CONST.WALL_DOOR_TYPES.NONE) && (w.data.ds === CONST.WALL_DOOR_STATES.OPEN)) continue;
					if (blockMovement && (w.data.move === CONST.WALL_MOVEMENT_TYPES.NONE)) continue;
					if (blockSenses && (w.data.sense === CONST.WALL_SENSE_TYPES.NONE)) continue;
					if (w.direction !== null) { // Directional walls where the ray angle is not in the same hemisphere
						if (!w.isDirectionBetweenAngles(...angleBounds)) continue;
					}
					 // Test a single wall
					const x = this.testWall(ray, w);
					if (_performance) _performance.tests++;
					if (!x) continue;
					if (isAny) return true;
					 // Update a known collision point to flag the sense type
					const pt = `${x.x},${x.y}`;
					let c = collisions[pt];
					if (c) {
						c.sense = Math.min(w.data.sense, c.sense);
						for ( let n of o.n ) c.nodes.push(n);
					} else {
						x.sense = w.data.sense;
						x.nodes = Array.from(o.n);
						collisions[pt] = x;
						collided = true;
					}
				}
			}
			 // At this point we may be done if the closest collision has been fully tested
			if ( isClosest && collided ) {
				const closest = this.getClosestCollision(Object.values(collisions));
				if ( closest && closest.nodes.every(n => testedNodes.has(n) ) ) {
					return closest;
				}
			}
		}
		 // Return the collision result
		if ( isAny ) return false;
		if ( isClosest ) {
			const closest = this.getClosestCollision(Object.values(collisions));
			return closest || null;
		}
		return Object.values(collisions);
	}
}

/**
 * The Drawing object is an implementation of the :class:`PlaceableObject` container.
 * Each Drawing is a placeable object in the :class:`DrawingsLayer`.
 * @extends {PlaceableObject}
 *
 * @example
 * Drawing.create({
 *   type: CONST.DRAWING_TYPES.RECTANGLE,
 *   author: game.user._id,
 *   x: 1000,
 *   y: 1000,
 *   width: 800,
 *   height: 600,
 *   fillType: CONST.DRAWING_FILL_TYPES.SOLID,
 *   fillColor: "#0000FF",
 *   fillAlpha: 0.5,
 *   strokeWidth: 4,
 *   strokeColor: "#FF0000",
 *   strokeAlpha: 0.75,
 *   texture: "ui/parchment.jpg",
 *   textureAlpha: 0.5,
 *   text: "HELLO DRAWINGS!",
 *   fontSize: 48,
 *   textColor: "#00FF00",
 *   points: []
 * });
 */
class Drawing extends PlaceableObject {
	constructor(...args) {
		super(...args);
		 /**
		 * The inner drawing container
		 * @type {PIXI.Container}
		 */
		this.drawing = null;
		 /**
		 * The primary drawing shape
		 * @type {PIXI.Graphics}
		 */
		this.shape = null;
		 /**
		 * Text content, if included
		 * @type {PIXI.Text}
		 */
		this.text = null;
		 /**
		 * The Graphics outer frame and handles
		 * @type {PIXI.Container}
		 */
		this.frame = null;
		 /**
		 * Internal timestamp for the previous freehand draw time, to limit sampling
		 * @type {number}
		 * @private
		 */
		this._drawTime = 0;
		this._sampleTime = 0;
		 /**
		 * Internal flag for the permanent points of the polygon
		 * @type {boolean}
		 * @private
		 */
		this._fixedPoints = duplicate(this.data.points || []);
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get embeddedName() {
		return "Drawing";
	}
	 /* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /**
	 * A reference to the User who created the Drawing object
	 * @type {User}
	 */
	get author() {
		return game.users.get(this.data.author);
	}
	 /* -------------------------------------------- */
	 /**
	 * A flag for whether the current user has full control over the Drawing object
	 * @type {User}
	 */
	get owner() {
		return game.user.isGM || (this.data.author === game.user._id)
	}
	 /* -------------------------------------------- */
	 /**
	 * A Boolean flag for whether or not the Drawing utilizes a tiled texture background
	 * @type {boolean}
	 */
	get isTiled() {
		return this.data.fillType === CONST.DRAWING_FILL_TYPES.PATTERN;
	}
	 /* -------------------------------------------- */
	 /**
	 * A Boolean flag for whether or not the Drawing is a Polygon type (either linear or freehand)
	 * @type {boolean}
	 */
	get isPolygon() {
		return [CONST.DRAWING_TYPES.POLYGON, CONST.DRAWING_TYPES.FREEHAND].includes(this.data.type);
	}
	 /* -------------------------------------------- */
	/* Rendering                                    */
	/* -------------------------------------------- */
	 /** @override */
	async draw() {
		this.clear();
		this._pendingText = this.data.text ?? "";
		 // Load the background texture, if one is defined
		if ( this.data.texture ) {
			this.texture = await loadTexture(this.data.texture, {fallback: 'icons/svg/hazard.svg'});
		} else {
			this.texture = null;
		}
		 // Create the inner Drawing container
		this._createDrawing();
		 // Control Border
		this._createFrame();
		 // Render Appearance
		this.refresh();
		 // Enable Interactivity, if this is a true Drawing
		if ( this.id ) this.activateListeners();
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Create the components of the drawing element, the drawing container, the drawn shape, and the overlay text
	 */
	_createDrawing() {
		 // Drawing container
		this.drawing = this.addChild(new PIXI.Container());
		 // Drawing Shape
		this.shape = this.drawing.addChild(new PIXI.Graphics());
		 // Overlay Text
		const hasText = this.data.type === CONST.DRAWING_TYPES.TEXT || this.data.text;
		this.text = hasText ? this.drawing.addChild(this._createText()) : null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Create elements for the foreground text
	 * @private
	 */
	_createText() {
		if ( this.text && !this.text._destroyed ) {
			this.text.destroy();
			this.text = null;
		}
		const isText = this.data.type === CONST.DRAWING_TYPES.TEXT;
		const stroke = Math.max(Math.round(this.data.fontSize / 32), 2);
		 // Define the text style
		const textStyle = new PIXI.TextStyle({
			fontFamily: this.data.fontFamily || CONFIG.defaultFontFamily,
			fontSize: this.data.fontSize,
			fill: this.data.textColor || "#FFFFFF",
			stroke: "#111111",
			strokeThickness: stroke,
			dropShadow: true,
			dropShadowColor: "#000000",
			dropShadowBlur: Math.max(Math.round(this.data.fontSize / 16), 2),
			dropShadowAngle: 0,
			dropShadowDistance: 0,
			align: isText ? "left" : "center",
			wordWrap: !isText,
			wordWrapWidth: 1.5 * this.data.width,
			padding: stroke
		});
		 // Create the text container
		return new PreciseText(this.data.text, textStyle);
	}
	 /* -------------------------------------------- */
	 /**
	 * Create elements for the Drawing border and handles
	 * @private
	 */
	_createFrame() {
		this.frame = this.addChild(new PIXI.Container());
		this.frame.border = this.frame.addChild(new PIXI.Graphics());
		this.frame.handle = this.frame.addChild(new ResizeHandle([1,1]));
	}
	 /* -------------------------------------------- */
	 /** @override */
	refresh() {
		if ( this._destroyed || this.shape._destroyed ) return;
		const isTextPreview = (this.data.type === CONST.DRAWING_TYPES.TEXT) && this._controlled;
		this.shape.clear();
		 // Outer Stroke
		if ( this.data.strokeWidth || isTextPreview ) {
			let sc = colorStringToHex(this.data.strokeColor || "#FFFFFF");
			this.shape.lineStyle(this.data.strokeWidth || 8, sc, this.data.strokeAlpha || 1);
		}
		 // Fill Color or Texture
		if ( this.data.fillType || isTextPreview ) {
			const fc = colorStringToHex(this.data.fillColor || "#FFFFFF");
			if ( (this.data.fillType === CONST.DRAWING_FILL_TYPES.PATTERN) && this.texture ) {
				this.shape.beginTextureFill({
					texture: this.texture,
					color: fc || 0xFFFFFF,
					alpha: fc ? this.data.fillAlpha : 1
				});
			} else {
				const fa = isTextPreview ? 0.25 : this.data.fillAlpha;
				this.shape.beginFill(fc, fa);
			}
		}
		 // Draw the shape
		switch ( this.data.type ) {
			case CONST.DRAWING_TYPES.RECTANGLE:
			case CONST.DRAWING_TYPES.TEXT:
				this._drawRectangle();
				break;
			case CONST.DRAWING_TYPES.ELLIPSE:
				this._drawEllipse();
				break;
			case CONST.DRAWING_TYPES.POLYGON:
				this._drawPolygon();
				break;
			case CONST.DRAWING_TYPES.FREEHAND:
				this._drawFreehand();
				break;
		}
		 // Conclude fills
		this.shape.lineStyle(0x000000, 0.0).closePath();
		this.shape.endFill();
		 // Set shape rotation, pivoting about the non-rotated center
		this.shape.pivot.set(this.data.width / 2, this.data.height / 2);
		this.shape.position.set(this.data.width / 2, this.data.height / 2);
		this.shape.rotation = toRadians(this.data.rotation || 0);
		 // Update text position and visibility
		if ( this.text ) {
			this.text.alpha = this.data.textAlpha || 1.0;
			this.text.pivot.set(this.text.width / 2, this.text.height / 2);
			this.text.position.set(
				(this.text.width / 2) + ((this.data.width - this.text.width) / 2),
				(this.text.height / 2) + ((this.data.height - this.text.height) / 2)
			);
			this.text.rotation = this.shape.rotation;
		}
		 // Determine shape bounds and update the frame
		const bounds = this.drawing.getLocalBounds();
		if ( this.id && this._controlled ) this._refreshFrame(bounds);
		else this.frame.visible = false;
		 // Toggle visibility
		this.position.set(this.data.x, this.data.y);
		this.drawing.hitArea = bounds;
		this.alpha = this.data.hidden ? 0.5 : 1.0;
		this.visible = !this.data.hidden || game.user.isGM;
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw rectangular shapes
	 * @private
	 */
	_drawRectangle() {
		let hs = this.data.strokeWidth / 2;
		this.shape.drawRect(hs, hs, this.data.width - (2*hs), this.data.height - (2*hs));
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw ellipsoid shapes
	 * @private
	 */
	_drawEllipse() {
		let hw = this.data.width / 2,
				hh = this.data.height / 2,
				hs = this.data.strokeWidth / 2;
		this.shape.drawEllipse(hw, hh, Math.abs(hw) - hs, Math.abs(hh) - hs);
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw polygonal shapes
	 * @private
	 */
	_drawPolygon() {
		let points = this.data.points || [];
		if ( points.length < 2 ) return;
		else if ( points.length === 2 ) this.shape.endFill();
		 // Get drawing points
		let last = points[points.length - 1];
		let isClosed = points[0].equals(last);
		 // If the polygon is closed, or if we are filling it, we can shortcut using the drawPolygon helper
		if ( points.length > 2 && (isClosed || this.data.fillType) ) this.shape.drawPolygon(points.deepFlatten());
		 // Otherwise, draw each line individually
		else {
			this.shape.moveTo(...points[0]);
			for ( let p of points.slice(1) ) {
				this.shape.lineTo(...p);
			}
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw freehand shapes with bezier spline smoothing
	 * @private
	 */
	_drawFreehand() {
		let factor = this.data.bezierFactor ?? 0.5;
		 // Get drawing points
		let points = this.data.points;
		let last = points[points.length - 1];
		let isClosed = points[0].equals(last);
		 // Handle edge cases
		this.shape.moveTo(...points[0]);
		if ( points.length < 2 ) return;
		else if ( points.length === 2 ) {
			this.shape.lineTo(...points[1]);
			return;
		}
		 // Set initial conditions
		let [previous, point] = points.slice(0, 2);
		if ( this.data.fillType ) points = points.concat([previous, point]);
		let cp0 = this._getBezierControlPoints(factor, last, previous, point).next_cp0;
		let cp1, next_cp0, next;
		 // Begin iteration
		for ( let i = 1; i < points.length; i++ ) {
			next = points[i+1];
			if ( next ) {
				let bp = this._getBezierControlPoints(factor, previous, point, next);
				cp1 = bp.cp1;
				next_cp0 = bp.next_cp0;
			}
			 // First point
			if ( (i === 1) && !isClosed ) {
				this.shape.quadraticCurveTo(cp1.x, cp1.y, point[0], point[1]);
			}
			 // Last Point
			else if ( (i === points.length - 1) && !isClosed ) {
				this.shape.quadraticCurveTo(cp0.x, cp0.y, point[0], point[1]);
			}
			 // Bezier points
			else {
				this.shape.bezierCurveTo(cp0.x, cp0.y, cp1.x, cp1.y, point[0], point[1]);
			}
			 // Increment
			previous = point;
			point = next;
			cp0 = next_cp0;
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Attribution: The equations for how to calculate the bezier control points are derived from Rob Spencer's article:
	 * http://scaledinnovation.com/analytics/splines/aboutSplines.html
	 * @param {number} factor       The smoothing factor
	 * @param {number[]} previous   The prior point
	 * @param {number[]} point      The current point
	 * @param {number[]} next       The next point
	 * @private
	 */
	_getBezierControlPoints(factor, previous, point, next) {
		 // Calculate distance vectors
		let vector = { x: next[0] - previous[0], y: next[1] - previous[1] },
				preDistance = Math.hypot(previous[0] - point[0], previous[1] - point[1]),
				postDistance = Math.hypot(next[0] - point[0], next[1] - point[1]),
				distance = preDistance + postDistance;
		 // Compute control point locations
		let cp0d = distance === 0 ? 0 : factor * (preDistance / distance),
				cp1d = distance === 0 ? 0 : factor * (postDistance / distance);
		 // Return points
		return {
			cp1: {
				x: point[0] - (vector.x * cp0d),
				y: point[1] - (vector.y * cp0d)
			},
			next_cp0: {
				x: point[0] + (vector.x * cp1d),
				y: point[1] + (vector.y * cp1d)
			}
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Refresh the boundary frame which outlines the Drawing shape
	 * @private
	 */
	_refreshFrame({x, y, width, height}) {
		 // Determine the border color
		const colors = CONFIG.Canvas.dispositionColors;
		let bc = colors.INACTIVE;
		if ( this._controlled ) {
			bc = this.data.locked ? colors.HOSTILE : colors.CONTROLLED;
		}
		 // Draw the border
		const pad = 6;
		const t = CONFIG.Canvas.objectBorderThickness;
		const h = Math.round(t/2);
		const o = Math.round(h/2) + pad;
		this.frame.border.clear()
			.lineStyle(t, 0x000000).drawRect(x - o, y - o, width + (2*o), height + (2*o))
			.lineStyle(h, bc).drawRect(x - o, y - o, width + (2*o), height + (2*o))
		 // Draw the handle
		this.frame.handle.position.set(x+width+o, y+height+o);
		this.frame.handle.clear()
			.beginFill(0x000000, 1.0).lineStyle(h, 0x000000).drawCircle(0, 0, pad+h)
			.lineStyle(h, bc).drawCircle(0, 0, pad);
		this.frame.visible = true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Add a new polygon point to the drawing, ensuring it differs from the last one
	 * @private
	 */
	_addPoint(position, temporary=true) {
		const point = [position.x - this.data.x, position.y - this.data.y];
		this.data.points = this._fixedPoints.concat([point]);
		if ( !temporary ) {
			this._fixedPoints = this.data.points;
			this._drawTime = Date.now();
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Remove the last fixed point from the polygon
	 * @private
	 */
	_removePoint() {
		if ( this._fixedPoints.length ) this._fixedPoints.pop();
		this.data.points = this._fixedPoints;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onControl(options) {
		super._onControl(options);
		if ( this.data.type === CONST.DRAWING_TYPES.TEXT ) {
			this._onkeydown = this._onDrawingTextKeydown.bind(this);
			if ( !options.isNew ) this._pendingText = this.data.text;
			document.addEventListener("keydown", this._onkeydown);
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onRelease(options) {
		super._onRelease(options);
		if ( this._onkeydown ) {
			document.removeEventListener("keydown", this._onkeydown);
			this._onkeydown = null;
		}
		if ( this.data.type === DRAWING_TYPES.TEXT ) {
			let text = this._pendingText ?? this.data.text;
			if ( text === "" ) return this.delete();
			if ( this._pendingText ) {    // Submit pending text
				this.update({text: this._pendingText, width: this.data.width, height: this.data.height});
				this._pendingText = "";
			}
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDelete(...args) {
		super._onDelete(...args);
		if ( this._onkeydown ) document.removeEventListener("keydown", this._onkeydown);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle text entry in an active text tool
	 * @param {KeyboardEvent} event
	 * @private
	 */
	_onDrawingTextKeydown(event) {
		 // Ignore events when an input is focused, or when ALT or CTRL modifiers are applied
		if ( event.altKey || event.ctrlKey || event.metaKey ) return;
		if ( game.keyboard.hasFocus ) return;
		 // Track refresh or conclusion conditions
		let conclude = ["Escape", "Enter"].includes(event.key);
		let refresh = false;
		 // Submitting the change, update or delete
		if ( event.key === "Enter" ) {
			if ( this._pendingText ) {
				const updateData = {text: this._pendingText, width: this.data.width, height: this.data.height};
				return this.update(updateData, {diff: false}).then(() => this.release())
			}
			else return this.delete();
		}
		 // Cancelling the change
		else if ( event.key === "Escape" ) {
			this._pendingText = this.data.text;
			refresh = true;
		}
		 // Deleting a character
		else if ( event.key === "Backspace" ) {
			this._pendingText = this._pendingText.slice(0, -1);
			refresh = true;
		}
		 // Typing text (any single char)
		else if ( /^.$/.test(event.key) ) {
			this._pendingText += event.key;
			refresh = true;
		}
		 // Stop propagation if the event was handled
		if ( refresh || conclude ) {
			event.preventDefault();
			event.stopPropagation();
		}
		 // Refresh the display
		if ( refresh ) {
			this.text.text = this._pendingText;
			this.data.width = this.text.width + 100;
			this.data.height = this.text.height + 50;
			this.refresh();
		}
		 // Conclude the workflow
		if ( conclude ) {
			this.release();
		}
	}
	 /* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */
	 /** @override */
	_onUpdate(data) {
		const changed = new Set(Object.keys(data));
		if ( changed.has("z") ) this.zIndex = parseInt(data.z) || 0;
		 // Fully re-draw when certain core aspects are changed
		const redraw = ["type", "text", "texture", "fontFamily", "fontSize", "textColor"];
		if ( redraw.some(k => changed.has(k)) ) {
			this.draw().then(() => super._onUpdate(data));
		}
		 // Otherwise simply refresh the existing drawing
		else {
			this.refresh();
			super._onUpdate(data);
		}
	}
	 /* -------------------------------------------- */
	/*  Permission Controls                         */
	/* -------------------------------------------- */
	 /** @override */
	_canControl(user, event) {
		if ( this._creating ) {  // Allow one-time control immediately following creation
			delete this._creating;
			return true;
		}
		if ( this._controlled ) return true;
		if ( game.activeTool !== "select" ) return false;
		return user.isGM || (user.id === this.data.author);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_canHUD(user, event) {
		return this._controlled;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_canConfigure(user, event) {
		return this._controlled;
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	activateListeners() {
		super.activateListeners();
		this.frame.handle.off("mouseover").off("mouseout").off("mousedown")
			.on("mouseover", this._onHandleHoverIn.bind(this))
			.on("mouseout", this._onHandleHoverOut.bind(this))
			.on("mousedown", this._onHandleMouseDown.bind(this));
		this.frame.handle.interactive = true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mouse movement which modifies the dimensions of the drawn shape
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onMouseDraw(event) {
		const {destination, originalEvent} = event.data;
		const isShift = originalEvent.shiftKey;
		const isAlt = originalEvent.altKey;
		 // Determine position
		let position = destination;
		if ( !isShift && (this.data.type !== CONST.DRAWING_TYPES.FREEHAND) ) {
			position = canvas.grid.getSnappedPosition(position.x, position.y, this.layer.gridPrecision);
		} else {
			position = {x: parseInt(position.x), y: parseInt(position.y)};
		}
		 // Drag differently depending on shape type
		switch ( this.data.type ) {
			 // Freehand Shapes
			case CONST.DRAWING_TYPES.FREEHAND:
				const now = Date.now();
				 // If the time since any drawing activity last occurred exceeds the sample rate - upgrade the prior point
				if ( (now - this._drawTime) >= this.constructor.FREEHAND_SAMPLE_RATE ) {
					this._sampleTime = now;
				}
				 // Determine whether the new point should be permanent based on the time since last sample
				let takeSample = (now - this._drawTime) >= this.constructor.FREEHAND_SAMPLE_RATE;
				this._addPoint(position, !takeSample);
				break;
			 // Polygon Shapes
			case CONST.DRAWING_TYPES.POLYGON:
				this._addPoint(position, true);
				break;
			 // Geometric Shapes
			default:
				let dx = (position.x - this.data.x) || (canvas.dimensions.size * Math.sign(this.data.width) * 0.5);
				let dy = (position.y - this.data.y) || (canvas.dimensions.size * Math.sign(this.data.height) * 0.5);
				if ( isAlt ) {
					dx = Math.abs(dy) < Math.abs(dx) ? Math.abs(dy) * Math.sign(dx) : dx;
					dy = Math.abs(dx) < Math.abs(dy) ? Math.abs(dx) * Math.sign(dy) : dy;
				}
				this.data.width = dx;
				this.data.height = dy;
		}
		 // Refresh the display
		this.refresh();
	}
	 /* -------------------------------------------- */
	/*  Interactivity                               */
	/* -------------------------------------------- */
	 /** @override */
	_onDragLeftStart(event) {
		if ( this._dragHandle ) return this._onHandleDragStart(event);
		if ( this._pendingText ) this.data.text = this._pendingText;
		return super._onDragLeftStart(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftMove(event) {
		if ( this._dragHandle ) return this._onHandleDragMove(event);
		return super._onDragLeftMove(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftDrop(event) {
		if ( this._dragHandle ) return this._onHandleDragDrop(event);
		 // Update each dragged Drawing, confirming pending text
		const clones = event.data.clones || [];
		const updates = clones.map(c => {
			let dest = {x: c.data.x, y: c.data.y};
			if ( !event.data.originalEvent.shiftKey ) {
				dest = canvas.grid.getSnappedPosition(c.data.x, c.data.y, this.layer.options.gridPrecision);
			}
			 // Define the update
			const update = {
				_id: c._original.id,
				x: dest.x,
				y: dest.y,
				rotation: c.data.rotation,
				text: c._original._pendingText ? c._original._pendingText : c.data.text
			};
			 // Commit pending text
			if ( c._original._pendingText ) {
				update.text = c._original._pendingText;
			}
			 // Hide the original until after the update processes
			c._original.visible = false;
			return update;
		});
		return canvas.scene.updateEmbeddedEntity(this.constructor.name, updates, {diff: false});
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftCancel(event) {
		if ( this._dragHandle ) return this._onHandleDragCancel(event);
		return super._onDragLeftCancel(event);
	}
	 /* -------------------------------------------- */
	/*  Resize Handling                             */
	/* -------------------------------------------- */
	 /**
	 * Handle mouse-over event on a control handle
	 * @param {PIXI.interaction.InteractionEvent} event   The mouseover event
	 * @private
	 */
	_onHandleHoverIn(event) {
		const handle = event.target;
		handle.scale.set(1.5, 1.5);
		event.data.handle = event.target;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mouse-out event on a control handle
	 * @param {PIXI.interaction.InteractionEvent} event   The mouseout event
	 * @private
	 */
	_onHandleHoverOut(event) {
		event.data.handle.scale.set(1.0, 1.0);
	}
	 /* -------------------------------------------- */
	 /**
	 * When we start a drag event - create a preview copy of the Tile for re-positioning
	 * @param {PIXI.interaction.InteractionEvent} event   The mousedown event
	 * @private
	 */
	_onHandleMouseDown(event) {
		if ( !this.data.locked ) {
			this._dragHandle = true;
			this._original = duplicate(this.data);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the beginning of a drag event on a resize handle
	 * @param event
	 * @private
	 */
	_onHandleDragStart(event) {
		const handle = event.data.handle;
		const aw = Math.abs(this.data.width);
		const ah = Math.abs(this.data.height);
		const x0 = this.data.x + (handle.offset[0] * aw);
		const y0 = this.data.y + (handle.offset[1] * ah);
		event.data.origin = {x: x0, y: y0, width: aw, height: ah};
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mousemove while dragging a tile scale handler
	 * @param {PIXI.interaction.InteractionEvent} event   The mousemove event
	 * @private
	 */
	_onHandleDragMove(event) {
		const {destination, origin, originalEvent} = event.data;
		 // Pan the canvas if the drag event approaches the edge
		canvas._onDragCanvasPan(originalEvent);
		 // Update Drawing dimensions
		const dx = destination.x - origin.x;
		const dy = destination.y - origin.y;
		const update = this._rescaleDimensions(this._original, dx, dy);
		mergeObject(this.data, update);
		this.refresh();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mouseup after dragging a tile scale handler
	 * @param {PIXI.interaction.InteractionEvent} event   The mouseup event
	 * @private
	 */
	_onHandleDragDrop(event) {
		let {destination, handle, origin, originalEvent} = event.data;
		if ( !originalEvent.shiftKey ) {
			destination = canvas.grid.getSnappedPosition(destination.x, destination.y, this.layer.gridPrecision);
		}
		 // Update dimensions
		const dx = destination.x - origin.x;
		const dy = destination.y - origin.y;
		const update = this._rescaleDimensions(this._original, dx, dy);
		 // Commit the update
		this.data = this._original;
		return this.update(update, {diff: false});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle cancellation of a drag event for one of the resizing handles
	 * @private
	 */
	_onHandleDragCancel(event) {
		this.data = this._original;
		this._dragHandle = false;
		delete this._original;
		this.refresh();
	}
	 /* -------------------------------------------- */
	 /**
	 * Apply a vectorized rescaling transformation for the drawing data
	 * @param {Object} original     The original drawing data
	 * @param {number} dx           The pixel distance dragged in the horizontal direction
	 * @param {number} dy           The pixel distance dragged in the vertical direction
	 * @private
	 */
	_rescaleDimensions(original, dx, dy) {
		let {points, width, height} = original;
		width += dx;
		height += dy;
		 // Rescale polygon points
		if ( this.isPolygon ) {
			const scaleX = 1 + (dx / original.width);
			const scaleY = 1 + (dy / original.height);
			points = points.map(p => [p[0]*scaleX, p[1]*scaleY]);
		}
		 // Constrain drawing bounds by the contained text size
		if ( this.data.text ) {
			const textBounds = this.text.getLocalBounds();
			width = Math.max(textBounds.width + 16, width);
			height = Math.max(textBounds.height + 8, height);
		}
		 // Normalize the shape
		const update = this.constructor.normalizeShape({
			x: original.x,
			y: original.y,
			width: width,
			height: height,
			points: points
		});
		return update;
	}
	 /* -------------------------------------------- */
	 /**
	 * Adjust the location, dimensions, and points of the Drawing before committing the change
	 * @param {Object} data   The Drawing data pending update
	 * @return {Object}       The adjusted data
	 * @private
	 */
	static normalizeShape(data) {
		 // Adjust shapes with an explicit points array
		let points = data.points;
		if ( points && points.length ) {
			 // De-dupe any points which were repeated in sequence
			points = points.reduce((arr, p1) => {
				let p0 = arr.length ? arr[arr.length - 1] : null;
				if ( !p0 || !p1.equals(p0) ) arr.push(p1);
				return arr;
			}, []);
			 // Adjust points for the minimal x and y values
			const [xs, ys] = data.points.reduce((arr, p) => {
				arr[0].push(p[0]);
				arr[1].push(p[1]);
				return arr;
			}, [[], []]);
			 // Determine minimal and maximal points
			let minX = Math.min(...xs);
			let maxX = Math.max(...xs);
			let minY = Math.min(...ys);
			let maxY = Math.max(...ys);
			 // Normalize points
			points = points.map(p => [p[0] - minX, p[1] - minY]);
			 // Update data
			data.x += minX;
			data.y += minY;
			data.width = maxX - minX;
			data.height = maxY - minY;
			data.points = points;
		}
		 // Adjust rectangles
		else {
			const {x, y, width, height} = data;
			const adjusted = new NormalizedRectangle(x, y, width, height);
			data.x = adjusted.x;
			data.y = adjusted.y;
			data.width = adjusted.width;
			data.height = adjusted.height;
		}
		return data;
	}
}

Drawing.FREEHAND_SAMPLE_RATE = 75;
/**
 * An AmbientLight is an implementation of PlaceableObject which represents a dynamic light source within the Scene.
 * @extends {PlaceableObject}
 *
 * @example
 * AmbientLight.create({
 *   t: "l",
 *   x: 1000,
 *   y: 1000,
 *   rotation: 0,
 *   dim: 30,
 *   bright: 15,
 *   angle: 360,
 *   tintColor: "#FF0000",
 *   tintAlpha: 0.05
 * });
 */
class AmbientLight extends PlaceableObject {
	constructor(...args) {
		super(...args);
		 /**
		 * A reference to the PointSource object which defines this light source area of effect
		 * @type {PointSource}
		 */
		this.source = new PointSource();
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get embeddedName() {
		return "AmbientLight";
	}
	 /* -------------------------------------------- */
	 /** @override */
	get bounds() {
		const r = Math.max(this.dimRadius, this.brightRadius);
		return new NormalizedRectangle(this.data.x - r, this.data.y - r, this.data.x + (2*r), this.data.y + (2*r));
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether a specific AmbientLight source provides global illumination
	 * @type {boolean}
	 */
	get global() {
		return this.data.t === "g";
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the pixel radius of dim light emitted by this light source
	 * @return {number}
	 */
	get dimRadius() {
		let d = canvas.dimensions;
		return ((this.data.dim / d.distance) * d.size);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the pixel radius of bright light emitted by this light source
	 * @return {number}
	 */
	get brightRadius() {
		let d = canvas.dimensions;
		return ((this.data.bright / d.distance) * d.size);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return whether the light source is currently visible in the scene
	 * @return {boolean}
	 */
	get isVisible() {
		if ( this.data.hidden ) return false;
		const dt = this.data.darknessThreshold ?? 0;
		return this.layer.darknessLevel >= dt;
	}
	 /* -------------------------------------------- */
	/* Rendering
	/* -------------------------------------------- */
	 /** @override */
	async draw() {
		 // Draw containers
		this.clear();
		this.field = this.addChild(new PIXI.Graphics());
		this.controlIcon = this.addChild(this._drawControlIcon());
		 // Initial rendering
		this.updateSource({defer: true});
		this.refresh();
		if ( this.id ) this.activateListeners();
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the ControlIcon for the AmbientLight
	 * @return {ControlIcon}
	 * @private
	 */
	_drawControlIcon() {
		const size = Math.max(Math.round((canvas.dimensions.size * 0.5) / 20) * 20, 40);
		let icon = new ControlIcon({texture: CONFIG.controlIcons.light, size: size });
		icon.x -= (size * 0.5);
		icon.y -= (size * 0.5);
		return icon;
	}
	 /* -------------------------------------------- */
	 /** @override */
	refresh() {
		const active = this.layer._active;
		 // Update position and FOV
		this.position.set(this.data.x, this.data.y);
		this.field.position.set(-this.data.x, -this.data.y);
		 // Draw the light preview field
		const l = this.field.clear();
		if ( active ) l.lineStyle(2, 0xEEEEEE, 0.4).drawShape(this.source.fov);
		 // Update control icon style
		this.controlIcon.tintColor = this.data.hidden ? 0xFF3300 : 0xFFFFFF;
		this.controlIcon.borderColor = this.data.hidden ? 0xFF3300 : 0xFF5500;
		this.controlIcon.draw();
		 // Update visibility
		this.controlIcon.visible = active;
		this.controlIcon.border.visible = this._hover;
		return this;
	}
	 /* -------------------------------------------- */
	/*  Light Source Management                     */
	/* -------------------------------------------- */
	 /**
	 * The named identified for the source object associated with this light
	 * @return {string}
	 */
	get sourceId() {
		return "Light." + (this._original?.id ?? this.id ?? "preview");
	}
	 /* -------------------------------------------- */
	 /**
	 * Update the source object associated with this light
	 * @param {boolean} defer     Defer refreshing the LightingLayer to manually call that refresh later.
	 * @param {boolean} deleted   Indicate that this light source has been deleted.
	 */
	updateSource({defer=false, deleted=false}={}) {
		if ( deleted ) {
			this.layer.sources.delete(this.sourceId);
			return defer ? null : this.layer.refresh();
		}
		const dt = this.data.darknessThreshold;
		 // Update source data
		this.source.initialize({
			x: this.data.x,
			y: this.data.y,
			z: this.getFlag("core", "priority") || null,
			dim: this.dimRadius,
			bright: this.brightRadius,
			angle: this.data.angle,
			rotation: this.data.rotation,
			color: this.data.tintColor,
			alpha: this.data.tintAlpha,
			animation: this.data.lightAnimation,
			seed: this.getFlag("core", "animationSeed"),
			darknessThreshold: dt,
			type: this.data.t
		});
		 // Update the lighting layer sources
		const isActive = (this.source.radius > 0) && !this.data.hidden;
		if ( isActive ) this.layer.sources.set(this.sourceId, this.source);
		else this.layer.sources.delete(this.sourceId);
		 // Refresh the layer, unless we are deferring that update
		if ( !defer ) {
			this.layer.refresh();
			canvas.sight.refresh();
		}
	}
	 /* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */
	 /** @override */
	_onCreate(...args) {
		super._onCreate(...args);
		this.updateSource();
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onUpdate(...args) {
		this.updateSource();
		super._onUpdate(...args);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDelete(...args) {
		super._onDelete(...args);
		this.updateSource({deleted: true});
	}
		/* -------------------------------------------- */
	/*  Mouse Interaction Handlers                  */
	/* -------------------------------------------- */
	 /** @override */
	_canHUD(user, event) {
		return user.isGM;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_canConfigure(user, event) {
		return user.isGM;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onClickRight(event) {
		this.update({hidden: !this.data.hidden});
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftStart(event) {
		super._onDragLeftStart(event);
		this.layer.deactivateAnimation();
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftMove(event) {
		super._onDragLeftMove(event);
		for ( let c of event.data.clones ) {
			c.updateSource({defer: true});
		}
		this.layer.refresh();
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftCancel(event) {
		super._onDragLeftCancel(event);
		this.updateSource();
		this.layer.activateAnimation();
	}
}

/**
 * A Note is an implementation of PlaceableObject which represents an annotated location within the Scene.
 * Each Note links to a JournalEntry entity and represents it's location on the map.
 * @extends {PlaceableObject}
 *
 * @example
 * Note.create({
 *   entryId: journalEntry.id,
 *   x: 1000,
 *   y: 1000,
 *   icon: "icons/my-journal-icon.svg",
 *   iconSize: 40,
 *   iconTint: "#00FF000",
 *   text: "A custom label",
 *   fontSize: 48,
 *   textAnchor: CONST.TEXT_ANCHOR_POINTS.CENTER,
 *   textColor: "#00FFFF"
 * });
 */
class Note extends PlaceableObject {
	constructor(...args) {
		super(...args);
		 /**
		 * The associated JournalEntry which is described by this note
		 * @type {JournalEntry}
		 */
		this.entry = game.journal.get(this.data.entryId);
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get embeddedName() {
		return "Note";
	}
	 /* -------------------------------------------- */
	/* Attributes
	/* -------------------------------------------- */
	 /**
	 * Return the text label which describes the Note
	 * Use a manually specified label with a fallback to the JournalEntry name
	 * @type {string}
	 */
	get text() {
		return this.data.text || (this.entry ? this.entry.name : "Unknown");
	}
	 /* -------------------------------------------- */
	 /**
	 * The Map Note icon size
	 * @type {number}
	 */
	get size() {
		return this.data.iconSize || 40;
	}
	 /* -------------------------------------------- */
	/* Rendering
	/* -------------------------------------------- */
	 /** @override */
	async draw() {
		this.clear();
		 // Draw the control icon
		this.controlIcon = this.addChild(this._drawControlIcon());
		 // Draw the note tooltip
		this.tooltip = this.addChild(this._drawTooltip());
		 // Refresh the current display
		this.refresh();
		 // Add control interactivity if the placeable has an ID
		if ( this.id ) this.activateListeners();
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the ControlIcon for the Map Note
	 * @return {ControlIcon}
	 * @private
	 */
	_drawControlIcon() {
		let tint = this.data.iconTint ? colorStringToHex(this.data.iconTint) : null;
		let icon = new ControlIcon({texture: this.data.icon, size: this.size, tint: tint});
		icon.x -= (this.size / 2);
		icon.y -= (this.size / 2);
		return icon;
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the map note Tooltip as a Text object
	 * @return {PIXI.Text}
	 */
	_drawTooltip() {
		 // Create the Text object
		const textStyle = this._getTextStyle();
		const text = new PreciseText(this.text, textStyle);
		text.visible = false;
		const halfPad = (0.5 * this.size) + 12;
		 // Configure Text position
		switch ( this.data.textAnchor ) {
			case CONST.TEXT_ANCHOR_POINTS.CENTER:
				text.anchor.set(0.5, 0.5);
				text.position.set(0, 0);
				break;
			case CONST.TEXT_ANCHOR_POINTS.BOTTOM:
				text.anchor.set(0.5, 0);
				text.position.set(0, halfPad);
				break;
			case CONST.TEXT_ANCHOR_POINTS.TOP:
				text.anchor.set(0.5, 1);
				text.position.set(0, -halfPad);
				break;
			case CONST.TEXT_ANCHOR_POINTS.LEFT:
				text.anchor.set(1, 0.5);
				text.position.set(-halfPad, 0);
				break;
			case CONST.TEXT_ANCHOR_POINTS.RIGHT:
				text.anchor.set(0, 0.5);
				text.position.set(halfPad, 0);
				break;
		}
		return text;
	}
	 /* -------------------------------------------- */
	 /**
	 * Define a PIXI TextStyle object which is used for the tooltip displayed for this Note
	 * @returns {PIXI.TextStyle}
	 */
	_getTextStyle() {
		const style = CONFIG.canvasTextStyle.clone();
		 // Positioning
		if ( this.data.textAnchor === CONST.TEXT_ANCHOR_POINTS.LEFT ) style.align = "right";
		else if ( this.data.textAnchor === CONST.TEXT_ANCHOR_POINTS.RIGHT ) style.align = "left";
		 // Font preferences
		style.fontFamily = this.data.fontFamily || CONFIG.defaultFontFamily;
		style.fontSize = this.data.fontSize;
		 // Toggle stroke style depending on whether the text color is dark or light
		const color = this.data.textColor ? colorStringToHex(this.data.textColor) : 0xFFFFFF;
		const hsv = rgbToHsv(...hexToRGB(color));
		style.fill = color;
		style.strokeThickness = 4;
		style.stroke = hsv[2] > 0.6 ? 0x000000 : 0xFFFFFF;
		return style;
	}
	 /* -------------------------------------------- */
	 /** @override */
	refresh() {
		this.position.set(this.data.x, this.data.y);
		this.controlIcon.border.visible = this._hover;
		this.tooltip.visible = this._hover;
		this.visible = this.entry ? this.entry.hasPerm(game.user, "LIMITED") : true;
		return this;
	}
	 /* -------------------------------------------- */
	/*  Socket Listeners and Handlers
	/* -------------------------------------------- */
	 /** @override */
	_onUpdate(data) {
		const changed = new Set(Object.keys(data));
		if ( changed.has("entryId") ) this.entry = game.journal.get(data.entryId);
		return this.draw();
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	_canHover(user) {
		return true;
	}
	 /** @override */
	_canView(user) {
		return this.entry ? this.entry.hasPerm(game.user, "LIMITED") : false;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onHoverIn(event, options) {
		this.zIndex = Math.max(...this.layer.placeables.map(n => n.data.z || 0)) + 1;
		return super._onHoverIn(event, options);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onHoverOut(event) {
		this.zIndex = parseInt(this.data.z || 0);
		return super._onHoverOut(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onClickLeft2(event) {
		if ( this.entry ) this.entry.sheet.render(true);
	}
}

/**
 * An AmbientSound is an implementation of PlaceableObject which represents a dynamic audio source within the Scene.
 * @extends {PlaceableObject}
 *
 * @example
 * AmbientSound.create({
 *   t: "l",
 *   x: 1000,
 *   y: 1000,
 *   radius: 60,
 *   easing: true,
 *   path: "sounds/audio-file.mp3",
 *   repeat: true,
 *   volume: 0.4
 * });
 */
class AmbientSound extends PlaceableObject {
	constructor(...args) {
		super(...args);
		 /**
		 * The Howl instance used to play this AmbientSound effect
		 * @type {Howl}
		 */
		this.howl = this._createHowl();
		 /**
		 * The Howl sound ID of the playing instance of this sound
		 * @type {number}
		 */
		this.howlId = undefined;
	}
	 /* -------------------------------------------- */
	 /**
	 * Create an audio helper instance to use for the Ambient Sound
	 * @return {Object|null}
	 * @private
	 */
	_createHowl() {
		if ( !this.data.path ) return null;
		return game.audio.create({
			src: this.data.path,
			preload: true,
			loop: true,
			volume: 0
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get embeddedName() {
		return "AmbientSound";
	}
	 /* -------------------------------------------- */
	/* Properties
	/* -------------------------------------------- */
	 /**
	 * A convenience accessor for the sound type
	 * @return {string}
	 */
	get type() {
		return this.data.type;
	}
	 /* -------------------------------------------- */
	 /**
	 * A convenience accessor for the sound radius in pixels
	 * @return {number}
	 */
	get radius() {
		let d = canvas.dimensions;
		return ((this.data.radius / d.distance) * d.size);
	}
	 /* -------------------------------------------- */
	/* Methods
	/* -------------------------------------------- */
	 /**
	 * Toggle playback of the sound depending on whether or not it is audible
	 * @param {boolean} isAudible   Is the sound audible?
	 * @param {number} volume       The target playback volume
	 * @param {boolean} fade        Whether to fade the volume from its previous level
	 */
	play(isAudible, volume, {fade=true}={}) {
		let howl = this.howl;
		let cv = howl.volume(null, this.howlId);
		volume = (volume || this.data.volume) * game.settings.get("core", "globalAmbientVolume");
		 // Fade the sound out if not currently audible
		if ( !isAudible ) {
			if ( this.howlId ) {
				howl.fade(cv, 0, 500);
				howl.once('fade', () => howl.pause(this.howlId));
			}
			return;
		}
		 // Trigger loading
		if ( howl.state() !== "loaded" ) howl.load();
		 // Begin playback and set volume
		howl.off('fade');
		this.howlId = this.howlId ? howl.play(this.howlId) : howl.play();
		if ( fade ) howl.fade(cv, volume, 500, this.howlId);
		else howl.volume(volume, this.howlId);
		return this.howlId;
	}
	 /* -------------------------------------------- */
	/* Rendering
	/* -------------------------------------------- */
	 /** @override */
	clear() {
		if ( this.controlIcon ) {
			this.controlIcon.parent.removeChild(this.controlIcon).destroy();
			this.controlIcon = null;
		}
		super.clear();
	}
	 /* -------------------------------------------- */
	 /** @override */
	async draw() {
		 // Draw containers
		this.clear();
		this.field = this.drawField();
		this.controlIcon = this.addChild(this._drawControlIcon());
		 // Initial rendering
		// this.updateSource({defer: true});
		this.refresh();
		if ( this.id ) this.activateListeners();
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the graphical preview of the audio source area of effect
	 * @return {PIXI.Container}
	 * @private
	 */
	drawField() {
		let field = new PIXI.Container();
		field.light = field.addChild(new PIXI.Graphics());
		field.msk = field.addChild(new PIXI.Graphics());
		field.mask = field.msk;
		return this.addChild(field);
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the ControlIcon for the AmbientLight
	 * @return {ControlIcon}
	 * @private
	 */
	_drawControlIcon() {
		const size = Math.max(Math.round((canvas.dimensions.size * 0.5) / 20) * 20, 40);
		let icon = new ControlIcon({texture: CONFIG.controlIcons.sound, size: size});
		icon.x -= (size * 0.5);
		icon.y -= (size * 0.5);
		return icon;
	}
	 /* -------------------------------------------- */
	 /** @override */
	refresh() {
		 // Update position and FOV
		this.position.set(this.data.x, this.data.y);
		this.computeFOV();
		 // Draw the light field
		this.field.light.clear()
			.beginFill(0xAADDFF, 0.15)
			.lineStyle(1, 0xFFFFFF, 0.5)
			.drawCircle(0, 0, this.radius)
			.endFill();
		 // Global light is not masked
		if ( this.type === "g" ) {
			this.field.msk.clear();
			this.field.mask = null;
		}
		 // Local light is masked by the FOV polygon
		else {
			this.field.msk.clear()
				.beginFill(0xFFFFFF)
				.drawPolygon(this.fov)
				.endFill();
			this.field.msk.position.set(-this.data.x, -this.data.y);
			this.field.mask = this.field.msk;
		}
		 // Update visibility
		this.controlIcon.visible = this.layer._active;
		this.controlIcon.border.visible = this._hover;
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Compute the field-of-vision for an object, determining its effective line-of-sight and field-of-vision polygons
	 * @returns {Object}      An object containing the rays, LOS polygon, and FOV polygon for the light
	 */
	computeFOV() {
		const center = this.center;
		const radius = this.radius + (canvas.dimensions.size * 0.1);
		 // Global audio
		if ( this.type === "g" ) {
			this.vision.los = null;
			this.vision.fov = new PIXI.Circle(center.x, center.y, this.radius);
			return {rays: null, los: null, fov: this.vision.fov};
		}
		 // Compute the polygon
		const {los, fov, rays} = SightLayer.computeSight(center, radius);
		 // Store and return
		this.vision = { los, fov };
		return {rays, los, fov};
	}
	 /* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */
	 /** @override */
	_onCreate(...args) {
		super._onCreate(...args);
		canvas.addPendingOperation(`SoundsLayer.initialize`, canvas.sounds.initialize, canvas.sounds);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onUpdate(data, ...args) {
		super._onUpdate(data, ...args);
		const changed = new Set(Object.keys(data));
		if ( changed.has("path") ) this.howl = this._createHowl();
		canvas.addPendingOperation(`SoundsLayer.initialize`, canvas.sounds.initialize, canvas.sounds);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDelete(...args) {
		super._onDelete(...args);
		if ( this.howl ) this.howl.stop(this.howlId);
		canvas.addPendingOperation(`SoundsLayer.initialize`, canvas.sounds.initialize, canvas.sounds);
	}
}

/**
 * A MeasuredTemplate is an implementation of PlaceableObject which represents an area of the canvas grid which is
 * covered by some effect.
 * @extends {PlaceableObject}
 *
 * @example
 * MeasuredTemplate.create({
 *   t: "cone",
 *   user: game.user._id,
 *   x: 1000,
 *   y: 1000,
 *   direction: 0.45,
 *   angle: 63.13,
 *   distance: 30,
 *   borderColor: "#FF0000",
 *   fillColor: "#FF3366",
 *   texture: "tiles/fire.jpg"
 * });
 */
class MeasuredTemplate extends PlaceableObject {
	constructor(...args) {
		super(...args);
		 // Draw portions of the content
		this.controlIcon = null;
		this.template = null;
		this.ruler = null;
		 /**
		 * The tiling texture used for this template, if any
		 * @type {PIXI.Texture}
		 */
		this.texture = null;
		 /**
		 * The template shape used for testing point intersection
		 * @type {PIXI.Circle | PIXI.Ellipse | PIXI.Polygon | PIXI.Rectangle | PIXI.RoundedRectangle}
		 */
		this.shape = null;
		 /**
		 * Create a highlighting layer to use for this Template
		 */
		canvas.grid.addHighlightLayer(`Template.${this.id}`);
		 /**
		 * Internal property used to configure the control border thickness
		 * @type {number}
		 * @private
		 */
		this._borderThickness = 3;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get embeddedName() {
		return "MeasuredTemplate";
	}
	 /* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /**
	 * A convenience accessor for the border color as a numeric hex code
	 * @return {number}
	 */
	get borderColor() {
		return this.data.borderColor ? this.data.borderColor.replace("#", "0x") : 0x000000;
	}
	 /* -------------------------------------------- */
	 /**
	 * A convenience accessor for the fill color as a numeric hex code
	 * @return {number}
	 */
	get fillColor() {
		return this.data.fillColor ? this.data.fillColor.replace("#", "0x") : 0x000000;
	}
	 /* -------------------------------------------- */
	 /** @override */
	get owner() {
		return game.user.isGM || (game.user._id === this.data.user);
	}
	 /* -------------------------------------------- */
	/*  Rendering
	/* -------------------------------------------- */
	 /** @override */
	async draw() {
		this.clear();
		 // Load the texture
		if ( this.data.texture ) {
			this.texture = await loadTexture(this.data.texture, {fallback: 'icons/svg/hazard.svg'});
		} else {
			this.texture = null;
		}
		 // Template shape
		this.template = this.addChild(new PIXI.Graphics());
		 // Rotation handle
		this.handle = this.addChild(new PIXI.Graphics());
		 // Draw the control icon
		this.controlIcon = this.addChild(this._drawControlIcon());
		 // Draw the ruler measurement
		this.ruler = this.addChild(this._drawRulerText());
		 // Update the shape and highlight grid squares
		this.refresh();
		this.highlightGrid();
		 // Enable interactivity, only if the Tile has a true ID
		if ( this.id ) this.activateListeners();
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the ControlIcon for the MeasuredTemplate
	 * @return {ControlIcon}
	 * @private
	 */
	_drawControlIcon() {
		const size = Math.max(Math.round((canvas.dimensions.size * 0.5) / 20) * 20, 40);
		let icon = new ControlIcon({texture: CONFIG.controlIcons.template, size: size});
		icon.x -= (size * 0.5);
		icon.y -= (size * 0.5);
		return icon;
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the Text label used for the MeasuredTemplate
	 * @return {PreciseText}
	 * @private
	 */
	_drawRulerText() {
		const style = CONFIG.canvasTextStyle.clone();
		style.fontSize = Math.max(Math.round(canvas.dimensions.size * 0.36 * 12) / 12, 36);
		const text = new PreciseText(null, style);
		text.anchor.set(0, 1);
		return text;
	}
	 /* -------------------------------------------- */
	 /** @override */
	refresh() {
		let d = canvas.dimensions;
		this.position.set(this.data.x, this.data.y);
		 // Extract and prepare data
		let {direction, distance, angle, width} = this.data;
		distance *= (d.size / d.distance);
		width *= (d.size / d.distance);
		direction = toRadians(direction);
		 // Create ray and bounding rectangle
		this.ray = Ray.fromAngle(this.data.x, this.data.y, direction, distance);
		 // Get the Template shape
		switch ( this.data.t ) {
			case "circle":
				this.shape = this._getCircleShape(distance);
				break;
			case "cone":
				this.shape = this._getConeShape(direction, angle, distance);
				break;
			case "rect":
				this.shape = this._getRectShape(direction, distance);
				break;
			case "ray":
				this.shape = this._getRayShape(direction, distance, width);
		}
		 // Draw the Template outline
		this.template.clear()
			.lineStyle(this._borderThickness, this.borderColor, 0.75)
			.beginFill(0x000000, 0.0);
		 // Fill Color or Texture
		if ( this.texture ) this.template.beginTextureFill({
			texture: this.texture
		});
		else this.template.beginFill(0x000000, 0.0);
		 // Draw the shape
		this.template.drawShape(this.shape);
		 // Draw origin and destination points
		this.template.lineStyle(this._borderThickness, 0x000000)
			.beginFill(0x000000, 0.5)
			.drawCircle(0, 0, 6)
			.drawCircle(this.ray.dx, this.ray.dy, 6);
		 // Update visibility
		this.controlIcon.visible = this.layer._active;
		this.controlIcon.border.visible = this._hover;
		 // Draw ruler text
		this._refreshRulerText();
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get a Circular area of effect given a radius of effect
	 * @private
	 */
	_getCircleShape(distance) {
		return new PIXI.Circle(0, 0, distance);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get a Conical area of effect given a direction, angle, and distance
	 * @private
	 */
	_getConeShape(direction, angle, distance) {
		angle = angle || 90;
		const coneType = game.settings.get("core", "coneTemplateType");
		 // For round cones - approximate the shape with a ray every 3 degrees
		let angles;
		if ( coneType === "round" ) {
			const da = Math.min(angle, 3);
			angles = Array.fromRange(angle/da).map(a => (angle/-2) + (a*da)).concat([angle/2]);
		}
		 // For flat cones, direct point-to-point
		else {
			angles = [(angle/-2), (angle/2)];
			distance /= Math.cos(toRadians(angle/2));
		}
		 // Get the cone shape as a polygon
		const rays = angles.map(a => Ray.fromAngle(0, 0, direction + toRadians(a), distance+1));
		const points = rays.reduce((arr, r) => {
			return arr.concat([r.B.x, r.B.y]);
		}, [0, 0]).concat([0, 0]);
		return new PIXI.Polygon(points);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get a Rectangular area of effect given a width and height
	 * @private
	 */
	_getRectShape(direction, distance) {
		let d = canvas.dimensions,
				r = Ray.fromAngle(0, 0, direction, distance),
				dx = Math.round(r.dx / (d.size / 2)) * (d.size / 2),
				dy = Math.round(r.dy / (d.size / 2)) * (d.size / 2);
		 // Create rectangle shape and draw
		return new NormalizedRectangle(0, 0, dx + Math.sign(dx), dy + Math.sign(dy));
	}
	 /* -------------------------------------------- */
	 /**
	 * Get a rotated Rectangular area of effect given a width, height, and direction
	 * @private
	 */
	_getRayShape(direction, distance, width) {
		let up = Ray.fromAngle(0, 0, direction - toRadians(90), (width / 2)+1),
				down = Ray.fromAngle(0, 0, direction + toRadians(90), (width / 2)+1),
				l1 = Ray.fromAngle(up.B.x, up.B.y, direction, distance+1),
				l2 = Ray.fromAngle(down.B.x, down.B.y, direction, distance+1);
		 // Create Polygon shape and draw
		const points = [down.B.x, down.B.y, up.B.x, up.B.y, l1.B.x, l1.B.y, l2.B.x, l2.B.y, down.B.x, down.B.y];
		return new PIXI.Polygon(points);
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the rotation control handle and assign event listeners
	 * @private
	 */
	_drawRotationHandle(radius) {
		this.handle.clear()
			.lineStyle(this._borderThickness, 0x000000)
			.beginFill(this.borderColor, 1.0)
			.drawCircle(0, 0, radius);
	}
	 /* -------------------------------------------- */
	 /**
	 * Update the displayed ruler tooltip text
	 * @private
	 */
	_refreshRulerText() {
		let text;
		let u = canvas.scene.data.gridUnits;
		if ( this.data.t === "rect" ) {
			let d = canvas.dimensions;
			let dx = Math.round(this.ray.dx) * (d.distance / d.size);
			let dy = Math.round(this.ray.dy) * (d.distance / d.size);
			let w = Math.round(dx * 10) / 10;
			let h = Math.round(dy * 10) / 10;
			text = `${w}${u} x ${h}${u}`;
		} else {
			let d = Math.round(this.data.distance * 10) / 10;
			text = `${d}${u}`;
		}
		this.ruler.text = text;
		this.ruler.position.set(this.ray.dx + 10, this.ray.dy + 5);
	}
	 /* -------------------------------------------- */
	 /**
	 * Highlight the grid squares which should be shown under the area of effect
	 */
	highlightGrid() {
		const grid = canvas.grid;
		const d = canvas.dimensions;
		const border = this.borderColor;
		const color = this.fillColor;
		 // Only highlight for objects which have a defined shape
		if ( !this.id || !this.shape ) return;
		 // Clear existing highlight
		const hl = grid.getHighlightLayer(`Template.${this.id}`);
		hl.clear();
		 // If we are in gridless mode, highlight the shape directly
		if ( grid.type === GRID_TYPES.GRIDLESS ) {
			const shape = this.shape.clone();
			if ( "points" in shape ) {
				shape.points = shape.points.map((p, i) => {
					if ( i % 2 ) return this.y + p;
					else return this.x + p;
				});
			} else {
				shape.x += this.x;
				shape.y += this.y;
			}
			return grid.grid.highlightGridPosition(hl, {border, color, shape});
		}
		 // Get number of rows and columns
		const nr = Math.ceil(((this.data.distance * 1.5) / d.distance) / (d.size / grid.h));
		const nc = Math.ceil(((this.data.distance * 1.5) / d.distance) / (d.size / grid.w));
		 // Get the offset of the template origin relative to the top-left grid space
		const [tx, ty] = canvas.grid.getTopLeft(this.data.x, this.data.y);
		const [row0, col0] = grid.grid.getGridPositionFromPixels(tx, ty);
		const hx = canvas.grid.w / 2;
		const hy = canvas.grid.h / 2;
		const isCenter = (this.data.x - tx === hx) && (this.data.y - ty === hy);
		 // Identify grid coordinates covered by the template Graphics
		for (let r = -nr; r < nr; r++) {
			for (let c = -nc; c < nc; c++) {
				let [gx, gy] = canvas.grid.grid.getPixelsFromGridPosition(row0 + r, col0 + c);
				const testX = (gx+hx) - this.data.x;
				const testY = (gy+hy) - this.data.y;
				let contains = ((r === 0) && (c === 0) && isCenter ) || this.shape.contains(testX, testY);
				if ( !contains ) continue;
				grid.grid.highlightGridPosition(hl, {x: gx, y: gy, border, color});
			}
		}
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /** @override */
	async rotate(angle, snap) {
		const direction = this._updateRotation({angle, snap});
		return this.update({direction});
	}
	 /* -------------------------------------------- */
	/*  Interactivity                               */
	/* -------------------------------------------- */
	 /** @override */
	_canControl(user, event) {
		return user.isGM || (user.id === this.data.user);
	}
	 /** @override */
	_canConfigure(user, event) {
		return this._canControl(user, event);
	}
	 /** @override */
	_canView(user, event) {
		return this._canControl(user, event);
	}
	 /* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */
	 /** @override */
	_onUpdate(data) {
		const changed = new Set(Object.keys(data));
		 // If the texture or type was changed, we need to re-draw the whole thing
		const redraw = ["texture", "type"];
		if ( redraw.some(k => changed.has(k)) ) return this.draw();
		 // Otherwise refresh the display and highlighting
		this.refresh();
		this.highlightGrid();
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDelete() {
		canvas.grid.destroyHighlightLayer(`Template.${this.id}`);
	}
}
	/**
 * A Tile is an implementation of PlaceableObject which represents a static piece of artwork or prop within the Scene.
 * Tiles are drawn above the {@link BackroundLayer} but below the {@link TokenLayer}.
 * @extends {PlaceableObject}
 *
 * @example
 * Tile.create({
 *   img: "path/to/tile-artwork.png",
 *   width: 300,
 *   height: 300,
 *   scale: 1,
 *   x: 1000,
 *   y: 1000,
 *   z: 370,
 *   rotation: 45,
 *   hidden: false,
 *   locked: true
 * });
 *
 * @see {@link TilesLayer}
 * @see {@link TileSheet}
 * @see {@link TileHUD}
 */
class Tile extends PlaceableObject {
	constructor(...args) {
		super(...args);
		 // Clean initial data
		this._cleanData();
		 /**
		 * The Tile border frame
		 * @type {PIXI.Container|null}
		 */
		this.frame = null;
		 /**
		 * The Tile image container
		 * @type {PIXI.Container|null}
		 */
		this.tile = null;
		 /**
		 * The primary tile image texture
		 * @type {PIXI.Texture|null}
		 */
		this.texture = null;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get embeddedName() {
		return "Tile";
	}
	 /* -------------------------------------------- */
	 /**
	 * Apply initial sanitizations to the provided input data to ensure that a Tile has valid required attributes.
	 * @private
	 */
	_cleanData() {
		 // Constrain dimensions
		this.data.width = this.data.width.toNearest(0.1);
		this.data.height = this.data.height.toNearest(0.1);
		 // Constrain canvas coordinates
		if ( !canvas || !this.scene?.active ) return;
		const d = canvas.dimensions;
		const minX = 0 - (this.data.width - d.size);
		const minY = 0 - (this.data.height - d.size);
		const maxX = d.width - d.size;
		const maxY = d.height - d.size;
		this.data.x = Math.clamped(this.data.x.toNearest(0.1), minX, maxX);
		this.data.y = Math.clamped(this.data.y.toNearest(0.1), minY, maxY);
	}
	 /* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /**
	 * Get the native aspect ratio of the base texture for the Tile sprite
	 * @type {number}
	 */
	get aspectRatio() {
		if (!this.texture) return null;
		let tex = this.texture.baseTexture;
		return (tex.width / tex.height);
	}
	 /* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */
	 /** @override */
	async draw() {
		this.clear();
		 // Create the outer frame for the border and interaction handles
		this.frame = this.addChild(new PIXI.Container());
		this.frame.border = this.frame.addChild(new PIXI.Graphics());
		this.frame.handle = this.frame.addChild(new ResizeHandle([1, 1]));
		 // Create the tile container and it's child elements
		this.tile = this.addChild(new PIXI.Container());
		if ( this.data.img ) {
			this.texture = await loadTexture(this.data.img, {fallback: 'icons/svg/hazard.svg'});
			this.tile.img = this.tile.addChild(this._drawPrimarySprite(this.texture));
			this.tile.bg = null;
		} else {
			this.texture = null;
			this.tile.img = null;
			this.tile.bg = this.addChild(new PIXI.Graphics());
		}
		 // Refresh the current display
		this.refresh();
		 // Enable interactivity, only if the Tile has a true ID
		if ( this.id ) this.activateListeners();
		return this;
	}
	 /* -------------------------------------------- */
	 /** @override */
	refresh() {
		 // Set Tile position
		this.position.set(this.data.x, this.data.y);
		const aw = Math.abs(this.data.width);
		const ah = Math.abs(this.data.height);
		 // Draw the sprite image
		let bounds = null;
		if ( this.data.img ) {
			const img = this.tile.img;
			 // Set the tile dimensions and mirroring
			img.width = aw;
			if ( this.data.width * img.scale.x < 0 ) img.scale.x *= -1;
			img.height = ah;
			if ( this.data.height * img.scale.y < 0 ) img.scale.y *= -1;
			 // Pivot in the center of the container
			img.anchor.set(0.5, 0.5);
			img.position.set(aw/2, ah/2);
			img.rotation = toRadians(this.data.rotation);
			 // Toggle tile visibility
			img.alpha = this.data.hidden ? 0.5 : 1.0;
			bounds = this.tile.getLocalBounds(undefined, true);
		}
		 // Draw a temporary background
		else {
			bounds = new NormalizedRectangle(0, 0, this.data.width, this.data.height);
			this.tile.bg.clear().beginFill(0xFFFFFF, 0.5).drawShape(bounds);
			this.tile.bg.visible = true;
		}
		 // Allow some extra padding to detect handle hover interactions
		this.hitArea = this._controlled ? bounds.clone().pad(20) : bounds;
		 // Update border frame
		this._refreshBorder(bounds);
		this._refreshHandle(bounds);
		 // Set visibility
		this.alpha = 1;
		this.visible = !this.data.hidden || game.user.isGM;
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Refresh the display of the Tile border
	 * @private
	 */
	_refreshBorder(b) {
		const border = this.frame.border;
		 // Determine border color
		const colors = CONFIG.Canvas.dispositionColors;
		let bc = colors.INACTIVE;
		if ( this._controlled ) {
			bc = this.data.locked ? colors.HOSTILE : colors.CONTROLLED;
		}
		 // Draw the tile border
		const t = CONFIG.Canvas.objectBorderThickness;
		const h = Math.round(t/2);
		const o = Math.round(h/2);
		border.clear()
			.lineStyle(t, 0x000000, 1.0).drawRoundedRect(b.x-o, b.y-o, b.width+h, b.height+h, 3)
			.lineStyle(h, bc, 1.0).drawRoundedRect(b.x-o, b.y-o, b.width+h, b.height+h, 3);
		border.visible = this._hover || this._controlled;
	}
	 /* -------------------------------------------- */
	 /**
	 * Refresh the display of the Tile resizing handle
	 * @private
	 */
	_refreshHandle(b) {
		this.frame.handle.refresh(b);
		this.frame.handle.visible = this._controlled && !this.data.locked;
	}
	 /* -------------------------------------------- */
	 /** @override */
	activateListeners() {
		super.activateListeners();
		this.frame.handle.off("mouseover").off("mouseout").off("mousedown")
			.on("mouseover", this._onHandleHoverIn.bind(this))
			.on("mouseout", this._onHandleHoverOut.bind(this))
			.on("mousedown", this._onHandleMouseDown.bind(this));
		this.frame.handle.interactive = true;
	}
	 /* -------------------------------------------- */
	/*  Database Operations                         */
	/* -------------------------------------------- */
	 /** @override */
	_onUpdate(data) {
		const changed = new Set(Object.keys(data));
		if ( changed.has("z") ) {
			this.zIndex = parseInt(data.z) || 0;
		}
		 // Release control if the Tile was locked
		if ( data.locked ) this.release();
		 // Full re-draw or partial refresh
		if ( changed.has("img" ) ) return this.draw();
		this.refresh();
		 // Update the sheet, if it's visible
		if ( this._sheet && this._sheet.rendered ) this.sheet.render();
	}
	 /* -------------------------------------------- */
	/*  Interactivity                               */
	/* -------------------------------------------- */
	 /** @override */
	_canHUD(user, event) {
		return this._controlled;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_canConfigure(user, event) {
		if ( this.data.locked && !this._controlled ) return false;
		return super._canConfigure(user);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftStart(event) {
		if ( this._dragHandle ) return this._onHandleDragStart(event);
		return super._onDragLeftStart(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftMove(event) {
		if ( this._dragHandle ) return this._onHandleDragMove(event);
		return super._onDragLeftMove(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftDrop(event) {
		if ( this._dragHandle ) return this._onHandleDragDrop(event);
		return super._onDragLeftDrop(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftCancel(event) {
		if ( this._dragHandle ) return this._onHandleDragCancel(event);
		return super._onDragLeftCancel(event);
	}
	 /* -------------------------------------------- */
	/*  Resize Handling                             */
	/* -------------------------------------------- */
	 /**
	 * Handle mouse-over event on a control handle
	 * @param {PIXI.interaction.InteractionEvent} event   The mouseover event
	 * @private
	 */
	_onHandleHoverIn(event) {
		const handle = event.target;
		handle.scale.set(1.5, 1.5);
		event.data.handle = event.target;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mouse-out event on a control handle
	 * @param {PIXI.interaction.InteractionEvent} event   The mouseout event
	 * @private
	 */
	_onHandleHoverOut(event) {
		event.data.handle.scale.set(1.0, 1.0);
	}
	 /* -------------------------------------------- */
	 /**
	 * When we start a drag event - create a preview copy of the Tile for re-positioning
	 * @param {PIXI.interaction.InteractionEvent} event   The mousedown event
	 * @private
	 */
	_onHandleMouseDown(event) {
		if ( !this.data.locked ) {
			this._dragHandle = true;
			const {x, y, width, height} = this.data;
			this._original = {x, y, width, height};
			Object.freeze(this._original);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the beginning of a drag event on a resize handle
	 * @param event
	 * @private
	 */
	_onHandleDragStart(event) {
		const handle = event.data.handle;
		const aw = Math.abs(this.data.width);
		const ah = Math.abs(this.data.height);
		const x0 = this.data.x + (handle.offset[0] * aw);
		const y0 = this.data.y + (handle.offset[1] * ah);
		event.data.origin = {x: x0, y: y0, width: aw, height: ah};
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mousemove while dragging a tile scale handler
	 * @param {PIXI.interaction.InteractionEvent} event   The mousemove event
	 * @private
	 */
	_onHandleDragMove(event) {
		const {destination, handle, origin, originalEvent} = event.data;
		 // Pan the canvas if the drag event approaches the edge
		canvas._onDragCanvasPan(originalEvent);
		 // Update Tile dimensions
		console.log(this.mouseInteractionManager.dragTime);
		const update = handle.updateDimensions(this._original, origin, destination, {
			aspectRatio: originalEvent.altKey ? this.aspectRatio : null
		});
		mergeObject(this.data, update);
		this.refresh();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mouseup after dragging a tile scale handler
	 * @param {PIXI.interaction.InteractionEvent} event   The mouseup event
	 * @private
	 */
	_onHandleDragDrop(event) {
		let {destination, handle, origin, originalEvent} = event.data;
		 // Get snapped deltas
		if ( !originalEvent.shiftKey ) {
			destination = canvas.grid.getSnappedPosition(destination.x, destination.y, this.layer.gridPrecision);
		}
		 // Update dimensions
		const update = handle.updateDimensions(this._original, origin, destination, {
			aspectRatio: originalEvent.altKey ? this.aspectRatio : null
		});
		return this.update(update, {diff: false});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle cancellation of a drag event for one of the resizing handles
	 * @private
	 */
	_onHandleDragCancel(event) {
		mergeObject(this.data, this._original);
		delete this._original;
		this._dragHandle = false;
		this.refresh();
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a preview tile with a background texture instead of an image
	 * @return {Tile}
	 */
	static createPreview(data) {
		const tile = new Tile(mergeObject({
			x: 0,
			y: 0,
			rotation: 0,
			z: 0,
			width: 0,
			height: 0
		}, data));
		tile._controlled = true;
		 // Swap the tile and the frame
		tile.draw().then(t => {
			tile.removeChild(tile.frame);
			tile.addChild(tile.frame);
		});
		return tile;
	}
}
/**
 * A Token is an implementation of PlaceableObject which represents an Actor within a viewed Scene on the game canvas.
 * @extends  {PlaceableObject}
 *
 * @example
 * Token.create({
 *   name: "Token Name",
 *   x: 1000,
 *   y: 1000,
 *   displayName: 3,
 *   img: "path/to/token-artwork.png",
 *   width: 2,
 *   height: 2,
 *   scale: 1.2,
 *   elevation: 50,
 *   lockRotation: false,
 *   rotation: 30,
 *   effects: ["icons/stun.png"],
 *   overlayEffect: "icons/dead.png",
 *   vision: true,
 *   dimSight: 60,
 *   brightSight: 0,
 *   dimLight: 40,
 *   brightLight: 20,
 *   sightAngle: 60,
 *   hidden: false,
 *   actorId: "dfgkjt43jkvdfkj34t",
 *   actorLink: true,
 *   actorData: {},
 *   disposition: 1,
 *   displayBars: 3,
 *   bar1: {attribute: "attributes.hp"},
 *   bar2: {attribute: "attributes.sp"}
 * }
 */
class Token extends PlaceableObject {
	constructor(...args) {
		super(...args);
		 // Clean initial data
		this._cleanData();
		 /**
		 * A Ray which represents the Token's current movement path
		 * @type {Ray}
		 * @private
		 */
		this._movement = null;
		 /**
		 * An Object which records the Token's prior velocity dx and dy
		 * This can be used to determine which direction a Token was previously moving
		 * @type {Object}
		 * @private
		 */
		this._velocity = {
			dx: null,
			dy: null,
			sx: null,
			sy: null
		};
		 /**
		 * The Token's most recent valid position
		 * @type {Object}
		 * @private
		 */
		this._validPosition = {x: this.data.x, y: this.data.y};
		 /**
		 * Provide a temporary flag through which th6is Token can be overridden to bypass any movement animation
		 * @type {boolean}
		 */
		this._noAnimate = false;
		 /**
		 * Track the set of User entities which are currently targeting this Token
		 * @type {Set.<User>}
		 */
		this.targeted = new Set([]);
		 /**
		 * An Actor entity constructed using this Token's data
		 * If actorLink is true, then the entity is the true Actor entity
		 * Otherwise, the Actor entity is a synthetic, constructed using the Token actorData
		 * @type {Actor}
		 */
		this.actor = Actor.fromToken(this);
		 /**
		 * A reference to the PointSource object which defines this vision source area of effect
		 * @type {PointSource}
		 */
		this.vision = new PointSource();
		 /**
		 * A reference to the PointSource object which defines this light source area of effect
		 * @type {PointSource}
		 */
		this.light = new PointSource();
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get embeddedName() {
		return "Token";
	}
	 /* -------------------------------------------- */
	 /**
	 * Apply initial sanitizations to the provided input data to ensure that a Token has valid required attributes.
	 * @private
	 */
	_cleanData() {
		 // Constrain dimensions
		this.data.width = Math.max((this.data.width || 1).toNearest(0.5), 0.5);
		this.data.height = Math.max((this.data.height || 1).toNearest(0.5), 0.5);
		 // Constrain canvas coordinates
		if ( !canvas || !this.scene?.active ) return;
		const d = canvas.dimensions;
		this.data.x = Math.clamped(Math.round(this.data.x), 0, d.width - this.w);
		this.data.y = Math.clamped(Math.round(this.data.y), 0, d.height - this.h);
	}
	 /* -------------------------------------------- */
	/*  Permission Attributes
	/* -------------------------------------------- */
	 /**
	 * A Boolean flag for whether the current game User has permission to control this token
	 * @type {boolean}
	 */
	get owner() {
		if ( game.user.isGM ) return true;
		return this.actor ? this.actor.owner : false;
	}
	 /* -------------------------------------------- */
	 /**
	 * A boolean flag for whether the current game User has observer permission for the Token
	 * @type {boolean}
	 */
	get observer() {
		return game.user.isGM || (this.actor && this.actor.hasPerm(game.user, "OBSERVER"));
	}
	 /* -------------------------------------------- */
	 /**
	 * Is the HUD display active for this token?
	 * @return {boolean}
	 */
	get hasActiveHUD() {
		return this.layer.hud.object === this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Convenience access to the token's nameplate string
	 * @type {string}
	 */
	get name() {
		return this.data.name;
	}
	 /* -------------------------------------------- */
	/*  Rendering Attributes
	/* -------------------------------------------- */
	 /**
	 * Translate the token's grid width into a pixel width based on the canvas size
	 * @type {number}
	 */
	get w() {
		return this.data.width * canvas.grid.w;
	}
	 /* -------------------------------------------- */
	 /**
	 * Translate the token's grid height into a pixel height based on the canvas size
	 * @type {number}
	 */
	get h() {
		return this.data.height * canvas.grid.h;
	}
	 /* -------------------------------------------- */
	 /**
	 * The Token's current central position
	 * @property x The central x-coordinate
	 * @property y The central y-coordinate
	 * @type {Object}
	 */
	get center() {
		return this.getCenter(this.data.x, this.data.y);
	}
	 /* -------------------------------------------- */
	/*  State Attributes
	/* -------------------------------------------- */
	 /**
	 * An indicator for whether or not this token is currently involved in the active combat encounter.
	 * @type {boolean}
	 */
	get inCombat() {
		const combat = ui.combat.combat;
		if ( !combat ) return false;
		const combatant = combat.getCombatantByToken(this.id);
		return combatant !== undefined;
	}
	 /* -------------------------------------------- */
	 /**
	 * An indicator for whether the Token is currently targeted by the active game User
	 * @type {boolean}
	 */
	get isTargeted() {
		return this.targeted.has(game.user);
	}
	 /* -------------------------------------------- */
	 /**
	 * Determine whether the Token is visible to the calling user's perspective.
	 * Hidden Tokens are only displayed to GM Users.
	 * Non-hidden Tokens are always visible if Token Vision is not required.
	 * Controlled tokens are always visible.
	 * All Tokens are visible to a GM user if no Token is controlled.
	 *
	 * @see {SightLayer#testVisibility}
	 * @type {boolean}
	 */
	get isVisible() {
		const gm = game.user.isGM;
		if ( this.data.hidden ) return gm;
		if (!canvas.sight.tokenVision) return true;
		if ( this._controlled ) return true;
		const tolerance = Math.min(this.w, this.h) / 4;
		return canvas.sight.testVisibility(this.center, {tolerance, object: this});
	}
	 /* -------------------------------------------- */
	/*  Lighting and Vision Attributes
	/* -------------------------------------------- */
	 /**
	 * Test whether the Token has sight (or blindness) at any radius
	 * @type {boolean}
	 */
	get hasSight() {
		return this.data.vision;
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether the Token emits light (or darkness) at any radius
	 * @type {boolean}
	 */
	get emitsLight() {
		return ["dimLight", "brightLight"].some(a => this.data[a] || false);
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether the Token has a limited angle of vision or light emission which would require sight to update on Token rotation
	 * @type {boolean}
	 */
	get hasLimitedVisionAngle() {
		return (this.hasSight && (this.data.sightAngle !== 360)) || (this.emitsLight && (this.data.lightAngle !== 360));
	}
	 /* -------------------------------------------- */
	 /**
	 * Translate the token's sight distance in units into a radius in pixels.
	 * @return {number}     The sight radius in pixels
	 */
	get dimRadius() {
		let r = Math.abs(this.data.dimLight) > Math.abs(this.data.dimSight) ? this.data.dimLight : this.data.dimSight;
		return this.getLightRadius(r);
	}
	 /* -------------------------------------------- */
	 /**
	 * Translate the token's bright light distance in units into a radius in pixels.
	 * @return {number}       The bright radius in pixels
	 */
	get brightRadius() {
		let r = Math.abs(this.data.brightLight) > Math.abs(this.data.brightSight) ? this.data.brightLight :
			this.data.brightSight;
		return this.getLightRadius(r);
	}
	 /* -------------------------------------------- */
	 /**
	 * The named identified for the source object associated with this Token
	 * @return {string}
	 */
	get sourceId() {
		return "Token." + (this._original?.id ?? this.id);
	}
	 /* -------------------------------------------- */
	 /**
	 * Update the light and vision source objects associated with this Token
	 * @param {boolean} [defer]           Defer refreshing the SightLayer to manually call that refresh later.
	 * @param {boolean} [deleted]         Indicate that this light source has been deleted.
	 * @param {boolean} [noUpdateFog]     Never update the Fog exploration progress for this update.
	 */
	updateSource({defer=false, deleted=false, noUpdateFog=false}={}) {
		if ( CONFIG.debug.sight ) {
			SightLayer._performance = { start: performance.now(), tests: 0, rays: 0 }
		}
		 // Prepare some common data
		const origin = this.getSightOrigin();
		const sourceId = this.sourceId;
		const d = canvas.dimensions;
		const maxR = Math.hypot(d.sceneWidth, d.sceneHeight);
		 // Update light source
		const isLightSource = this.emitsLight && !this.data.hidden;
		if ( isLightSource && !deleted ) {
			const bright = Math.min(this.getLightRadius(this.data.brightLight), maxR);
			const dim = Math.min(this.getLightRadius(this.data.dimLight), maxR);
			this.light.initialize({
				x: origin.x,
				y: origin.y,
				dim: dim,
				bright: bright,
				angle: this.data.lightAngle,
				rotation: this.data.rotation,
				color: this.data.lightColor,
				alpha: this.data.lightAlpha,
				animation: this.data.lightAnimation
			});
			canvas.lighting.sources.set(sourceId, this.light);
			if ( !defer ) {
				this.light.drawLight();
				this.light.drawColor();
			}
		}
		else {
			canvas.lighting.sources.delete(sourceId);
			if ( isLightSource && !defer ) canvas.lighting.refresh();
		}
		 // Update vision source
		const isVisionSource = this._isVisionSource();
		if ( isVisionSource && !deleted ) {
			let dim =  canvas.lighting.globalLight ? maxR : Math.min(this.getLightRadius(this.data.dimSight), maxR);
			const bright = Math.min(this.getLightRadius(this.data.brightSight), maxR);
			if ((dim === 0) && (bright === 0)) dim = Math.min(this.w, this.h) * 0.5;
			this.vision.initialize({
				x: origin.x,
				y: origin.y,
				dim: dim,
				bright: bright,
				angle: this.data.sightAngle,
				rotation: this.data.rotation
			});
			canvas.sight.sources.set(sourceId, this.vision);
			if ( !defer ) {
				this.vision.drawLight();
				canvas.sight.refresh({noUpdateFog});
			}
		}
		else {
			canvas.sight.sources.delete(sourceId);
			if ( isVisionSource && !defer ) canvas.sight.refresh();
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether this Token is a viable vision source for the current User
	 * @return {boolean}
	 * @private
	 */
	_isVisionSource() {
		if ( !canvas.sight.tokenVision || !this.hasSight ) return false;
		 // Only display hidden tokens for the GM
		const isGM = game.user.isGM;
		if (this.data.hidden && !isGM) return false;
		 // Always display controlled tokens which have vision
		if ( this._controlled ) return true;
		 // Otherwise vision is ignored for GM users
		if ( isGM ) return false;
		 // If a non-GM user controls no other tokens with sight, display sight anyways
		const canObserve = this.actor && this.actor.hasPerm(game.user, "OBSERVER");
		if ( !canObserve ) return false;
		const others = this.layer.controlled.filter(t => !t.data.hidden && t.hasSight);
		return !others.length;
	}
	 /* -------------------------------------------- */
	/* Rendering
	/* -------------------------------------------- */
	 /** @override */
	async draw() {
		this.clear();
		if ( this.hasActiveHUD ) canvas.tokens.hud.clear();
		 // Draw the token as invisible so it will be safely revealed later
		this.visible = false;
		 // Load token texture
		this.texture = await loadTexture(this.data.img, {fallback: CONST.DEFAULT_TOKEN});
		 // Draw Token components
		this.border = this.addChild(new PIXI.Graphics());
		this.icon = this.addChild(await this._drawIcon());
		this.bars = this.addChild(this._drawAttributeBars());
		this.nameplate = this.addChild(this._drawNameplate());
		this.tooltip = this.addChild(new PIXI.Container());
		this.effects = this.addChild(new PIXI.Container());
		this.target = this.addChild(new PIXI.Graphics());
		 // Define initial interactivity and visibility state
		this.hitArea = new PIXI.Rectangle(0, 0, this.w, this.h);
		this.buttonMode = true;
		 // Draw the initial position
		this.refresh();
		await this.drawEffects();
		this.drawTooltip();
		this.drawBars();
		 // Enable interactivity, only if the Tile has a true ID
		if ( this.id ) this.activateListeners();
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw resource bars for the Token
	 * @private
	 */
	_drawAttributeBars() {
		const bars = new PIXI.Container();
		bars.bar1 = bars.addChild(new PIXI.Graphics());
		bars.bar2 = bars.addChild(new PIXI.Graphics());
		return bars;
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the Sprite icon for the Token
	 * @return {Promise<PIXI.Sprite>}
	 * @private
	 */
	async _drawIcon() {
		 // Create Sprite using the loaded texture
		let icon = new PIXI.Sprite(this.texture);
		icon.anchor.set(0.5, 0.5);
		if ( !this.texture ) return icon;
		 // Ensure playback state for video tokens
		const source = getProperty(this.texture, "baseTexture.resource.source");
		if ( source && (source.tagName === "VIDEO") ) {
			source.loop = true;
			source.muted = true;
			source.currentTime = 0;
			game.video.play(source);
		}
		 // Apply color tinting
		icon.tint = this.data.tint ? colorStringToHex(this.data.tint) : 0xFFFFFF;
		return icon;
	}
	 /* -------------------------------------------- */
	 /**
	 * Update display of the Token, pulling latest data and re-rendering the display of Token components
	 */
	refresh() {
		 // Token position and visibility
		if ( !this._movement ) this.position.set(this.data.x, this.data.y);
		 // Size the texture aspect ratio within the token frame
		const tex = this.texture;
		if ( tex ) {
			let aspect = tex.width / tex.height;
			if ( aspect >= 1 ) {
				this.icon.width = this.w * this.data.scale;
				this.icon.scale.y = this.icon.scale.x;
			} else {
				this.icon.height = this.h * this.data.scale;
				this.icon.scale.x = this.icon.scale.y;
			}
		}
		 // Mirror horizontally or vertically
		this.icon.scale.x = Math.abs(this.icon.scale.x) * (this.data.mirrorX ? -1 : 1);
		this.icon.scale.y = Math.abs(this.icon.scale.y) * (this.data.mirrorY ? -1 : 1);
		 // Set rotation, position, and opacity
		this.icon.rotation = toRadians(this.data.lockRotation ? 0 : this.data.rotation);
		this.icon.position.set(this.w / 2, this.h / 2);
		this.icon.alpha = this.data.hidden ? 0.5 : 1.0;
		 // Refresh Token border and target
		this._refreshBorder();
		this._refreshTarget();
		 // Refresh nameplate and resource bars
		this.nameplate.visible = this._canViewMode(this.data.displayName);
		this.bars.visible = this._canViewMode(this.data.displayBars);
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the Token border, taking into consideration the grid type and border color
	 * @private
	 */
	_refreshBorder() {
		this.border.clear();
		const borderColor = this._getBorderColor();
		if( !borderColor ) return;
		const t = CONFIG.Canvas.objectBorderThickness;
		 // Draw Hex border for size 1 tokens on a hex grid
		const gt = CONST.GRID_TYPES;
		const hexTypes = [gt.HEXEVENQ, gt.HEXEVENR, gt.HEXODDQ, gt.HEXODDR];
		if ( hexTypes.includes(canvas.grid.type) && (this.data.width === 1) && (this.data.height === 1) ) {
			const polygon = canvas.grid.grid.getPolygon(-1, -1, this.w+2, this.h+2);
			this.border.lineStyle(t, 0x000000, 0.8).drawPolygon(polygon);
			this.border.lineStyle(t/2, borderColor, 1.0).drawPolygon(polygon);
		}
		 // Otherwise Draw Square border
		else {
			const h = Math.round(t/2);
			const o = Math.round(h/2);
			this.border.lineStyle(t, 0x000000, 0.8).drawRoundedRect(-o, -o, this.w+h, this.h+h, 3);
			this.border.lineStyle(h, borderColor, 1.0).drawRoundedRect(-o, -o, this.w+h, this.h+h, 3);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the hex color that should be used to render the Token border
	 * @return {number}   The hex color used to depict the border color
	 * @private
	 */
	_getBorderColor() {
		const colors = CONFIG.Canvas.dispositionColors;
		if ( this._controlled ) return colors.CONTROLLED;
		else if ( this._hover ) {
			let d = parseInt(this.data.disposition);
			if (!game.user.isGM && this.owner) return colors.CONTROLLED;
			else if (this.actor?.hasPlayerOwner) return colors.PARTY;
			else if (d === CONST.TOKEN_DISPLAY_MODES.FRIENDLY) return colors.FRIENDLY;
			else if (d === CONST.TOKEN_DISPLAY_MODES.NEUTRAL) return colors.NEUTRAL;
			else return colors.HOSTILE;
		}
		else return null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Refresh the target indicators for the Token.
	 * Draw both target arrows for the primary User as well as indicator pips for other Users targeting the same Token.
	 * @private
	 */
	_refreshTarget() {
		this.target.clear();
		if ( !this.targeted.size ) return;
		 // Determine whether the current user has target and any other users
		const [others, user] = Array.from(this.targeted).partition(u => u === game.user);
		const userTarget = user.length;
		 // For the current user, draw the target arrows
		if ( userTarget ) {
			let p = 4;
			let aw = 12;
			let h = this.h;
			let hh = h / 2;
			let w = this.w;
			let hw = w / 2;
			let ah = canvas.dimensions.size / 3;
			this.target.beginFill(0xFF9829, 1.0).lineStyle(1, 0x000000)
				.drawPolygon([-p,hh, -p-aw,hh-ah, -p-aw,hh+ah])
				.drawPolygon([w+p,hh, w+p+aw,hh-ah, w+p+aw,hh+ah])
				.drawPolygon([hw,-p, hw-ah,-p-aw, hw+ah,-p-aw])
				.drawPolygon([hw,h+p, hw-ah,h+p+aw, hw+ah,h+p+aw]);
		}
		 // For other users, draw offset pips
		for ( let [i, u] of others.entries() ) {
			let color = colorStringToHex(u.data.color);
			this.target.beginFill(color, 1.0).lineStyle(2, 0x0000000).drawCircle(2 + (i * 8), 0, 6);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * A helper method to retrieve the underlying data behind one of the Token's attribute bars
	 * @param {string} barName        The named bar to retrieve the attribute for
	 * @param {string} alternative    An alternative attribute path to get instead of the default one
	 * @return {Object|null}          The attribute displayed on the Token bar, if any
	 */
	getBarAttribute(barName, {alternative}={}) {
		const attr = alternative || (barName ? this.data[barName].attribute : null);
		if ( !attr || !this.actor ) return null;
		let data = getProperty(this.actor.data.data, attr);
		 // Single values
		if ( Number.isFinite(data) ) {
			return {
				type: "value",
				attribute: attr,
				value: data
			}
		}
		 // Attribute objects
		else if ( (typeof data === "object") && ("value" in data) && ("max" in data) ) {
			data = duplicate(data);
			return {
				type: "bar",
				attribute: attr,
				value: parseInt(data.value || 0),
				max: parseInt(data.max || 0)
			}
		}
		 // Otherwise null
		return null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Refresh the display of Token attribute bars, rendering latest resource data
	 * If the bar attribute is valid (has a value and max), draw the bar. Otherwise hide it.
	 * @private
	 */
	drawBars() {
		if ( !this.actor || (this.data.displayBars === CONST.TOKEN_DISPLAY_MODES.NONE) ) return;
		["bar1", "bar2"].forEach((b, i) => {
			const bar = this.bars[b];
			const attr = this.getBarAttribute(b);
			if ( !attr || (attr.type !== "bar") ) return bar.visible = false;
			this._drawBar(i, bar, attr);
			bar.visible = true;
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw a single resource bar, given provided data
	 * @param {number} number       The Bar number
	 * @param {PIXI.Graphics} bar   The Bar container
	 * @param {Object} data         Resource data for this bar
	 * @private
	 */
	_drawBar(number, bar, data) {
		const val = Number(data.value);
		const pct = Math.clamped(val, 0, data.max) / data.max;
		let h = Math.max((canvas.dimensions.size / 12), 8);
		if ( this.data.height >= 2 ) h *= 1.6;  // Enlarge the bar for large tokens
		 // Draw the bar
		let color = (number === 0) ? [(1-(pct/2)), pct, 0] : [(0.5 * pct), (0.7 * pct), 0.5 + (pct / 2)];
		bar.clear()
			 .beginFill(0x000000, 0.5)
			 .lineStyle(2, 0x000000, 0.9)
			 .drawRoundedRect(0, 0, this.w, h, 3)
			 .beginFill(PIXI.utils.rgb2hex(color), 0.8)
			 .lineStyle(1, 0x000000, 0.8)
			 .drawRoundedRect(1, 1, pct*(this.w-2), h-2, 2);
		 // Set position
		let posY = number === 0 ? this.h - h : 0;
		bar.position.set(0, posY);
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the token's nameplate as a text object
	 * @return {PIXI.Text}  The Text object for the Token nameplate
	 */
	_drawNameplate() {
		const style = this._getTextStyle();
		const name = new PreciseText(this.data.name, style);
		name.anchor.set(0.5, 0);
		name.position.set(this.w / 2, this.h + 2);
		return name;
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw a text tooltip for the token which can be used to display Elevation or a resource value
	 */
	drawTooltip() {
		this.tooltip.removeChildren().forEach(c => c.destroy());
		 // Create the tooltip Text
		let tip = this._getTooltipText();
		if (!tip.length) return;
		const style = this._getTextStyle();
		const text = new PreciseText(tip, style);
		this.tooltip.addChild(text);
		 // Add the tooltip at the top of the parent Token container
		text.anchor.set(0.5, 1);
		this.tooltip.position.set(this.w / 2, -2);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the text which should be displayed in a token's tooltip field
	 * @return {string}
	 * @private
	 */
	_getTooltipText() {
		let el = this.data.elevation;
		if (!Number.isFinite(el) || el === 0) return "";
		let units = canvas.scene.data.gridUnits;
		return el > 0 ? `+${el} ${units}` : `${el} ${units}`;
	}
	 /* -------------------------------------------- */
	 _getTextStyle() {
		const style = CONFIG.canvasTextStyle.clone();
		style.fontSize = 24;
		if (canvas.dimensions.size >= 200) style.fontSize = 28;
		else if (canvas.dimensions.size < 50) style.fontSize = 20;
		style.wordWrapWidth = this.w * 2.5;
		return style
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the active effects and overlay effect icons which are present upon the Token
	 */
	async drawEffects() {
		this.effects.removeChildren().forEach(c => c.destroy());
		const tokenEffects = this.data.effects;
		const actorEffects = this.actor?.temporaryEffects || [];
		let overlay = {
			src: this.data.overlayEffect,
			tint: null
		};
		 // Draw status effects
		if ( tokenEffects.length || actorEffects.length ) {
			const promises = [];
			let w = Math.round(canvas.dimensions.size / 2 / 5) * 2;
			let bg = this.effects.addChild(new PIXI.Graphics()).beginFill(0x000000, 0.40).lineStyle(1.0, 0x000000);
			let i = 0;
			 // Draw actor effects first
			for ( let f of actorEffects ) {
				if ( !f.data.icon ) continue;
				const tint = f.data.tint ? colorStringToHex(f.data.tint) : null;
				if ( f.getFlag("core", "overlay") ) {
					overlay = {src: f.data.icon, tint};
					continue;
				}
				promises.push(this._drawEffect(f.data.icon, i, bg, w, tint));
				i++;
			}
			 // Next draw token effects
			for ( let f of tokenEffects ) {
				promises.push(this._drawEffect(f, i, bg, w, null));
				i++;
			}
			await Promise.all(promises);
		}
		 // Draw overlay effect
		return this._drawOverlay(overlay)
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the overlay effect icon
	 * @return {Promise<void>}
	 * @private
	 */
	async _drawOverlay({src, tint}={}) {
		if ( !src ) return;
		const tex = await loadTexture(src);
		const icon = new PIXI.Sprite(tex);
		const size = Math.min(this.w * 0.6, this.h * 0.6);
		icon.width = icon.height = size;
		icon.position.set((this.w - size) / 2, (this.h - size) / 2);
		icon.alpha = 0.80;
		if ( tint ) icon.tint = tint;
		this.effects.addChild(icon);
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw a status effect icon
	 * @return {Promise<void>}
	 * @private
	 */
	async _drawEffect(src, i, bg, w, tint) {
		let tex = await loadTexture(src);
		let icon = this.effects.addChild(new PIXI.Sprite(tex));
		icon.width = icon.height = w;
		const nr = Math.floor(this.data.height * 5);
		icon.x = Math.floor(i / nr) * w;
		icon.y = (i % nr) * w;
		if ( tint ) icon.tint = tint;
		bg.drawRoundedRect(icon.x + 1, icon.y + 1, w - 2, w - 2, 2);
		this.effects.addChild(icon);
	}
	 /* -------------------------------------------- */
	 /**
	 * Helper method to determine whether a token attribute is viewable under a certain mode
	 * @param {number} mode   The mode from CONST.TOKEN_DISPLAY_MODES
	 * @return {boolean}      Is the attribute viewable?
	 * @private
	 */
	_canViewMode(mode) {
		if ( mode === CONST.TOKEN_DISPLAY_MODES.NONE ) return false;
		else if ( mode === CONST.TOKEN_DISPLAY_MODES.ALWAYS ) return true;
		else if ( mode === CONST.TOKEN_DISPLAY_MODES.CONTROL ) return this._controlled;
		else if ( mode === CONST.TOKEN_DISPLAY_MODES.HOVER ) return this._hover;
		else if ( mode === CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER ) return this.owner && this._hover;
		else if ( mode === CONST.TOKEN_DISPLAY_MODES.OWNER ) return this.owner;
		return false;
	}
	 /* -------------------------------------------- */
	 /**
	 * Animate Token movement along a certain path which is defined by a Ray object
	 * @param {Ray} ray   The path along which to animate Token movement
	 */
	async animateMovement(ray) {
		 // Move distance is 10 spaces per second
		const s = canvas.dimensions.size;
		this._movement = ray;
		const speed = s * 10;
		const duration = (ray.distance * 1000) / speed;
		let {x, y} = this.data;
		 // Define attributes
		const attributes = [
			{ parent: this, attribute: 'x', to: ray.B.x },
			{ parent: this, attribute: 'y', to: ray.B.y }
		];
		 // Determine whether to animate vision reveal
		 // Determine what type of updates should be animated
		const emits = this.emitsLight;
		const config = {
			animate: game.settings.get("core", "visionAnimation"),
			source: this._isVisionSource() || emits,
			sound: this._controlled || this.observer,
			fog: emits && !this._controlled && (canvas.sight.sources.size > 0)
		}
		 // Trigger the animation function
		let animationName = `Token.${this.id}.animateMovement`;
		await CanvasAnimation.animateLinear(attributes, {
			name: animationName,
			context: this,
			duration: duration,
			ontick: (dt, anim) => this._onMovementFrame(dt, anim, config)
		});
		 // Once animation is complete, confirm the final position
		this.data.x = x;
		this.data.y = y;
		this._animatePerceptionFrame(config);
		this._movement = null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Animate the continual revealing of Token vision during a movement animation
	 * @private
	 */
	_onMovementFrame(dt, anim, config) {
		 // Update the displayed position of the Token
		this.data.x = this.x;
		this.data.y = this.y;
		 // Update perception, if allowed
		if ( !config.animate || !anim.length ) return;
		let updateFog = config.fog;
		if ( config.source ) {
			const dist = Math.hypot(anim[0].done, anim[1]?.done || 0);
			const n = Math.floor(dist / canvas.dimensions.size);
			if ((n > 0) && (anim[0].dist !== n)) {
				updateFog = true;
				anim[0].dist = n;
			}
		}
		 // Animate perception
		this._animatePerceptionFrame({source: config.source, sound: config.sound, fog: updateFog});
	}
	 /* -------------------------------------------- */
	 /**
	 * Update perception each frame depending on the animation configuration
	 * @private
	 */
	_animatePerceptionFrame({source=false, sound=false, fog=false}={}) {
		if ( source ) {
			this.updateSource({defer: true});
			canvas.lighting.refresh();
			canvas.sight.refresh({forceUpdateFog: fog});
		}
		if ( sound ) canvas.sounds.update({fade: false});
	}
	 /* -------------------------------------------- */
	 /**
	 * Terminate animation of this particular Token
	 */
	stopAnimation() {
		return CanvasAnimation.terminateAnimation(`Token.${this.id}.animateMovement`);
	}
	 /* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */
	 /**
	 * Check for collision when attempting a move to a new position
	 * @param {Point} destination   The destination point of the attempted movement
	 * @return {boolean}            A true/false indicator for whether the attempted movement caused a collision
	 */
	checkCollision(destination) {
		 // Create a Ray for the attempted move
		let origin = this.getCenter(...Object.values(this._validPosition));
		let ray = new Ray(duplicate(origin), duplicate(destination));
		 // Shift the origin point by the prior velocity
		ray.A.x -= this._velocity.sx;
		ray.A.y -= this._velocity.sy;
		 // Shift the destination point by the requested velocity
		ray.B.x -= Math.sign(ray.dx);
		ray.B.y -= Math.sign(ray.dy);
		 // Check for a wall collision
		return canvas.walls.checkCollision(ray);
	}
	 /* -------------------------------------------- */
	 /** @override */
	clone() {
		const o = super.clone();
		o.actor = this.actor;
		return o;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onControl({releaseOthers=true, updateSight=true, pan=false} = {}) {
		_token = this;
		this.zIndex = 1;
		this.refresh();
		if ( updateSight ) canvas.addPendingOperation(`Canvas.initializeSources`, canvas.initializeSources, canvas);
		if ( pan ) canvas.addPendingOperation("Canvas.animatePan", canvas.animatePan, canvas, [{x: this.x, y: this.y}]);
		canvas.sounds.refresh();
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onRelease({updateSight=true}={}) {
		super._onRelease({});
		this.zIndex = 0;
		if ( updateSight ) canvas.addPendingOperation("Canvas.initializeSources", canvas.initializeSources, canvas);
		canvas.sounds.refresh();
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the center-point coordinate for a given grid position
	 * @param {number} x    The grid x-coordinate that represents the top-left of the Token
	 * @param {number} y    The grid y-coordinate that represents the top-left of the Token
	 * @return {Object}     The coordinate pair which represents the Token's center at position (x, y)
	 */
	getCenter(x, y) {
		return {
			x: x + (this.w / 2),
			y: y + (this.h / 2)
		};
	}
	 /* -------------------------------------------- */
	 /**
	 * Set the token's position by comparing its center position vs the nearest grid vertex
	 * Return a Promise that resolves to the Token once the animation for the movement has been completed
	 * @param {number} x            The x-coordinate of the token center
	 * @param {number} y            The y-coordinate of the token center
	 * @param {boolean} [animate]   Animate the movement path, default is true
	 * @return {Promise<Token>}     The Token after animation has completed
	 */
	async setPosition(x, y, {animate=true}={}) {
		 // Create a Ray for the requested movement
		let origin = this._movement ? this.position : this._validPosition,
				target = {x: x, y: y},
				isVisible = this.isVisible;
		 // Create the movement ray
		let ray = new Ray(origin, target);
		 // Update the new valid position
		this._validPosition = target;
		 // Record the Token's new velocity
		this._velocity = this._updateVelocity(ray);
		 // Update visibility for a non-controlled token which may have moved into the controlled tokens FOV
		this.visible = isVisible;
		 // Conceal the HUD if it targets this Token
		if ( this.hasActiveHUD ) this.layer.hud.clear();
		 // Either animate movement to the destination position, or set it directly if animation is disabled
		if ( animate ) await this.animateMovement(new Ray(this.position, ray.B));
		else this.position.set(x, y);
		 // If the movement took a controlled token off-screen, re-center the view
		if (this._controlled && isVisible) {
			let pad = 50;
			let gp = this.getGlobalPosition();
			if ((gp.x < pad) || (gp.x > window.innerWidth - pad) || (gp.y < pad) || (gp.y > window.innerHeight - pad)) {
				canvas.animatePan(this.center);
			}
		}
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Update the Token velocity auto-regressively, shifting increasing weight towards more recent movement
	 * Employ a magic constant chosen to minimize (effectively zero) the likelihood of trigonometric edge cases
	 * @param {Ray} ray     The proposed movement ray
	 * @return {Object}     An updated velocity with directional memory
	 * @private
	 */
	_updateVelocity(ray) {
		const v = this._velocity;
		const m = 0.89734721;
		return {
			dx: ray.dx,
			sx: ray.dx ? (m * Math.sign(ray.dx)) : (0.5 * m * Math.sign(v.sx)),
			dy: ray.dy,
			sy: ray.dy ? (m * Math.sign(ray.dy)) : (0.5 * m * Math.sign(v.sy))
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Set this Token as an active target for the current game User
	 * @param {boolean} targeted        Is the Token now targeted?
	 * @param {User|null} user          Assign the token as a target for a specific User
	 * @param {boolean} releaseOthers   Release other active targets for the same player?
	 * @param {boolean} groupSelection  Is this target being set as part of a group selection workflow?
	 */
	setTarget(targeted=true, {user=null, releaseOthers=true, groupSelection=false}={}) {
		user = user || game.user;
		 // Release other targets
		if ( user.targets.size && releaseOthers ) {
			user.targets.forEach(t => {
				if ( t !== this ) t.setTarget(false, {releaseOthers: false});
			});
			user.targets.clear();
		}
		 // Acquire target
		if ( targeted ) {
			this.targeted.add(user);
			user.targets.add(this);
		}
		 // Release target
		else {
			this.targeted.delete(user);
			user.targets.delete(this);
		}
		 // Refresh Token display
		this.refresh();
		 // Refresh the Token HUD
		if ( this.hasActiveHUD ) this.layer.hud.render();
		 // Broadcast the target change
		if ( !groupSelection ) user.broadcastActivity({targets: user.targets.ids});
	}
	 /* -------------------------------------------- */
	 /**
	 * Add or remove the currently controlled Tokens from the active combat encounter
	 * @param {Combat} [combat]    A specific combat encounter to which this Token should be added
	 * @return {Promise<Token>} The Token which initiated the toggle
	 */
	async toggleCombat(combat) {
		await this.layer.toggleCombat(!this.inCombat, combat, {token: this});
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Toggle an active effect by it's texture path.
	 * Copy the existing Array in order to ensure the update method detects the data as changed.
	 *
	 * @param {string|object} effect  The texture file-path of the effect icon to toggle on the Token.
	 * @param {object} [options]      Additional optional arguments which configure how the effect is handled.
	 * @param {boolean} [options.active]    Force a certain active state for the effect
	 * @param {boolean} [options.overlay]   Whether to set the effect as the overlay effect?
	 * @return {Promise<boolean>}   Was the texture applied (true) or removed (false)
	 */
	async toggleEffect(effect, {active, overlay=false}={}) {
		const fx = this.data.effects;
		const texture = effect.icon ?? effect;
		 // Case 1 - handle an active effect object
		if ( effect.icon ) await this._toggleActiveEffect(effect, {overlay});
		 // Case 2 - overlay effect
		else if ( overlay ) await this._toggleOverlayEffect(texture, {active});
		 // Case 3 - add or remove a standard effect icon
		else {
			const idx = fx.findIndex(e => e === texture);
			if ((idx !== -1) && (active !== true)) fx.splice(idx, 1);
			else if ((idx === -1) && (active !== false)) fx.push(texture);
			await this.update({effects: fx}, {diff: false});
		}
		 // Update the Token HUD
		if ( this.hasActiveHUD ) canvas.tokens.hud.refreshStatusIcons();
		return active;
	}
	 /* -------------------------------------------- */
	 /**
	 * A helper function to toggle a status effect which includes an Active Effect template
	 * @return {Promise<boolean>}
	 * @private
	 */
	async _toggleActiveEffect(effectData, {overlay=false}={}) {
		if ( !this.actor || !effectData.id ) return;
		let state = false;
		 // Remove an existing effect
		const existing = this.actor.effects.find(e => e.getFlag("core", "statusId") === effectData.id);
		if ( existing ) {
			await existing.delete();
			await this.toggleEffect(effectData.icon, {active: false, overlay});
		}
		 // Add a new effect
		else {
			const createData = duplicate(effectData);
			createData.label = game.i18n.localize(effectData.label);
			createData["flags.core.statusId"] = effectData.id;
			if ( overlay ) createData["flags.core.overlay"] = true;
			delete createData.id;
			const effect = ActiveEffect.create(createData, this.actor);
			await effect.create();
			state = true;
		}
		return state;
	}
	 /* -------------------------------------------- */
	 /**
	 * A helper function to toggle the overlay status icon on the Token
	 * @return {Promise<*>}
	 * @private
	 */
	async _toggleOverlayEffect(texture, {active}) {
		 // Assign the overlay effect
		active = active ?? this.data.overlayEffect !== texture;
		let effect = active ? texture : null;
		await this.update({overlayEffect: effect});
		 // Set the defeated status in the combat tracker
		// TODO - deprecate this and require that active effects be used instead
		if ( (texture === CONFIG.controlIcons.defeated) && game.combat ) {
			const combatant = game.combat.getCombatantByToken(this.id);
			if (combatant) await game.combat.updateCombatant({_id: combatant._id, defeated: active});
		}
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Toggle the visibility state of any Tokens in the currently selected set
	 * @return {Promise<Scene>}     A Promise which resolves to the updated Scene
	 */
	async toggleVisibility() {
		let isHidden = this.data.hidden;
		const tokens = this._controlled ? canvas.tokens.controlled : [this];
		const updates = tokens.map(t => { return {_id: t.id, hidden: !isHidden}});
		return this.layer.updateMany(updates);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the token's sight origin, tailored for the direction of their movement velocity to break ties with walls
	 * @return {Object}
	 */
	getSightOrigin() {
		let p = this.center;
		return {
			x: p.x - this._velocity.sx,
			y: p.y - this._velocity.sy
		};
	}
	 /* -------------------------------------------- */
	 /**
	 * A generic transformation to turn a certain number of grid units into a radius in canvas pixels.
	 * This function adds additional padding to the light radius equal to half the token width.
	 * This causes light to be measured from the outer token edge, rather than from the center-point.
	 * @param units {Number}  The radius in grid units
	 * @return {number}       The radius in canvas units
	 */
	getLightRadius(units) {
		if (units === 0) return 0;
		const u = Math.abs(units);
		const hw = (this.w / 2);
		return (((u / canvas.dimensions.distance) * canvas.dimensions.size) + hw) * Math.sign(units);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_getShiftedPosition(dx, dy) {
		let [x, y] = canvas.grid.grid.shiftPosition(this.data.x, this.data.y, dx, dy);
		let targetCenter = this.getCenter(x, y);
		let collide = this.checkCollision(targetCenter);
		return collide ? {x: this.data.x, y: this.data.y} : {x, y};
	}
	 /* -------------------------------------------- */
	 /**
	 * Extend the PlaceableObject.rotate method to prevent rotation if the Token is in the midst of a movement animation
	 */
	rotate(...args) {
		if ( this._movement ) return;
		super.rotate(...args);
	}
	 /* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */
	 /** @override */
	_onCreate(options, userId) {
		 // Initialize Tokens on the Sight Layer if the Token could be a vision source or emits light
		if ( (this.data.vision && this.observer) || this.emitsLight ) {
			canvas.addPendingOperation(`Canvas.initializeSources`, canvas.initializeSources, canvas);
		}
		 // Draw the object and display the new Token
		this.draw().then(token => {
			if ( !game.user.isGM && this.owner ) this.control({pan: true});
			this.visible = this.isVisible;
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onUpdate(data, options, userId) {
		const keys = Object.keys(data);
		const changed = new Set(keys);
		 // If Actor data link has changed, replace the Token actor
		if ( ["actorId", "actorLink"].some(c => changed.has(c))) this.actor = Actor.fromToken(this);
		if ( !this.data.actorLink && changed.has("actorData") ){
			this._onUpdateTokenActor(data.actorData);
		}
		 // Handle direct Token updates
		const fullRedraw = ["img", "name", "width", "height", "tint"].some(r => changed.has(r));
		const positionChange = ["x", "y"].some(c => changed.has(c));
		 // Change in Token appearance
		if ( fullRedraw ) {
			const visible = this.visible;
			this.draw();
			this.visible = visible;
		}
		 // Non-full updates
		else {
			if ( positionChange ) this.setPosition(this.data.x, this.data.y, options);
			if ( ["effects", "overlayEffect"].some(k => changed.has(k)) ) this.drawEffects();
			if ( changed.has("elevation") ) this.drawTooltip();
			if ( keys.some(k => k.startsWith("bar")) ) this.drawBars();
			this.refresh();
		}
		 // Handle changes to the visibility state of the token
		const visibilityChange = changed.has("hidden");
		if ( visibilityChange ) {
			if ( !game.user.isGM ) {
				if ( this._controlled && data.hidden ) this.release();
				else if ( !data.hidden && !canvas.tokens.controlled.length ) this.control({pan: true});
			}
			this.visible = this.isVisible;
		}
		 // Determine whether the token's perspective has changed
		const rotationChange = changed.has("rotation") && this.hasLimitedVisionAngle;
		let perspectiveChange = changed.has("vision") ||
			((this.data.vision || this.emitsLight) && (visibilityChange || positionChange || rotationChange)) ||
			(this.data.vision && ["dimSight", "brightSight", "sightAngle"].some(k => changed.has(k))) ||
			["dimLight", "brightLight", "lightAlpha", "lightAngle", "lightColor", "lightAnimation", "width", "height"].some(k => changed.has(k));
		if ( perspectiveChange ) {
			const animating = positionChange && (options.animate !== false);
			if ( !animating ) {
				this.updateSource({defer: true});
				canvas.addPendingOperation("LightingLayer.refresh", canvas.lighting.refresh, canvas.lighting);
				canvas.addPendingOperation("SightLayer.refresh", canvas.sight.refresh, canvas.sight, [{
					forceUpdateFog: this.hasLimitedVisionAngle
				}]);
			}
			canvas.sounds.refresh();
		}
		 // Process Combat Tracker changes
		if ( this.inCombat ) {
			if ( changed.has("name") ) {
				canvas.addPendingOperation(`Combat.setupTurns`, game.combat.setupTurns, game.combat);
			}
			if ( ["effects", "name", "overlayEffect"].some(k => changed.has(k)) ) {
				canvas.addPendingOperation(`CombatTracker.render`, ui.combat.render, ui.combat);
			}
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDelete(options, userId) {
		 // Cancel movement animations
		this.stopAnimation();
		 // Remove target (if applicable)
		game.user.targets.delete(this);
		 // Process changes to perception
		if ( this.emitsLight || ( this.observer && this.data.vision ) ) {
			this.updateSource({deleted: true, defer: true});
			canvas.addPendingOperation(`Canvas.initializeSources`, canvas.initializeSources, canvas);
		}
		 // Remove audible sound
		if ( this.observer ) {
			// TODO - this should be folded into canvas.initializeSources
			canvas.addPendingOperation(`SoundsLayer.initialize`, canvas.sounds.initialize, canvas.sounds);
		}
		 // Remove Combatants
		if ( userId === game.user.id ) {
			game.combats._onDeleteToken(this.scene.id, this.id);
		}
		 // Parent class deletion handlers
		return super._onDelete(options, userId);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle updates to the Token's referenced Actor (either Entity or synthetic)
	 * @param {Object} updateData     The changes to Token actorData overrides which are incremental
	 * @private
	 */
	_onUpdateTokenActor(updateData) {
		 // Reject any calls which were incorrectly placed to this method for tokens which are linked
		if ( !this.actor || this.data.actorLink ) return;
		 // Update data for the synthetic Token
		mergeObject(this.actor._data, updateData);
		this.actor._onUpdate(updateData);
		 // Update Token bar attributes
		this._onUpdateBarAttributes(updateData);
		 // Update active effects
		const updateEffects = "effects" in updateData;
		if ( updateEffects ) {
			this.drawEffects();
		}
		 // Update tracked Combat resources
		if ( this.inCombat ) {
			if ( updateEffects || hasProperty(updateData?.data, game.combats.settings.resource) ) {
				canvas.addPendingOperation(`Combat.setupTurns`, game.combat.setupTurns, game.combat);
				canvas.addPendingOperation(`CombatTracker.render`, ui.combat.render, ui.combat);
			}
		}
		 // Render the active Token sheet
		this.actor.sheet.render();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle updates to this Token which originate from changes to the base Actor entity
	 * @param {Object} actorData     Updated data for the base Actor
	 * @param {Object} updateData    Changes to the base Actor which were incremental
	 * @private
	 */
	_onUpdateBaseActor(actorData, updateData) {
		if ( !this.actor ) return;
		 // For Tokens which are unlinked, update the synthetic Actor
		if ( !this.data.actorLink ) {
			this.actor._data = mergeObject(actorData, this.data.actorData, {inplace: false});
			this.actor.prepareData();
		}
		 // Update Token bar attributes
		this._onUpdateBarAttributes(updateData);
		 // Update tracked Combat resources
		if ( this.inCombat && updateData.data && hasProperty(updateData.data, game.combats.settings.resource) ) {
			game.combat.setupTurns();
			ui.combat.render();
		}
		 // Render the active Token sheet
		this.actor.sheet.render();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the possible re-drawing of Token attribute bars depending on whether the tracked attribute changed
	 * @param {Object} updateData     An object of changed data
	 * @private
	 */
	_onUpdateBarAttributes(updateData) {
		const update = ["bar1", "bar2"].some(b => {
			let bar = this.data[b];
			return bar.attribute && hasProperty(updateData, "data."+bar.attribute);
		});
		if ( update ) this.drawBars();
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */
	 /** @override */
	_canControl(user, event) {
		if ( canvas.controls.ruler.active ) return false;
		const tool = game.activeTool;
		if ( tool === "target" ) return true;
		return game.user.isGM || (this.actor && this.actor.hasPerm(user, "OWNER"));
	}
	 /** @override */
	_canHUD(user, event) {
		if ( canvas.controls.ruler.active ) return false;
		return user.isGM || (this.actor && this.actor.hasPerm(user, "OWNER"));
	}
	 /** @override */
	_canConfigure(user, event) {
		return true;
	}
	 /** @override */
	_canHover(user, event) {
		return true;
	}
	 /** @override */
	_canView(user, event) {
		return this.actor && this.actor.hasPerm(user, "LIMITED");
	}
	 /** @override */
	_canDrag(user, event) {
		if ( !this._controlled ) return false;
		const tool = game.activeTool;
		if (( tool !== "select" ) || game.keyboard.isCtrl(event) ) return false;
		const blockMove = game.paused && !game.user.isGM;
		return !this._movement && !blockMove;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onHoverIn(event, options) {
		if ( this.inCombat ) {
			$(`li.combatant[data-token-id="${this.id}"]`).addClass("hover");
		}
		return super._onHoverIn(event, options);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onHoverOut(event) {
		if ( this.inCombat ) {
			$(`li.combatant[data-token-id="${this.id}"]`).removeClass("hover");
		}
		return super._onHoverOut(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onClickLeft(event) {
		const tool = game.activeTool;
		const oe = event.data.originalEvent;
		let isRuler = (tool === "ruler") || ( oe.ctrlKey || oe.metaKey );
		if ( isRuler ) canvas.mouseInteractionManager._handleClickLeft(event);
		if ( tool === "target" ) return this.setTarget(!this.isTargeted, {releaseOthers: !oe.shiftKey});
		super._onClickLeft(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onClickLeft2(event) {
		const sheet = this.actor.sheet;
		if ( sheet.rendered ) {
			sheet.maximize();
			sheet.bringToTop();
		}
		else sheet.render(true, {token: this});
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onClickRight2(event) {
		if ( this.owner ) {
			if ( game.user.can("TOKEN_CONFIGURE") ) return super._onClickRight2(event);
		}
		else return this.setTarget(!this.targeted.has(game.user), {releaseOthers: !event.data.originalEvent.shiftKey});
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftDrop(event) {
		const clones = event.data.clones || [];
		const {originalEvent, destination} = event.data;
		const preview = game.settings.get("core", "tokenDragPreview");
		 // Ensure the destination is within bounds
		if ( !canvas.grid.hitArea.contains(destination.x, destination.y) ) return false;
		 // Compute the final dropped positions
		const updates = clones.reduce((updates, c) => {
			 // Reset vision back to the initial location
			if ( preview )  c._original.updateSource({noUpdateFog: true});
			 // Get the snapped top-left coordinate
			let dest = {x: c.data.x, y: c.data.y};
			if (!originalEvent.shiftKey) {
				let precision = (c.data.width < 1) || (c.data.height < 1) ? 2 : 1;
				if ( canvas.grid.type === GRID_TYPES.GRIDLESS ) precision = null;
				dest = canvas.grid.getSnappedPosition(dest.x, dest.y, precision);
			}
			 // Test collision for each moved token vs the central point of it's destination space
			if ( !game.user.isGM ) {
				c._velocity = c._original._velocity;
				let target = c.getCenter(dest.x, dest.y);
				let collides = c.checkCollision(target);
				if ( collides ) {
					ui.notifications.error(game.i18n.localize("ERROR.TokenCollide"));
					return updates
				}
			}
			 // Perform updates where no collision occurs
			updates.push({_id: c._original.id, x: dest.x, y: dest.y});
			return updates;
		}, []);
		return canvas.scene.updateEmbeddedEntity(this.constructor.name, updates);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftMove(event) {
		const {clones, destination, origin, originalEvent} = event.data;
		const preview = game.settings.get("core", "tokenDragPreview");
		 // Pan the canvas if the drag event approaches the edge
		canvas._onDragCanvasPan(originalEvent);
		 // Determine dragged distance
		const dx = destination.x - origin.x;
		const dy = destination.y - origin.y;
		 // Update the position of each clone
		for ( let c of clones || [] ) {
			const o = c._original;
			const x = o.data.x + dx;
			const y = o.data.y + dy;
			if ( preview && !game.user.isGM ) {
				const collision = o.checkCollision(o.getCenter(x, y));
				if ( collision ) continue;
			}
			c.data.x = x;
			c.data.y = y;
			c.refresh();
			if ( preview ) c.updateSource({noUpdateFog: true});
		}
	}
	 /* -------------------------------------------- */
	/*  Factory Methods                             */
	/* -------------------------------------------- */
	 /**
	 * A factory method to create a Token instance from an Actor entity.
	 * The Token is not automatically saved to the database, it is up to the caller whether or not they wish to do that.
	 *
	 * @param {Actor} actor         The input actor entity
	 * @param {object} [tokenData]  Additional data, such as x, y, rotation, etc. for the created token
	 * @return {Promise<Token>}     The created Token instance
	 */
	static async fromActor(actor, tokenData={}) {
		if ( actor.data.token.randomImg ) {
			let images = await actor.getTokenImages();
			images = images.filter(i => (images.length === 1) || !(i === this._lastWildcard));
			const image = images[Math.floor(Math.random() * images.length)];
			tokenData.img = this._lastWildcard = image;
		}
		tokenData = mergeObject(actor.data.token, tokenData, {inplace: false});
		return new Token(tokenData);
	}
	 /* -------------------------------------------- */
	/*  DEPRECATED FUNCTIONS                        */
	/* -------------------------------------------- */
	 /**
	 * @deprecated since 0.7.4
	 */
	async shiftPosition(dx, dy) {
		let moveData = this._getShiftedPosition(dx, dy);
		return this.update(moveData);
	}
	 /* -------------------------------------------- */
	 /**
	 * @deprecated since 0.7.4
	 * @see {Token#toggleEffect}
	 */
	async toggleOverlay(texture) {
		return this.toggleEffect(texture, {overlay: true});
	}
}

/**
 * A "secret" global to help debug attributes of the currently controlled Token.
 * This is only for debugging, and may be removed in the future, so it's not safe to use.
 * @type {Token}
 * @private
 */
let _token = null;
/**
 * A Wall is an implementation of PlaceableObject which represents a physical or visual barrier within the Scene.
 * Walls are used to restrict Token movement or visibility as well as to define the areas of effect for ambient lights
 * and sounds.
 *
 * @implements {PlaceableObject}
 * @see {@link WallsLayer}
 * @see {@link WallConfig}
 *
 * @example
 * Wall.create({
 *  c = [100, 200, 400, 600],
 *  move: CONST.WALL_MOVEMENT_TYPES.NORMAL,
 *  sense: CONST.WALL_SENSE_TYPES.NORMAL,
 *  dir: CONST.WALL_DIRECTIONS.BOTH,
 *  door: CONST.WALL_DOOR_TYPES.DOOR,
 *  ds: CONST.WALL_DOOR_STATES.CLOSED
 * });
 */
class Wall extends PlaceableObject {
	constructor(...args) {
		super(...args);
		 /**
		 * An reference the Door Control icon associated with this Wall, if any
		 * @type {DoorControl|null}
		 * @private
		 */
		this.doorControl = null;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get embeddedName() {
		return "Wall";
	}
	 /* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */
	 /**
	 * A convenience reference to the coordinates Array for the Wall endpoints, [x0,y0,x1,y1].
	 * @type {Array.<number>}
	 */
	get coords() {
		return this.data.c;
	}
	 /* -------------------------------------------- */
	 /** @override */
	get bounds() {
		const [x0, y0, x1, y1] = this.data.c;
		return new NormalizedRectangle(x0, y0, x1-x0, y1-y0);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return the coordinates [x,y] at the midpoint of the wall segment
	 * @return {Array.<number>}
	 */
	get midpoint() {
		return [(this.coords[0] + this.coords[2]) / 2, (this.coords[1] + this.coords[3]) / 2]
	}
	 /* -------------------------------------------- */
	 /** @override */
	get center() {
		const [x,y] = this.midpoint;
		return new PIXI.Point(x, y)
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the direction of effect for a directional Wall
	 * @return {number|null}   The angle of wall effect
	 */
	get direction() {
		let d = this.data.dir;
		if ( !d ) return null;
		let c = this.coords;
		let angle = Math.atan2(c[3] - c[1], c[2] - c[0]);
		if ( d === CONST.WALL_DIRECTIONS.LEFT ) return angle + (Math.PI / 2);
		else return angle - (Math.PI / 2);
	}
	 /* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */
	 /**
	 * This helper converts the wall segment to a Ray
	 * @return {Ray}    The wall in Ray representation
	 */
	toRay() {
		return Ray.fromArrays(this.coords.slice(0, 2), this.coords.slice(2,));
	}
	 /* -------------------------------------------- */
	 /** @override */
	async draw() {
		this.clear();
		 // Draw wall components
		this.directionIcon = this.data.dir ? this.addChild(this._drawDirection()) : null;
		this.line = this.addChild(new PIXI.Graphics());
		this.endpoints = this.addChild(new PIXI.Graphics());
		 // Draw current wall
		this.refresh();
		 // Enable interactivity, only if the Tile has a true ID
		if ( this.id ) this.activateListeners();
		return this;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_createInteractionManager() {
		const mgr = super._createInteractionManager();
		mgr.options.target = ["endpoints"];
		return mgr;
	}
	 /* -------------------------------------------- */
	 /** @override */
	activateListeners() {
		super.activateListeners();
		this.line.interactive = true;
		this.line.on("mouseover", this._onMouseOverLine, this)
						 .on("mouseout", this._onHoverOut, this);
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw a directional prompt icon for one-way walls to illustrate their direction of effect.
	 * @private
	 * @return {PIXI.Sprite}    The drawn icon
	 */
	_drawDirection() {
		if (this.directionIcon) this.removeChild(this.directionIcon);
		let d = this.data.dir;
		if ( !d ) return;
		 // Create the icon
		const icon = PIXI.Sprite.from("icons/svg/wall-direction.svg");
		icon.width = icon.height = 32;
		 // Rotate the icon
		let iconAngle = -Math.PI / 2;
		let angle = this.direction;
		icon.anchor.set(0.5, 0.5);
		icon.rotation = iconAngle + angle;
		return icon;
	}
	 /* -------------------------------------------- */
	 /** @override */
	refresh() {
		const p = this.coords;
		const mp = [(p[0] + p[2]) / 2, (p[1] + p[3]) / 2];
		const wc = this._getWallColor();
		 // Determine circle radius and line width
		let lw = 2;
		if ( canvas.dimensions.size > 150 ) lw = 4;
		else if ( canvas.dimensions.size > 100 ) lw = 3;
		const  cr = this._hover ? lw * 3 : lw * 2;
		let lw3 = lw * 3;
		 // Draw background
		this.line.clear()
			.lineStyle(lw3, 0x000000, 1.0)
			.moveTo(p[0], p[1])
			.lineTo(p[2], p[3]);
		this.endpoints.clear()
			.beginFill(0x000000, 1.0)
			.drawCircle(p[0], p[1], cr + lw)
			.drawCircle(p[2], p[3], cr + lw);
		 // Draw foreground
		this.line.lineStyle(lw, wc, 1.0)
			.lineTo(p[0], p[1]);
		this.endpoints.beginFill(wc, 1.0)
			.drawCircle(p[0], p[1], cr)
			.drawCircle(p[2], p[3], cr);
		 // Tint direction icon
		if ( this.directionIcon ) {
			this.directionIcon.position.set(...mp);
			this.directionIcon.tint = wc;
		}
		 // Update line hit area
		this.line.hitArea = this._getWallHitPolygon(p, lw3);
		// this.line.beginFill(0x00FF00, 1.0).drawShape(this.line.hitArea).endFill(); // Debug line hit area
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Compute an approximate Polygon which encloses the line segment providing a specific hitArea for the line
	 * @param {number[]} coords     The original wall coordinates
	 * @param {number} pad          The amount of padding to apply
	 * @return {PIXI.Polygon}       A constructed Polygon for the line
	 * @private
	 */
	_getWallHitPolygon(coords, pad) {
		 // Identify wall orientation
		const dx = coords[2] - coords[0];
		const dy = coords[3] - coords[1];
		 // Define the array of polygon points
		let points = [];
		if ( Math.abs(dx) >= Math.abs(dy) ) {
			const sx = Math.sign(dx);
			points = [
				coords[0]-(pad*sx), coords[1]-pad,
				coords[2]+(pad*sx), coords[3]-pad,
				coords[2]+(pad*sx), coords[3]+pad,
				coords[0]-(pad*sx), coords[1]+pad
			];
		} else {
			const sy = Math.sign(dy);
			points = [
				coords[0]-pad, coords[1]-(pad*sy),
				coords[2]-pad, coords[3]+(pad*sy),
				coords[2]+pad, coords[3]+(pad*sy),
				coords[0]+pad, coords[1]-(pad*sy)
			];
		}
		 // Return a Polygon which pads the line
		return new PIXI.Polygon(points);
	}
	 /* -------------------------------------------- */
	 /**
	 * Given the properties of the wall - decide upon a color to render the wall for display on the WallsLayer
	 * @private
	 */
	_getWallColor() {
		 // Invisible Walls
		if ( this.data.sense === CONST.WALL_SENSE_TYPES.NONE ) return 0x77E7E8;
		 // Terrain Walls
		else if ( this.data.sense === CONST.WALL_SENSE_TYPES.LIMITED ) return 0x81B90C;
		 // Ethereal Walls
		else if ( this.data.move === CONST.WALL_SENSE_TYPES.NONE ) return 0xCA81FF;
		 // Doors
		else if ( this.data.door === CONST.WALL_DOOR_TYPES.DOOR ) {
			let ds = this.data.ds || CONST.WALL_DOOR_STATES.CLOSED;
			if ( ds === CONST.WALL_DOOR_STATES.CLOSED ) return 0x6666EE;
			else if ( ds === CONST.WALL_DOOR_STATES.OPEN ) return 0x66CC66;
			else if ( ds === CONST.WALL_DOOR_STATES.LOCKED ) return 0xEE4444;
		}
		 // Secret Doors
		else if ( this.data.door === CONST.WALL_DOOR_TYPES.SECRET ) {
			let ds = this.data.ds || CONST.WALL_DOOR_STATES.CLOSED;
			if ( ds === CONST.WALL_DOOR_STATES.CLOSED ) return 0xA612D4;
			else if ( ds === CONST.WALL_DOOR_STATES.OPEN ) return 0x7C1A9b;
			else if ( ds === CONST.WALL_DOOR_STATES.LOCKED ) return 0xEE4444;
		}
		 // Standard Walls
		else return 0xFFFFBB;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onControl({chain=false}={}) {
		 // Add chained walls
		if ( chain ) {
			const links = this.getLinkedSegments();
			for ( let l of links.walls ) {
				l._controlled = true;
				this.layer._controlled[l.id] = l;
			}
		}
		 // Draw control highlights
		this.layer.highlightControlledSegments();
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onRelease() {
		this.layer.highlightControlledSegments();
	}
	 /* -------------------------------------------- */
	 /** @override */
	destroy(options) {
		if (this.data.door && this.doorControl) this.doorControl.destroy({children: true});
		super.destroy(options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Test whether the Wall direction lies between two provided angles
	 * This test is used for collision and vision checks against one-directional walls
	 * @param lower
	 * @param upper
	 * @return {boolean}
	 */
	isDirectionBetweenAngles(lower, upper) {
		let d = this.direction;
		if ( d < lower ) {
			while ( d < lower ) d += (2 * Math.PI);
		} else if ( d > upper ) {
			while ( d > upper ) d -= (2 * Math.PI);
		}
		return ( d > lower && d < upper );
	}
	 /* -------------------------------------------- */
	 /**
	 * A simple test for whether a Ray can intersect a directional wall
	 * @param {Ray} ray     The ray to test
	 * @return {boolean}    Can an intersection occur?
	 */
	canRayIntersect(ray) {
		if ( this.direction === null ) return true;
		return this.isDirectionBetweenAngles(ray.angle - (Math.PI/2), ray.angle + (Math.PI/2));
	}
	 /* -------------------------------------------- */
	 /**
	 * Get an Array of Wall objects which are linked by a common coordinate
	 * @returns {Object}    An object reporting ids and endpoints of the linked segments
	 */
	getLinkedSegments() {
		const test = new Set();
		const done = new Set();
		const ids = new Set();
		const objects = [];
		 // Helper function to add wall points to the set
		const _addPoints = w => {
			let p0 = w.coords.slice(0,2).join(".");
			if ( !done.has(p0) ) test.add(p0);
			let p1 = w.coords.slice(2,).join(".");
			if ( !done.has(p1) ) test.add(p1);
		};
		 // Helper function to identify other walls which share a point
		const _getWalls = p => {
			return canvas.walls.placeables.filter(w => {
				if ( ids.has(w.id) ) return false;
				let p0 = w.coords.slice(0,2).join(".");
				let p1 = w.coords.slice(2,).join(".");
				return ( p === p0 ) || ( p === p1 );
			})
		};
		 // Seed the initial search with this wall's points
		_addPoints(this);
		 // Begin recursively searching
		while ( test.size > 0 ) {
			const testIds = new Array(...test);
			for ( let p of testIds ) {
				let walls = _getWalls(p);
				walls.forEach(w => {
					_addPoints(w);
					if ( !ids.has(w.id) ) objects.push(w);
					ids.add(w.id);
				});
				test.delete(p);
				done.add(p);
			}
		}
		 // Return the wall IDs and their endpoints
		return {
			ids: new Array(...ids),
			walls: objects,
			endpoints: new Array(...done).map(p => p.split(".").map(Number))
		};
	}
	 /* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */
	 /** @override */
	_onCreate(...args) {
		super._onCreate(...args);
		this.layer._cloneType = duplicate(this.data);
		return this._onModifyWall(this.data.door !== CONST.WALL_DOOR_TYPES.NONE);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onUpdate(data, ...args) {
		super._onUpdate(data, ...args);
		 // Re-draw if the direction changed
		if ( data.hasOwnProperty("dir") ) this.draw();
		 // If the wall is controlled, update the highlighted segments
		if ( this._controlled ) {
			canvas.addPendingOperation("WallsLayer.highlightControlledSegments", this.layer.highlightControlledSegments, this.layer);
		}
		 // Downstream layer operations
		this.layer._cloneType = duplicate(this.data);
		 // // If the type of door or door state has changed also modify the door icon
		const rebuildEndpoints = ["move", "sense", "c"].some(k => k in data);
		const doorChange = (this.data.door > 0) || ("door" in data) || ("ds" in data);
		if ( rebuildEndpoints || doorChange ) return this._onModifyWall(doorChange);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDelete(...args) {
		super._onDelete(...args);
		const wasControlled = this._controlled;
		 // Clear last coordinates from the layer
		if ( this.layer.last.id === this.id ) this.layer.last.id = null;
		 // Release the deleted wall and update highlighted segments
		this.release();
		if ( wasControlled ) {
			canvas.addPendingOperation("WallsLayer.highlightControlledSegments", this.layer.highlightControlledSegments, this.layer);
		}
		 // Refresh the display
		return this._onModifyWall(false);
	}
	 /* -------------------------------------------- */
	 /**
	 * Callback actions when a wall that contains a door is moved or its state is changed
	 * @param {boolean} doorChange   Update vision and sound restrictions
	 * @private
	 */
	async _onModifyWall(doorChange=false) {
		 // Update WallsLayer data
		canvas.addPendingOperation("WallsLayer.initialize", this.layer.initialize, this.layer);
		 // Re-draw door icons
		if ( doorChange ) {
			const dt = this.data.door;
			const hasCtrl = (dt === CONST.WALL_DOOR_TYPES.DOOR) || ((dt === CONST.WALL_DOOR_TYPES.SECRET) && game.user.isGM);
			if ( hasCtrl ) {
				if ( this.doorControl ) this.doorControl.draw();
				else canvas.controls.createDoorControl(this);
			}
			else if ( this.doorControl ) {
				this.doorControl.parent.removeChild(this.doorControl);
				this.doorControl = null;
			}
		}
		 // Re-initialize perception
		canvas.addPendingOperation("WallsLayer.modifyWall", () => canvas.initializeSources(), this);
	}
	 /* -------------------------------------------- */
	/*  Interaction Event Callbacks                 */
	/* -------------------------------------------- */
	 /** @override */
	_canControl(user, event) {
		const isCtrl = game.keyboard.isCtrl(event);
		return !isCtrl;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onHoverIn(event, options) {
		this.zIndex = 1;
		if ( !this.layer._chain && event.data ) {
			const dest = event.data.getLocalPosition(this.layer);
			this.layer.last = {
				id: this.data._id,
				point: WallsLayer.getClosestEndpoint(dest, this)
			};
		}
		super._onHoverIn(event, options);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onHoverOut(event) {
		this.zIndex = 0;
		super._onHoverOut(event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle mouse-hover events on the line segment itself, pulling the Wall to the front of the container stack
	 * @private
	 */
	_onMouseOverLine(event) {
		event.stopPropagation();
		if ( this.layer.preview.children.length ) return;
		this.zIndex = 1;
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onClickLeft(event) {
		const oe = event.data.originalEvent;
		if ( this._controlled ) {
			if ( oe.shiftKey ) return this.release();
		}
		else return this.control({releaseOthers: !oe.shiftKey, chain: oe.altKey});
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onClickLeft2(event) {
		const sheet = this.sheet;
		const controlled = this.layer.controlled;
		if ( controlled.length > 1 ) sheet.options.editTargets = controlled.map(w => w.id);
		sheet.render(true);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onClickRight2(event) {
		return this._onClickLeft2(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftStart(event) {
		const { origin } = event.data;
		const dLeft = Math.hypot(origin.x - this.coords[0], origin.y - this.coords[1]);
		const dRight = Math.hypot(origin.x - this.coords[2], origin.y - this.coords[3]);
		event.data.fixed = dLeft < dRight ? 1 : 0; // Affix the opposite point
		return super._onDragLeftStart(event);
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftMove(event) {
		const {clones, destination, fixed, origin, originalEvent} = event.data;
		 // Pan the canvas if the drag event approaches the edge
		canvas._onDragCanvasPan(originalEvent);
		 // Group movement
		if ( clones.length > 1 ) {
			const dx = destination.x - origin.x;
			const dy = destination.y - origin.y;
			for ( let c of clones ) {
				c.data.c = c._original.data.c.map((p, i) => i % 2 ? p + dy : p + dx);
			}
		}
		 // Single-wall pivot
		else if ( clones.length === 1 ) {
			const w = clones[0];
			const pt = [destination.x, destination.y];
			w.data.c = fixed ? pt.concat(this.coords.slice(2,4)) : this.coords.slice(0, 2).concat(pt);
		}
		 // Refresh display
		clones.forEach(c => c.refresh());
	}
	 /* -------------------------------------------- */
	 /** @override */
	_onDragLeftDrop(event) {
		const {clones, destination, fixed, originalEvent} = event.data;
		const layer = this.layer;
		const snap = layer._forceSnap || !originalEvent.shiftKey;
		 // Get the snapped final point
		const pt = this.layer._getWallEndpointCoordinates(destination, {snap});
		 // Pivot a single wall
		if ( clones.length === 1 ) {
			const p0 = fixed ? this.coords.slice(2,4) : this.coords.slice(0,2);
			const coords = fixed ? pt.concat(p0) : p0.concat(pt);
			if ( (coords[0] === coords[2]) && (coords[1] === coords[3]) ) {
				return this.delete(); // If we collapsed the wall, delete it
			}
			this.layer.last.point = pt;
			return this.update({c: coords});
		}
		 // Drag a group of walls - snap to the end point maintaining relative positioning
		const p0 = fixed ? this.coords.slice(0,2) : this.coords.slice(2,4);
		const dx = pt[0] - p0[0];
		const dy = pt[1] - p0[1];
		const updates = clones.map(w => {
			const c = w._original.data.c;
			return {_id: w._original.id, c: [c[0]+dx, c[1]+dy, c[2]+dx, c[3]+dy]};
		});
		return canvas.scene.updateEmbeddedEntity("Wall", updates);
	}
}

const BLEND_MODES = {};

/**
 * Register a custom blend mode equation which chooses the maximum color from each channel within the stack.
 * @type {number[]}
 */
BLEND_MODES.MAX_COLOR = [
	WebGL2RenderingContext.ONE,
	WebGL2RenderingContext.ONE,
	WebGL2RenderingContext.ONE,
	WebGL2RenderingContext.ONE,
	WebGL2RenderingContext.MAX,
	WebGL2RenderingContext.MAX
];

/**
 * Register a custom blend mode equation which chooses the minimum color from each channel within the stack.
 * @type {number[]}
 */
BLEND_MODES.MIN_COLOR = [
	WebGL2RenderingContext.ONE,
	WebGL2RenderingContext.ONE,
	WebGL2RenderingContext.ONE,
	WebGL2RenderingContext.ONE,
	WebGL2RenderingContext.MIN,
	WebGL2RenderingContext.MAX
];

/**
 * This class defines an interface which all shaders utilize
 * @extends {PIXI.Shader}
 * @interface
 */
class AbstractBaseShader extends PIXI.Shader {
	constructor(program, uniforms) {
		super(program, duplicate(uniforms));
		 /**
		 * The initial default values of shader uniforms
		 * @type {object}
		 * @private
		 */
		this._defaults = uniforms;
	}
	 /**
	 * The default vertex shader used by all instances of AbstractBaseShader
	 * @type {string}
	 */
	static vertexShader = `
	precision mediump float;
	attribute vec2 aVertexPosition;
	attribute vec2 aUvs;
	uniform mat3 translationMatrix;
	uniform mat3 projectionMatrix;
	varying vec2 vUvs;
		void main() {
			vUvs = aUvs;
			gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
	}
	`;
	 /**
	 * The fragment shader which renders this source.
	 * A subclass of AbstractBaseShader must implement the fragmentShader static field.
	 * @type {string}
	 */
	static fragmentShader = "";
	 /**
	 * The default uniform values for the shader.
	 * A subclass of AbstractBaseShader must implement the defaultUniforms static field.
	 * @type {object}
	 */
	static defaultUniforms = {};
	 /**
	 * A factory method for creating the shader using its defined default values
	 * @return {AbstractBaseShader}
	 */
	static create(defaultUniforms) {
		const program = PIXI.Program.from(this.vertexShader, this.fragmentShader);
		const uniforms = mergeObject(this.defaultUniforms, defaultUniforms, { inplace: false, insertKeys: false });
		return new this(program, uniforms);
	}
	 /**
	 * Reset the shader uniforms back to their provided default values
	 * @private
	 */
	reset() {
		for (let [k, v] of Object.entries(this._defaults)) {
			this.uniforms[k] = v;
		}
	}
	 /* -------------------------------------------- */
	/*  GLSL Helper Functions                       */
	/* -------------------------------------------- */
	 /**
	 * A Vec3 pseudo-random generator, based on uv position
	 * @type {string}
	 */
	static PRNG3D = `
	vec3 random(in vec3 uv) {
		return vec3(fract(cos(dot(uv, vec3(12.9898,  234.1418,    152.01))) * 43758.5453),
								fract(sin(dot(uv, vec3(80.9898,  545.8937, 151515.12))) * 23411.1789),
								fract(cos(dot(uv, vec3(01.9898, 1568.5439,    154.78))) * 31256.8817));
	}`;
	 /* -------------------------------------------- */
	 /**
	 * A conventional pseudo-random number generator with the "golden" numbers, based on uv position
	 * @type {string}
	 */
	static PRNG = `
	float random(in vec2 uv) { 
	 return fract(cos(dot(uv, vec2(12.9898, 4.1414))) * 43758.5453);
	}`;
	 /* -------------------------------------------- */
	 /**
	 * A conventional noise generator
	 * @type {string}
	 */
	static NOISE = `
	float noise(in vec2 uv) {
	 const vec2 d = vec2(0.0, 1.0);
	 vec2 b = floor(uv);
	 vec2 f = smoothstep(vec2(0.), vec2(1.0), fract(uv));
	 return mix(
		 mix(random(b), random(b + d.yx), f.x), 
		 mix(random(b + d.xy), random(b + d.yy), f.x), 
		 f.y
	 );
	}`;
	 /* -------------------------------------------- */
	 /**
	 * Fractional Brownian Motion for a given number of octaves
	 * @type {string}
	 */
	static FBM(octaves = 4, amp = 1.0) {
		return `float fbm(in vec2 uv) {
			float total = 0.0, amp = ${amp.toFixed(1)};
			for (int i = 0; i < ${octaves}; i++) {
				total += noise(uv) * amp;
				uv += uv;
				amp *= 0.5;
			}
			return total;
		}`;
	}
	 /* -------------------------------------------- */
	 /**
	 * Fade easing to use with distance in interval [0,1]
	 * @type {string}
	 */
	static FADE(amp = 3, coef = 0.80) {
		return `float fade(in float dist) {
			float ampdist = dist;
			for (int i = 1; i < ${amp}; i++) {
				ampdist *= ampdist;
			}
			return 1.0 - (${coef.toFixed(2)} * ampdist * (${(amp + 1).toFixed(1)} - ${amp.toFixed(1)} * dist));
		}`;
	}
	 /* -------------------------------------------- */
	 /**
	 * TODO: FOR TESTING
	 * An alternative easing function which is partially linear followed by exponential falloff
	 * @param {number} slope    The slope of linear falloff
	 * @param {number} order    The order of polynomial falloff
	 */
	static FADE2(slope=0.2, order=4) {
		const a = slope.toFixed(2);
		const b = (1 - a).toFixed(2);
		return `float fade(in float dist) {
			float x = dist;
			for (int i=1; i<${order}; i++) {
				x *= x;
			}
			return 1.0 - (${a} * dist) - (${b} * x);
		}`;
	}
		/* -------------------------------------------- */
	 /**
	 * Convert a Hue-Saturation-Brightness color to RGB - useful to convert polar coordinates to RGB
	 * @type {string}
	 */
	static HSB2RGB = `
		vec3 hsb2rgb(in vec3 c) {
		vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0 );
		rgb = rgb*rgb*(3.0-2.0*rgb);
		return c.z * mix(vec3(1.0), rgb, c.y);
	}`;
}

/* -------------------------------------------- */

/**
 * The default coloration shader used by standard rendering and animations
 * A fragment shader which creates a solid light source.
 * @implements {AbstractBaseShader}
 */
class StandardIlluminationShader extends AbstractBaseShader {
	static fragmentShader = `
	precision mediump float;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 colorDim;
	uniform vec3 colorBright;
	varying vec2 vUvs;
		void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
			vec3 color = mix(colorDim, colorBright, step(dist, ratio));
			gl_FragColor = vec4(color * alpha, 1.0);
	}`;
	static defaultUniforms = {
		alpha: 1.0,
		ratio: 0.5,
		colorDim: [0.5, 0.5, 0.5],
		colorBright: [1.0, 1.0, 1.0],
		time: 0,
		intensity: 5
	}
}

/* -------------------------------------------- */

/**
 * The default coloration shader used by standard rendering and animations.
 * A fragment shader which creates a light source.
 * @implements {AbstractBaseShader}
 */
class StandardColorationShader extends AbstractBaseShader {
	static fragmentShader = `
	precision mediump float;
	uniform bool darkness;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;
		${AbstractBaseShader.FADE(3, 1)}
		
	void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
			vec3 fcolor = (darkness ? vec3(0.0) : color * fade(dist) * alpha);
			gl_FragColor = vec4(fcolor, 1.0);
	}`;
	static defaultUniforms = {
		alpha: 1.0,
		color: [1.0, 1.0, 1.0],
		time: 0,
		intensity: 5,
		darkness: false,
	}
}

/* -------------------------------------------- */

/**
 * Allow coloring of illumination 
 * @implements {StandardIlluminationShader}
 * @author SecretFire
 */
class TorchIlluminationShader extends StandardIlluminationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 colorDim;
	uniform vec3 colorBright;
	varying vec2 vUvs;
	 void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
			float fade = pow(1.0 - dist, 0.20);
			vec3 color = mix(colorDim, colorBright, step(dist, ratio));
			gl_FragColor = vec4(color * alpha * fade, 1.0);
	}`;
}

/* -------------------------------------------- */

/**
 * Torch animation coloration shader
 * @implements {StandardColorationShader}
 * @author SecretFire
 */
class TorchColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 color;
	varying vec2 vUvs;
		const float MU_TWOPI = 0.1591549431;
	 float torchfade(in float dist, in float fadepower) {
			return pow(clamp(1.0 - dist, 0.0, 1.0), fadepower);
	}
	 void main() {
			vec2 uv = (vUvs * 2.0) - 1.0;
			float dist = length(uv);
			
			// creating the central waving "starlight"
			float angle = atan(uv.x, uv.y) * MU_TWOPI;
			float flame = fract(angle * 64.0 + time);
			 // compose the flame, put smooth gradient on all "edges"
			float df = pow( abs(max(flame, 1.0 - flame)), 0.05);
			 // inner dancing flame distance
			float distr = dist / ratio * 0.75 / clamp(df, 0.1, 1.0);
			
			// maxing from coloration and the inner dancing flame
			gl_FragColor = vec4(max(color * torchfade(dist, 1.8),
								color * torchfade(distr, 1.2) * 1.5)
								* alpha, 1.0);
	}
	`;
	 static defaultUniforms = mergeObject(super.defaultUniforms, {
		ratio: 0,
	});
}

/* -------------------------------------------- */

/**
 * Pulse animation illumination shader
 * @implements {StandardIlluminationShader}
 * @author SecretFire
 */
class PulseIlluminationShader extends StandardIlluminationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 colorDim;
	uniform vec3 colorBright;
	varying vec2 vUvs;
	 void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
			float fade = pow(abs(1.0 - dist * dist), 1.01 - ratio);
			vec3 color = mix(colorDim, colorBright, step(dist, ratio));
			gl_FragColor = vec4(color * alpha * fade, 1.0);
	}`;
}

/* -------------------------------------------- */

/**
 * Pulse animation coloration shader
 * @implements {StandardColorationShader}
 * @author SecretFire
 */
class PulseColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float pulse;
	uniform vec3 color;
	varying vec2 vUvs;
	 float pfade(in float dist, in float pulse) {
			return pow(1.0 - dist, 1.25 - (pulse * 0.5));
	}
	 void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
			gl_FragColor = vec4(color * pfade(dist, pulse) * alpha, 1.0);
	}`;
	 static defaultUniforms = mergeObject(super.defaultUniforms, {
		pulse: 0,
	});
}

/* -------------------------------------------- */

/**
 * Energy field animation coloration shader
 * @implements {StandardColorationShader}
 * @author SecretFire
 */
class EnergyFieldColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;
	 ${AbstractBaseShader.PRNG3D}
	 // classic 3d voronoi (with some bug fixes)
	vec3 voronoi3d(const in vec3 x) {
			vec3 p = floor(x);
			vec3 f = fract(x);
		
			float id = 0.0;
			vec2 res = vec2(100.0);
		
			for (int k = -1; k <= 1; k++) {
				for (int j = -1; j <= 1; j++) {
					for (int i = -1; i <= 1; i++) {
					
						vec3 b = vec3(float(i), float(j), float(k));
						vec3 r = vec3(b) - f + random(p + b);
					
						float d = dot(r, r);
						float cond = max(sign(res.x - d), 0.0);
						float nCond = 1.0 - cond;
						float cond2 = nCond * max(sign(res.y - d), 0.0);
						float nCond2 = 1.0 - cond2;
		
						id = (dot(p + b, vec3(1.0, 67.0, 142.0)) * cond) + (id * nCond);
						res = vec2(d, res.x) * cond + res * nCond;
		
						res.y = cond2 * d + nCond2 * res.y;
					}
				}
			}
			// replaced abs(id) by pow( abs(id + 10.0), 0.01)
			// needed to remove artifacts in some specific configuration
			return vec3( sqrt(res), pow( abs(id + 10.0), 0.01) );
	}
	 void main() {
			vec2 uv = vUvs;
			float dist = distance(uv, vec2(0.5)) * 2.0;
		
			// Hemispherize and scaling the uv
			float f = (1.0 - sqrt(1.0 - dist)) / dist;
			uv -= vec2(0.5);
			uv *= f * 4.0 * intensity;
			uv += vec2(0.5);
		
			// time and uv motion variables
			float t = time * 0.4;
			float uvx = cos(uv.x - t);
			float uvy = cos(uv.y + t);
			float uvxt = cos(uv.x + sin(t));
			float uvyt = sin(uv.y + cos(t));
		
			// creating the voronoi 3D sphere, applying motion
			vec3 c = voronoi3d(vec3(uv.x - uvx + uvyt,
				mix(uv.x, uv.y, 0.5) + uvxt - uvyt + uvx,
				uv.y + uvxt - uvx));
		
			// applying color and contrast, to create sharp black areas.
			vec3 fcolor = c.x * c.x * c.x * color * color * 5.0;
		
			// abrupt fading
			float fade = pow(1.0 - dist, 0.20);
		
			gl_FragColor = vec4(fcolor * fade * alpha,1.0);
	}`;
}

/* -------------------------------------------- */

/**
 * Chroma animation coloration shader
 * @implements {StandardColorationShader}
 * @author SecretFire
 */
class ChromaColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;
	 ${AbstractBaseShader.FADE(3,1.0)}
	${AbstractBaseShader.HSB2RGB}
	 void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
			gl_FragColor = vec4( mix(
				color, 
				hsb2rgb( vec3(time * 0.25, 1.0, 1.0)), 
				intensity*0.1
			) * fade(dist) * alpha, 1.0 );
	}`;
}

/* -------------------------------------------- */

/**
 * Wave animation illumination shader
 * @implements {StandardIlluminationShader}
 * @author SecretFire
 */
class WaveIlluminationShader extends StandardIlluminationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 colorDim;
	uniform vec3 colorBright;
	varying vec2 vUvs;
	 const float MAX_INTENSITY = 1.1;
	const float MIN_INTENSITY = 0.8;
	 float wave(in float dist) {
			float sinWave = 0.5 * (sin(-time * 6.0 + dist * 10.0 * intensity) + 1.0);
			return ((MAX_INTENSITY - MIN_INTENSITY) * sinWave) + MIN_INTENSITY;
	}
	 void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
			vec3 color = mix(colorDim, colorBright, step(dist, ratio)) * wave(dist);
			gl_FragColor = vec4(color * alpha, 1.0);
	}`;
}

/* -------------------------------------------- */

/**
 * Wave animation coloration shader
 * @implements {StandardColorationShader}
 * @author SecretFire
 */
class WaveColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;
	 const float MAX_INTENSITY = 1.35;
	const float MIN_INTENSITY = 0.8;
	 ${AbstractBaseShader.FADE(3, 1.0)}
	 float wave(in float dist) {
			float sinWave = 0.5 * (sin(-time * 6.0 + dist * 10.0 * intensity) + 1.0);
			return ((MAX_INTENSITY - MIN_INTENSITY) * sinWave) + MIN_INTENSITY;
	}
	 void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
			gl_FragColor = vec4(color * fade(dist) * wave(dist) * alpha, 1.0) ;
	}`;
}

/* -------------------------------------------- */

/**
 * Fog animation coloration shader
 * @extends {StandardColorationShader}
 * @author SecretFire
 */
class FogColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	 uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;
	 ${AbstractBaseShader.PRNG}
	${AbstractBaseShader.NOISE}
	${AbstractBaseShader.FBM(4, 1.0)}
	${AbstractBaseShader.FADE(5, 1.0)}
	 vec3 fog() {
		// constructing the palette
		vec3 c1 = color * 0.20;
	 vec3 c2 = color * 0.80;
	 vec3 c3 = color * 0.15;
	 vec3 c4 = color * 0.85;
	 vec3 c5 = c3;
	 vec3 c6 = vec3(0.9);
		 // creating the deformation
		vec2 uv = vUvs;
	 vec2 p = uv.xy * 8.0;
		 // time motion fbm and palette mixing
	 float q = fbm(p - time * 0.1);
	 vec2 r = vec2(fbm(p + q - time * 0.5 - p.x - p.y), fbm(p + q - time * 0.3));
	 vec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);
		 // returning the color
	 return c;
	}
	 void main() {
			float intens = intensity * 0.2;
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
			 // applying fog
		 gl_FragColor = vec4(fog() * 1.25 * intens * fade(dist) * alpha, 1.0);
	}`;
}

/* -------------------------------------------- */

/**
 * Sunburst animation illumination shader
 * @extends {StandardIlluminationShader}
 * @author SecretFire
 */
class SunburstIlluminationShader extends StandardIlluminationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 colorDim;
	uniform vec3 colorBright;
	varying vec2 vUvs;
	const float MU_TWOPI = 0.1591549431;
	 // Smooth back and forth between a and b
	float cosTime(in float a, in float b) {
			return (a - b) * ((cos(time) + 1.0) * 0.5) + b;
	}
	 // Create the sunburst effect
	vec3 sunBurst(in vec3 color, in vec2 uv, in float dist) {
				// Pulse calibration
			float intensityMod = 1.0 + (intensity * 0.05);
			float lpulse = cosTime(1.3 * intensityMod, 0.85 * intensityMod);
		
			// Compute angle
			float angle = atan(uv.x, uv.y) * MU_TWOPI;
		
			// Creating the beams and the inner light
			float beam = fract(angle * 16.0 + time);
			float light = lpulse * pow(abs(1.0 - dist), 0.65);
		
			// Max agregation of the central light and the two gradient edges
			float sunburst = max(light, max(beam, 1.0 - beam));
		
			// Strong color correction, to desaturate the space between the beams.
			float correction = pow(abs(sunburst), 1.0 - dist);
		
			// Creating the effect : applying color and color correction. ultra saturate the entire output color.
			return smoothstep( 0.2, 1.1, sunburst * color * correction) * 10.0;
	}
	 void main() {
		vec2 uv = (2.0 * vUvs) - 1.0;
		float dist = length(uv);
		 // Linear interpolation between dim and bright, weighted by distance from center. Ratio is used to lighten color
		vec3 color = mix(colorDim, colorBright, 1.0 - dist) * (1.0 + ratio);
		 // Linear interpolation between color and max from color and sunburst, weighted by distance from center
		// the output is used as an illumination mask for the coloration shader. ratio influence luminosity.
		vec3 fcolor = mix(color, max(color, sunBurst(color, uv, dist)), 1.0 - dist) * alpha;
		gl_FragColor = vec4(fcolor, 1.0);
	}`;
}

/**
 * Sunburst animation coloration shader
 * @extends {StandardColorationShader}
 * @author SecretFire
 */
class SunburstColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;
	const float MU_TWOPI = 0.1591549431;
	 ${AbstractBaseShader.FADE(4, 1.0)}
	 // Smooth back and forth between a and b
	float cosTime(in float a, in float b) {
			return (a - b) * ((cos(time) + 1.0) * 0.5) + b;
	}
	 // Create a sun burst effect
	vec3 sunBurst(in vec2 uv, in float dist) {
		// pulse calibration
		float intensityMod = 1.0 + (intensity * 0.05);
		float lpulse = cosTime(1.1 * intensityMod, 0.85 * intensityMod);
		 // compute angle
		float angle = atan(uv.x, uv.y) * MU_TWOPI;
		
		// creating the beams and the inner light
		float beam = fract(angle * 16.0 + time);
		float light = lpulse * pow(abs(1.0 - dist), 0.65);
		
		// agregation of the central light and the two gradient edges to create the sunburst
		float sunburst = max(light, max(beam, 1.0 - beam));
		
		// strong color correction, to desaturate the space between the sunburst's beams.
		float correction = pow(abs(sunburst), dist * 2.0);
		
		// creating the effect : applying color and color correction. saturate the entire output color.
		return smoothstep( 0.2, 1.1, sunburst * color * correction) * 2.0;
	}
	 void main() {
		vec2 uvs = (2.0 * vUvs) - 1.0;
		float dist = length(uvs);
		gl_FragColor = vec4(sunBurst(uvs, dist) * fade(dist) * alpha, 1.0);
	}`;
}

/* -------------------------------------------- */

/**
 * Light dome animation coloration shader
 * @extends {StandardColorationShader}
 * @author SecretFire
 */
class LightDomeColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;
	const vec2 pivot = vec2(0.5);
	 // Rotate and scale uv
	vec2 transform(in vec2 uv, in float dist) {
		float hspherize = (1.0 - sqrt(1.0 - dist)) / dist;
		float t = time * 0.02;
		mat2 rotmat = mat2(cos(t), -sin(t), sin(t), cos(t));
		mat2 scalemat = mat2(8.0 * intensity, 0.0, 0.0, 8.0 * intensity);
		uv -= pivot; 
		uv *= rotmat * scalemat * hspherize;
		uv += pivot;
		return uv;
	}
	 ${AbstractBaseShader.PRNG}
	${AbstractBaseShader.NOISE}
	${AbstractBaseShader.FBM(2)}
		vec3 ripples(in vec2 uv) {
			// creating the palette
			vec3 c1 = color * 0.250;
			vec3 c2 = color * 0.001;
			vec3 c3 = vec3(0.02);
			vec3 c4 = color * 2.0;
			vec3 c5 = color * 0.005;
			vec3 c6 = color * 0.002;
			 vec2 p = uv + vec2(5.0);
			float q = 2.0 * fbm(p + time * 0.2);
			vec2 r = vec2(fbm(p + q + ( time  ) - p.x - p.y), fbm(p * 2.0 + ( time )));
		
			return color * (
					mix( c1, c2, abs(fbm(p + r)) ) + mix( c3, c4, abs(r.x * r.x * r.x) ) - mix( c5, c6, abs(r.y * r.y) )
			);
	}
	 void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
		
			// to hemispherize, rotate and magnify
			vec2 uv = transform(vUvs, dist);
			 // abrupt fade
			float fade = pow(1.0 - dist, 0.25);
		
			gl_FragColor = vec4(ripples(uv) * fade * alpha, 1.0);
	}`;
}

/* -------------------------------------------- */
	/**
 * Emanation animation coloration shader
 * @extends {StandardColorationShader}
 * @author SecretFire
 */
class EmanationColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;
	const float MU_TWOPI = 0.1591549431;
	 ${AbstractBaseShader.FADE(4, 1.0)}
	 // Create an emanation composed of n beams, n = intensity
	vec3 beamsEmanation(in vec2 uv, in float dist) {
			float angle = atan(uv.x, uv.y) * MU_TWOPI;
			 // create the beams
			float beams = fract( angle * intensity + sin(dist * 10.0 - time));
			 // compose the final beams with max, to get a nice gradient on EACH side of the beams.
			beams = max(beams, 1.0 - beams);
			 // compute a strong color correction, to desaturate the space between the beams.
			float colorburn = pow(beams, dist * 2.0);
			 // creating the effect : applying color and color correction. saturate the entire output color.
			return smoothstep( 0.2, 1.1, beams * color * colorburn) * 3.0;
	}
	 void main() {
			// compute uvs and distance
			vec2 uvs = (2.0 * vUvs) - 1.0;
			float dist = length(uvs);
			 // apply beams emanation, fade and alpha
			gl_FragColor = vec4(beamsEmanation(uvs, dist) * fade(dist) * alpha, 1.0);
	}`;
}

/* -------------------------------------------- */
	/**
 * Ghost light animation illumination shader
 * @extends {StandardIlluminationShader}
 * @author SecretFire
 */
class GhostLightIlluminationShader extends StandardIlluminationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 colorDim;
	uniform vec3 colorBright;
	varying vec2 vUvs;
	const float PI = 3.1415927;
	 ${AbstractBaseShader.PRNG}
	${AbstractBaseShader.NOISE}
	${AbstractBaseShader.FBM(3, 1.0)}
	 void main() {
		
			// Creating distortion with vUvs and fbm
			float distortion1 = fbm(vec2( 
					fbm(vUvs * 5.0 - time * 0.50), 
					fbm((-vUvs - vec2(0.01)) * 5.0 + time * 0.3333334)
			));
		
			float distortion2 = fbm(vec2(
				fbm(-vUvs * 5.0 - time * 0.50),
				fbm((-vUvs + vec2(0.01)) * 5.0 + time * 0.3333334)
			));
			vec2 uv = vUvs;
			
			// time related var
			float t = time * 0.5;
			float tcos = 0.5 * (0.5 * (cos(t)+1.0)) + 0.25;
			float tsin = 0.5 * (0.5 * (sin(t)+1.0)) + 0.25;
		
			// Creating distortions with cos and sin : create fluidity
			vec2 pivot = vec2(0.5);
			uv.x += 0.8 * sin(mix(distortion1 * 0.1, distortion2 * 0.1, tsin));
			uv.y -= 0.8 * cos(mix(distortion1 * 0.1, distortion2 * 0.1, tcos));
			uv -= pivot;
			uv *= 1.13 + 0.9 *(cos(sqrt(mix(distortion1, distortion2,0.5)) +1.0) * 0.5);
			uv += pivot;
			uv -= vec2(0.049,-0.827); 
			 float dist = distance(uv, vec2(0.5)) * 2.0;
			vec3 color = mix(colorDim, colorBright, step(dist, ratio));
			gl_FragColor = vec4(color * alpha * mix(
				distortion1 * 1.5 * (intensity * 0.2),
				distortion2 * 1.5 * (intensity * 0.2), tcos
			), 1.0);
	}`;
}

/* -------------------------------------------- */

/**
 * Ghost light animation coloration shader
 * @extends {StandardIlluminationShader}
 * @author SecretFire
 */
class GhostLightColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;
	const float PI = 3.1415927;
	 ${AbstractBaseShader.PRNG}
	${AbstractBaseShader.NOISE}
	${AbstractBaseShader.FBM(3, 1.0)}
	 void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;

			// Creating distortion with vUvs and fbm
			float distortion1 = fbm(vec2( 
					fbm(vUvs * 3.0 + time * 0.50), 
					fbm((-vUvs + vec2(1.)) * 5.0 + time * 0.3333334)
			));

			float distortion2 = fbm(vec2(
				fbm(-vUvs * 3.0 + time * 0.50),
				fbm((-vUvs + vec2(1.)) * 5.0 - time * 0.3333334)
			));
			vec2 uv = vUvs;
			
			// time related var
			float t = time * 0.5;
			float tcos = 0.5 * (0.5 * (cos(t)+1.0)) + 0.25;
			float tsin = 0.5 * (0.5 * (sin(t)+1.0)) + 0.25;
		
			// Creating distortions with cos and sin : create fluidity
			vec2 pivot = vec2(0.5);
			uv -= pivot;
			uv *= tcos*distortion1;
			uv *= tsin*distortion2;
			uv *= fbm(vec2(time + distortion1, time + distortion2));
			uv += pivot;
			 vec3 fcolor = distortion1 * distortion1 * 
										distortion2 * distortion2 * 
										color * pow(1.0 - dist, dist);

			gl_FragColor = vec4(fcolor * alpha * mix(
				uv.x + distortion1 * 4.5 * (intensity * 0.2),
				uv.y + distortion2 * 4.5 * (intensity * 0.2), tcos
			), 1.0);
	}`;
}

/* -------------------------------------------- */

/**
 * Hexagonal dome animation coloration shader
 * @extends {StandardColorationShader}
 * @author SecretFire
 */
class HexaDomeColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;
	const vec2 pivot = vec2(0.5);
	 // rotate and scale uv
	vec2 transform(in vec2 uv, in float dist) {
		float hspherize = (1.0 - sqrt(1.0 - dist)) / dist;
		float t = -time * 0.20;
		float scale = 10.0 / (11.0 - intensity);
		float cost = cos(t);
		float sint = sin(t);
		 mat2 rotmat = mat2(cost, -sint, sint, cost);
		mat2 scalemat = mat2(scale, 0.0, 0.0, scale);
		uv -= pivot; 
		uv *= rotmat * scalemat * hspherize;
		uv += pivot;
		return uv;
	}
	 // Adapted classic hexa algorithm
	float hexDist(in vec2 uv) {
	 vec2 p = abs(uv);
		float c = dot(p, normalize(vec2(1.0, 1.73)));
		c = max(c, p.x);
		return c;
	}
	 vec4 hexUvs(in vec2 uv) {
	const vec2 r = vec2(1.0, 1.73);
		const vec2 h = r*0.5;
		
		vec2 a = mod(uv, r) - h;
		vec2 b = mod(uv - h, r) - h;
		vec2 gv = dot(a, a) < dot(b,b) ? a : b;
		
		float x = atan(gv.x, gv.y);
		float y = 0.55 - hexDist(gv);
		vec2 id = uv - gv;
		return vec4(x, y, id.x, id.y);
	}
	 vec3 hexa(in vec2 uv) {
		float t = time;
		vec2 uv1 = uv + vec2(0.0, sin(uv.y) * 0.25);
		vec2 uv2 = 0.5 * uv1 + 0.5 * uv + vec2(0.55, 0);
		float a = 0.2;
		float c = 0.5;
		float s = -1.0;
		uv2 *= mat2(c, -s, s, c);
		 vec3 col = color;
		float hexy = hexUvs(uv2 * 10.0).y;
		float hexa = smoothstep( 3.0 * (cos(t)) + 4.5, 12.0, hexy * 20.0) * 3.0;
		 col *= mix(hexa, 1.0 - hexa, min(hexy, 1.0 - hexy));
		col += color * fract(smoothstep(1.0, 2.0, hexy * 20.0)) * 0.65;
		 return col;
	}
	 void main() {
		float dist = distance(vUvs, vec2(0.5)) * 2.0;
		 // Rotate, magnify and hemispherize the uvs
		vec2 uv = transform(vUvs, dist);
		 // Very abrupt fading
		float fade = pow(1.0 - dist, 0.18);
		
		// Hexaify the uv (hemisphere) and apply fade and alpha
		gl_FragColor = vec4(hexa(uv) * 2.0 * fade * alpha, 1.0);
	}`;
}

/* -------------------------------------------- */

/**
 * Roling mass illumination shader - intended primarily for darkness
 * @extends {StandardIlluminationShader}
 * @author SecretFire
 */
class RoilingIlluminationShader extends StandardIlluminationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 colorDim;
	uniform vec3 colorBright;
	varying vec2 vUvs;
	const float PI = 3.1415927;
	 ${AbstractBaseShader.PRNG}
	${AbstractBaseShader.NOISE}
	${AbstractBaseShader.FBM(3)}
	 void main() {
		
		// Creating distortion with vUvs and fbm
		float distortion1 = fbm(vec2( 
			fbm(vUvs * 2.5 + time*0.5),
			fbm( (-vUvs - vec2(0.01)) * 5. + time*0.3333334))
		);
		
		float distortion2 = fbm(vec2(
			fbm(-vUvs * 5. + time*0.5),
			fbm((vUvs + vec2(0.01)) * 2.5 + time*0.3333334))
		);
		
		// Amplify distortions
		vec2 uv = vUvs;
		vec2 pivot = vec2(0.5);
		uv.x += 0.8*sin(min(distortion1*0.1,distortion2*0.1));
		uv.y += 0.8*cos(min(distortion1*0.1,distortion2*0.1));
		uv -= pivot;
		uv *= 1.13 + 0.90*(cos(sqrt(max(distortion1, distortion2))+1.)*0.5);
		uv += pivot;
		uv -= vec2(0.04,0.830); 
		 float alphaBright,alphaDim;
		float dist = distance(uv, vec2(0.5)) * 2.0;
		
		// Creating the red spooky membrane around the bright darkness
		if (dist > (ratio - 0.003) && dist < (ratio + 0.003)) {
			float n = ((ratio + 0.003) * 5.0 - dist * 5.0);
			float glow = pow(n, 0.8);
			gl_FragColor = vec4( vec3(2.0,0.0,2.0) * glow, 1.0); 
			return;
		}
		
		// Intensity modifier
		alphaBright = 1.0 - pow(clamp(ratio - dist, 0.0, 1.0), 0.75) * sqrt(2.0 - dist);
		alphaDim = 1.0 - pow(clamp(1.0 - dist, 0.0, 1.0), 0.65);
		float intensMod = (11.0-intensity) * 0.5;
		 // Darkness control by intensity
		vec3 color = mix(colorDim * intensMod, colorBright * intensMod, step(dist, ratio));
		gl_FragColor = vec4(color * min(alphaBright, alphaDim) * alpha, 1.0);
	}`;
}

/* -------------------------------------------- */

/**
 * Black Hole animation illumination shader
 * @extends {StandardIlluminationShader}
 * @author SecretFire
 */
class BlackHoleIlluminationShader extends StandardIlluminationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 colorBright;
	uniform vec3 colorDim;
	varying vec2 vUvs;
	const float MU_TWOPI = 0.1591549431;
	 // create an emanation composed of n beams, n = intensity
	vec3 beamsEmanation(in vec2 uv, in float dist, in vec3 pCol) {
		float angle = atan(uv.x, uv.y) * MU_TWOPI;
		 // Create the beams
		float beams = fract(angle * intensity + sin(dist * 30.0 - time));
		 // Compose the final beams and reverse beams, to get a nice gradient on EACH side of the beams.
		beams = max(beams, 1.0 - beams);
		 // Compute a darkness modifier.
		float darknessPower = pow(beams, 1.5);
		 // Creating the effect : applying color and darkness power correction. saturate the entire output color.
		return smoothstep(0.2, 1.1 + (intensity * 0.1), beams * pCol * darknessPower) * intensity;
	}
	 void main() {
		// compute uvs and distance
		vec2 uvs = (2.0 * vUvs) - 1.0;
		float dist = length(uvs);
		
		// palette of colors to give the darkness a disturbing purpleish tone
		vec3 pColorDim    = vec3(0.25, 0.10, 0.35);
		vec3 pColorBright = vec3(0.85, 0.80, 0.95);
		
		// smooth mixing of the palette by distance from center and bright ratio
		vec3 pCol = mix(pColorDim, pColorBright, smoothstep(ratio * 0.5, ratio * 1.5, dist));
		
		// Apply darker components of colorDim and mixed emanations/colorBright.
		gl_FragColor = vec4(min(colorDim, 
			mix(colorBright, beamsEmanation(uvs, dist, pCol), 1.0 - sqrt(1.0 - dist))
		 ) * alpha, 1.0);
	}`;
}

/**
 * A single Mouse Cursor
 * @type {PIXI.Container}
 */
class Cursor extends PIXI.Container {
	constructor(user) {
		super();
		this.target = {x: 0, y: 0};
		this.draw(user);
		 // Register and add animation
		canvas.app.ticker.add(this._animate, this);
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the user's cursor as a small dot with their user name attached as text
	 */
	draw(user) {
		 // Cursor dot
		const d = this.addChild(new PIXI.Graphics());
		const color = user.data.color.replace("#", "0x") || 0x42F4E2;
		d.beginFill(color, 0.35).lineStyle(1, 0x000000, 0.5).drawCircle(0, 0, 6);
		 // Player name
		const style = CONFIG.canvasTextStyle.clone();
		style.fontSize = 14;
		let n = this.addChild(new PreciseText(user.name, style));
		n.x -= n.width / 2;
		n.y += 10;
	}
	 /* -------------------------------------------- */
	 /**
	 * Move an existing cursor to a new position smoothly along the animation loop
	 */
	_animate() {
		let dy = this.target.y - this.y,
				dx = this.target.x - this.x;
		if ( Math.abs( dx ) + Math.abs( dy ) < 10 ) return;
		this.x += dx / 10;
		this.y += dy / 10;
	}
	 /* -------------------------------------------- */
	 /**
	 * Remove the cursor update from the animation loop and destroy the container.
	 * @param options {Object}      Additional options passed to the parent ``PIXI.Container.destroy()`` method
	 */
	destroy(options) {
		canvas.app.ticker.remove(this._animate, this);
		super.destroy(options);
	}
}

/**
 * An icon representing a Door Control
 * @extends {PIXI.Container}
 */
class DoorControl extends PIXI.Container {
	constructor(wall) {
		super();
		this.wall = wall;
		this.wall.doorControl = this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the DoorControl icon, displaying it's icon texture and border
	 * @return {Promise<DoorControl>}
	 */
	async draw() {
		 // Remove existing components
		this.icon = this.icon || this.addChild(new PIXI.Sprite());
		this.icon.width = this.icon.height = 40;
		this.icon.alpha = 0.6;
		this.icon.texture = await this._getTexture();
		 // Background
		this.bg = this.bg || this.addChild(new PIXI.Graphics());
		this.bg.clear().beginFill(0x000000, 1.0).drawRoundedRect(-2, -2, 44, 44, 5).endFill();
		this.bg.alpha = 0;
		 // Border
		this.border = this.border || this.addChild(new PIXI.Graphics());
		this.border.clear().lineStyle(1, 0xFF5500, 0.8).drawRoundedRect(-2, -2, 44, 44, 5).endFill();
		this.border.visible = false;
		 // Add control interactivity
		this.interactive = true;
		this.interactiveChildren = false;
		this.hitArea = new PIXI.Rectangle(-2, -2, 44, 44);
		 // Set position
		this.reposition();
		this.alpha = 1.0;
		 // Activate listeners
		this.removeAllListeners();
		this.on("mouseover", this._onMouseOver)
				.on("mouseout", this._onMouseOut)
				.on("mousedown", this._onMouseDown)
				.on('rightdown', this._onRightDown);
		 // Return the control icon
		return this;
	}
		/* -------------------------------------------- */
	 /**
	 * Get the icon texture to use for the Door Control icon based on the door state
	 * @type {string}
	 */
	async _getTexture() {
		let s = this.wall.data.ds;
		const ds = CONST.WALL_DOOR_STATES;
		if ( !game.user.isGM && s === ds.LOCKED ) s = ds.CLOSED;
		const textures = {
			[ds.LOCKED]: 'icons/svg/padlock.svg',
			[ds.CLOSED]: 'icons/svg/door-steel.svg',
			[ds.OPEN]: 'icons/svg/door-exit.svg'
		};
		return getTexture(textures[s] || ds.CLOSED);
	}
	 /* -------------------------------------------- */
	 reposition() {
		let pos = this.wall.midpoint.map(p => p - 20);
		this.position.set(...pos);
	}
	 /* -------------------------------------------- */
	 /**
	 * Determine whether the DoorControl is visible to the calling user's perspective.
	 * The control is always visible if the user is a GM and no Tokens are controlled.
	 * @see {SightLayer#testVisibility}
	 * @type {boolean}
	 */
	get isVisible() {
		if ( (this.wall.data.door === CONST.WALL_DOOR_TYPES.SECRET) && !game.user.isGM ) return false;
		const [x, y] = this.wall.midpoint;
		const point = new PIXI.Point(x, y);
		return canvas.sight.testVisibility(point, {tolerance: 2, object: this});
	}
	 /* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */
	 _onMouseOver(ev) {
		ev.stopPropagation();
		const canControl = game.user.can("WALL_DOORS");
		const blockPaused = game.paused && !game.user.isGM;
		if ( !canControl || blockPaused ) return false;
		this.border.visible = true;
		this.icon.alpha = 1.0;
		this.bg.alpha = 0.25;
		canvas.walls._hover = this.wall;
	}
	 /* -------------------------------------------- */
	 _onMouseOut(ev) {
		ev.stopPropagation();
		if ( game.paused && !game.user.isGM ) return false;
		this.border.visible = false;
		this.icon.alpha = 0.6;
		this.bg.alpha = 0;
		canvas.walls._hover = null;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle left mouse down events on the door control icon.
	 * This should only toggle between the OPEN and CLOSED states.
	 * @param event
	 * @private
	 */
	_onMouseDown(event) {
		event.stopPropagation();
		const state = this.wall.data.ds;
		const states = CONST.WALL_DOOR_STATES;
		 // Determine whether the player can control the door at this time
		if ( !game.user.can("WALL_DOORS") ) return false;
		if ( game.paused && !game.user.isGM ) {
			ui.notifications.warn(game.i18n.localize("GAME.PausedWarning"));
			return false;
		}
		 // Play an audio cue for locked doors
		if ( state === states.LOCKED ) {
			AudioHelper.play({src: CONFIG.sounds.lock});
			return false;
		}
		 // Toggle between OPEN and CLOSED states
		this.wall.update({ds: state === states.CLOSED ? states.OPEN : states.CLOSED});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle right mouse down events on the door control icon
	 * This should toggle whether the door is LOCKED or CLOSED
	 * @param event
	 * @private
	 */
	_onRightDown(event) {
		event.stopPropagation();
		if ( !game.user.isGM ) return;
		let state = this.wall.data.ds,
				states = CONST.WALL_DOOR_STATES;
		if ( state === states.OPEN ) return;
		state = state === states.LOCKED ? states.CLOSED : states.LOCKED;
		this.wall.update({ds: state});
	}
}
	/**
 * A CanvasLayer for displaying UI controls which are overlayed on top of other layers.
 *
 * We track three types of events:
 * 1) Cursor movement
 * 2) Ruler measurement
 * 3) Map pings
 */
class ControlsLayer extends CanvasLayer {
	constructor() {
		super();
		 /**
		 * Cursor position indicators
		 * @type {PIXI.Container}
		 */
		this.cursors = null;
		 /**
		 * A mapping of user IDs to Cursor instances for quick access
		 * @type {Object}
		 */
		this._cursors = {};
		 /**
		 * Door control icons
		 * @type {PIXI.Container|null}
		 */
		this.doors = null;
		 /**
		 * Status effect icons
		 */
		this.effects = null;
		 /**
		 * Ruler tools, one per connected user
		 * @type {PIXI.Container}
		 */
		this.rulers = null;
		 /**
		 * A convenience mapping of user IDs to Ruler instances for quick access
		 * @type {Object}
		 */
		this._rulers = {};
		 /**
		 * Canvas selection rectangle
		 * @type {PIXI.Graphics}
		 */
		this.select = null;
		 // The controls layer is always interactive
		this.interactiveChildren = true;
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get layerOptions() {
		return mergeObject(super.layerOptions, { zIndex: 400 });
	}
	 /* -------------------------------------------- */
	/*  Properties and Public Methods               */
	/* -------------------------------------------- */
	 /**
	 * A convenience accessor to the Ruler for the active game user
	 * @type {Ruler}
	 */
	get ruler() {
		return this.getRulerForUser(game.user._id);
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the Ruler display for a specific User ID
	 * @param {string} userId
	 * @return {Ruler|null}
	 */
	getRulerForUser(userId) {
		return this._rulers[userId] || null;
	}
		/* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */
	 /** @override */
	draw() {
		this.drawCursors();
		this.drawDoors();
		this.drawRulers();
		this.select = this.addChild(new PIXI.Graphics());
		this.debug = this.addChild(new PIXI.Graphics());
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the cursors container
	 */
	drawCursors() {
		if ( this.cursors ) {
			this.cursors.destroy({children: true});
			this.cursors = null;
		}
		this.cursors = this.addChild(new PIXI.Container());
		for ( let u of game.users.entities.filter(u => u.active && u._id !== game.user._id ) ) {
			this.drawCursor(u);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the Door controls container
	 */
	drawDoors() {
		 // Create the container
		if ( this.doors ) this.doors.destroy({children: true});
		this.doors = this.addChild(new PIXI.Container());
		 // Iterate over all walls, selecting the doors
		for ( let w of canvas.walls.placeables ) {
			this.createDoorControl(w);
		}
		 // Toggle visibility for the set of door control icons
		this.doors.visible = !canvas.walls._active;
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a Door Control icon for a given Wall object
	 * @param {Wall} wall           The Wall for which to create a DoorControl
	 * @return {DoorControl|null}   The created DoorControl
	 */
	createDoorControl(wall) {
		if ( wall.data.door === CONST.WALL_DOOR_TYPES.NONE ) return null;
		if (( wall.data.door === CONST.WALL_DOOR_TYPES.SECRET ) && !game.user.isGM ) return null;
		const dc = this.doors.addChild(new DoorControl(wall));
		dc.visible = false;
		return dc.draw();
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw Ruler tools
	 */
	drawRulers() {
		this.rulers = this.addChild(new PIXI.Container());
		for (let u of game.users.entities) {
			let ruler = new Ruler(u);
			this._rulers[u._id] = this.rulers.addChild(ruler);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the select rectangle given an event originated within the base canvas layer
	 * @param {Object} coords   The rectangle coordinates of the form {x, y, width, height}
	 */
	drawSelect({x, y, width, height}) {
		const s = this.select.clear();
		s.lineStyle(3, 0xFF9829, 0.9).drawRect(x, y, width, height);
	}
	 /* -------------------------------------------- */
	 /** @override */
	deactivate() {
		super.deactivate();
		this.visible = true;
		this.interactiveChildren = true;
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */
	 /**
	 * Handle mousemove events on the game canvas to broadcast activity of the user's cursor position
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onMoveCursor(event) {
		const sc = game.user.hasPermission("SHOW_CURSOR");
		const sr = game.user.hasPermission("SHOW_RULER");
		if ( !sc && !sr ) return;
		 // Throttle cursor position updates to 100ms per tick
		const now = Date.now();
		if ( (now - event.data._cursorTime) < 100 ) return;
		event.data._cursorTime = now;
		 // Show cursor position
		const position = sr ? event.data.getLocalPosition(this) : null;
		 // Determine the ruler update
		const ruler = sr && (this.ruler._state > 0) ? this.ruler.toJSON() : null;
		 // Submit the activity update
		game.user.broadcastActivity({
			cursor: position,
			ruler: ruler
		});
	}
	 /* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */
	 /**
	 * Create and draw the Cursor object for a given User
	 * @param user {User}   The User entity for whom to draw the cursor Container
	 */
	drawCursor(user) {
		if ( user._id in this._cursors ) {
			this._cursors[user._id].destroy({children: true});
			delete this._cursors[user._id];
		}
		return this._cursors[user._id] = this.cursors.addChild(new Cursor(user));
	}
	 /* -------------------------------------------- */
	 /**
	 * Update the cursor when the user moves to a new position
	 */
	updateCursor(user, position) {
		if ( !this.cursors ) return;
		const cursor = this._cursors[user._id] || this.drawCursor(user);
		 // Ignore cursors on other Scenes
		if ( ( position === null ) || (user.viewedScene !== canvas.scene._id) ) {
			if ( cursor ) cursor.visible = false;
			return;
		}
		 // Ignore cursors for users who are not permitted to share
		if ( (user === game.user) || !user.hasPermission("SHOW_CURSOR") ) {
			if ( cursor ) cursor.visible = false;
				return;
		}
		 // Show the cursor in its currently tracked position
		cursor.visible = true;
		cursor.target = {x: position.x || 0, y: position.y || 0};
	}
	 /* -------------------------------------------- */
	 /**
	 * Update display of an active Ruler object for a user given provided data
	 * @param {User} user
	 * @param {Object} rulerData
	 */
	updateRuler(user, rulerData) {
		 // Ignore rulers for users who are not permitted to share
		if ( (user === game.user) || !user.hasPermission("SHOW_RULER") ) return;
		 // Update the Ruler display for the user
		let ruler = this.getRulerForUser(user.id);
		if ( !ruler ) return;
		if ( rulerData === null ) ruler.clear();
		else ruler.update(rulerData);
	}
}

/**
 * The Ruler - used to measure distances and trigger movements
 * @param {User}  The User for whom to construct the Ruler instance
 * @type {PIXI.Container}
 */
class Ruler extends PIXI.Container {
	constructor(user, {color=null}={}) {
		super();
		user = user || game.user;
		 /**
		 * Record the User which this Ruler references
		 * @type {User}
		 */
		this.user = user;
		 /**
		 * The ruler name - used to differentiate between players
		 * @type {string}
		 */
		this.name = `Ruler.${user._id}`;
		 /**
		 * The ruler color - by default the color of the active user
		 * @type {number|null}
		 */
		this.color = color || colorStringToHex(this.user.data.color) || 0x42F4E2;
		 /**
		 * This Array tracks individual waypoints along the ruler's measured path.
		 * The first waypoint is always the origin of the route.
		 * @type {Array.<PIXI.Point>}
		 */
		this.waypoints = [];
		 /**
		 * The current destination point at the end of the measurement
		 * @type {PIXI.Point}
		 */
		this.destination = null;
		 /**
		 * The Ruler element is a Graphics instance which draws the line and points of the measured path
		 * @type {PIXI.Graphics}
		 */
		this.ruler = this.addChild(new PIXI.Graphics());
		 /**
		 * The Labels element is a Container of Text elements which label the measured path
		 * @type {PIXI.Container}
		 */
		this.labels = this.addChild(new PIXI.Container());
		 /**
		 * Track the current measurement state
		 * @type {number}
		 */
		this._state = Ruler.STATES.INACTIVE;
	}
	 /* -------------------------------------------- */
	 /**
	 * Is the Ruler being actively used to measure distance?
	 * @return {boolean}
	 */
	get active() {
		return this.waypoints.length > 0;
	}
	 /* -------------------------------------------- */
	 /**
	 * Measure the distance between two points and render the ruler UI to illustrate it
	 * @param {PIXI.Point} destination  The destination point to which to measure
	 * @param {boolean} gridSpaces      Restrict measurement only to grid spaces
	 */
	measure(destination, {gridSpaces=true}={}) {
		destination = new PIXI.Point(...canvas.grid.getCenter(destination.x, destination.y));
		const waypoints = this.waypoints.concat([destination]);
		const r = this.ruler;
		this.destination = destination;
		 // Iterate over waypoints and construct segment rays
		const segments = [];
		for ( let [i, dest] of waypoints.slice(1).entries() ) {
			const origin = waypoints[i];
			const label = this.labels.children[i];
			const ray = new Ray(origin, dest);
			if ( ray.distance < 10 ) {
				if ( label ) label.visible = false;
				continue;
			}
			segments.push({ray, label});
		}
		 // Compute measured distance
		const distances = canvas.grid.measureDistances(segments, {gridSpaces});
		let totalDistance = 0;
		for ( let [i, d] of distances.entries() ) {
			totalDistance += d;
			let s = segments[i];
			s.last = i === (segments.length - 1);
			s.distance = d;
			s.text = this._getSegmentLabel(d, totalDistance, s.last);
		}
		 // Clear the grid highlight layer
		const hlt = canvas.grid.highlightLayers[this.name] || canvas.grid.addHighlightLayer(this.name);
		hlt.clear();
		 // Draw measured path
		r.clear();
		for ( let s of segments ) {
			const {ray, label, text, last} = s;
			 // Draw line segment
			r.lineStyle(6, 0x000000, 0.5).moveTo(ray.A.x, ray.A.y).lineTo(ray.B.x, ray.B.y)
			 .lineStyle(4, this.color, 0.25).moveTo(ray.A.x, ray.A.y).lineTo(ray.B.x, ray.B.y);
			 // Draw the distance label just after the endpoint of the segment
			if ( label ) {
				label.text = text;
				label.alpha = last ? 1.0 : 0.5;
				label.visible = true;
				let labelPosition = ray.project((ray.distance + 50) / ray.distance);
				label.position.set(labelPosition.x, labelPosition.y);
			}
			 // Highlight grid positions
			this._highlightMeasurement(ray);
		}
		 // Draw endpoints
		for ( let p of waypoints ) {
			r.lineStyle(2, 0x000000, 0.5).beginFill(this.color, 0.25).drawCircle(p.x, p.y, 8);
		}
		 // Return the measured segments
		return segments;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the text label for a segment of the measured path
	 * @param {number} segmentDistance
	 * @param {number} totalDistance
	 * @param {boolean} isTotal
	 * @return {string}
	 * @private
	 */
	_getSegmentLabel(segmentDistance, totalDistance, isTotal) {
		const units = canvas.scene.data.gridUnits;
		let label = `${Math.round(segmentDistance * 100) / 100} ${units}`;
		if ( isTotal ) {
			label += ` [${Math.round(totalDistance * 100) / 100} ${units}]`;
		}
		return label;
	}
	 /* -------------------------------------------- */
	 /**
	 * Highlight the measurement required to complete the move in the minimum number of discrete spaces
	 * @param {Ray} ray
	 * @private
	 */
	_highlightMeasurement(ray) {
		const spacer = canvas.scene.data.gridType === CONST.GRID_TYPES.SQUARE ? 1.41 : 1;
		const nMax = Math.max(Math.floor(ray.distance / (spacer * Math.min(canvas.grid.w, canvas.grid.h))), 1);
		const tMax = Array.fromRange(nMax+1).map(t => t / nMax);
		 // Track prior position
		let prior = null;
		 // Iterate over ray portions
		for ( let [i, t] of tMax.entries() ) {
			let {x, y} = ray.project(t);
			 // Get grid position
			let [x0, y0] = (i === 0) ? [null, null] : prior;
			let [x1, y1] = canvas.grid.grid.getGridPositionFromPixels(x, y);
			if ( x0 === x1 && y0 === y1 ) continue;
			 // Highlight the grid position
			let [xg, yg] = canvas.grid.grid.getPixelsFromGridPosition(x1, y1);
			canvas.grid.highlightPosition(this.name, {x: xg, y: yg, color: this.color});
			 // Skip the first one
			prior = [x1, y1];
			if ( i === 0 ) continue;
			 // If the positions are not neighbors, also highlight their halfway point
			if ( !canvas.grid.isNeighbor(x0, y0, x1, y1) ) {
				let th = tMax[i - 1] + (0.5 / nMax);
				let {x, y} = ray.project(th);
				let [x1h, y1h] = canvas.grid.grid.getGridPositionFromPixels(x, y);
				let [xgh, ygh] = canvas.grid.grid.getPixelsFromGridPosition(x1h, y1h);
				canvas.grid.highlightPosition(this.name, {x: xgh, y: ygh, color: this.color});
			}
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Determine whether a SPACE keypress event entails a legal token movement along a measured ruler
	 *
	 * @return {Promise<boolean>}    An indicator for whether a token was successfully moved or not. If True the event should be
	 *                               prevented from propagating further, if False it should move on to other handlers.
	 */
	async moveToken() {
		let wasPaused = game.paused;
		if ( wasPaused && !game.user.isGM ) {
			ui.notifications.warn(game.i18n.localize("GAME.PausedWarning"));
			return false;
		}
		if ( !this.visible || !this.destination ) return false;
		const token = this._getMovementToken();
		if ( !token ) return;
		 // Determine offset relative to the Token top-left.
		// This is important so we can position the token relative to the ruler origin for non-1x1 tokens.
		const origin = canvas.grid.getTopLeft(this.waypoints[0].x, this.waypoints[0].y);
		const s2 = canvas.dimensions.size / 2;
		const dx = Math.round((token.data.x - origin[0]) / s2) * s2;
		const dy = Math.round((token.data.y - origin[1]) / s2) * s2;
		 // Get the movement rays and check collision along each Ray
		// These rays are center-to-center for the purposes of collision checking
		const rays = this._getRaysFromWaypoints(this.waypoints, this.destination);
		let hasCollision = rays.some(r => canvas.walls.checkCollision(r));
		if ( hasCollision ) {
			ui.notifications.error(game.i18n.localize("ERROR.TokenCollide"));
			return;
		}
		 // Execute the movement path.
		// Transform each center-to-center ray into a top-left to top-left ray using the prior token offsets.
		this._state = Ruler.STATES.MOVING;
		token._noAnimate = true;
		for ( let r of rays ) {
			if ( !wasPaused && game.paused ) break;
			const dest = canvas.grid.getTopLeft(r.B.x, r.B.y);
			const path = new Ray({x: token.x, y: token.y}, {x: dest[0] + dx, y: dest[1] + dy});
			await token.update(path.B);
			await token.animateMovement(path);
		}
		token._noAnimate = false;
		 // Once all animations are complete we can clear the ruler
		this._endMeasurement();
	}
	 /* -------------------------------------------- */
	 /**
	 * Acquire a Token, if any, which is eligible to perform a movement based on the starting point of the Ruler
	 * @return {Token}
	 * @private
	 */
	_getMovementToken() {
		let [x0, y0] = Object.values(this.waypoints[0]);
		let tokens = canvas.tokens.controlled;
		if ( !tokens.length && game.user.character ) tokens = game.user.character.getActiveTokens();
		if ( !tokens.length ) return null;
		return tokens.find(t => {
			let pos = new PIXI.Rectangle(t.x - 1, t.y - 1, t.w + 2, t.h + 2);
			return pos.contains(x0, y0);
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * A helper method to return an Array of Ray objects constructed from the waypoints of the measurement
	 * @param {PIXI.Point[]} waypoints    An Array of waypoint {x, y} Objects
	 * @param {PIXI.Point} destination    An optional destination point to append to the existing waypoints
	 * @return {Ray[]}                    An Array of Ray objects which represent the segemnts of the waypoint path
	 * @private
	 */
	_getRaysFromWaypoints(waypoints, destination) {
		if ( destination ) waypoints = waypoints.concat([destination]);
		return waypoints.slice(1).map((wp, i) => {
			return new Ray(waypoints[i], wp);
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Clear display of the current Ruler
	 */
	clear() {
		this._state = Ruler.STATES.INACTIVE;
		this.waypoints = [];
		if ( this.ruler ) this.ruler.clear();
		this.labels.removeChildren().forEach(c => c.destroy());
		canvas.grid.clearHighlightLayer(this.name);
	}
	 /* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */
	 /**
	 * Handle the beginning of a new Ruler measurement workflow
	 * @see {Canvas._onDragLeftStart}
	 */
	_onDragStart(event) {
		this.clear();
		this._state = Ruler.STATES.STARTING;
		this._addWaypoint(event.data.origin);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle left-click events on the Canvas during Ruler measurement.
	 * @see {Canvas._onClickLeft}
	 */
	_onClickLeft(event) {
		const isCtrl = game.keyboard.isCtrl(event);
		if ( (this._state === 2) && isCtrl ) this._addWaypoint(event.data.origin);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle right-click events on the Canvas during Ruler measurement.
	 * @see {Canvas._onClickRight}
	 */
	_onClickRight(event) {
		if ( (this._state === 2) && (this.waypoints.length > 1) ) {
			this._removeWaypoint(event.data.origin, {snap: !event.data.originalEvent.shiftKey});
			return canvas.mouseInteractionManager._dragRight = false;
		}
		else return this._endMeasurement();
	}
	 /* -------------------------------------------- */
	 /**
	 * Continue a Ruler measurement workflow for left-mouse movements on the Canvas.
	 * @see {Canvas._onDragLeftMove}
	 */
	_onMouseMove(event) {
		if ( this._state === Ruler.STATES.MOVING ) return;
		 // Extract event data
		const mt = event._measureTime || 0;
		const {origin, destination, originalEvent} = event.data;
		 // Do not begin measuring unless we have moved at least 1/4 of a grid space
		const dx = destination.x - origin.x;
		const dy = destination.y - origin.y;
		const distance = Math.hypot(dy, dx);
		if ( !this.waypoints.length && (distance < (canvas.dimensions.size / 4))) return;
		 // Hide any existing Token HUD
		canvas.hud.token.clear();
		delete event.data.hudState;
		 // Draw measurement updates
		if ( Date.now() - mt > 50 ) {
			this.measure(destination, {gridSpaces: !originalEvent.shiftKey});
			event._measureTime = Date.now();
			this._state = Ruler.STATES.MEASURING;
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Conclude a Ruler measurement workflow by releasing the left-mouse button.
	 * @see {Canvas._onDragLeftDrop}
	 */
	_onMouseUp(event) {
		const oe = event.data.originalEvent;
		const isCtrl = oe.ctrlKey || oe.metaKey;
		if ( !isCtrl ) this._endMeasurement();
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the addition of a new waypoint in the Ruler measurement path
	 * @param {PIXI.Point} point
	 * @private
	 */
	_addWaypoint(point) {
		const center = canvas.grid.getCenter(point.x, point.y);
		this.waypoints.push(new PIXI.Point(center[0], center[1]));
		this.labels.addChild(new PreciseText("", CONFIG.canvasTextStyle));
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the removal of a waypoint in the Ruler measurement path
	 * @param {PIXI.Point} point      The current cursor position to snap to
	 * @param {boolean} [snap]        Snap exactly to grid spaces?
	 * @private
	 */
	_removeWaypoint(point, {snap=true}={}) {
		this.waypoints.pop();
		this.labels.removeChild(this.labels.children.pop());
		this.measure(point, {gridSpaces: snap});
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle the conclusion of a Ruler measurement workflow
	 * @private
	 */
	_endMeasurement() {
		this.clear();
		game.user.broadcastActivity({ruler: null});
		canvas.mouseInteractionManager.state = MouseInteractionManager.INTERACTION_STATES.HOVER;
	}
	 /* -------------------------------------------- */
	/*  Saving and Loading
	/* -------------------------------------------- */
	 toJSON() {
		return {
			class: "Ruler",
			name: `Ruler.${game.user._id}`,
			waypoints: this.waypoints,
			destination: this.destination,
			_state: this._state
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Update a Ruler instance using data provided through the cursor activity socket
	 * @param {Object} data   Ruler data with which to update the display
	 */
	update(data) {
		if ( data.class !== "Ruler" ) throw new Error("Unable to recreate Ruler instance from provided data");
		 // Populate data
		this.waypoints = data.waypoints;
		this.destination = data.destination;
		this._state = data._state;
		 // Ensure labels are created
		for ( let i=0; i<this.waypoints.length - this.labels.children.length; i++) {
			this.labels.addChild(new PreciseText("", CONFIG.canvasTextStyle));
		}
		 // Measure current distance
		if ( data.destination ) this.measure(data.destination);
	}
}

/**
 * The possible Ruler measurement states which can occur
 * @type {{STARTING: number, INACTIVE: number, MOVING: number, MEASURING: number}}
 */
Ruler.STATES = {
	INACTIVE: 0,
	STARTING: 1,
	MEASURING: 2,
	MOVING: 3
};
/**
 * I don't know what this will do yet
 */
class SpecialEffect {
	constructor(parent, options) {
		this.parent = parent;
		this.options = mergeObject(this.constructor.effectOptions, options, {insertKeys: false});
		this.emitters = this.getParticleEmitters();
		 /**
		 * Use this flag as a way to pass a stop signal into the animation frame
		 * @type {boolean}
		 */
		this._stop = null;
	}
	 /* -------------------------------------------- */
	 static get label() {
		return "Special Effect";
	}
	 /* -------------------------------------------- */
	 static get effectOptions() {
		return {
			density: {
				label: "Particle Density",
				type: this.OPTION_TYPES.RANGE,
				value: 0.5,
				min: 0.1,
				max: 5,
				step: 0.1
			}
		};
	}
	 /* -------------------------------------------- */
	 getParticleEmitters() {
		return [];
	}
	 /* -------------------------------------------- */
	 play(duration) {
		this._stop = null;
		for ( let e of this.emitters ) {
			this._startEmitter(e);
		}
	}
	 /* -------------------------------------------- */
	 stop() {
		this._stop = true;
		for ( let e of this.emitters ) {
			e.emit = false;
			e.cleanup();
		}
	}
	 /* -------------------------------------------- */
	 _startEmitter(emitter) {
		 // Calculate the current time
		let elapsed = Date.now();
		 // Update function every frame
		let update = () => {
			 // Maybe stop
			if ( this._stop) return;
			 // Update the next frame
			requestAnimationFrame(update);
			 // Track the number of elapsed seconds since the previous frame update
			let now = Date.now();
			emitter.update((now - elapsed) * 0.001);
			elapsed = now;
		};
		 // Start emitting
		emitter.emit = true;
		update();
	}
}

SpecialEffect.OPTION_TYPES = {
	VALUE: 1,
	CHECKBOX: 2,
	RANGE: 3,
	SELECT: 4
};

SpecialEffect.DEFAULT_CONFIG = {
	"maxSpeed": 0,
	"noRotation": false,
	"blendMode": "normal",
	"emitterLifetime": -1,
	"pos": {
	"x": 0,
	"y": 0
	},
	"spawnType": "rect"
};
/**
 * A special full-screen weather effect which uses one Emitters to render gently falling autumn leaves
 * @type {SpecialEffect}
 */
class AutumnLeavesWeatherEffect extends SpecialEffect {
	static get label() {
		return "Autumn Leaves";
	}
	 /* -------------------------------------------- */
	static get effectOptions() {
	const options = super.effectOptions;
	options.density.min = 0.05;
	options.density.value = 0.25;
	options.density.max = 1;
	options.density.step = 0.05;
	return options;
	}
	 /* -------------------------------------------- */
	 getParticleEmitters() {
	return [this._getLeafEmitter(this.parent)];
	}
	 /* -------------------------------------------- */
	 _getLeafEmitter(parent) {
		const d = canvas.dimensions;
	const p = (d.width / d.size) * (d.height / d.size) * this.options.density.value;
		const config = mergeObject(this.constructor.LEAF_CONFIG, {
			spawnRect: {
				x: d.paddingX,
				y: d.paddingY,
				w: d.sceneWidth,
				h: d.sceneHeight
			},
		maxParticles: p,
		frequency: this.constructor.LEAF_CONFIG.lifetime.min / p
		}, {inplace: false});
		const sprites = Array.fromRange(6).map(n => `ui/particles/leaf${n+1}.png`);
		return new PIXI.particles.Emitter(parent, sprites, config);
	}
}

// Configure the Rain particle
AutumnLeavesWeatherEffect.LEAF_CONFIG = mergeObject(SpecialEffect.DEFAULT_CONFIG, {
	"alpha": {
	"start": 0.9,
	"end": 0.5
	},
	"scale": {
	"start": 0.2,
	"end": 0.4,
	"minimumScaleMultiplier": 0.5
	},
	"speed": {
	"start": 20,
	"end": 60,
	"minimumSpeedMultiplier": 0.6
	},
	"startRotation": {
	"min": 0,
	"max": 365
	},
	"rotation": 180,
	"rotationSpeed": {
	"min": 100,
	"max": 200
	},
	"lifetime": {
	"min": 10,
	"max": 10
	},
}, {inplace: false});

/**
 * A special full-screen weather effect which uses two Emitters to render drops and splashes
 * @type {SpecialEffect}
 */
class RainWeatherEffect extends SpecialEffect {
	static get label() {
		return "Rain";
	}
	 /* -------------------------------------------- */
	 getParticleEmitters() {
	return [
		this._getRainEmitter(this.parent),
			this._getSplashEmitter(this.parent)
		];
	}
	 /* -------------------------------------------- */
	 _getRainEmitter(parent) {
		const d = canvas.dimensions;
	const p = (d.width / d.size) * (d.height / d.size) * this.options.density.value;
		const config = mergeObject(this.constructor.RAIN_CONFIG, {
			spawnRect: {
				x: -0.05 * d.width,
				y: -0.10 * d.height,
				w: d.width,
				h: 0.8 * d.height
			},
		maxParticles: p,
		frequency: 1 / p
		}, {inplace: false});
		return new PIXI.particles.Emitter(parent, ["ui/particles/rain.png"], config);
	}
	 /* -------------------------------------------- */
	 _getSplashEmitter(parent) {
		const d = canvas.dimensions;
	const p = (d.width / d.size) * (d.height / d.size) * this.options.density.value;
		const config = mergeObject(this.constructor.SPLASH_CONFIG, {
		spawnRect: {
		x: 0,
		y: 0.25 * d.height,
		w: d.width,
		h: 0.75 * d.height
		},
		maxParticles: 0.5 * p,
		frequency: 2 / p
		}, {inplace: false});
		return new PIXI.particles.Emitter(parent, ["ui/particles/drop.png"], config);
	}
}

// Configure the Rain particle
RainWeatherEffect.RAIN_CONFIG = mergeObject(SpecialEffect.DEFAULT_CONFIG, {
	"alpha": {
	"start": 0.7,
	"end": 0.1
	},
	"scale": {
	"start": 1.0,
	"end": 1.0,
	"minimumScaleMultiplier": 0.8
	},
	"speed": {
	"start": 3500,
	"end": 3500,
	"minimumSpeedMultiplier": 0.8
	},
	"startRotation": {
	"min": 75,
	"max": 75
	},
	"rotation": 90,
	"rotationSpeed": {
	"min": 0,
	"max": 0
	},
	"lifetime": {
	"min": 0.5,
	"max": 0.5
	}
}, {inplace: false});

// Configure the Splash particle
RainWeatherEffect.SPLASH_CONFIG = mergeObject(SpecialEffect.DEFAULT_CONFIG, {
	"alpha": {
	"start": 1,
	"end": 1
	},
	"scale": {
	"start": 0.6,
	"end": 0.6,
	"minimumScaleMultiplier": 0.8
	},
	"speed": {
	"start": 0,
	"end": 0
	},
	"startRotation": {
	"min": -90,
	"max": -90
	},
	"noRotation": true,
	"lifetime": {
	"min": 0.5,
	"max": 0.5
	}
}, {inplace: false});

/**
 * A special full-screen weather effect which uses one Emitters to render snowflakes
 * @type {SpecialEffect}
 */
class SnowWeatherEffect extends SpecialEffect {
	static get label() {
		return "Snow";
	}
	 /* -------------------------------------------- */
	 getParticleEmitters() {
	return [this._getSnowEmitter(this.parent)];
	}
	 /* -------------------------------------------- */
	 _getSnowEmitter(parent) {
		const d = canvas.dimensions;
	const p = (d.width / d.size) * (d.height / d.size) * this.options.density.value;
		const config = mergeObject(this.constructor.SNOW_CONFIG, {
			spawnRect: {
				x: 0,
				y: -0.10 * d.height,
				w: d.width,
				h: d.height
			},
		maxParticles: p,
		frequency: 1 / p
		}, {inplace: false});
		return new PIXI.particles.Emitter(parent, ["ui/particles/snow.png"], config);
	}
}

// Configure the Rain particle
SnowWeatherEffect.SNOW_CONFIG = mergeObject(SpecialEffect.DEFAULT_CONFIG, {
	"alpha": {
	"start": 0.9,
	"end": 0.5
	},
	"scale": {
	"start": 0.2,
	"end": 0.4,
	"minimumScaleMultiplier": 0.5
	},
	"speed": {
	"start": 190,
	"end": 210,
	"minimumSpeedMultiplier": 0.6
	},
	"startRotation": {
	"min": 50,
	"max": 75
	},
	"rotation": 90,
	"rotationSpeed": {
	"min": 0,
	"max": 200
	},
	"lifetime": {
	"min": 4,
	"max": 4
	},
}, {inplace: false});

/**
 * The base grid class.
 * This double-dips to implement the "gridless" option
 */
class BaseGrid extends PIXI.Container {
	constructor(options) {
		super();
		this.options = options;
		 /**
		 * Grid Unit Width
		 */
		this.w = options.dimensions.size;
		 /**
		 * Grid Unit Height
		 */
		this.h = options.dimensions.size;
		 /**
		 * Highlight active grid spaces
		 * @type {Object}
		 */
		this.highlight = this.addChild(new PIXI.Container());
	}
	 /* -------------------------------------------- */
	 draw() {
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Highlight a grid position for a certain coordinates
	 * @param {GridHighlight} layer The highlight layer to use
	 * @param {number} x            The x-coordinate of the highlighted position
	 * @param {number} y            The y-coordinate of the highlighted position
	 * @param {number} color        The hex fill color of the highlight
	 * @param {number} border       The hex border color of the highlight
	 * @param {number} alpha        The opacity of the highlight
	 * @param {PIXI.Polygon} shape  A predefined shape to highlight
	 */
	highlightGridPosition(layer, {x, y, color=0x33BBFF, border=null, alpha=0.25, shape=null}={}) {
		if ( !shape ) return;
		layer.beginFill(color, alpha);
		if ( border ) layer.lineStyle(2, border, Math.min(alpha*1.5, 1.0));
		layer.drawShape(shape).endFill();
	}
	 /* -------------------------------------------- */
	/*  Grid Measurement Methods
	/* -------------------------------------------- */
	 /**
	 * Given a pair of coordinates (x, y) - return the top-left of the grid square which contains that point
	 * @return {number[]}    An Array [x, y] of the top-left coordinate of the square which contains (x, y)
	 */
	getTopLeft(x, y) {
		return [x, y].map(Math.round);
	}
	 /* -------------------------------------------- */
	 /**
	 * Given a pair of coordinates (x, y), return the center of the grid square which contains that point
	 * @param {number} x          The x-coordinate
	 * @param {number} y          The y-coordinate
	 * @return {number[]}         An array [cx, cy] of the central point of the grid space which contains (x, y)
	 */
	getCenter(x, y) {
		return [x, y];
	}
	 /* -------------------------------------------- */
	 /**
	 * Given a pair of coordinates (x1,y1), return the grid coordinates (x2,y2) which represent the snapped position
	 * Under a "gridless" system, every pixel position is a valid snapping position
	 *
	 * @param {number} x          The exact target location x
	 * @param {number} y          The exact target location y
	 * @param {number|null} [interval]  An interval of grid spaces at which to snap.
	 *                                  At interval=1, snapping occurs at pixel intervals defined by the grid size
	 *                                  At interval=2, snapping would occur at the center-points of each grid size
	 *                                  At interval=null, no snapping occurs
	 *
	 * @return {{x, y}}           An object containing the coordinates of the snapped location
	 */
	getSnappedPosition(x, y, interval=null) {
		const d = interval ? canvas.dimensions.size / interval : 1;
		return {
			x: Math.round(x / d) * d,
			y: Math.round(y / d) * d
		};
	}
	 /* -------------------------------------------- */
	 /**
	 * Given a pair of pixel coordinates, return the grid position as an Array.
	 * Always round down to the nearest grid position so the pixels are within the grid space (from top-left).
	 * @param {number} x    The x-coordinate pixel position
	 * @param {number} y    The y-coordinate pixel position
	 * @return {number[]}   An array representing the position in grid units
	 */
	getGridPositionFromPixels(x, y) {
		return [x, y].map(Math.round);
	}
	 /* -------------------------------------------- */
	 /**
	 * Given a pair of grid coordinates, return the pixel position as an Array.
	 * Always round up to a whole pixel so the pixel is within the grid space (from top-left).
	 * @param {number} x    The x-coordinate grid position
	 * @param {number} y    The y-coordinate grid position
	 * @return {number[]}   An array representing the position in pixels
	 */
	getPixelsFromGridPosition(x, y) {
		return [x, y].map(Math.round);
	}
	 /* -------------------------------------------- */
	 /**
	 * Shift a pixel position [x,y] by some number of grid units dx and dy
	 * @param {number} x    The starting x-coordinate in pixels
	 * @param {number} y    The starting y-coordinate in pixels
	 * @param {number} dx   The number of grid positions to shift horizontally
	 * @param {number} dy   The number of grid positions to shift vertically
	 */
	shiftPosition(x, y, dx, dy) {
		let s = canvas.dimensions.size;
		return [x + (dx*s), y + (dy*s)];
	}
	 /* -------------------------------------------- */
	 /**
	 * Measure the distance traversed over an array of measured segments
	 * @param {object[]} segments     An Array of measured movement segments
	 * @param {Options} options       Additional options which modify the measurement
	 * @return {number[]}             An Array of distance measurements for each segment
	 */
	measureDistances(segments, options={}) {
		const d = canvas.dimensions;
		return segments.map(s => {
			return (s.ray.distance / d.size) * d.distance;
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Get the grid row and column positions which are neighbors of a certain position
	 * @param {number} row  The grid row coordinate against which to test for neighbors
	 * @param {number} col  The grid column coordinate against which to test for neighbors
	 * @return {number[]}   An array of grid positions which are neighbors of the row and column
	 */
	getNeighbors(row, col) {
		return [];
	}
}
/**
 * Construct a hexagonal grid
 * @extends {BaseGrid}
 */
class HexagonalGrid extends BaseGrid {
	constructor(options) {
		super(options);
		this.columns = !!options.columns;
		this.even = !!options.even;
		 // Grid width and height
		let s = options.dimensions.size;
		if ( this.columns ) {
			this.w = s;
			this.h = Math.sqrt(3) * 0.5 * s;
		} else {
			this.w = Math.sqrt(3) * 0.5 * s;
			this.h = s;
		}
	}
	 /**
	 * A matrix of x and y offsets which is multiplied by the width/height vector to get pointy-top polygon coordinates
	 * @type {Array<number[]>}
	 */
	static get pointyHexPoints() {
		return [[0, 0.25], [0.5, 0], [1, 0.25], [1, 0.75], [0.5, 1], [0, 0.75], [0, 0.25]];
	}
	 /* -------------------------------------------- */
	 /**
	 * A matrix of x and y offsets which is multiplied by the width/height vector to get flat-top polygon coordinates
	 * @type {Array<number[]>}
	 */
	static get flatHexPoints() {
		return [[0, 0.5], [0.25, 0], [0.75, 0], [1, 0.5], [0.75, 1], [0.25, 1], [0, 0.5]];
	}
	 /* -------------------------------------------- */
	 /**
	 * An array of the points which define a hexagon for this grid shape
	 * @return {PointArray[]}
	 */
	get hexPoints() {
		return this.options.columns ? this.constructor.flatHexPoints : this.constructor.pointyHexPoints;
	}
		/* -------------------------------------------- */
	/*  Grid Rendering
	/* -------------------------------------------- */
	 /** @override */
	draw() {
		if ( this.alpha === 0 ) return this;
		 // Set dimensions
		let d = this.options.dimensions;
		this.width = d.width;
		this.height = d.height;
		 // Draw grid polygons
		this.addChild(this._drawGrid());
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * A convenience method for getting all the polygon points relative to a top-left [x,y] coordinate pair
	 * @param {number} x    The top-left x-coordinate
	 * @param {number} y    The top-right y-coordinate
	 * @param {number} [w]  An optional polygon width
	 * @param {number} [h]  An optional polygon height
	 */
	getPolygon(x, y, w, h) {
		w = w ?? this.w;
		h = h ?? this.h;
		return this.hexPoints.reduce((arr, p) => {
			return arr.concat([x + (w * p[0]), y + (h * p[1])]);
		}, []);
	}
	 /* -------------------------------------------- */
	 _drawGrid() {
		let { color, alpha, columns } = this.options;
		let ncols = Math.floor(canvas.dimensions.width / this.w),
				nrows = Math.ceil(canvas.dimensions.height / this.h);
		 // Draw Grid graphic
		let grid = new PIXI.Graphics();
				grid.lineStyle(1, color, alpha);
		 // Draw hex rows
		if ( columns ) this._drawColumns(grid, nrows, ncols);
		else this._drawRows(grid, nrows, ncols);
		return grid;
	}
	 /* -------------------------------------------- */
	 _drawRows(grid, nrows, ncols) {
		let shift = this.even ? 0 : 1;
		nrows /= 0.75;
		for ( let r=0; r<nrows; r++ ) {
			let sx = (r % 2) === shift ? 0 : -0.5;
			let y0 = r * this.h * 0.75;
			for ( let c=0; c<ncols; c++ ) {
				let x0 = (c+sx) * this.w;
				grid.drawPolygon(this.getPolygon(x0, y0));
			}
		}
	}
	 /* -------------------------------------------- */
	 _drawColumns(grid, nrows, ncols) {
		let shift = this.even ? 0 : 1;
		ncols /= 0.75;
		for ( let c=0; c<ncols; c++ ) {
			let sy = (c % 2) === shift ? 0 : -0.5;
			let x0 = c * this.w * 0.75;
			for ( let r=0; r<nrows; r++ ) {
				let y0 = (r+sy) * this.h;
				grid.drawPolygon(this.getPolygon(x0, y0));
			}
		}
	}
	 /* -------------------------------------------- */
	/*  Grid Measurement Methods
	/* -------------------------------------------- */
	 /** @override */
	getGridPositionFromPixels(x, y) {
		let row, col;
		 // Get the row and column that correspond to first encountered bounding box
		if ( this.options.columns ) {
			col = Math.floor(x / (this.w*0.75));
			const isEven = (col+1) % 2 === 0;
			row = Math.floor((y / this.h) + (this.options.even === isEven ? 0.5 : 0));
		} else {
			row = Math.floor(y / (this.h*0.75));
			const isEven = (row+1) % 2 === 0;
			col = Math.floor((x / this.w) + (this.options.even === isEven ? 0.5 : 0))
		}
		return [row, col];
	}
	 /* -------------------------------------------- */
	 /** @override */
	getPixelsFromGridPosition(row, col) {
		let x, y;
		 // Flat-topped hexes
		if (this.options.columns) {
			x = Math.ceil(col * (this.w * 0.75));
			const isEven = (col + 1) % 2 === 0;
			y = Math.ceil((row - (this.options.even === isEven ? 0.5 : 0)) * this.h);
		}
		 // Pointy-topped hexes
		else {
			y = Math.ceil(row * (this.h * 0.75));
			const isEven = (row + 1) % 2 === 0;
			x = Math.ceil((col - (this.options.even === isEven ? 0.5 : 0)) * this.w);
		}
		return [x, y];
	}
	 /* -------------------------------------------- */
	 /** @override */
	getTopLeft(x, y) {
		let [row, col] = this.getGridPositionFromPixels(x,y);
		return this.getPixelsFromGridPosition(row, col);
	}
	 /* -------------------------------------------- */
	 /** @override */
	getCenter(x, y) {
		let [x0, y0] = this.getTopLeft(x, y);
		return [x0 + (this.w/2), y0 + (this.h/2)];
	}
	 /* -------------------------------------------- */
	 /** @override */
	getSnappedPosition(x, y, interval=1) {
		 // Get the top-left coordinate of the dropped space, cascading down and to the right
		let [x0, y0] = this.getTopLeft(x + (this.w / 2), y + (this.h / 2));
		if ( interval === 1 ) return {x: x0, y: y0};
		 // Round the difference to a certain level of precision
		let ix = this.w / interval;
		let dx = Math.round((x - x0) / ix) * ix;
		let iy = this.h / interval;
		let dy = Math.round((y - y0) / iy) * iy;
		return {x: x0 + dx, y: y0 + dy};
	}
	 /* -------------------------------------------- */
	 /** @override */
	shiftPosition(x, y, dx, dy) {
		let [row, col] = canvas.grid.grid.getGridPositionFromPixels(x, y);
		 // Adjust diagonal moves for offset
		let isDiagonal = (dx !== 0) && (dy !== 0);
		if ( isDiagonal ) {
			 // Column orientation
			if ( this.options.columns ) {
				let isEven = ((col+1) % 2 === 0) === this.options.even;
				if ( isEven && (dy > 0)) dy--;
				else if ( !isEven && (dy < 0)) dy++;
			}
			 // Row orientation
			else {
				let isEven = ((row + 1) % 2 === 0) === this.options.even;
				if ( isEven && (dx > 0) ) dx--;
				else if ( !isEven && (dx < 0 ) ) dx++;
			}
		}
		return canvas.grid.grid.getPixelsFromGridPosition(row+dy, col+dx);
	}
	 /* -------------------------------------------- */
	/*  Grid Highlighting
	/* -------------------------------------------- */
	 /** @override */
	highlightGridPosition(layer, options={}) {
		const {x, y} = options;
		if ( !layer.highlight(x, y) ) return;
		options.shape = new PIXI.Polygon(this.getPolygon(x, y));
		return super.highlightGridPosition(layer, options);
	}
	 /* -------------------------------------------- */
	 /** @override */
	getNeighbors(row, col) {
		let offsets;
		 // Column orientation
		if ( this.options.columns ) {
			let shift = ((col+1) % 2 === 0) === this.options.even;
			if ( shift ) offsets = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 0], [0, -1]];
			else offsets = [[0, -1], [-1, 0], [0, 1], [1, 1], [1, 0], [1, -1]];
		}
		 // Row orientation
		else {
			let shift = ((row+1) % 2 === 0) === this.options.even;
			if ( shift ) offsets = [[0, -1], [-1, -1], [-1, 0], [0, 1], [1, 0], [1, -1]];
			else offsets = [[0, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0]];
		}
		return offsets.map(o => [row+o[0], col+o[1]]);
	}
	 /* -------------------------------------------- */
	 /** @override */
	measureDistances(segments, options={}) {
		if ( !options.gridSpaces ) return super.measureDistances(segments, options);
		return segments.map(s => {
			let r = s.ray;
			let [r0, c0] = this.getGridPositionFromPixels(r.A.x, r.A.y);
			let [r1, c1] = this.getGridPositionFromPixels(r.B.x, r.B.y);
			 // Use cube conversion to measure distance
			let hex0 = this.offsetToCube(r0, c0);
			let hex1 = this.offsetToCube(r1, c1);
			let distance = HexagonalGrid.cubeDistance(hex0, hex1);
			return distance * canvas.dimensions.distance;
		});
	}
	 /* -------------------------------------------- */
	/*  Helper Functions
	/* -------------------------------------------- */
	 /**
	 * Convert an offset coordinate (row, col) into a cube coordinate (q, r, s).
	 * See https://www.redblobgames.com/grids/hexagons/ for reference
	 * Source code available https://www.redblobgames.com/grids/hexagons/codegen/output/lib-functions.js
	 * @param {number} row      The row number
	 * @param {number} col      The column number
	 * @return {{q: number, r: number, s: number}}
	 */
	offsetToCube(row, col) {
		const offset = this.options.even ? 1 : -1;
		 // Column orientation
		if ( this.options.columns ) {
			const q = col;
			const s = row - (col + (offset*(col & 1))) / 2;
			return {q, r: 0 - q - s, s};
		}
		 // Row orientation
		else {
			const q = col - (row + (offset*(row & 1))) / 2;
			const s = row;
			return {q, r: 0 - q - s, s};
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Convert a cube coordinate (q, r, s) into an offset coordinate (row, col).
	 * See https://www.redblobgames.com/grids/hexagons/ for reference
	 * Source code available https://www.redblobgames.com/grids/hexagons/codegen/output/lib-functions.js
	 * @param {number} q      Cube coordinate 1
	 * @param {number} r      Cube coordinate 2
	 * @param {number} s      Cube coordinate 3
	 * @return {{row: number, col: number}}
	 */
	cubeToOffset(q, r, s) {
		const offset = this.options.even ? 1 : -1;
		 // Column orientation
		if ( this.options.columns ) {
			const col = q;
			const row = s + (q - (offset * (q&1))) / 2;
			return {row, col};
		}
		 // Row orientation
		else {
			const row = s;
			const col = q + (s - (offset * (s&1))) / 2;
			return {row, col}
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Given a cursor position (x, y), obtain the cube coordinate hex (q, r, s) of the hex which contains it
	 * http://justinpombrio.net/programming/2020/04/28/pixel-to-hex.html
	 * @param {number} x    The x-coordinate in pixels
	 * @param {number} y    The y-coordinate in pixels
	 * @private
	 */
	static pixelToCube(x, y) {
		const size = canvas.dimensions.size / 2;
		const cx = x / size;
		const cy = y / size;
		 // Fractional hex coordinates, might not satisfy (fx + fy + fz = 0) due to rounding
		const fr = (2/3) * cx;
		const fq = ((-1/3) * cx) + ((1 / Math.sqrt(3)) * cy);
		const fs = ((-1/3) * cx) - ((1 / Math.sqrt(3)) * cy);
		 // Convert to integer triangle coordinates
		const a = Math.ceil(fr - fq);
		const b = Math.ceil(fq - fs);
		const c = Math.ceil(fs - fr);
		 // Convert back to cube coordinates
		return [
			Math.round((a - c) / 3),
			Math.round((c - b) / 3),
			Math.round((b - a) / 3)
		];
	}
	 /* -------------------------------------------- */
	 /**
	 * Measure the distance in hexagons between two cube coordinates
	 * @private
	 */
	static cubeDistance(a, b) {
		let diff = {q: a.q - b.q, r: a.r - b.r, s: a.s - b.s};
		return (Math.abs(diff.q) + Math.abs(diff.r) + Math.abs(diff.s)) / 2;
	}
	 /* -------------------------------------------- */
	/*  Deprecated Functions                        */
	/* -------------------------------------------- */
	 /**
	 * @deprecated since 0.7.4
	 * @see {HexagonalGrid#getPolygon}
	 */
	getFlatHexPolygon(x, y, w, h) {
		const points = this.constructor.flatHexPoints;
		return points.reduce((arr, p) => {
			return arr.concat([x + (w * p[0]), y + (h * p[1])]);
		}, []);
	}
	 /* -------------------------------------------- */
	 /**
	 * @deprecated since 0.7.4
	 * @see {HexagonalGrid#getPolygon}
	 */
	getPointyHexPolygon(x, y, w, h) {
		const points = this.constructor.pointyHexPoints;
		return points.reduce((arr, p) => {
			return arr.concat([x + (w * p[0]), y + (h * p[1])]);
		}, []);
	}
}

/**
 * A special Graphics class which handles Grid layer highlighting
 * @type {PIXI.Graphics}
 */
class GridHighlight extends PIXI.Graphics {
	constructor(name, ...args) {
		super(...args);
		 /**
		 * Track the Grid Highlight name
		 * @type {string}
		 */
		this.name = name;
		 /**
		 * Track distinct positions which have already been highlighted
		 * @type {Set}
		 */
		this.positions = new Set();
	}
	 /* -------------------------------------------- */
	 /**
	 * Record a position that is highlighted and return whether or not it should be rendered
	 * @param {number} x    The x-coordinate to highlight
	 * @param {number} y    The y-coordinate to highlight
	 * @return {boolean}    Whether or not to draw the highlight for this location
	 */
	highlight(x, y) {
		let key = `${x}.${y}`;
		if ( this.positions.has(key) ) return false;
		this.positions.add(key);
		return true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Extend the Graphics clear logic to also reset the highlighted positions
	 * @param args
	 */
	clear(...args) {
		super.clear(...args);
		this.positions = new Set();
	}
		/* -------------------------------------------- */
	 /**
	 * Extend how this Graphics container is destroyed to also remove parent layer references
	 * @param args
	 */
	destroy(...args) {
		delete canvas.grid.highlightLayers[this.name];
		super.destroy(...args);
	}
}
	/**
 * A CanvasLayer responsible for drawing a square grid
 */
class GridLayer extends CanvasLayer {
	constructor() {
		super();
		 /**
		 * The Grid container
		 * @type {PIXI.Container}
		 */
		this.grid = null;
		 /**
		 * The Grid Highlight container
		 * @type {PIXI.Container}
		 */
		this.highlight = null;
		 /**
		 * Map named highlight layers
		 * @type {{GridHighlight}}
		 */
		this.highlightLayers = {};
	}
	 /* -------------------------------------------- */
	 /** @override */
	static get layerOptions() {
		return mergeObject(super.layerOptions, {
			zIndex: 30
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * The grid type rendered in this Scene
	 * @type {string}
	 */
	get type() {
		return canvas.scene.data.gridType;
	}
	 /**
	 * A convenient reference to the pixel grid size used throughout this layer
	 * @type {number}
	 */
	get size() {
		return canvas.dimensions.size;
	}
	 /**
	 * Get grid unit width
	 */
	get w() {
		return this.grid.w;
	}
	 /**
	 * Get grid unit height
	 */
	get h() {
		return this.grid.h;
	}
	 /**
	 * A boolean flag for whether the current grid is hexagonal
	 * @type {boolean}
	 */
	get isHex() {
		const gt = CONST.GRID_TYPES;
		return [gt.HEXODDQ, gt.HEXEVENQ, gt.HEXODDR, gt.HEXEVENR].includes(this.type);
	}
	 /* -------------------------------------------- */
	 /**
	 * Draw the grid
	 * @param {Object} preview    Override settings used in place of those saved to the Scene data
	 */
	async draw({type=null, dimensions=null, gridColor=null, gridAlpha=null}={}) {
		await super.draw();
		 // Get grid data
		const gt = type !== null ? type : this.type;
		 // Grid configuration
		let grid;
		let gridOptions = {
			dimensions: dimensions || canvas.dimensions,
			color: gridColor || canvas.scene.data.gridColor.replace("#", "0x") || "0x000000",
			alpha: gridAlpha || canvas.scene.data.gridAlpha,
			columns: [CONST.GRID_TYPES.HEXODDQ, CONST.GRID_TYPES.HEXEVENQ].includes(gt),
			even: [CONST.GRID_TYPES.HEXEVENR, CONST.GRID_TYPES.HEXEVENQ].includes(gt)
		};
		 // Gridless
		if ( gt === CONST.GRID_TYPES.GRIDLESS ) grid = new BaseGrid(gridOptions);
		 // Square grid
		else if ( gt === CONST.GRID_TYPES.SQUARE ) grid = new SquareGrid(gridOptions);
		 // Hexagonal grid
		else grid = new HexagonalGrid(gridOptions);
		 // Draw the highlight layer
		this.highlightLayers = {};
		this.highlight = this.addChild(new PIXI.Container());
		 // Draw the grid
		this.grid = this.addChild(grid.draw());
		return this;
	}
	 /* -------------------------------------------- */
	 /**
	 * Given a pair of coordinates (x1,y1), return the grid coordinates (x2,y2) which represent the snapped position
	 * @param {number} x          The exact target location x
	 * @param {number} y          The exact target location y
	 * @param {number} interval   An interval of grid spaces at which to snap, default is 1.
	 */
	getSnappedPosition(x, y, interval) {
		return this.grid.getSnappedPosition(x, y, interval);
	}
	 /* -------------------------------------------- */
	 /**
	 * Given a pair of coordinates (x, y) - return the top-left of the grid square which contains that point
	 * @return {number[]}    An Array [x, y] of the top-left coordinate of the square which contains (x, y)
	 */
	getTopLeft(x, y) {
		return this.grid.getTopLeft(x, y);
	}
	 /* -------------------------------------------- */
	 /**
	 * Given a pair of coordinates (x, y), return the center of the grid square which contains that point
	 * @return {number[]}    An Array [x, y] of the central point of the square which contains (x, y)
	 */
	getCenter(x, y) {
		return this.grid.getCenter(x, y);
	}
	 /* -------------------------------------------- */
	 /**
	 * Measure the grid-wise distance between two point coordinates.
	 * @param {{x: number, y: number}} origin    The origin point
	 * @param {{x: number, y: number}} target    The target point
	 * @return {number}                          The measured distance between these points
	 *
	 * @example
	 * let distance = canvas.grid.measureDistance({x: 1000, y: 1000}, {x: 2000, y: 2000});
	 */
	measureDistance(origin, target) {
		const ray = new Ray(origin, target);
		const segments = [{ray}];
		return this.grid.measureDistances(segments)[0];
	}
	 /* -------------------------------------------- */
	 /**
	 * Measure the distance traveled over an array of distance segments.
	 * @param {object[]} segments     An array of measured segments
	 * @param {Options} options       Additional options which modify the measurement
	 */
	measureDistances(segments, options={}) {
		return this.grid.measureDistances(segments, options);
	}
	 /* -------------------------------------------- */
	/*  Grid Highlighting Methods
	/* -------------------------------------------- */
	 /**
	 * Define a new Highlight graphic
	 * @param name
	 */
	addHighlightLayer(name) {
		const layer = this.highlightLayers[name];
		if ( !layer || layer._destroyed ) {
			this.highlightLayers[name] = this.highlight.addChild(new GridHighlight(name));
		}
		return this.highlightLayers[name];
	}
	 /* -------------------------------------------- */
	 /**
	 * Clear a specific Highlight graphic
	 * @param name
	 */
	clearHighlightLayer(name) {
		const layer = this.highlightLayers[name];
		if ( layer ) layer.clear();
	}
	 /* -------------------------------------------- */
	 /**
	 * Destroy a specific Highlight graphic
	 * @param name
	 */
	destroyHighlightLayer(name) {
		const layer = this.highlightLayers[name];
		this.highlight.removeChild(layer);
		layer.destroy();
	}
	 /* -------------------------------------------- */
	 getHighlightLayer(name) {
		return this.highlightLayers[name];
	}
	 /* -------------------------------------------- */
	 highlightPosition(name, options) {
		const layer = this.highlightLayers[name];
		if ( !layer ) return false;
		this.grid.highlightGridPosition(layer, options);
	}
	 /* -------------------------------------------- */
	 /**
	 * Test if a specific row and column position is a neighboring location to another row and column coordinate
	 */
	isNeighbor(r0, c0, r1, c1) {
		let neighbors = this.grid.getNeighbors(r0, c0);
		return neighbors.some(n => (n[0] === r1) && (n[1] === c1));
	}
}

/**
 * Construct a square grid container
 * @type {BaseGrid}
 */
class SquareGrid extends BaseGrid {
	 /** @override */
	draw() {
		let { color, alpha } = this.options;
		if ( alpha === 0 ) return this;
		 // Set dimensions
		let d = this.options.dimensions;
		this.width = d.width;
		this.height = d.height;
		 // Vertical lines
		let nx = Math.floor(d.width / d.size);
		for (let i = 1; i < nx; i++) {
			let x = i * d.size;
			this.addChild(this._drawLine([x, 0, x, d.height], color , alpha));
		}
		 // Horizontal lines
		let ny = Math.ceil(d.height / d.size);
		for (let i = 1; i < ny; i++) {
			let y = i * d.size;
			this.addChild(this._drawLine([0, y, d.width, y], color , alpha));
		}
		return this;
	}
	 /* -------------------------------------------- */
	 _drawLine(points, lineColor, lineAlpha) {
		let line = new PIXI.Graphics();
		line.lineStyle(1, lineColor, lineAlpha)
				.moveTo(points[0], points[1])
				.lineTo(points[2], points[3]);
		return line;
	}
	 /* -------------------------------------------- */
	/*  Grid Measurement Methods
	/* -------------------------------------------- */
	 /** @override */
	getTopLeft(x, y) {
		let [x0, y0] = this.getGridPositionFromPixels(x,y);
		return this.getPixelsFromGridPosition(x0, y0);
	}
	 /* -------------------------------------------- */
	 /** @override */
	getCenter(x, y) {
		const gs = canvas.dimensions.size;
		return this.getTopLeft(x, y).map(c => c + (gs / 2));
	}
	 /* -------------------------------------------- */
	 /** @override */
	getGridPositionFromPixels(x, y) {
		let gs = canvas.dimensions.size;
		return [Math.floor(y / gs), Math.floor(x / gs)];
	}
	 /* -------------------------------------------- */
	 /** @override */
	getPixelsFromGridPosition(row, col) {
		let gs = canvas.dimensions.size;
		return [col*gs, row*gs];
	}
	 /* -------------------------------------------- */
	 /** @override */
	getSnappedPosition(x, y, interval=1) {
		let [x0, y0] = this._getNearestVertex(x, y);
		let dx = 0;
		let dy = 0;
		if ( interval !== 1 ) {
			let delta = canvas.dimensions.size / interval;
			dx = Math.round((x - x0) / delta) * delta;
			dy = Math.round((y - y0) / delta) * delta;
		}
		return {
			x: x0 + dx,
			y: y0 + dy
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Shift a pixel position [x,y] by some number of grid units dx and dy
	 * @param {number} x    The starting x-coordinate in pixels
	 * @param {number} y    The starting y-coordinate in pixels
	 * @param {number} dx   The number of grid positions to shift horizontally
	 * @param {number} dy   The number of grid positions to shift vertically
	 */
	shiftPosition(x, y, dx, dy) {
		let [row, col] = canvas.grid.grid.getGridPositionFromPixels(x, y);
		return canvas.grid.grid.getPixelsFromGridPosition(row+dy, col+dx);
	}
	 /* -------------------------------------------- */
	 _getNearestVertex(x, y) {
		const gs = canvas.dimensions.size;
		return [Math.round(x / gs) * gs, Math.round(y / gs) * gs];
	}
	 /* -------------------------------------------- */
	 /** @override */
	highlightGridPosition(layer , options={}) {
		const {x, y} = options;
		if ( !layer.highlight(x, y) ) return;
		let s = canvas.dimensions.size;
		options.shape = new PIXI.Rectangle(x, y, s, s);
		return super.highlightGridPosition(layer, options);
	}
	 /* -------------------------------------------- */
	 /** @override */
	measureDistances(segments, options={}) {
		if ( !options.gridSpaces ) return super.measureDistances(segments, options);
		const d = canvas.dimensions;
		return segments.map(s => {
			let r = s.ray;
			let nx = Math.abs(Math.ceil(r.dx / d.size));
			let ny = Math.abs(Math.ceil(r.dy / d.size));
			 // Determine the number of straight and diagonal moves
			let nd = Math.min(nx, ny);
			let ns = Math.abs(ny - nx);
			 // Linear distance for all moves
			return (nd + ns) * d.distance;
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	getNeighbors(row, col) {
		let offsets = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
		return offsets.map(o => [row+o[0], col+o[1]]);
	}
}

/**
 * An implementation interface for an Audio/Video client which is extended to provide broadcasting functionality.
 * @interface
 * @param {AVMaster} master           The master orchestration instance
 * @param {AVSettings} settings       The audio/video settings being used
 */
class AVClient {
	constructor(master, settings) {
		this.master = master;
		this.settings = settings;
	}
	 /* -------------------------------------------- */
	/*  Connection                                  */
	/* -------------------------------------------- */
	 /**
	 * One-time initialization actions that should be performed for this client implementation.
	 * This will be called only once when the Game object is first set-up.
	 * @return {Promise<void>}
	 */
	async initialize() {
		throw Error("The initialize() method must be defined by an AVClient subclass.");
	}
	 /* -------------------------------------------- */
	 /**
	 * Connect to any servers or services needed in order to provide audio/video functionality.
	 * Any parameters needed in order to establish the connection should be drawn from the settings object.
	 * This function should return a boolean for whether the connection attempt was successful.
	 * @return {Promise<boolean>}   Was the connection attempt successful?
	 */
	async connect() {
		throw Error("The connect() method must be defined by an AVClient subclass.");
	}
	 /* -------------------------------------------- */
	 /**
	 * Disconnect from any servers or services which are used to provide audio/video functionality.
	 * This function should return a boolean for whether a valid disconnection occurred.
	 * @return {Promise<boolean>}   Did a disconnection occur?
	 */
	async disconnect() {
		throw Error("The disconnect() method must be defined by an AVClient subclass.");
	}
	 /* -------------------------------------------- */
	/*  Device Discovery                            */
	/* -------------------------------------------- */
	 /**
	 * Provide an Object of available audio sources which can be used by this implementation.
	 * Each object key should be a device id and the key should be a human-readable label.
	 * @return {Promise<{string: string}>}
	 */
	async getAudioSinks() {
		throw Error("The getAudioSinks() method must be defined by an AVClient subclass.");
	}
	 /* -------------------------------------------- */
	 /**
	 * Provide an Object of available audio sources which can be used by this implementation.
	 * Each object key should be a device id and the key should be a human-readable label.
	 * @return {Promise<{string: string}>}
	 */
	async getAudioSources() {
		throw Error("The getAudioSources() method must be defined by an AVClient subclass.");
	}
	 /* -------------------------------------------- */
	 /**
	 * Provide an Object of available video sources which can be used by this implementation.
	 * Each object key should be a device id and the key should be a human-readable label.
	 * @return {Promise<{string: string}>}
	 */
	async getVideoSources() {
		throw Error("The getVideoSources() method must be defined by an AVClient subclass.");
	}
	 /* -------------------------------------------- */
	/*  Track Manipulation                          */
	/* -------------------------------------------- */
	 /**
	 * Return an array of Foundry User IDs which are currently connected to A/V.
	 * The current user should also be included as a connected user in addition to all peers.
	 * @return {string[]}           The connected User IDs
	 */
	getConnectedUsers() {
		throw Error("The getConnectedUsers() method must be defined by an AVClient subclass.");
	}
	 /* -------------------------------------------- */
	 /**
	 * Provide a MediaStream instance for a given user ID
	 * @param {string} userId        The User id
	 * @return {MediaStream|null}    The MediaStream for the user, or null if the user does not have one
	 */
	getMediaStreamForUser(userId) {
		throw Error("The getMediaStreamForUser() method must be defined by an AVClient subclass.");
	}
	 /* -------------------------------------------- */
	 /**
	 * Is outbound audio enabled for the current user?
	 * @return {boolean}
	 */
	isAudioEnabled() {
		throw Error("The isAudioEnabled() method must be defined by an AVClient subclass.");
	}
	 /* -------------------------------------------- */
	 /**
	 * Is outbound video enabled for the current user?
	 * @return {boolean}
	 */
	isVideoEnabled() {
		throw Error("The isVideoEnabled() method must be defined by an AVClient subclass.");
	}
	 /* -------------------------------------------- */
	 /**
	 * Set whether the outbound audio feed for the current game user is enabled.
	 * This method should be used when the user marks themselves as muted or if the gamemaster globally mutes them.
	 * @param {boolean} enable        Whether the outbound audio track should be enabled (true) or disabled (false)
	 */
	toggleAudio(enable) {
		throw Error("The toggleAudio() method must be defined by an AVClient subclass.");
	}
	 /* -------------------------------------------- */
	 /**
	 * Set whether the outbound audio feed for the current game user is actively broadcasting.
	 * This can only be true if audio is enabled, but may be false if using push-to-talk or voice activation modes.
	 * @param {boolean} broadcast      Whether outbound audio should be sent to connected peers or not?
	 */
	toggleBroadcast(broadcast) {
		throw Error("The toggleBroadcast() method must be defined by an AVClient subclass.");
	}
	 /* -------------------------------------------- */
	 /**
	 * Set whether the outbound video feed for the current game user is enabled.
	 * This method should be used when the user marks themselves as hidden or if the gamemaster globally hides them.
	 * @param {boolean} enable        Whether the outbound audio track should be enabled (true) or disabled (false)
	 */
	toggleVideo(enable) {
		throw Error("The toggleVideo() method must be defined by an AVClient subclass.");
	}
	 /* -------------------------------------------- */
	 /**
	 * Set the Video Track for a given User ID to a provided VideoElement
	 * @param {string} userId                   The User ID to set to the element
	 * @param {HTMLVideoElement} videoElement   The HTMLVideoElement to which the video should be set
	 */
	async setUserVideo(userId, videoElement) {
		throw Error("The setUserVideo() method must be defined by an AVClient subclass.");
	}
	 /* -------------------------------------------- */
	/*  Settings and Configuration                  */
	/* -------------------------------------------- */
	 /**
	 * Handle changes to A/V configuration settings.
	 * @param {object} changed      The settings which have changed
	 */
	onSettingsChanged(changed) {}
}

/**
 * The master Audio/Video controller instance.
 * This is available as the singleton game.webrtc
 *
 * @param {AVSettings} settings     The Audio/Video settings to use
 */
class AVMaster {
	constructor() {
		this.settings = new AVSettings();
		this.config = new AVConfig(this);
		 /**
		 * The Audio/Video client class
		 * @type {AVClient}
		 */
		this.client = new CONFIG.WebRTC.clientClass(this, this.settings);
		 /**
		 * A flag to track whether the current user is actively broadcasting their microphone.
		 * @type {boolean}
		 */
		this.broadcasting = false;
		 /**
		 * Flag to determine if we are connected to the signalling server or not.
		 * This is required for synchronization between connection and reconnection attempts.
		 * @type {boolean}
		 */
		this._connected = false;
		 /**
		 * A flag to track whether the A/V system is currently in the process of reconnecting.
		 * This occurs if the connection is lost or interrupted.
		 * @type {boolean}
		 * @private
		 */
		this._reconnecting = false;
		 // Other internal flags
		this._speakingData = {};
		this._pttHandlers = {};
		this._pttMuteTimeout = 0;
	}
	 /* -------------------------------------------- */
	 get mode() {
		return this.settings.world.mode;
	}
	 /* -------------------------------------------- */
	/*  Initialization                              */
	/* -------------------------------------------- */
	 /**
	 * Connect to the Audio/Video client.
	 * @return {Promise<boolean>}     Was the connection attempt successful?
	 */
	async connect() {
		 // Initialize Client state
		await this.client.initialize();
		 // Disconnect from any existing session
		await this.disconnect();
		 // Activate the connection
		if ( this.mode === AVSettings.AV_MODES.DISABLED ) return false;
		 // Connect to the client
		const connected = await this.client.connect();
		if ( !connected ) return false;
		console.log(`Connected to the ${this.client.constructor.name} Audio/Video client.`);
		 // Initialize local broadcasting
		this._initialize();
		return this._connected = connected;
	}
	 /* -------------------------------------------- */
	 /**
	 * Disconnect from the Audio/Video client.
	 * @return {Promise<boolean>}     Whether an existing connection was terminated?
	 */
	async disconnect() {
		if ( !this._connected ) return false;
		this._connected = this._reconnecting = false;
		await this.client.disconnect();
		console.log(`Disconnected from the ${this.client.constructor.name} Audio/Video client.`);
		return true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Callback actions to take when the user becomes disconnected from the server.
	 * @return {Promise<void>}
	 */
	async reestablish() {
		if ( !this._connected ) return;
		ui.notifications.warn(game.i18n.localize("WEBRTC.ConnectionLostWarning"));
		await this.disconnect();
		 // Attempt to reconnect
		while ( this._reconnecting ) {
			await this.connect();
			if ( this._connected ) {
				this._reconnecting = true;
				break;
			}
			await new Promise(resolve => setTimeout(resolve, this._reconnectPeriodMS));
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize the local broadcast state.
	 * @private
	 */
	_initialize() {
		const client = this.settings.client;
		const voiceMode = client.voice.mode;
		 // Initialize voice detection
		this._initializeUserVoiceDetection(voiceMode);
		 // Initialize push-to-talk
		this._initializePushToTalk();
		 // Reset the speaking history for the user
		this._resetSpeakingHistory(game.user.id);
		 // Set the initial state of outbound audio and video streams
		const isAlways = voiceMode === "always";
		this.client.toggleAudio(isAlways && client.audioSrc && this.canUserShareAudio(game.user._id));
		this.client.toggleVideo(client.videoSrc && this.canUserShareVideo(game.user._id));
		this.broadcast(isAlways);
		 // Update the display of connected A/V
		ui.webrtc.render();
	}
	 /* -------------------------------------------- */
	/*  Permissions                                 */
	/* -------------------------------------------- */
	 /**
	 * A user can broadcast audio if the AV mode is compatible and if they are allowed to broadcast.
	 * @param {string} userId
	 * @return {boolean}
	 */
	canUserBroadcastAudio(userId) {
		if ( [AVSettings.AV_MODES.DISABLED, AVSettings.AV_MODES.VIDEO].includes(this.mode) ) return false;
		const user = this.settings.getUser(userId);
		return user && user.canBroadcastAudio;
	}
	 /* -------------------------------------------- */
	 /**
	 * A user can share audio if they are allowed to broadcast and if they have not muted themselves or been blocked.
	 * @param {string} userId
	 * @return {boolean}
	 */
	canUserShareAudio(userId) {
		if ( [AVSettings.AV_MODES.DISABLED, AVSettings.AV_MODES.VIDEO].includes(this.mode) ) return false;
		const user = this.settings.getUser(userId);
		return user && user.canBroadcastAudio && !(user.muted || user.blocked);
	}
	 /* -------------------------------------------- */
	 /**
	 * A user can broadcast video if the AV mode is compatible and if they are allowed to broadcast.
	 * @param {string} userId
	 * @return {boolean}
	 */
	canUserBroadcastVideo(userId) {
		if ( [AVSettings.AV_MODES.DISABLED, AVSettings.AV_MODES.AUDIO].includes(this.mode) ) return false;
		const user = this.settings.getUser(userId);
		return user && user.canBroadcastVideo;
	}
	 /* -------------------------------------------- */
	 /**
	 * A user can share video if they are allowed to broadcast and if they have not hidden themselves or been blocked.
	 * @param {string} userId
	 * @return {boolean}
	 */
	canUserShareVideo(userId) {
		if ( [AVSettings.AV_MODES.DISABLED, AVSettings.AV_MODES.AUDIO].includes(this.mode) ) return false;
		const user = this.settings.getUser(userId);
		return user && user.canBroadcastVideo && !(user.hidden || user.blocked);
	}
	 /* -------------------------------------------- */
	/*  Broadcasting                                */
	/* -------------------------------------------- */
	 /**
	 * Trigger a change in the audio broadcasting state when using a push-to-talk workflow.
	 * @param {boolean} intent        The user's intent to broadcast. Whether an actual broadcast occurs will depend
	 *                                on whether or not the user has muted their audio feed.
	 */
	broadcast(intent) {
		this.broadcasting = intent && this.canUserShareAudio(game.user._id);
		this.client.toggleBroadcast(this.broadcasting);
		ui.webrtc.setUserIsSpeaking(game.user._id, this.broadcasting);
	}
	 /* -------------------------------------------- */
	 /**
	 * Set up audio level listeners to handle voice activation detection workflow.
	 * @param {string} mode           The currently selected voice broadcasting mode
	 * @private
	 */
	_initializeUserVoiceDetection(mode) {
		 // Deactivate prior detection
		game.audio.stopLevelReports(game.user.id);
		if ( !["always", "activity"].includes(mode) ) return;
		 // Activate voice level detection for always-on and activity-based broadcasting
		const stream = this.client.getMediaStreamForUser(game.user.id);
		const ms = mode === "activity" ? CONFIG.WebRTC.detectSelfVolumeInterval : CONFIG.WebRTC.detectPeerVolumeInterval;
		this.activateVoiceDetection(game.user.id, stream, ms);
	}
	 /* -------------------------------------------- */
	 /**
	 * Activate voice detection tracking for a userId on a provided MediaStream.
	 * Currently only a MediaStream is supported because MediaStreamTrack processing is not yet supported cross-browser.
	 * @param {string} userId         The Foundry User ID whose voice is being processed
	 * @param {MediaStream} stream    The MediaStream which corresponds to that User
	 * @param {number} [ms]           A number of milliseconds which represents the voice activation volume interval
	 */
	activateVoiceDetection(userId, stream, ms) {
		this.deactivateVoiceDetection(userId);
		if ( !stream || !stream.getAudioTracks().some(t => t.enabled) ) return;
		ms = ms || CONFIG.WebRTC.detectPeerVolumeInterval;
		const handler = this._onAudioLevel.bind(this, userId);
		game.audio.startLevelReports(userId, stream, handler, ms);
	}
	 /* -------------------------------------------- */
	 /**
	 * Actions which the orchestration layer should take when a peer user disconnects from the audio/video service.
	 * @param {string} userId   The id of the disconnecting User
	 */
	deactivateVoiceDetection(userId) {
		this._resetSpeakingHistory(userId);
		game.audio.stopLevelReports(userId);
	}
	 /* -------------------------------------------- */
	 /**
	 * Periodic notification of user audio level
	 *
	 * This function uses the audio level (in dB) of each stream it's listening to to determine if a user
	 * is speaking or not and notifies the UI of such changes.
	 *
	 * The User is considered speaking if they are above the decibel threshold in any of the history values.
	 * This marks them as speaking as soon as they have a high enough volume, and marks them as not speaking only after
	 * they drop below the threshold in all histories (last 4 volumes = for 200 ms).
	 *
	 * There can be more optimal ways to do this and which uses whether the user was already considered speaking before
	 * or not, in order to eliminate short bursts of audio (coughing for example).
	 *
	 * @param {string} userId          The user ID of the user whose audio levels are being reported
	 * @param {number} dbLevel         The audio level in decibels of the user within the last 50ms
	 * @private
	 */
	_onAudioLevel(userId, dbLevel) {
		const voice = this.settings.client.voice;
		 // Get speaking data for the user
		if ( !this._speakingData.hasOwnProperty(userId) ) {
			this._speakingData[userId] = { speaking: false, volumeHistories: [] };
		}
		const speakingData = this._speakingData[userId];
		 // Add the current volume to the history of the user and keep the list below the history length config.
		if (speakingData.volumeHistories.push(dbLevel) > CONFIG.WebRTC.speakingHistoryLength) {
			speakingData.volumeHistories.shift();
		}
		 // Count the number and total decibels of speaking events which exceed an activity threshold
		const [count, max, total] = speakingData.volumeHistories.reduce((totals, vol) => {
			if ( vol >= voice.activityThreshold )  {
				totals[0] += 1;
				totals[1] = Math.min(totals[1], vol);
				totals[2] += vol;
			}
			return totals;
		}, [0, 0, 0]);
		 // Determine whether a change in the speaking state has occurred
		const wasSpeaking = speakingData.speaking;
		const isSpeaking = wasSpeaking ? (count > 0) : (count >= CONFIG.WebRTC.speakingThresholdEvents);
		speakingData.speaking = isSpeaking;
		if ( isSpeaking === wasSpeaking ) return;
		 // Enable or disable voice activity based broadcasting
		const isSelf = userId === game.user.id;
		if ( isSelf ) {
			if ( voice.mode === "activity" ) return this.broadcast(isSpeaking);
		}
		else ui.webrtc.setUserIsSpeaking(userId, isSpeaking);
	}
	 /* -------------------------------------------- */
	/*  Push-To-Talk Controls                       */
	/* -------------------------------------------- */
	 /**
	 * Set up interactivity and handling of push-to-talk broadcasting workflow.
	 * @private
	 */
	_initializePushToTalk() {
		 // Deactivate prior broadcasting
		for (let [event, handler] of Object.entries(this._pttHandlers)) {
			window.removeEventListener(event, handler, {capture: true});
		}
		 // Configure handling
		const start = this._onPTTStart.bind(this);
		const end = this._onPTTEnd.bind(this);
		this._pttHandlers = this.settings.client.voice.pttMouse ? {
			mousedown: start,
			mouseup: end
		} : {
			keydown: start,
			keyup: end
		};
		 // Activate push-to-talk handlers
		for (let [event, handler] of Object.entries(this._pttHandlers)) {
			window.addEventListener(event, handler, {capture: true});
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Resets the speaking history of a user
	 * If the user was considered speaking, then mark them as not speaking
	 * @param {string} userId         The ID of the user
	 */
	_resetSpeakingHistory(userId) {
		if ( ui.webrtc ) ui.webrtc.setUserIsSpeaking(userId, false);
		delete this._speakingData[userId];
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle activation of a push-to-talk key or button.
	 * @param {KeyboardEvent|MouseEvent} event   The original keydown event
	 */
	_onPTTStart(event) {
		const voice = this.settings.client.voice;
		const pressed = voice.pttMouse ? event.button : event.keyCode;
		if (pressed !== voice.pttKey) return;
		event.preventDefault();
		if ( event.repeat ) return;
		 // Case 1: Push-to-Talk (begin broadcasting immediately)
		if ( voice.mode === "ptt" ) {
			if (this._pttMuteTimeout > 0) clearTimeout(this._pttMuteTimeout);
			this._pttMuteTimeout = 0;
			this.broadcast(true);
		}
		 // Case 2: Push-to-Mute (disable broadcasting on a timeout)
		else this._pttMuteTimeout = setTimeout(() => this.broadcast(false), voice.pttDelay);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle deactivation of a push-to-talk key or button.
	 * @param {KeyboardEvent|MouseEvent} event   The original keyup event
	 */
	_onPTTEnd(event) {
		const voice = this.settings.client.voice;
		const pressed = voice.pttMouse ? event.button : event.keyCode;
		if (pressed !== voice.pttKey) return;
		event.preventDefault();
		if ( event.repeat ) return;
		 // Case 1: Push-to-Talk (disable broadcasting on a timeout)
		if ( voice.mode === "ptt" ) {
			this._pttMuteTimeout = setTimeout(() => this.broadcast(false), voice.pttDelay);
		}
		 // Case 2: Push-to-Mute (re-enable broadcasting immediately)
		else {
			if (this._pttMuteTimeout > 0) clearTimeout(this._pttMuteTimeout);
			this._pttMuteTimeout = 0;
			this.broadcast(true);
		}
	}
	 /* -------------------------------------------- */
	/*  User Interface Controls                     */
	/* -------------------------------------------- */
	 render() {
		return ui.webrtc.render();
	}
	 /* -------------------------------------------- */
	 /**
	 * Render the audio/video streams to the CameraViews UI.
	 * Assign each connected user to the correct video frame element.
	 */
	onRender() {
		const users = this.client.getConnectedUsers();
		for ( let u of users ) {
			const videoElement = ui.webrtc.getUserVideoElement(u);
			if ( !videoElement ) continue;
			const isSpeaking = this._speakingData?.[u]?.speaking || false;
			this.client.setUserVideo(u, videoElement);
			ui.webrtc.setUserIsSpeaking(u, isSpeaking);
		}
	}
	 /* -------------------------------------------- */
	/*  Events Handlers and Callbacks               */
	/* -------------------------------------------- */
	 /**
	 * Respond to changes which occur to AV Settings.
	 * Changes are handled in descending order of impact.
	 * @param {Object} changed       The object of changed AV settings
	 */
	onSettingsChanged(changed) {
		const keys = Object.keys(flattenObject(changed));
		 // Change the server mode (full reload)
		if (keys.includes('world.mode')) return window.location.reload();
		 // Change the server configuration (full AV re-connection)
		if (["world.server", "world.turn"].some(k => hasProperty(changed, k))) return this.connect();
		 // Change audio and video visibility at a user level
		const users = getProperty(changed, "client.users") || {};
		for ( let [userId, user] of Object.entries(users) ) {
			const changed = new Set(Object.keys(user));
			if ( ["hidden", "blocked"].some(k => changed.has(k)) ) {
				this.client.toggleVideo(this.canUserShareVideo(userId));
			}
			if ( ["muted", "blocked"].some(k => changed.has(k)) ) {
				this.client.toggleAudio(this.canUserShareAudio(userId));
			}
		}
		 // Call client specific setting handling
		this.client.onSettingsChanged(changed);
	}
	 /* -------------------------------------------- */
	 debug(message) {
		if ( this.settings.debug ) console.debug(message);
	}
}

class AVSettings {
	constructor() {
		this.initialize();
		this._set = debounce((key, value) => game.settings.set("core", key, value), 100);
		this._change = debounce(this._onSettingsChanged.bind(this), 100);
	}
	 /* -------------------------------------------- */
	 initialize() {
		this.client = game.settings.get("core", "rtcClientSettings");
		this.world = game.settings.get("core", "rtcWorldSettings");
		this._original = duplicate({client: this.client, world: this.world});
	}
	 /* -------------------------------------------- */
	 changed(settings) {
		return this._change(settings);
	}
	 /* -------------------------------------------- */
	 get(scope, setting) {
		return getProperty(this[scope], setting);
	}
	 /* -------------------------------------------- */
	 getUser(userId) {
		const user = game.users.get(userId);
		if ( !user ) return null;
		return this._getUserSettings(user);
	}
	 /* -------------------------------------------- */
	 set(scope, setting, value) {
		setProperty(this[scope], setting, value);
		this._set(`rtc${scope.titleCase()}Settings`, this[scope]);
	}
	 /* -------------------------------------------- */
	 /**
	 * Return a mapping of AV settings for each game User.
	 * @type {object}
	 */
	get users() {
		const users = {};
		for ( let u of game.users ) {
			users[u.id] = this._getUserSettings(u);
		}
		return users;
	}
	 /* -------------------------------------------- */
	 /**
	 * Prepare a standardized object of user settings data for a single User
	 * @private
	 */
	_getUserSettings(user) {
		const clientSettings = this.client.users[user.id] || {};
		const settings = mergeObject(AVSettings.DEFAULT_USER_SETTINGS, clientSettings, {inplace: false});
		settings.canBroadcastAudio = user.can('BROADCAST_AUDIO');
		settings.canBroadcastVideo = user.can('BROADCAST_VIDEO');
		if ( !user.isSelf ) {
			settings.muted = !settings.canBroadcastAudio;
			settings.hidden = !settings.canBroadcastVideo;
		}
		return settings;
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle setting changes to either rctClientSettings or rtcWorldSettings.
	 * @private
	 */
	_onSettingsChanged() {
		const original = this._original;
		this.initialize();
		const changed = diffObject(original, this._original);
		game.webrtc.onSettingsChanged(changed);
		Hooks.callAll("rtcSettingsChanged", this, changed);
	}
}

/**
 * WebRTC Mode, Disabled, Audio only, Video only, Audio & Video
 * @type {Object}
 */
AVSettings.AV_MODES = {
	DISABLED: 0,
	AUDIO: 1,
	VIDEO: 2,
	AUDIO_VIDEO: 3
};

AVSettings.VOICE_MODES = {
	ALWAYS: "always",
	ACTIVITY: "activity",
	PTT: "ptt"
};

AVSettings.DEFAULT_CLIENT_SETTINGS = {
	videoSrc: "default",
	audioSrc: "default",
	audioSink: "default",
	dockSize: "medium",
	dockPosition: "bottom",
	hidePlayerList: false,
	muteAll: false,
	voice: {
		mode: AVSettings.VOICE_MODES.PTT,
		pttKey: 192, // Tilde
		pttName: "`",
		pttMouse: false,
		pttDelay: 100,
		activityThreshold: -45
	},
	users: {}
};

AVSettings.DEFAULT_WORLD_SETTINGS = {
	mode: AVSettings.AV_MODES.DISABLED,
	server: {
		type: "FVTT",
		url: "",
		room: "",
		username: "",
		password: ""
	},
	turn: {
		type: "server",
		url: "",
		username: "",
		password: "",
	}
};

AVSettings.DEFAULT_USER_SETTINGS = {
	popout: false,
	x: 100,
	y: 100,
	z: 0,
	width: 320,
	volume: 1.0,
	muted: false,
	hidden: false,
	blocked: false
};

/**
 * An AVClient implementation that uses WebRTC and the EasyRTC library.
 * @extends {AVClient}
 * @param {AVMaster} master           The master orchestration instance
 * @param {AVSettings} settings       The audio/video settings being used
 */
class EasyRTCClient extends AVClient {
	constructor(master, settings) {
		super(master, settings);
		 /**
		 * Store the name of the joined EasyRTC room
		 * @type {string|null}
		 * @private
		 */
		this._room = null;
		 /**
		 * A mapping of easyRtcId peer ids to Foundry User ids
		 * @type {{string: string}}
		 * @private
		 */
		this._usernameCache = {};
		 /**
		 * An array of easyRtcId peers that rejected our call. Avoid continually trying to call the same peer.
		 * @type {object[]}
		 * @private
		 */
		this._callRejections = [];
		 // Set some one-time configuration data
		easyrtc.setUsername(game.user.id);
		easyrtc.setAutoInitUserMedia(false);
		easyrtc.setVideoDims(320, 240, undefined);
		easyrtc.enableDebug(CONFIG.debug.av);
	}
	 /* -------------------------------------------- */
	 /** @override */
	async initialize() {
		easyrtc.setRoomOccupantListener(this._onRoomOccupantsChange.bind(this));
		easyrtc.setOnError(this._onError.bind(this));
		easyrtc.setAcceptChecker(this._answerIncomingCall.bind(this));
		easyrtc.setPeerOpenListener(this._onPeerOpen.bind(this));
		easyrtc.setStreamAcceptor(this._onPeerConnect.bind(this));
		easyrtc.setOnStreamClosed(this._onPeerDisconnect.bind(this));
		easyrtc.setPeerClosedListener(this._onPeerClosed.bind(this));
	}
	 /* -------------------------------------------- */
	 /** @override */
	async connect() {
		await this.disconnect();  // Disconnect first, just in case
		await this._connectServer(this.settings.world.server);
		await this._initializeLocal(this.settings.client);
		return true;
	}
	 /* -------------------------------------------- */
	 /** @override */
	async disconnect() {
		await new Promise(resolve => {
			easyrtc.setDisconnectListener(resolve);
			easyrtc.hangupAll();
			easyrtc.disconnect();
		});
		return true;
	}
	 /* -------------------------------------------- */
	 /**
	 * Connect to the WebRTC server and configure ICE/TURN servers
	 * @return {Promise<boolean>}   Was the server connected?
	 * @private
	 */
	async _connectServer({type, room, url, username, password}={}) {
		easyrtc.setDisconnectListener(this._onConnectionLost.bind(this));
		return new Promise(resolve => {
			 // Configure custom server
			let host = url;
			let credential = {username, password};
			let socketPath = getRoute("easyrtc");
			 // Fall-back to default server
			const isCustom = ( type === "custom" ) && ( url !== '' );
			if ( !isCustom ) {
				host = window.location.origin;
				credential = {sessionId: game.sessionId };
			}
			 // Configure EasyRTC socket and credentials
			easyrtc.setSocketUrl(host, {
				path: socketPath,
				reconnectionAttempts: 2,
				timeout: 10000,
				forceNew: true
			});
			easyrtc.setCredential(credential);
			 // Choose the room to join
			this._room = isCustom ? room : "default";
			Object.keys(easyrtc.getRoomsJoined()).forEach(easyrtc.leaveRoom);
			easyrtc.joinRoom(this._room, null, null, null);
			 // Connect to the server
			const onSuccess = easyRtcId => {
				game.webrtc.debug("EasyRTCClient | Login successful, I am " + easyrtc.cleanId(easyRtcId));
				this._setupCustomTURN();
				resolve(true);
			};
			const onFailure = (errorCode, message) => {
				game.webrtc.debug("EasyRTCClient | Login error: ", errorCode, message);
				console.error(game.i18n.localize("WEBRTC.GenericError") + message);
				if (errorCode !== easyrtc.errCodes.ICECANDIDATE_ERR) this.webrtc.onError(errorText);
				resolve(false);
			};
			easyrtc.connect("FoundryVTT", onSuccess, onFailure);
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Setup the custom TURN relay to be used in subsequent calls if there is one configured
	 * If configured, setup custom TURN configuration for future calls. Turn credentials are mandatory in WebRTC.
	 * @private
	 */
	_setupCustomTURN() {
		const {type, url, username, password} = this.settings.world.turn;
		const isCustom = (type === "custom") && !!url && !!username && !!password;
		const config = duplicate(easyrtc.getServerIce());
		 // Create a custom TURN configuration, replacing the default server-provided one
		if ( isCustom ) {
			config.iceServers = config.iceServers.filter(ice => !(ice.url || ice.urls[0]).startsWith('turn'));
			config.iceServers.push({
				urls: ["turn:" + url],
				url: "turn:" + url,
				username: username,
				credential: password
			});
		}
		easyrtc.setIceUsedInCalls(config);
	}
	 /* -------------------------------------------- */
	 /**
	 * Initialize a local media stream
	 * Capture the local audio and video and returns the stream associated with them.
	 *
	 * If @temporary is false (default), then this will initialize the master stream, not the actual
	 * streams being sent to individual users. However, if a master stream was already created, it
	 * will automatically get closed and every individual streams derived from it that are being sent
	 * to connected users will be removed from the calls.
	 * Each established or subsequent calls will receive a copy of the created stream (A/V depending on user permissions)
	 *
	 * If @temporary is true then this only applies to a temporary stream and does not affect
	 * the master stream or any streams in existing calls.
	 * Note that this assumes only one temporary stream can be created at a time.
	 *
	 * @param {string|null} audioSrc       ID of the audio source to capture from or null to disable Audio
	 * @param {string|null} videoSrc       ID of the video source to capture from or null to disable Video
	 * @param {boolean} temporary          Whether to create a temporary stream or the master stream
	 * @return {Promise.MediaStream}       Returns the local stream or `null` if none could be created
	 */
	async _initializeLocal({audioSrc, videoSrc, temporary=false}={}) {
		this._closeLocalStream(temporary);
		return this._openLocalStream(audioSrc, videoSrc, temporary);
	}
	 /* -------------------------------------------- */
	 /**
	 * Create an open a local stream when initially connecting to the server.
	 * This local stream becomes the "master" stream which tracks your own device inputs.
	 * The master stream is cloned to provide a stream to every connected peer.
	 * @private
	 */
	async _openLocalStream(audioSrc, videoSrc, temporary=false) {
		 // Close an already opened stream
		const streamName = temporary ? "temporary" : null;
		this._closeLocalStream(temporary);
		const settings = this.settings.getUser(game.user.id);
		 // Configure data channels
		easyrtc.enableDataChannels(false);
		easyrtc.enableAudio(audioSrc != null);
		easyrtc.enableVideo(videoSrc != null);
		 // Assign media sources, or return early if none are applied
		if (!audioSrc && !videoSrc) return null;
		easyrtc.setVideoSource(videoSrc);
		easyrtc.setAudioSource(audioSrc);
		 // Wrap the initialization in a Promise
		return new Promise(resolve => {
			 // Define success handler
			const onSuccess = () => {
				 // Get the users own stream
				const stream = easyrtc.getLocalStream(streamName);
				if (temporary) return resolve(stream);
				 // Set initial camera and microphone state
				easyrtc.enableCamera(!settings.hidden, streamName);
				easyrtc.enableMicrophone(!settings.muted, streamName);
				 // Define preferred media constraints
				easyrtc._presetMediaConstraints = this._getStreamMediaConstraints(videoSrc, audioSrc);
				 // Add the stream to each peer
				const peers = easyrtc.getRoomOccupantsAsArray(this._room) || [];
				for (let peer of peers) {
					if (easyrtc.getConnectStatus(peer) === easyrtc.NOT_CONNECTED) continue;
					let peerStream = this._createStreamForPeer(peer);
					if (peerStream) {
						easyrtc.addStreamToCall(peer, peerStream.streamName, null);
						// addStreamToCall should cause a renegotiation but it won't happen if we just closed our stream which
						// means we removed it from the call then we add a similar one to it right away. The problem is that the
						// other side risks not seeing the change in the stream if that happens so we force a renegotiation with
						// the other peer.
						easyrtc.renegotiate(peer);
					}
				}
				return resolve(stream);
			};
			 // Define failure handler
			const onFailure = (errorCode, errorText) => {
				game.webrtc.debug("Error capturing media ", errorCode, errorText);
				if (temporary) return resolve(null);
				else ui.notifications.warn(game.i18n.localize("WEBRTC.DeviceUnavailableWarning"), {permanent: true});
				 // Attempt to renegotiate with failed peers
				const peers = easyrtc.getRoomOccupantsAsArray(this._room) || [];
				for (let peer of peers) {
					if (easyrtc.getConnectStatus(peer) !== easyrtc.NOT_CONNECTED) easyrtc.renegotiate(peer);
				}
				return resolve(null);
			};
			 // Initialize the media source with an appropriate stream name
			easyrtc.initMediaSource(onSuccess, onFailure, streamName);
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Close the local stream
	 * @private
	 */
	_closeLocalStream(temporary=false) {
		 // Close the temporary master stream
		const streamName = temporary ? "temporary" : null;
		easyrtc.closeLocalStream(streamName);
		if ( temporary ) return;
		 // Close other local media streams
		const streamNames = easyrtc.getLocalMediaIds();
		for (let streamName of streamNames) {
			if (streamName === "temporary")  continue;
			easyrtc.closeLocalStream(streamName);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Define media constraints to control the resolution and devices used.
	 * We need to set our own constraints so we can specify a min/max range of resolutions.
	 * @return {{video: *, audio: *}}
	 * @private
	 */
	_getStreamMediaConstraints(videoSrc, audioSrc) {
		return {
			video: !!videoSrc ? {
				aspectRatio: 4/3,
				width: {
						ideal: 320,
						max: 640,
						min: 160
				},
				height: {
						ideal: 240,
						max: 480,
						min: 120
				},
				frameRate: {
						ideal: 15,
						max: 30
				},
				deviceId: videoSrc
			} : false,
			audio: !!audioSrc ? {
				deviceId: audioSrc
			} : false
		};
	}
	 /* -------------------------------------------- */
	 /**
	 * Call a peer and establish a connection with them
	 * @param {string} easyRtcId      The peer ID to call
	 * @return {Promise.<boolean>}    Returns false if no call was made or true if the call is successful.
	 *                                raises an Exception in case of failure to establish the call.
	 * @private
	 */
	async _performCall(easyRtcId) {
		return new Promise((resolve, reject) => {
			 // Determine whether to make the call (if it has not already been rejected)
			let makeCall = !this._callRejections.includes(easyRtcId) &&
				(easyrtc.getConnectStatus(easyRtcId) === easyrtc.NOT_CONNECTED);
			 // Get the peers to call
			const userId = easyrtc.idToName(easyRtcId);
			const allPeers = makeCall ? easyrtc.usernameToIds(userId, null) : [];
			 // Make sure we don't already have an existing connection with the same user
			for (let peer of allPeers) {
				if (easyrtc.getConnectStatus(peer.easyrtcid) !== easyrtc.NOT_CONNECTED) {
					game.webrtc.debug(`EasyRTCClient | Not making the call to ${easyRtcId}, already in a call with same user.`);
					makeCall = false;
					break;
				}
			}
			if (!makeCall) return resolve(false);
			 // Important: create a clone of the local stream to send to the peer
			const stream = this._createStreamForPeer(easyrtc.idToName(easyRtcId));
			 // Define success, failure, and acceptance callbacks
			const onSuccess = () => {
				game.webrtc.debug("EasyRTCClient | Successfully established call ", arguments);
				resolve(true);
			};
			const onFailure = (errorCode, errorText) => {
				game.webrtc.debug("EasyRTCClient | Failed to establish call ", errorCode, errorText);
				if (stream) easyrtc.closeLocalStream(stream.streamName);
				reject(errorText);
			};
			const onAccept = (accepted) => {
				game.webrtc.debug("EasyRTCClient | The call was ", accepted ? "accepted" : "rejected", arguments);
				if (!accepted) this._callRejections.push(easyRtcId)
			};
			 // Perform the call
			game.webrtc.debug("EasyRTCClient | Calling user ", easyRtcId);
			easyrtc.call(easyRtcId, onSuccess, onFailure, onAccept, stream ? [stream.streamName] : null);
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Create a MediaStream to be sent to a specific peer.
	 * This stream should control whether outbound video and audio is transmitted.
	 * Create the stream as a clone of the current master stream for configuration on a peer-to-peer basis.
	 * @private
	 */
	_createStreamForPeer(peer) {
		const master = easyrtc.getLocalStream();
		if ( !master ) return null;
		 // Use the user's ID as the stream name to create the local named stream
		const userId = this._usernameCache[peer] || easyrtc.idToName(peer);
		const createTracks = {
			audioTracks: master.getAudioTracks(),
			videoTracks: master.getVideoTracks()
		};
		const streamName = userId;
		easyrtc.closeLocalStream(streamName);
		 // Close the stream in case it's been opened already.
		game.webrtc.debug("EasyRTCClient | Creating new stream for user ", userId);
		const stream = easyrtc.buildLocalMediaStream(streamName, createTracks.audioTracks, createTracks.videoTracks);
		 // Set the initial audio broadcast state
		easyrtc.enableMicrophone(this.master.broadcasting, streamName);
		return stream;
	}
	 /* -------------------------------------------- */
	/*  Device Discovery                            */
	/* -------------------------------------------- */
	 /** @override */
	async getAudioSinks() {
		return new Promise(resolve => {
			try {
				easyrtc.getAudioSinkList(list => resolve(this._deviceInfoToObject(list)));
			} catch (err) {
				resolve({})
			}
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	async getAudioSources() {
		return new Promise(resolve => {
			try {
				easyrtc.getAudioSourceList(list => resolve(this._deviceInfoToObject(list)));
			} catch (err) {
				resolve({})
			}
		});
	}
	 /* -------------------------------------------- */
	 /** @override */
	async getVideoSources() {
		return new Promise(resolve => {
			try {
				easyrtc.getVideoSourceList(list => resolve(this._deviceInfoToObject(list)));
			} catch (err) {
				resolve({})
			}
		});
	}
	 /* -------------------------------------------- */
	 /**
	 * Transform the device info array from easyrtc into an object with {id: label} keys
	 * @param {Object[]} list    The list of devices
	 * @private
	 */
	_deviceInfoToObject(list) {
		return list.reduce((obj, device) => {
			obj[device.id] = device.label || game.i18n.localize("WEBRTC.UnknownDevice");
			return obj;
		}, {});
	}
	 /* -------------------------------------------- */
	 /**
	 * Obtain the EasyRTC user ID of a user based on their Foundry VTT user ID
	 * @param {string} userId     The ID of the user
	 * @return {string|null}      The EasyRtcId of the peer
	 */
	_userIdToEasyRtcId(userId) {
		const ids = easyrtc.usernameToIds(userId, null);
		if (ids && ids.length > 0)
			return ids[0].easyrtcid;
		return null;
	}
	 /* -------------------------------------------- */
	/*  Track Manipulation                          */
	/* -------------------------------------------- */
	 /** @override */
	getConnectedUsers() {
		const connected = [];
		 // The current user
		if ( easyrtc.getLocalStream() ) connected.push(game.user._id);
		 // Connected peers
		for ( let [easyRtcId, userId] of Object.entries(this._usernameCache ) ) {
			const peer = easyrtc.getPeerConnectionByUserId(easyRtcId);
			if ( !peer ) continue;
			else connected.push(userId);
		}
		return connected;
	}
	 /* -------------------------------------------- */
	 /**
	 * Get MediaStream instances for every connected peer in the room.
	 * @return {object[]}   An array of stream information for each peer
	 */
	getConnectedStreams() {
		const peers = easyrtc.getRoomOccupantsAsArray(this._room) || [];
		return peers.reduce((streams, peer) => {
			const pc = easyrtc.getPeerConnectionByUserId(peer);
			if ( !pc ) return streams;
			const stream = {
				id: easyrtc.idToName(peer),
				connection: pc,
				local: null,
				remote: null
			};
			const remote = pc.getRemoteStreams();
			if ( remote?.length ) stream.remote = remote[0];
			const local = pc.getLocalStreams();
			if ( local?.length ) stream.local = local[0];
			streams.push(stream);
			return streams;
		}, []);
	}
	 /* -------------------------------------------- */
	 /** @override */
	getMediaStreamForUser(userId) {
		if (userId === game.userId) return easyrtc.getLocalStream();
		const easyRtcId = this._userIdToEasyRtcId(userId);
		const pc = easyrtc.getPeerConnectionByUserId(easyRtcId);
		if ( !pc ) return null;
		const remote = pc.getRemoteStreams();
		return remote?.length ? remote[0] : null;
	}
	 /* -------------------------------------------- */
	 /** @override */
	isAudioEnabled() {
		const stream = easyrtc.getLocalStream();
		return stream && stream.getAudioTracks().some(t => t.enabled);
	}
	 /* -------------------------------------------- */
	 /** @override */
	isVideoEnabled() {
		const stream = easyrtc.getLocalStream();
		return stream && stream.getVideoTracks().some(t => t.enabled);
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a request to enable or disable the outbound audio feed for the current game user.
	 * @param {boolean} enable        Whether the outbound audio track should be enabled (true) or disabled (false)
	 */
	toggleAudio(enable) {
		const stream = easyrtc.getLocalStream();
		if ( !stream ) return;
		for ( let s of this.getConnectedStreams() ) {   // Toggle outbound streams to connected peers
			this.enableStreamAudio(s.local, enable);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Set whether the outbound audio feed for the current game user is actively broadcasting.
	 * This can only be true if audio is enabled, but may be false if using push-to-talk or voice activation modes.
	 * @param {boolean} broadcast      Whether outbound audio should be sent to connected peers or not?
	 */
	toggleBroadcast(broadcast) {
		const stream = easyrtc.getLocalStream();
		if ( !stream ) return;
		if ( !this.isAudioEnabled() ) broadcast = false;
		for ( let s of this.getConnectedStreams() ) {
			easyrtc.enableMicrophone(broadcast, s.id);
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Handle a request to enable or disable the outbound video feed for the current game user.
	 * @param {boolean} enable        Whether the outbound audio track should be enabled (true) or disabled (false)
	 */
	toggleVideo(enable) {
		const stream = easyrtc.getLocalStream();
		if ( !stream ) return;
		this.enableStreamVideo(stream, enable);       // Toggle your own local stream
		for ( let s of this.getConnectedStreams() ) {   // Also toggle outbound streams to connected peers
			this.enableStreamVideo(s.local, enable);
		}
	}
	 /* -------------------------------------------- */
	 /** @override */
	async setUserVideo(userId, videoElement) {
		const stream = this.getMediaStreamForUser(userId);
		easyrtc.setVideoObjectSrc(videoElement, stream);
		easyrtc.muteVideoObject(videoElement, game.user._id === userId);
		easyrtc.setAudioOutput(videoElement, this.settings.client.audioSink);
		const event = new CustomEvent('webrtcVideoSet', { detail: { stream, userId } });
		videoElement.dispatchEvent(event);
	}
	 /* -------------------------------------------- */
	 /**
	 * Enable or disable the audio tracks in a stream
	 *
	 * Disabling a track represents what a typical user would consider muting it.
	 * We use the term 'enable' here instead of 'mute' to match the MediaStreamTrack
	 * field name and to avoid confusion with the 'muted' read-only field of the MediaStreamTrack
	 * as well as the video element's `muted` field which only stops playing the audio.
	 * Muting by definition stops rendering any of the data, while a disabled track in this case
	 * is still rendering its data, but is simply generating disabled content (silence and black frames)
	 * See https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack/enabled
	 *
	 * @param {MediaStream} stream    The stream to modify
	 * @param {boolean} enable        (optional) Whether to enable or disable the tracks
	 */
	enableStreamAudio(stream, enable=true) {
		if (stream) this._enableMediaTracks(stream.getAudioTracks(), enable);
	}
	 /* -------------------------------------------- */
	 /**
	 * Enable or disable the video tracks in a stream
	 *
	 * Disabling a track represents what a typical user would consider muting it. We use the term 'enable' here instead
	 * of 'mute' to match the MediaStreamTrack field name and to avoid confusion with the 'muted' read-only field of the
	 * MediaStreamTrack as well as the video element's `muted` field which only stops playing the audio.
	 *
	 * Muting by definition stops rendering any of the data, while a disabled track in this case is still rendering its
	 * data, but is simply generating disabled content (silence and black frames).
	 *
	 * See https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack/enabled
	 *
	 * @param {MediaStream} stream    The stream to modify
	 * @param {boolean} enable        (optional) Whether to enable or disable the tracks
	 */
	enableStreamVideo(stream, enable = true) {
		if (stream) this._enableMediaTracks(stream.getVideoTracks(), enable);
	}
	 /* -------------------------------------------- */
	 /**
	 * Enables or disables media tracks
	 * See https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack/enabled
	 * @param {object[]} tracks       The tracks to enable/disable
	 * @param {boolean} enable        Whether to enable or disable the tracks
	 */
	_enableMediaTracks(tracks, enable) {
		for (let track of tracks || []) {
			track.enabled = enable;
		}
	}
	 /* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */
	 /**
	 * Callback used to check if an incoming call should be accepted or not
	 * @param {string} easyRtcId     The peer ID of the caller
	 * @param {Function} acceptor    Function to call with whether or not to accept the call and the media streams to use
	 * @private
	 */
	_answerIncomingCall(easyRtcId , acceptor) {
		const userId = easyrtc.idToName(easyRtcId);
		const user = game.users.get(userId);
		const settings = this.settings.getUser(userId);
		let accept = (user !== undefined) && !settings.blocked;
		 // Verify that we don't already have an existing call with someone else using the same user ID
		const allPeers = accept ? easyrtc.usernameToIds(userId, null) : [];
		if (allPeers.some(peer => easyrtc.getConnectStatus(peer.easyrtcid) !== easyrtc.NOT_CONNECTED)) {
			accept = false;
		}
		 // Create the stream for an accepted call
		const stream = accept ? this._createStreamForPeer(easyrtc.idToName(easyRtcId)) : null;
		 // Call any provided callback function
		game.webrtc.debug("EasyRTCClient |", (accept ? "Accepting" : "Rejecting") + " call from ", arguments);
		acceptor(accept, stream ? [stream.streamName] : null);
	}
	 /* -------------------------------------------- */
	 /**
	 * Called when the connection to the signaling server is lost (unintentionally).
	 * This handles the case of when connectivity is interrupted non-deliberately.
	 * @private
	 */
	_onConnectionLost() {
		return this.master.reestablish();
	}
	 /* -------------------------------------------- */
	 /**
	 * Called when an error occurs
	 * @private
	 */
	_onError({errorCode, errorText}) {
		console.error(`EasyRTCClient | `, ...arguments);
	}
	 /* -------------------------------------------- */
	 /**
	 * Called whenever there is a change in the list of occupants in a room.
	 * It can also be called if a peer's state changes, such as when a call is established or ended.
	 * For each other peer in the room, record their user ID and establish a call with them.
	 * Record the username associated with each peer.
	 *
	 * Important: We need to make sure that only user initiates a call, instead of both trying to call each other.
	 * Resolve this by having the alphabetically greater ID call the other peer.
	 *
	 * @param {string} roomName       The room name where occupants have changed
	 * @param {object[]} otherPeople  An array of other peers in the room
	 * @param {object} myInfo         My own connection info
	 * @private
	 */
	async _onRoomOccupantsChange(roomName, otherPeople, myInfo) {
		game.webrtc.debug("EasyRTCClient | Room occupancy changed : ", otherPeople, myInfo);
		this._usernameCache[myInfo.easyrtcid] = game.user.id;
		const users = this.settings.users;
		for ( let easyRtcId of Object.keys(otherPeople) ) {
			 // Verify the Foundry user ID
			const userId = easyrtc.idToName(easyRtcId);
			const user = game.users.get(userId);
			if ( !user ) continue;
			this._usernameCache[easyRtcId] = userId;
			 // Create a call for any non-blocked users other than ourselves
			if ( (userId.localeCompare(game.user.id) === 1) && !users[userId].blocked ) {
				this._performCall(easyRtcId).catch(()=>{});
			}
		}
	}
	 /* -------------------------------------------- */
	 /**
	 * Called when the connection with a peer has been established
	 * @private
	 */
	_onPeerOpen(easyRtcId) {
		let userId = this._usernameCache[easyRtcId] || easyrtc.idToName(easyRtcId);
		game.webrtc.debug(`EasyRTCClient | Connection established with peer ${userId}`);
	}
	 /* -------------------------------------------- */
	 /**
	 * Called when the connection with a peer has been lost and the ICE machine was unable to re-establish it.
	 * In case of irrecoverable connection loss with the peer, hanging up the call will cause a roomOccupantListener
	 * signal to be sent and we will automatically try to reconnect to the user.
	 * First make sure that they are still in the room so we don't try to hangup with an easyRtcId that is invalid.
	 * @private
	 */
	_onPeerClosed(easyRtcId) {
		let userId = this._usernameCache[easyRtcId] || easyrtc.idToName(easyRtcId);
		game.webrtc.debug(`EasyRTCClient | Connection lost with peer ${userId}`);
		if ( (easyrtc.getRoomOccupantsAsArray(this._room) || []).includes(easyRtcId) )
			easyrtc.hangup(easyRtcId);
	}
	 /* -------------------------------------------- */
	 /**
	 * Called when a remote stream is added to an existing call
	 * @private
	 */
	_onPeerConnect(easyRtcId, stream) {
		const userId = this._usernameCache[easyRtcId] || easyrtc.idToName(easyRtcId);
		game.webrtc.debug(`EasyRTCClient | Stream opened from ${easyRtcId} for user ${userId}`);
		 // Remove tracks from the stream which the user does not have permission to be sharing
		const user = this.settings.getUser(userId);
		if ( !user.canBroadcastAudio ) stream.getAudioTracks().forEach(t => stream.removeTrack(t));
		if ( !user.canBroadcastVideo ) stream.getVideoTracks().forEach(t => stream.removeTrack(t));
		 // Disable tracks based on the user's broadcast state
		if ( user.muted ) this.enableStreamAudio(stream, false);
		if ( user.hidden ) this.enableStreamVideo(stream, false);
		 // Activate voice detection for the audio channel
		this.master.activateVoiceDetection(userId, stream);
		 // Update the video element in the Camera Views UI
		this.master.render();
	}
	 /* -------------------------------------------- */
	 /**
	 * Called when a remote stream is removed from an existing call
	 * @private
	 */
	_onPeerDisconnect(easyRtcId, stream, streamName) {
		const userId = this._usernameCache[easyRtcId] || easyrtc.idToName(easyRtcId);
		game.webrtc.debug(`EasyRTCClient | Stream closed from ${easyRtcId} for user ${userId}`);
		this.master.deactivateVoiceDetection(userId);
	}
	 /* -------------------------------------------- */
	/*  DEPRECATED OR NEEDS REFACTOR                */
	/* -------------------------------------------- */
	 getStreamForUser(userId) {
		console.warn("You are calling getStreamForUser() which is DEPRECATED in favor of getMediaStreamForUser()");
		return this.getMediaStreamForUser(userId)
	}
}
/**
 * Runtime configuration settings for Foundry VTT which exposes a large number of variables which determine how
 * aspects of the software behaves.
 *
 * Unlike the CONST analog which is frozen and immutable, the CONFIG object may be updated during the course of a
 * session or modified by system and module developers to adjust how the application behaves.
 *
 * @type {Object}
 */
const CONFIG = window.CONFIG = {
	 /**
	 * Configure debugging flags to display additional information
	 */
	debug: {
		fog: false,
		hooks: false,
		sight: false,
		sightRays: false,
		av: false,
		avclient: false,
		mouseInteraction: false,
		time: false
	},
	 /**
	 * Configuration for the ActiveEffect embedded Entity
	 */
	ActiveEffect: {
		entityClass: ActiveEffect,
		sheetClass: ActiveEffectConfig
	},
	 /**
	 * Configuration for the default Actor entity class
	 */
	Actor: {
		entityClass: Actor,
		collection: Actors,
		sheetClasses: {},
		sidebarIcon: "fas fa-user",
		typeLabels: {}
	},
	 /**
	 * Configuration settings for the Canvas and its contained layers and objects
	 * @type {Object}
	 */
	Canvas: {
		blurStrength: 8,
		darknessColor: 0x242448,
		darknessLightPenalty: 0.4,
		daylightColor: 0xEEEEEE,
		dispositionColors: {
			HOSTILE: 0xE72124,
			NEUTRAL: 0xF1D836,
			FRIENDLY: 0x43DFDF,
			INACTIVE: 0x555555,
			PARTY: 0x33BC4E,
			CONTROLLED: 0xFF9829
		},
		exploredColor: 0x7f7f7f,
		unexploredColor: 0x000000,
		lightLevels: {
			dark: 0,
			dim: 0.5,
			bright: 1.0
		},
		normalLightColor: 0xb86200,
		maxZoom: 3.0,
		objectBorderThickness: 4,
		lightAnimations: {
			"torch": {
				label: "LIGHT.AnimationTorch",
				animation: PointSource.prototype.animateTorch,
				illuminationShader: TorchIlluminationShader,
				colorationShader: TorchColorationShader
			},
			"pulse": {
				label: "LIGHT.AnimationPulse",
				animation: PointSource.prototype.animatePulse,
				illuminationShader: PulseIlluminationShader,
				colorationShader: PulseColorationShader
			},
			"chroma": {
				label: "LIGHT.AnimationChroma",
				animation: PointSource.prototype.animateTime,
				colorationShader: ChromaColorationShader
			},
			"wave": {
				label: "LIGHT.AnimationWave",
				animation: PointSource.prototype.animateTime,
				illuminationShader: WaveIlluminationShader,
				colorationShader: WaveColorationShader
			},
			"fog": {
				label: "LIGHT.AnimationFog",
				animation: PointSource.prototype.animateTime,
				colorationShader: FogColorationShader
			},
			"sunburst": {
				label: "LIGHT.AnimationSunburst",
				animation: PointSource.prototype.animateTime,
				illuminationShader: SunburstIlluminationShader,
				colorationShader: SunburstColorationShader
			},
			"dome": {
				label: "LIGHT.AnimationLightDome",
				animation: PointSource.prototype.animateTime,
				colorationShader: LightDomeColorationShader
			},
			"emanation": {
				label: "LIGHT.AnimationEmanation",
				animation: PointSource.prototype.animateTime,
				colorationShader: EmanationColorationShader
			},
			"hexa": {
				label: "LIGHT.AnimationHexaDome",
				animation: PointSource.prototype.animateTime,
				colorationShader: HexaDomeColorationShader
			},
			"ghost": {
				label: "LIGHT.AnimationGhostLight",
				animation: PointSource.prototype.animateTime,
				illuminationShader: GhostLightIlluminationShader,
				colorationShader: GhostLightColorationShader
			},
			"energy": {
				label: "LIGHT.AnimationEnergyField",
				animation: PointSource.prototype.animateTime,
				colorationShader: EnergyFieldColorationShader
			},
			"roiling": {
				label: "LIGHT.AnimationRoilingMass",
				animation: PointSource.prototype.animateTime,
				illuminationShader: RoilingIlluminationShader
			},
			"hole": {
				label: "LIGHT.AnimationBlackHole",
				animation: PointSource.prototype.animateTime,
				illuminationShader: BlackHoleIlluminationShader
			}
		}
	},
	 /**
	 * Configuration for the ChatMessage entity
	 */
	ChatMessage: {
		entityClass: ChatMessage,
		collection: Messages,
		template: "templates/sidebar/chat-message.html",
		sidebarIcon: "fas fa-comments",
		batchSize: 100
	},
	 /**
	 * Configuration for the Combat entity
	 */
	Combat: {
		entityClass: Combat,
		collection: CombatEncounters,
		defeatedStatusId: "dead",
		sidebarIcon: "fas fa-fist-raised",
		initiative: {
			formula: null,
			decimals: 2
		}
	},
	 /**
	 * Configuration for dice rolling behaviors in the Foundry VTT client
	 * @type {Object}
	 */
	Dice: {
		types: [Die, FateDie],
		rollModes: Object.entries(CONST.DICE_ROLL_MODES).reduce((obj, e) => {
			let [k, v] = e;
			obj[v] = `CHAT.Roll${k.titleCase()}`;
			return obj;
		}, {}),
		rolls: [Roll],
		terms: {
			"c": Coin,
			"d": Die,
			"f": FateDie
		},
		randomUniform: MersenneTwister.random
	},
	 /**
	 * Configuration for the Folder entity
	 */
	Folder: {
		entityClass: Folder,
		sheetClass: FolderConfig
	},
	 /**
	 * Configuration for the default Item entity class
	 */
	Item: {
		entityClass: Item,
		collection: Items,
		sheetClass: ItemSheet,
		sheetClasses: {},
		sidebarIcon: "fas fa-suitcase",
		typeLabels: {}
	},
	 /**
	 * Configuration for the JournalEntry entity
	 */
	JournalEntry: {
		entityClass: JournalEntry,
		collection: Journal,
		sheetClass: JournalSheet,
		noteIcons: {
			"Anchor": "icons/svg/anchor.svg",
			"Barrel": "icons/svg/barrel.svg",
			"Book": "icons/svg/book.svg",
			"Bridge": "icons/svg/bridge.svg",
			"Cave": "icons/svg/cave.svg",
			"Castle": "icons/svg/castle.svg",
			"Chest": "icons/svg/chest.svg",
			"City": "icons/svg/city.svg",
			"Coins": "icons/svg/coins.svg",
			"Fire": "icons/svg/fire.svg",
			"Hanging Sign": "icons/svg/hanging-sign.svg",
			"House": "icons/svg/house.svg",
			"Mountain": "icons/svg/mountain.svg",
			"Oak Tree": "icons/svg/oak.svg",
			"Obelisk": "icons/svg/obelisk.svg",
			"Pawprint": "icons/svg/pawprint.svg",
			"Ruins": "icons/svg/ruins.svg",
			"Tankard": "icons/svg/tankard.svg",
			"Temple": "icons/svg/temple.svg",
			"Tower": "icons/svg/tower.svg",
			"Trap": "icons/svg/trap.svg",
			"Skull": "icons/svg/skull.svg",
			"Statue": "icons/svg/statue.svg",
			"Sword": "icons/svg/sword.svg",
			"Village": "icons/svg/village.svg",
			"Waterfall": "icons/svg/waterfall.svg",
			"Windmill": "icons/svg/windmill.svg"
		},
		sidebarIcon: "fas fa-book-open"
	},
	 /**
	 * Configuration for the Macro entity
	 */
	Macro: {
		entityClass: Macro,
		collection: Macros,
		sheetClass: MacroConfig,
		sidebarIcon: "fas fa-terminal"
	},
	 /**
	 * Configuration for MeasuredTemplate settings and options
	 */
	MeasuredTemplate: {
		types: {
			"circle": "Circle",
			"cone": "Cone",
			"rect": "Rectangle",
			"ray": "Ray"
		},
		defaults: {
			angle: 53.13,
			width: 1
		}
	},
	 /**
	 * Configuration for the default Playlist entity class
	 */
	Playlist: {
		entityClass: Playlist,
		collection: Playlists,
		sheetClass: null,
		sidebarIcon: "fas fa-music"
	},
	 /**
	 * Configuration for RollTable random draws
	 */
	RollTable: {
		entityClass: RollTable,
		collection: RollTables,
		sheetClass: RollTableConfig,
		sidebarIcon: "fas fa-th-list",
		resultIcon: "icons/svg/d20-black.svg",
		resultTemplate: "templates/dice/table-result.html"
	},
	 /**
	 * Configuration for the default Scene entity class
	 */
	Scene: {
		entityClass: Scene,
		collection: Scenes,
		sheetClass: SceneConfig,
		sidebarIcon: "fas fa-map"
	},
	 /**
	 * Configuration for the User entity, it's roles, and permissions
	 */
	User: {
		entityClass: User,
		collection: Users,
		sheetClass: PlayerConfig,
		permissions: Users.permissions
	},
	 /**
	 * Configure the default Token text style so that it may be reused and overridden by modules
	 * @type {PIXI.TextStyle}
	 */
	canvasTextStyle: new PIXI.TextStyle({
		fontFamily: "Signika",
		fontSize: 36,
		fill: "#FFFFFF",
		stroke: '#111111',
		strokeThickness: 1,
		dropShadow: true,
		dropShadowColor: "#000000",
		dropShadowBlur: 4,
		dropShadowAngle: 0,
		dropShadowDistance: 0,
		align: "center",
		wordWrap: false,
		padding: 1
	}),
	 /**
	 * The control icons used for rendering common HUD operations
	 * @type {Object}
	 */
	controlIcons: {
		combat: "icons/svg/combat.svg",
		visibility: "icons/svg/cowled.svg",
		effects: "icons/svg/aura.svg",
		lock: "icons/svg/padlock.svg",
		up: "icons/svg/up.svg",
		down: "icons/svg/down.svg",
		defeated: "icons/svg/skull.svg",
		light: "icons/svg/fire.svg",
		template: "icons/svg/explosion.svg",
		sound: "icons/svg/sound.svg",
		doorClosed: "icons/svg/door-steel.svg",
		doorOpen: "icons/svg/door-exit.svg",
		doorLocked: "icons/svg/padlock.svg"
	},
	 /**
	 * Suggested font families that are displayed wherever a choice is presented
	 * @type {string[]}
	 */
	fontFamilies: [
		"Arial",
		"Arial Black",
		"Comic Sans MS",
		"Courier New",
		"Times New Roman",
		"Signika",
		"Modesto Condensed"
	],
	 /**
	 * The default font family used for text labels on the PIXI Canvas
	 * @type {string}
	 */
	defaultFontFamily: "Signika",
	 /**
	 * An array of status effect icons which can be applied to Tokens
	 * @type {string[]}
	 */
	statusEffects: [
		{
			id: "dead",
			label: "EFFECT.StatusDead",
			icon: "icons/svg/skull.svg"
		},
		{
			id: "unconscious",
			label: "EFFECT.StatusUnconscious",
			icon: "icons/svg/unconscious.svg"
		},
		{
			id: "sleep",
			label: "EFFECT.StatusAsleep",
			icon: "icons/svg/sleep.svg"
		},
		{
			id: "stun",
			label: "EFFECT.StatusStunned",
			icon: "icons/svg/daze.svg"
		},
		{
			id: "prone",
			label: "EFFECT.StatusProne",
			icon: "icons/svg/falling.svg"
		},
		{
			id: "restrain",
			label: "EFFECT.StatusRestrained",
			icon: "icons/svg/net.svg",
		},
		{
			id: "paralysis",
			label: "EFFECT.StatusParalysis",
			icon: "icons/svg/paralysis.svg",
		},
		{
			id: "fly",
			label: "EFFECT.StatusFlying",
			icon: "icons/svg/wing.svg",
		},
		{
			id: "blind",
			label: "EFFECT.StatusBlind",
			icon: "icons/svg/blind.svg"
		},
		{
			id: "deaf",
			label: "EFFECT.StatusDeaf",
			icon: "icons/svg/deaf.svg"
		},
		{
			id: "silence",
			label: "EFFECT.StatusSilenced",
			icon: "icons/svg/silenced.svg"
		},
		{
			id: "fear",
			label: "EFFECT.StatusFear",
			icon: "icons/svg/terror.svg"
		},
		{
			id: "burning",
			label: "EFFECT.StatusBurning",
			icon: "icons/svg/fire.svg"
		},
		{
			id: "frozen",
			label: "EFFECT.StatusFrozen",
			icon: "icons/svg/frozen.svg"
		},
		{
			id: "shock",
			label: "EFFECT.StatusShocked",
			icon: "icons/svg/lightning.svg"
		},
		{
			id: "corrode",
			label: "EFFECT.StatusCorrode",
			icon: "icons/svg/acid.svg"
		},
		{
			id: "bleeding",
			label: "EFFECT.StatusBleeding",
			icon: "icons/svg/blood.svg"
		},
		{
			id: "disease",
			label: "EFFECT.StatusDisease",
			icon: "icons/svg/biohazard.svg"
		},
		{
			id: "poison",
			label: "EFFECT.StatusPoison",
			icon: "icons/svg/poison.svg"
		},
		{
			id: "radiation",
			label: "EFFECT.StatusRadiation",
			icon: "icons/svg/radiation.svg"
		},
		{
			id: "regen",
			label: "EFFECT.StatusRegen",
			icon: "icons/svg/regen.svg"
		},
		{
			id: "degen",
			label: "EFFECT.StatusDegen",
			icon: "icons/svg/degen.svg"
		},
		{
			id: "upgrade",
			label: "EFFECT.StatusUpgrade",
			icon: "icons/svg/upgrade.svg"
		},
		{
			id: "downgrade",
			label: "EFFECT.StatusDowngrade",
			icon: "icons/svg/downgrade.svg"
		},
		{
			id: "target",
			label: "EFFECT.StatusTarget",
			icon: "icons/svg/target.svg"
		},
		{
			id: "eye",
			label: "EFFECT.StatusMarked",
			icon: "icons/svg/eye.svg"
		},
		{
			id: "curse",
			label: "EFFECT.StatusCursed",
			icon: "icons/svg/sun.svg"
		},
		{
			id: "bless",
			label: "EFFECT.StatusBlessed",
			icon: "icons/svg/angel.svg"
		},
		{
			id: "fireShield",
			label: "EFFECT.StatusFireShield",
			icon: "icons/svg/fire-shield.svg"
		},
		{
			id: "coldShield",
			label: "EFFECT.StatusIceShield",
			icon: "icons/svg/ice-shield.svg"
		},
		{
			id: "magicShield",
			label: "EFFECT.StatusMagicShield",
			icon: "icons/svg/mage-shield.svg"
		},
		{
			id: "holyShield",
			label: "EFFECT.StatusHolyShield",
			icon: "icons/svg/holy-shield.svg"
		},
	],
	 /**
	 * A mapping of core audio effects used which can be replaced by systems or mods
	 * @type {Object}
	 */
	sounds: {
		dice: "sounds/dice.wav",
		lock: "sounds/lock.wav",
		notification: "sounds/notify.wav",
		combat: "sounds/drums.wav"
	},
	 /**
	 * Define the set of supported languages for localization
	 * @type {{string, string}}
	 */
	supportedLanguages: {
		en: "English"
	},
	 /**
	 * Configuration for time tracking
	 * @type {{turnTime: number}}
	 */
	time: {
		turnTime: 0,
		roundTime: 0
	},
	 /**
	 * Default configuration options for TinyMCE editors
	 * @type {object}
	 */
	TinyMCE: {
		branding: false,
		menubar: false,
		statusbar: false,
		content_css: ["/css/mce.css"],
		plugins: "lists image table hr code save link",
		toolbar: "styleselect bullist numlist image table hr link removeformat code save",
		save_enablewhendirty: true,
		table_default_styles: {},
		style_formats: [
			{
				title: "Custom",
				items: [
					{
						title: "Secret",
						block: 'section',
						classes: 'secret',
						wrapper: true
					}
				]
			}
		],
		style_formats_merge: true,
	},
	 /**
	 * Configure the Application classes used to render various core UI elements in the application
	 */
	ui: {
		actors: ActorDirectory,
		chat: ChatLog,
		combat: CombatTracker,
		compendium: CompendiumDirectory,
		controls: SceneControls,
		hotbar: Hotbar,
		items: ItemDirectory,
		journal: JournalDirectory,
		macros: MacroDirectory,
		menu: MainMenu,
		nav: SceneNavigation,
		notifications: Notifications,
		pause: Pause,
		players: PlayerList,
		playlists: PlaylistDirectory,
		scenes: SceneDirectory,
		settings: Settings,
		sidebar: Sidebar,
		tables: RollTableDirectory,
		webrtc: CameraViews
	},
	 /**
	 * Available Weather Effects implementations
	 * @type {Object}
	 */
	weatherEffects: {
		leaves: AutumnLeavesWeatherEffect,
		rain: RainWeatherEffect,
		snow: SnowWeatherEffect
	},
	 /**
	 * Configuration for the WebRTC implementation class
	 * @type {Object}
	 */
	WebRTC: {
		clientClass: EasyRTCClient,
		detectPeerVolumeInterval: 50,
		detectSelfVolumeInterval: 20,
		emitVolumeInterval: 25,
		speakingThresholdEvents: 2,
		speakingHistoryLength: 10
	}
};

/**
 * This object records the major version number of each component feature of Foundry Virtual Tabletop.
 * This can be referenced by modules and systems to provide conditional logic for when different handling may be needed.
 * When a component feature receives a major new revision, the number of its feature version is incremented.
 * @type {Object<string, number>}
 */
const FEATURES = window.FEATURES = {
	ACTIVE_EFFECTS: 1,
	ACTORS: 2,
	AUDIO_VIDEO: 2,
	CHAT: 2,
	COMBAT: 2,
	COMPENDIUM: 2,
	DICE: 2,
	DRAWINGS: 2,
	ENTITIES: 4,
	GRID: 2,
	ITEMS: 2,
	JOURNAL: 1,
	LIGHTING: 2,
	LOCALIZATION: 2,
	MACROS: 1,
	NOTES: 1,
	PLAYLISTS: 1,
	ROLL_TABLES: 1,
	SETTINGS: 2,
	SOUND: 1,
	TEMPLATES: 1,
	TILES: 2,
	TOKENS: 3,
	WALLS: 2
}

// Default Entity sheet registrations
Actors.registerSheet("core", ActorSheet, {label: "Default Actor Sheet"});
Items.registerSheet("core", ItemSheet, {label: "Default Item Sheet"});

// Window Exports
window.CONST = CONST;
window.CONFIG = CONFIG;
window.socket = socket;
window.ui = ui;
window.canvas = canvas;
window.keyboard = keyboard;

// Helper classes
window.Hooks = Hooks;
window.TextEditor = TextEditor;
window.SortingHelpers = SortingHelpers;
