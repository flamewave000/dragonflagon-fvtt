// Global Variables
const vtt = "Foundry VTT";
let game = globalThis.game = {};
let socket = globalThis.socket = null;

/**
 * The global constants object
 * @external CONST
 */

/**
 * The global boolean for whether the EULA is signed
 * @external SIGNED_EULA
 */

/**
 * A collection of application instances
 * @type {Object<Application>}
 */
globalThis.ui = {
	windows: {}
};

// The client-side console is the default logger
globalThis.logger = console;

/**
 * @deprecated since 0.8.0
 * @ignore
 * @type {Object<string, number>}
 */
window.FEATURES = {}
for ( let [k, v] of Object.entries({
	ACTIVE_EFFECTS: 2,
	ACTORS: 3,
	AUDIO_VIDEO: 2,
	CHAT: 3,
	COMBAT: 3,
	COMPENDIUM: 3,
	DICE: 2,
	DRAWINGS: 3,
	ENTITIES: 5,
	GRID: 2,
	ITEMS: 3,
	JOURNAL: 2,
	LIGHTING: 3,
	LOCALIZATION: 2,
	MACROS: 2,
	NOTES: 2,
	PLAYLISTS: 2,
	ROLL_TABLES: 2,
	SETTINGS: 3,
	SOUND: 2,
	TEMPLATES: 2,
	TILES: 3,
	TOKENS: 4,
	WALLS: 3
})) {
	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	Object.defineProperty(window.FEATURES, k, {
		get: () => {
			console.warn(`You are referencing the FEATURES object which has been deprecated as it is no longer an agreed-upon method for how to track evolution of the Foundry Virtual Tabletop API. Discussion about alternate approaches is actively ongoing within the League of Developers community. For the time being the recommendation is to test against game.data.version to understand the current Foundry VTT version which is active. The FEATURES object will be removed in 0.9.0.`);
			return v;
		},
	})
}

/**
 * A directory listing of hook events which occur in the Foundry VTT framework
 * @namespace hookEvents
 */

/**
 * A simple event framework used throughout Foundry Virtual Tabletop.
 * When key actions or events occur, a "hook" is defined where user-defined callback functions can execute.
 * This class manages the registration and execution of hooked callback functions.
 */
class Hooks {

	/**
	 * Register a callback handler which should be triggered when a hook is triggered.
	 *
	 * @param {string} hook   The unique name of the hooked event
	 * @param {Function} fn   The callback function which should be triggered when the hook event occurs
	 * @return {number}       An ID number of the hooked function which can be used to turn off the hook later
	 */
	static on(hook, fn) {
		console.debug(`${vtt} | Registered callback for ${hook} hook`);
		const id = this._id++;
		this._hooks[hook] = this._hooks[hook] || [];
		this._hooks[hook].push(fn);
		this._ids[id] = fn;
		return id;
	}

	/* -------------------------------------------- */

	/**
	 * Register a callback handler for an event which is only triggered once the first time the event occurs.
	 * After a "once" hook is triggered the hook is automatically removed.
	 *
	 * @param {string} hook   The unique name of the hooked event
	 * @param {Function} fn   The callback function which should be triggered when the hook event occurs
	 * @return {number}       An ID number of the hooked function which can be used to turn off the hook later
	 */
	static once(hook, fn) {
		this._once.push(fn);
		return this.on(hook, fn);
	}

	/* -------------------------------------------- */

	/**
	 * Unregister a callback handler for a particular hook event
	 *
	 * @param {string} hook           The unique name of the hooked event
	 * @param {Function|number} fn    The function, or ID number for the function, that should be turned off
	 */
	static off(hook, fn) {
		if ( typeof fn === "number" ) {
			let id = fn;
			fn = this._ids[fn];
			delete this._ids[id];
		}
		if ( !this._hooks.hasOwnProperty(hook) ) return;
		const fns = this._hooks[hook];
		let idx = fns.indexOf(fn);
		if ( idx !== -1 ) fns.splice(idx, 1);
		console.debug(`${vtt} | Unregistered callback for ${hook} hook`);
	}

	/* -------------------------------------------- */

	/**
	 * Call all hook listeners in the order in which they were registered
	 * Hooks called this way can not be handled by returning false and will always trigger every hook callback.
	 *
	 * @param {string} hook   The hook being triggered
	 * @param {...*} args     Arguments passed to the hook callback functions
	 * @returns {boolean}     Were all hooks called without execution being prevented?
	 */
	static callAll(hook, ...args) {
		if ( CONFIG.debug.hooks ) {
			console.log(`DEBUG | Calling ${hook} hook with args:`);
			console.log(args);
		}
		if ( !this._hooks.hasOwnProperty(hook) ) return true;
		const fns = new Array(...this._hooks[hook]);
		for ( let fn of fns ) {
			this._call(hook, fn, args);
		}
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Call hook listeners in the order in which they were registered.
	 * Continue calling hooks until either all have been called or one returns false.
	 *
	 * Hook listeners which return false denote that the original event has been adequately handled and no further
	 * hooks should be called.
	 *
	 * @param {string} hook   The hook being triggered
	 * @param {...*} args     Arguments passed to the hook callback functions
	 * @returns {boolean}     Were all hooks called without execution being prevented?
	 */
	static call(hook, ...args) {
		if ( CONFIG.debug.hooks ) {
			console.log(`DEBUG | Calling ${hook} hook with args:`);
			console.log(args);
		}
		if ( !this._hooks.hasOwnProperty(hook) ) return true;
		const fns = new Array(...this._hooks[hook]);
		for ( let fn of fns ) {
			let callAdditional = this._call(hook, fn, args);
			if ( callAdditional === false ) return false;
		}
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Call a hooked function using provided arguments and perhaps unregister it.
	 * @private
	 */
	static _call(hook, fn, args) {
		if ( this._once.includes(fn) ) this.off(hook, fn);
		try {
			return fn(...args);
		} catch(err) {
			console.warn(`${vtt} | Error thrown in hooked function ${fn.name}`);
			console.error(err);
		}
	}
}

// Static class attributes
Hooks._hooks = {};
Hooks._once = [];
Hooks._ids = {};
Hooks._id = 1;

/**
 * A helper class to provide common functionality for working with Image objects
 */
class ImageHelper {

	/**
	 * Create thumbnail preview for a provided image path.
	 * @param {string|PIXI.DisplayObject} src   The URL or display object of the texture to render to a thumbnail
	 * @param {object} options    Additional named options passed to the compositeCanvasTexture function
	 * @return {Promise<object>}  The parsed and converted thumbnail data
	 */
	static async createThumbnail(src, options) {
		if ( !src ) return null;

		// Load the texture and create a Sprite
		let object = src;
		if ( !(src instanceof PIXI.DisplayObject) ) {
			const texture = await loadTexture(src);
			object = PIXI.Sprite.from(texture);
		}

		// Reduce to the smaller thumbnail texture
		const reduced = this.compositeCanvasTexture(object, options);
		const thumb = this.textureToImage(reduced);
		reduced.destroy(true);

		// Return the image data
		return { src, texture: reduced, thumb, width: object.width, height: object.height };
	}

	/* -------------------------------------------- */

	/**
	 * Composite a canvas object by rendering it to a single texture
	 *
	 * @param {PIXI.DisplayObject} object   The object to render to a texture
	 * @param {number} [width]              The desired width of the output texture
	 * @param {number} [height]             The desired height of the output texture
	 * @param {number} [tx]                 A horizontal translation to apply to the object
	 * @param {number} [ty]                 A vertical translation to apply to the object
	 * @param {boolean} [center]            Center the texture in the rendered frame?
	 *
	 * @return {PIXI.Texture}               The composite Texture object
	 */
	static compositeCanvasTexture(object, {width, height, tx=0, ty=0, center=true}={}) {
		if ( !canvas.app?.renderer ) throw new Error("Unable to compose texture because there is no game canvas");
		width = width ?? object.width;
		height = height ?? object.height;

		// Downscale the object to the desired thumbnail size
		const currentRatio = object.width / object.height;
		const targetRatio = width / height;
		const s = currentRatio > targetRatio ? (height / object.height) : (width / object.width);

		// Define a transform matrix
		const transform = PIXI.Matrix.IDENTITY.clone();
		transform.scale(s, s);

		// Translate position
		if ( center ) {
			tx = (width - (object.width * s)) / 2;
			ty = (height - (object.height * s)) / 2;
		} else {
			tx *= s;
			ty *= s;
		}
		transform.translate(tx, ty);

		// Create and render a texture with the desired dimensions
		const texture = PIXI.RenderTexture.create({
			width: width,
			height: height,
			scaleMode: PIXI.SCALE_MODES.LINEAR,
			resolution: 2
		});
		canvas.app.renderer.render(object, texture, undefined, transform);
		return texture;
	}

	/* -------------------------------------------- */

	/**
	 * Extract a texture to a base64 PNG string
	 * @param {PIXI.Texture} texture      The texture object to extract
	 * @return {string}                   A base64 png string of the texture
	 */
	static textureToImage(texture) {
		const s = new PIXI.Sprite(texture);
		return canvas.app.renderer.extract.base64(s);
	}
}

/**
 * A set of helpers and management functions for dealing with user input from keyboard events.
 * {@link https://keycode.info/}
 */
class KeyboardManager {
	constructor() {

		/**
		 * The set of key codes which are currently depressed (down)
		 * @type {Set}
		 */
		this._downKeys = null;

		/**
		 * The set of key codes which have been already handled per workflow
		 * @type {Set}
		 */
		this._handled = null;

		/**
		 * A mapping of movement keys which are pending
		 * @type {Set}
		 * @private
		 */
		this._moveKeys = null;

		// Status handlers
		this._moveTime = null;
		this._tabState = 0;
		this._wheelTime = 0;

		// Initial reset
		this._reset();

		// Activate input listeners
		window.addEventListener('keydown', this._onKeyDown.bind(this));
		window.addEventListener('keyup', this._onKeyUp.bind(this));
		window.addEventListener("visibilitychange", this._reset.bind(this));
		window.addEventListener("wheel", this._onWheel.bind(this), {passive: false});
		window.addEventListener("compositionend", this._onCompositionEnd.bind(this));
	}

	/**
	 * Specify a rate limit for mouse wheel to gate repeated scrolling.
	 * This is especially important for continuous scrolling mice which emit hundreds of events per second.
	 * This designates a minimum number of milliseconds which must pass before another wheel event is handled
	 * @type {number}
	 */
	static MOUSE_WHEEL_RATE_LIMIT = 50;

	/**
	 * Enumerate the "digit keys"
	 * @type {string[]}
	 */
	static DIGIT_KEYS = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"];

	/**
	 * Map keys used for movement
	 * @enum {string[]}
	 */
	static MOVEMENT_KEYS = {
		w: ["up"],
		a: ["left"],
		s: ["down"],
		d: ["right"],
		W: ["up"],
		A: ["left"],
		S: ["down"],
		D: ["right"],
		ArrowUp: ["up"],
		ArrowRight: ["right"],
		ArrowDown: ["down"],
		ArrowLeft: ["left"],
		Numpad1: ["down", "left"],
		Numpad2: ["down"],
		Numpad3: ["down", "right"],
		Numpad4: ["left"],
		Numpad6: ["right"],
		Numpad7: ["up", "left"],
		Numpad8: ["up"],
		Numpad9: ["up", "right"],
	};

	/**
	 * Map keys used for canvas zooming
	 * @enum {string}
	 */
	static ZOOM_KEYS = {
		"PageUp": "in",
		"PageDown": "out",
		"NumpadAdd": "in",
		"NumpadSubtract": "out"
	};

	/* -------------------------------------------- */

	/**
	 * Reset tracking for which keys are in the down and released states
	 * @private
	 */
	_reset() {
		this._downKeys = new Set();
		this._handled = new Set();
		this._moveKeys = new Set();
		this._tabState = 0;
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * Return whether the key code is currently in the DOWN state
	 * @param {string} code    The key code to test
	 * @type {boolean}
	 */
	isDown(code) {
		return this._downKeys.has(code);
	}

	/* -------------------------------------------- */

	/**
	 * A helper method to test whether, given an Event, the CTRL (or CMD) keys are pressed
	 * @param {Event|PIXI.InteractionEvent} event     The originating event or canvas interaction
	 * @return {boolean}
	 */
	isCtrl(event) {
		if ( !event ) return false;
		event = "ctrlKey" in event ? event : event.data.originalEvent;
		return event.ctrlKey || event.metaKey;
	}

	/* -------------------------------------------- */

	/**
	 * Get a standardized keyboard code for a given event
	 * @param {KeyboardEvent} event   The originating keypress event
	 * @return {string}               The standardized string code to use
	 */
	getKey(event) {

		// Space bar gets a code because its key is misleading
		if ( event.code === "Space" ) return event.code;

		// Digit keys are coerced to their number
		if ( /^Digit/.test(event.code) ) return event.code[5];

		// Enforce that numpad keys are differentiated from digits
		if ( (event.location === 3) && ((event.code in this.moveKeys) || (event.code in this.zoomKeys)) ) {
			return event.code;
		}

		// Otherwise always use the character key
		return event.key;
	}

	/* -------------------------------------------- */

	/**
	 * The key codes which represent a possible movement key
	 * @return {Object.<Array>}
	 */
	get moveKeys() {
		return this.constructor.MOVEMENT_KEYS;
	}

	/* -------------------------------------------- */

	/**
	 * The key codes which represent a digit key
	 * @return {Array.<string>}
	 */
	get digitKeys() {
		return this.constructor.DIGIT_KEYS;
	}

	/* -------------------------------------------- */

	/**
	 * Return the key codes used for zooming the canvas
	 * @return {Object.<string>}
	 */
	get zoomKeys() {
		return this.constructor.ZOOM_KEYS;
	}

	/* -------------------------------------------- */

	/**
	 * Test whether an input currently has focus
	 * @return {boolean}
	 */
	get hasFocus() {
		return $(":focus").length > 0;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Handle a key press into the down position
	 * @param {KeyboardEvent} event   The originating keyboard event
	 * @private
	 */
	_onKeyDown(event) {
		if ( event.isComposing ) return; // Ignore IME composition
		const key = this.getKey(event);
		if ( (key === undefined) || this._handled.has(key) ) return;
		this._downKeys.add(key);
		this._handleKeys(event, key, false);
	}

	/* -------------------------------------------- */

	/**
	 * Handle a key release into the up position
	 * @param {KeyboardEvent} event   The originating keyboard event
	 * @private
	 */
	_onKeyUp(event) {
		if ( event.isComposing ) return; // Ignore IME composition
		const key = this.getKey(event);
		if ( key === undefined ) return;
		this._downKeys.delete(key);
		this._handleKeys(event, key, true);
		if ( this._handled.has(key) ) {
			this._handled.clear();
			this._downKeys.clear();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Delegate tracked key codes by dispatching to their various handlers
	 * @param {KeyboardEvent} event   The keydown or keyup event
	 * @param {string} key            The key being depressed
	 * @param {boolean} up            A flag for whether the key is down or up
	 * @private
	 */
	_handleKeys(event, key, up) {

		// Collect meta modifiers
		const modifiers = {
			key: key,
			isShift: event.shiftKey,
			isCtrl: event.ctrlKey || event.metaKey,
			isAlt: event.altKey,
			hasFocus: this.hasFocus,
			hasModifier: event.shiftKey || event.ctrlKey || event.metaKey || event.altKey
		};

		// Dispatch events to bound handlers
		if ( key === "Tab" ) this._onTab(event, up, modifiers);
		else if ( key === "Escape" ) this._onEscape(event, up, modifiers);
		else if ( key === "Space" ) this._onSpace(event, up, modifiers);
		else if ( key in this.moveKeys ) this._onMovement(event, up, modifiers);
		else if ( this.digitKeys.includes(key) ) this._onDigit(event, up, modifiers);
		else if ( ["Delete", "Backspace"].includes(key) ) this._onDelete(event, up, modifiers);
		else if ( key === "Alt" ) this._onAlt(event, up, modifiers);
		else if ( key.toLowerCase() === "z" ) this._onKeyZ(event, up, modifiers);
		else if ( key.toLowerCase() === "c" ) this._onKeyC(event, up, modifiers);
		else if ( key.toLowerCase() === "v" ) this._onKeyV(event, up, modifiers);
		else if ( key in this.zoomKeys ) this._onKeyZoom(event, up, modifiers);

	}

	/* -------------------------------------------- */

	/**
	 * Input events do not fire with isComposing = false at the end of a composition event in Chrome
	 * See: https://github.com/w3c/uievents/issues/202
	 * @param {CompositionEvent} event
	 */
	_onCompositionEnd(event) {
		return this._onKeyDown(event);
	}

	/* -------------------------------------------- */

	/**
	 * Master mouse-wheel event keyboard handler
	 * @private
	 */
	_onWheel(event) {

		// Prevent zooming the entire browser window
		if ( event.ctrlKey ) event.preventDefault();

		// Interpret shift+scroll as vertical scroll
		let dy = event.deltaY;
		if ( event.shiftKey && (dy === 0) ) dy = event.deltaX;
		if ( dy === 0 ) return;

		// Take no actions if the canvas is not hovered
		if ( !canvas.ready ) return;
		const hover = document.elementFromPoint(event.clientX, event.clientY);
		if ( !hover || (hover.id !== "board" )) return;
		event.preventDefault();

		// Identify scroll modifiers
		const isCtrl = event.ctrlKey || event.metaKey;
		const isShift = event.shiftKey;
		const layer = canvas.activeLayer;

		// Case 1 - rotate placeable objects
		if ( layer?.options?.rotatableObjects && ( isCtrl || isShift ) ) {
			const hasTarget = layer.options?.controllableObjects ? layer.controlled.length : !!layer._hover;
			if (hasTarget) {
				const t = Date.now();
				if ((t - this._wheelTime) < this.constructor.MOUSE_WHEEL_RATE_LIMIT) return;
				this._wheelTime = t;
				return layer._onMouseWheel(event);
			}
		}

		// Case 2 - zoom the canvas
		canvas._onMouseWheel(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle TAB keypress events
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onTab(event, up, modifiers) {

		// Always prevent tab actions if a form field is not in focus
		if ( !modifiers.hasFocus ) event.preventDefault();
		else return;
		if ( up || !canvas.ready ) {
			this._tabState = 0;
			return;
		}
		if ( this._tabState > 0 ) return;

		// Attempt to cycle tokens, otherwise re-center the canvas
		if ( canvas.tokens._active ) {
			let cycled = canvas.tokens.cycleTokens(!modifiers.isShift);
			if ( !cycled ) canvas.recenter();
		}
		this._tabState = 1;
	}

	/* -------------------------------------------- */

	/**
	 * Handle ESC keypress events
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onEscape(event, up, modifiers) {
		if (up || modifiers.hasFocus) return;
		this._handled.add(modifiers.key)

		// Save fog of war if there are pending changes
		if ( canvas.ready ) canvas.sight.saveFog();

		// Case 1 - dismiss an open context menu
		if (ui.context && ui.context.menu.length) return ui.context.close();

		// Case 2 - close open UI windows
		if (Object.keys(ui.windows).length) {
			Object.values(ui.windows).forEach(app => app.close());
			return
		}

		// Case 3 (GM) - release controlled objects (if not in a preview)
		if (game.user.isGM && canvas.activeLayer && Object.keys(canvas.activeLayer._controlled).length) {
			event.preventDefault();
			if ( !canvas.activeLayer.preview?.children.length ) canvas.activeLayer.releaseAll();
			return
		}

		// Case 4 - toggle the main menu
		ui.menu.toggle();
	}

	/* -------------------------------------------- */

	/**
	 * Handle SPACE keypress events
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onSpace(event, up, modifiers) {

		// If an input element has focus, always allow keydown
		if ( up || modifiers.hasFocus ) return;

		// Move along a measured ruler
		const ruler = canvas.controls?.ruler;
		if ( canvas.ready && ruler.active ) {
			let moved = ruler.moveToken(event);
			if ( moved ) event.preventDefault();
			return this._handled.add(modifiers.key);
		}

		// Pause the game
		if ( game.user.isGM && !modifiers.hasModifier ) {
			event.preventDefault();
			game.togglePause(undefined, true);
			return this._handled.add(modifiers.key);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle ALT keypress events
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onAlt(event, up, modifiers) {
		if ( !canvas.ready ) return;
		event.preventDefault();

		// Highlight placeable objects on any layers which are visible
		for ( let layer of canvas.layers ) {
			if ( !layer.objects || !layer.interactiveChildren ) continue;
			for ( let o of layer.placeables ) {
				if ( !o.visible ) continue;
				if ( !o.can(game.user, "hover") ) return;
				if ( !up ) o._onHoverIn(event, {hoverOutOthers: false});
				else o._onHoverOut(event);
			}
		}

		// Flag the keydown workflow as handled
		if ( !up ) this._handled.add(modifiers.key);
	}

	/* -------------------------------------------- */

	/**
	 * Handle movement keypress events
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onMovement(event, up, modifiers) {
		if ( !canvas.ready || up || modifiers.hasFocus ) return;
		event.preventDefault();

		// Handle CTRL+A
		if ( (modifiers.key === "a") && modifiers.isCtrl ) return this._onKeyA(event, up, modifiers);

		// Reset move keys after a delay of 50ms or greater
		const now = Date.now();
		const delta = now - this._moveTime;
		if ( delta > 50 ) this._moveKeys.clear();

		// Track the movement set
		const directions = this.moveKeys[modifiers.key];
		for ( let d of directions ) {
			this._moveKeys.add(d);
		}

		// Handle canvas pan using CTRL
		if ( modifiers.isCtrl ) {
			if ( ["w", "a", "s", "d"].includes(modifiers.key) ) return;
			return this._handleCanvasPan();
		}

		// Delay 50ms before shifting tokens in order to capture diagonal movements
		const layer = canvas.activeLayer;
		if ( (layer instanceof TokenLayer) || (layer instanceof BackgroundLayer) ) {
			if ( delta < 100 ) return; // Throttle keyboard movement once per 100ms
			setTimeout(() => this._handleMovement(event, layer), 50);
		}
		this._moveTime = now;
	}

	/* -------------------------------------------- */

	/**
	 * Handle keyboard movement once a small delay has elapsed to allow for multiple simultaneous key-presses.
	 * @private
	 */
	_handleMovement(event, layer) {
		if ( !this._moveKeys.size ) return;

		// Get controlled objects
		let objects = layer.placeables.filter(o => o._controlled);
		if ( objects.length === 0 ) return;

		// Define movement offsets and get moved directions
		const directions = this._moveKeys;
		let dx = 0;
		let dy = 0;

		// Assign movement offsets
		if ( directions.has("left") ) dx -= 1;
		if ( directions.has("up") ) dy -= 1;
		if ( directions.has("right") ) dx += 1;
		if ( directions.has("down") ) dy += 1;
		this._moveKeys.clear();

		// Perform the shift or rotation
		layer.moveMany({dx, dy, rotate: event.shiftKey});
	}

	/* -------------------------------------------- */

	/**
	 * Handle panning the canvas using CTRL + directional keys
	 */
	_handleCanvasPan() {

		// Determine movement offsets
		let dx = 0;
		let dy = 0;
		if (this._moveKeys.has("left")) dx -= 1;
		if (this._moveKeys.has("up")) dy -= 1;
		if (this._moveKeys.has("right")) dx += 1;
		if (this._moveKeys.has("down")) dy += 1;

		// Clear the pending set
		this._moveKeys.clear();

		// Pan by the grid size
		const s = canvas.dimensions.size;
		return canvas.animatePan({
			x: canvas.stage.pivot.x + (dx * s),
			y: canvas.stage.pivot.y + (dy * s),
			duration: 100
		});
	}

	/* -------------------------------------------- */

	/**
	 * Handle number key presses
	 * @param {Event} event       The original digit key press
	 * @param {boolean} up        Is it a keyup?
	 * @param {Object}modifiers   What modifiers affect the keypress?
	 * @private
	 */
	_onDigit(event, up, modifiers) {
		if ( modifiers.hasFocus || up || modifiers.isCtrl || modifiers.isShift ) return;
		const num = parseInt(modifiers.key);
		if ( modifiers.isAlt ) ui.hotbar.changePage(num);
		else {
			const slot = ui.hotbar.macros.find(m => m.key === num);
			if ( slot.macro ) slot.macro.execute();
		}
		this._handled.add(modifiers.key);
	}

	/* -------------------------------------------- */

	/**
	 * Handle "A" keypress events (CTRL only) to select all objects
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onKeyA(event, up, modifiers) {
		if ( up || modifiers.hasFocus ) return;
		if ( !modifiers.isCtrl ) return;
		canvas.activeLayer.controlAll();
		this._handled.add(modifiers.key);
	}

	/* -------------------------------------------- */

	/**
	 * Handle "C" keypress events to copy data to clipboard
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onKeyC(event, up, modifiers) {
		if ( up || event.repeat || modifiers.hasFocus ) return;

		// Case 1 - attempt a copy operation on the PlaceablesLayer
		if ( modifiers.isCtrl ) {
			if (window.getSelection().toString() !== "") return;
			if ( !canvas.ready || !game.user.isGM ) return;
			let layer = canvas.activeLayer;
			if ( layer instanceof PlaceablesLayer ) layer.copyObjects();
		}

		// Case 2 - Toggle character sheet
		else {
			const token = canvas.ready && (canvas.tokens.controlled.length === 1) ? canvas.tokens.controlled[0] : null;
			const actor = token ? token.actor : game.user.character;
			if ( actor ) {
				const sheet = actor.sheet;
				if ( sheet.rendered ) {
					if ( sheet._minimized ) sheet.maximize();
					else sheet.close()
				}
				else sheet.render(true);
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle "V" keypress events to paste data from clipboard
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onKeyV(event, up, modifiers ) {
		if ( up || event.repeat || !game.user.isGM || !canvas.ready || modifiers.hasFocus || !modifiers.isCtrl ) return;
		let layer = canvas.activeLayer;
		if ( layer instanceof PlaceablesLayer ) {
			let pos = canvas.app.renderer.plugins.interaction.mouse.getLocalPosition(canvas.tokens);
			return layer.pasteObjects(pos, {hidden: modifiers.isAlt, snap: !modifiers.isShift});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle Z Keypress Events to generally undo previous actions
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onKeyZ(event, up, modifiers) {
		if ( up || event.repeat || modifiers.hasFocus || !canvas.ready ) return;

		// Undo history for a PlaceablesLayer
		const layer = canvas.activeLayer;
		if ( !(layer instanceof PlaceablesLayer) ) return;
		if ( modifiers.isCtrl && layer.history.length ) {
			layer.undoHistory();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle presses to keyboard zoom keys
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onKeyZoom(event, up, modifiers ) {
		if ( !canvas.ready || this.hasFocus || up ) return;
		event.preventDefault();
		const direction = this.zoomKeys[modifiers.key];
		const delta = direction === "in" ? 1.05 : 0.95;
		return canvas.animatePan({scale: delta * canvas.stage.scale.x, duration: 100});
	}

	/* -------------------------------------------- */

	/**
	 * Handle DELETE Keypress Events
	 * @param {KeyboardEvent} event     The originating keyboard event
	 * @param {boolean} up              Is the key being released?
	 * @param {Object} modifiers        The identified modifiers attached to this keypress
	 * @private
	 */
	_onDelete(event, up, modifiers) {
		if ( this.hasFocus || up ) return;
		event.preventDefault();

		// Remove hotbar Macro
		if ( ui.hotbar._hover ) game.user.assignHotbarMacro(null, ui.hotbar._hover);

		// Delete placeables from Canvas layer
		else if ( canvas.ready && ( canvas.activeLayer instanceof PlaceablesLayer ) ) {
			return canvas.activeLayer._onDeleteKey(event);
		}
	}
}

/**
 * An abstract interface for managing defined game settings or settings menus for different packages.
 * Each setting is a string key/value pair belonging to a certain package and a certain store scope.
 *
 * When Foundry Virtual Tabletop is initialized, a singleton instance of this class is constructed within the global
 * Game object as as game.settings.
 *
 * @see {@link Game#settings}
 * @see {@link Settings}
 * @see {@link SettingsConfig}
 */
class ClientSettings {
	constructor(worldSettings) {

		/**
		 * A object of registered game settings for this scope
		 * @type {Map}
		 */
		this.settings = new Map();

		/**
		 * Registered settings menus which trigger secondary applications
		 * @type {Map}
		 */
		this.menus = new Map();

		/**
		 * The storage interfaces used for persisting settings
		 * Each storage interface shares the same API as window.localStorage
		 */
		this.storage = new Map([
			["client", window.localStorage],
			["world", new WorldSettings(worldSettings)]
		]);
	}

	/**
	 * The types of settings which should be constructed as a primitive type
	 * @private
	 */
	static PRIMITIVE_TYPES = [String, Number, Boolean, Array];

	/* -------------------------------------------- */

	/**
	 * Return a singleton instance of the Game Settings Configuration app
	 * @return {SettingsConfig}
	 */
	get sheet() {
		if ( !this._sheet ) this._sheet = new SettingsConfig();
		return this._sheet;
	}

	/* -------------------------------------------- */

	/**
	 * Register a new game setting under this setting scope
	 *
	 * @param {string} module   The namespace under which the setting is registered
	 * @param {string} key      The key name for the setting under the namespace module
	 * @param {Object} data     Configuration for setting data
	 *
	 * @example
	 * // Register a client setting
	 * game.settings.register("myModule", "myClientSetting", {
	 *   name: "Register a Module Setting with Choices",
	 *   hint: "A description of the registered setting and its behavior.",
	 *   scope: "client",     // This specifies a client-stored setting
	 *   config: true,        // This specifies that the setting appears in the configuration view
	 *   type: String,
	 *   choices: {           // If choices are defined, the resulting setting will be a select menu
	 *     "a": "Option A",
	 *     "b": "Option B"
	 *   },
	 *   default: "a",        // The default value for the setting
	 *   onChange: value => { // A callback function which triggers when the setting is changed
	 *     console.log(value)
	 *   }
	 * });
	 *
	 * @example
	 * // Register a world setting
	 * game.settings.register("myModule", "myWorldSetting", {
	 *   name: "Register a Module Setting with a Range slider",
	 *   hint: "A description of the registered setting and its behavior.",
	 *   scope: "world",      // This specifies a world-level setting
	 *   config: true,        // This specifies that the setting appears in the configuration view
	 *   type: Number,
	 *   range: {             // If range is specified, the resulting setting will be a range slider
	 *     min: 0,
	 *     max: 100,
	 *     step: 10
	 *   }
	 *   default: 50,         // The default value for the setting
	 *   onChange: value => { // A callback function which triggers when the setting is changed
	 *     console.log(value)
	 *   }
	 * });
	 */
	register(module, key, data) {
		if ( !module || !key ) throw new Error("You must specify both module and key portions of the setting");
		data["key"] = key;
		data["module"] = module;
		data["scope"] = ["client", "world"].includes(data.scope) ? data.scope : "client";
		if ( data.type && !(data.type instanceof Function) ) {
			throw new Error(`Setting ${key} type must be a constructable object or callable function`);
		}
		this.settings.set(`${module}.${key}`, data);
	}

	/* -------------------------------------------- */

	/**
	 * Register a new sub-settings menu
	 *
	 * @param {string} module   The namespace under which the menu is registered
	 * @param {string} key      The key name for the setting under the namespace module
	 * @param {Object} data     Configuration for setting data
	 *
	 * @example
	 * // Define a settings submenu which handles advanced configuration needs
	 * game.settings.registerMenu("myModule", "mySettingsMenu", {
	 *   name: "My Settings Submenu",
	 *   label: "Settings Menu Label",      // The text label used in the button
	 *   hint: "A description of what will occur in the submenu dialog.",
	 *   icon: "fas fa-bars",               // A Font Awesome icon used in the submenu button
	 *   type: MySubmenuApplicationClass,   // A FormApplication subclass which should be created
	 *   restricted: true                   // Restrict this submenu to gamemaster only?
	 * });
	 */
	registerMenu(module, key, data) {
		if ( !module || !key ) throw new Error("You must specify both module and key portions of the menu");
		data.key = `${module}.${key}`;
		data.module = module;
		if ( !data.type || !(data.type.prototype instanceof FormApplication) ) {
			throw new Error("You must provide a menu type that is FormApplication instance or subclass");
		}
		this.menus.set(data.key, data);
	}

	/* -------------------------------------------- */

	/**
	 * Get the value of a game setting for a certain module and setting key
	 *
	 * @param {string} module   The module namespace under which the setting is registered
	 * @param {string} key      The setting key to retrieve
	 *
	 * @example
	 * // Retrieve the current setting value
	 * game.settings.get("myModule", "myClientSetting");
	 */
	get(module, key) {
		if ( !module || !key ) throw new Error("You must specify both module and key portions of the setting");
		key = `${module}.${key}`;
		if ( !this.settings.has(key) ) throw new Error("This is not a registered game setting");

		// Get the setting and the correct storage interface
		const setting = this.settings.get(key);
		const storage = this.storage.get(setting.scope);

		// Get the setting value
		let value = storage.getItem(key);
		if ( value ) {
			try {
				value = JSON.parse(value);
			} catch(err) {
				value = String(value);
			}
		}
		else value = (setting.default || "");

		// Cast the value to a requested type
		if ( setting.type ) {
			if ( !(value instanceof setting.type) ) {
				if ( this.constructor.PRIMITIVE_TYPES.includes(setting.type) ) value = setting.type(value);
				else {
					const isConstructed = setting.type?.prototype?.constructor === setting.type;
					value = isConstructed ? new setting.type(value) : setting.type(value);
				}
			}
		}
		return value
	}

	/* -------------------------------------------- */

	/**
	 * Set the value of a game setting for a certain module and setting key
	 *
	 * @param {string} module   The module namespace under which the setting is registered
	 * @param {string} key      The setting key to retrieve
	 * @param {any} value       The data to assign to the setting key
	 *
	 * @example
	 * // Update the current value of a setting
	 * game.settings.set("myModule", "myClientSetting", "b");
	 */
	async set(module, key, value) {
		if ( !module || !key ) throw new Error("You must specify both module and key portions of the setting");
		key = `${module}.${key}`;
		if ( !this.settings.has(key) ) throw new Error("This is not a registered game setting");

		// Obtain the setting data and serialize the value
		const setting = this.settings.get(key);
		if ( value === undefined ) value = setting.default;
		const json = JSON.stringify(value);

		// Submit World setting changes
		switch (setting.scope) {
			case "world":
				if ( !game.ready ) throw new Error("You may not assign the value of a world-level Setting before the Game is ready.");
				const doc = this.storage.get("world").getSetting(key);
				if ( doc ) await doc.update({value: json});
				else await Setting.create({key, value: json});
				break;
			case "client":
				const storage = this.storage.get(setting.scope);
				storage.setItem(key, json);
				if ( setting.onChange instanceof Function ) setting.onChange(value);
				break;
		}
		return value;
	}
}


class SocketInterface {

	/**
	 * Standardize the way that socket messages are dispatched and their results are handled
	 * @param {string} eventName          The socket event name being handled
	 * @param {SocketRequest} request     Data provided to the Socket event
	 * @return {Promise<SocketResponse>}  A Promise which resolves to the SocketResponse
	 */
	static dispatch(eventName, request) {
		return new Promise((resolve, reject) => {
			game.socket.emit(eventName, request, response => {
				if ( response.error ) {
					const err = this._handleError(response.error);
					reject(err);
				}
				else resolve(response);
			})
		})
	}

	/* -------------------------------------------- */

	/**
	 * Handle an error returned from the database, displaying it on screen and in the console
	 * @param {Error} err   The provided Error message
	 * @private
	 */
	static _handleError(err) {
		let error = err instanceof Error ? err : new Error(err.message);
		if ( err.stack ) error.stack = err.stack;
		if ( ui.notifications ) ui.notifications.error(error.message);
		return error;
	}
}

/**
 * A collection of functions related to sorting objects within a parent container.
 */
class SortingHelpers {

	/**
	 * Given a source object to sort, a target to sort relative to, and an Array of siblings in the container:
	 * Determine the updated sort keys for the source object, or all siblings if a reindex is required.
	 * Return an Array of updates to perform, it is up to the caller to dispatch these updates.
	 * Each update is structured as:
	 * {
	 *   target: object,
	 *   update: {sortKey: sortValue}
	 * }
	 *
	 * @param {*} source            The source object being sorted
	 * @param {*} target            The target object relative which to sort
	 * @param {object[]} siblings   The sorted Array of siblings which share the same sorted container
	 * @param {string} sortKey      The name of the data property within the source object which defines the sort key
	 * @param {boolean} sortBefore  Whether to sort before the target (if true) or after (if false)
	 *
	 * @returns {object[]}          An Array of updates for the caller of the helper function to perform
	 */
	static performIntegerSort(source, {target=null, siblings=[], sortKey="sort", sortBefore=true}={}) {

		// Ensure the siblings are sorted
		siblings.sort((a, b) => a.data[sortKey] - b.data[sortKey]);

		// Determine the index target for the sort
		let defaultIdx = sortBefore ? siblings.length : 0;
		let idx = target ? siblings.findIndex(sib => sib === target) : defaultIdx;

		// Determine the indices to sort between
		let min, max;
		if ( sortBefore ) [min, max] = this._sortBefore(siblings, idx, sortKey);
		else [min, max] = this._sortAfter(siblings, idx, sortKey);

		// Easiest case - no siblings
		if ( siblings.length === 0 ) {
			return [{
				target: source,
				update: {[sortKey]: CONST.SORT_INTEGER_DENSITY}
			}]
		}

		// No minimum - sort to beginning
		else if ( Number.isFinite(max) && (min === null) ) {
			return [{
				target: source,
				update: {[sortKey]: max - CONST.SORT_INTEGER_DENSITY}
			}];
		}

		// No maximum - sort to end
		else if ( Number.isFinite(min) && (max === null) ) {
			return [{
				target: source,
				update: {[sortKey]: min + CONST.SORT_INTEGER_DENSITY}
			}];
		}

		// Sort between two
		else if ( Number.isFinite(min) && Number.isFinite(max) && (Math.abs(max - min) > 1) ) {
			return [{
				target: source,
				update: {[sortKey]: Math.round(0.5 * (min + max))}
			}];
		}

		// Reindex all siblings
		else {
			siblings.splice(idx, 0, source);
			return siblings.map((sib, i) => {
				return {
					target: sib,
					update: {[sortKey]: (i+1) * CONST.SORT_INTEGER_DENSITY}
				}
			});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Given an ordered Array of siblings and a target position, return the [min,max] indices to sort before the target
	 * @private
	 */
	static _sortBefore(siblings, idx, sortKey) {
		let max = siblings[idx] ? siblings[idx].data[sortKey] : null;
		let min = siblings[idx-1] ? siblings[idx-1].data[sortKey] : null;
		return [min, max];
	}

	/* -------------------------------------------- */

	/**
	 * Given an ordered Array of siblings and a target position, return the [min,max] indices to sort after the target
	 * @private
	 */
	static _sortAfter(siblings, idx, sortKey) {
		let min = siblings[idx] ? siblings[idx].data[sortKey] : null;
		let max = siblings[idx+1] ? siblings[idx+1].data[sortKey] : null;
		return [min, max];
	}

	/* -------------------------------------------- */
}
/**
 * A singleton class {@link game#time} which keeps the official Server and World time stamps.
 * Uses a basic implementation of https://www.geeksforgeeks.org/cristians-algorithm/ for synchronization.
 */
class GameTime {
	constructor(socket) {

		/**
		 * The most recently synchronized timestamps retrieved from the server.
		 * @type {{clientTime: number, serverTime: number, worldTime: number}}
		 */
		this._time = {};

		/**
		 * The average one-way latency across the most recent 5 trips
		 * @type {number}
		 */
		this._dt = 0;

		/**
		 * The most recent five synchronization durations
		 * @type {number[]}
		 */
		this._dts = [];

		// Perform an initial sync
		if ( socket ) this.sync(socket);
	}

	/**
	 * The amount of time to delay before re-syncing the official server time.
	 * @type {number}
	 */
	static SYNC_INTERVAL_MS = 1000 * 60 * 5;

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * The current server time based on the last synchronization point and the approximated one-way latency.
	 * @return {number}
	 */
	get serverTime() {
		const t1 = Date.now();
		const dt = t1 - this._time.clientTime;
		if ( dt > GameTime.SYNC_INTERVAL_MS ) this.sync();
		return this._time.serverTime + dt;
	}

	/* -------------------------------------------- */

	/**
	 * The current World time based on the last recorded value of the core.time setting
	 * @return {number}
	 */
	get worldTime() {
		return this._time.worldTime;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Advance the game time by a certain number of seconds
	 * @param {number} seconds        The number of seconds to advance (or rewind if negative) by
	 * @return {Promise<number>}      The new game time
	 */
	async advance(seconds) {
		return game.settings.set("core", "time", this.worldTime + seconds);
	}

	/* -------------------------------------------- */

	/**
	 * Synchronize the local client game time with the official time kept by the server
	 * @return {Promise<GameTime>}
	 */
	async sync(socket) {
		socket = socket ?? game.socket;

		// Get the official time from the server
		const t0 = Date.now();
		const time = await new Promise(resolve => socket.emit("time", resolve));
		const t1 = Date.now();

		// Adjust for trip duration
		if ( this._dts.length >= 5 ) this._dts.unshift();
		this._dts.push(t1 - t0);

		// Re-compute the average one-way duration
		this._dt = Math.round(this._dts.reduce((total, t) => total + t, 0) / (this._dts.length * 2));

		// Adjust the server time and return the adjusted time
		time.clientTime = t1 - this._dt;
		this._time = time;
		console.log(`${vtt} | Synchronized official game time in ${this._dt}ms`);
		return this;
	}

	/* -------------------------------------------- */
	/*  Event Handlers and Callbacks                */
	/* -------------------------------------------- */

	/**
	 * Handle follow-up actions when the official World time is changed
	 * @param {number} worldTime  The new canonical World time.
	 */
	onUpdateWorldTime(worldTime) {
		const dt = worldTime - this._time.worldTime;
		this._time.worldTime = worldTime;
		Hooks.callAll("updateWorldTime", worldTime, dt);
		if ( CONFIG.debug.time ) console.log(`The world time advanced by ${dt} seconds, and is now ${worldTime}.`);
	}
}


/**
 * Export data content to be saved to a local file
 * @param {string} data       Data content converted to a string
 * @param {string} type       The type of
 * @param {string} filename   The filename of the resulting download
 */
function saveDataToFile(data, type, filename) {
	const blob = new Blob([data], {type: type});

	// Create an element to trigger the download
	let a = document.createElement('a');
	a.href = window.URL.createObjectURL(blob);
	a.download = filename;

	// Dispatch a click event to the element
	a.dispatchEvent(new MouseEvent("click", {bubbles: true, cancelable: true, view: window}));
	setTimeout(() => window.URL.revokeObjectURL(a.href), 100);
}


/* -------------------------------------------- */


/**
 * Read text data from a user provided File object
 * @param {File} file           A File object
 * @return {Promise.<String>}   A Promise which resolves to the loaded text data
 */
function readTextFromFile(file) {
	const reader = new FileReader();
	return new Promise((resolve, reject) => {
		reader.onload = ev => {
			resolve(reader.result);
		};
		reader.onerror = ev => {
			reader.abort();
			reject();
		};
		reader.readAsText(file);
	});
}

/* -------------------------------------------- */

/**
 * Retrieve a Document by its Universally Unique Identifier (uuid).
 * @param {string} uuid   The uuid of the Document to retrieve
 * @return {Promise<Document|null>}
 */
async function fromUuid(uuid) {
	let parts = uuid.split(".");
	let doc;

	// Compendium Documents
	if ( parts[0] === "Compendium" ) {
		parts.shift();
		const [scope, packName, id] = parts.slice(0, 3);
		parts = parts.slice(3);
		const pack = game.packs.get(`${scope}.${packName}`);
		doc = await pack.getDocument(id);
	}

	// World Documents
	else {
		const [docName, docId] = parts.slice(0, 2);
		parts = parts.slice(2);
		const collection = CONFIG[docName].collection.instance;
		doc = collection.get(docId);
	}

	// Embedded Documents
	while ( doc && (parts.length > 1) ) {
		const [embeddedName, embeddedId] = parts.slice(0, 2);
		doc = doc.getEmbeddedDocument(embeddedName, embeddedId);
		parts = parts.slice(2);
	}
	return doc || null;
}

/* -------------------------------------------- */

/**
 * Return a reference to the Document class implementation which is configured for use.
 * @param {string} documentName     The canonical Document name, for example "Actor"
 * @return {Function}               The configured Document class implementation
 */
function getDocumentClass(documentName) {
	return CONFIG[documentName]?.documentClass;
}

/* -------------------------------------------- */

/**
 * A helper class to provide common functionality for working with HTML5 video objects
 * A singleton instance of this class is available as ``game.video``
 */
class VideoHelper {
	constructor() {
		if ( game.video instanceof this.constructor ) {
			throw new Error("You may not re-initialize the singleton VideoHelper. Use game.video instead.");
		}

		/**
		 * A collection of HTML5 video objects which are currently active within the FVTT page
		 * @type {Object}
		 */
		this.videos = [];

		/**
		 * A user gesture must be registered before video playback can begin.
		 * This Set records the video elements which await such a gesture.
		 * @type {Set}
		 */
		this.pending = new Set();

		/**
		 * A mapping of base64 video thumbnail images
		 * @type {Map<string,string>}
		 */
		this.thumbs = new Map();

		/**
		 * A flag for whether video playback is currently locked by awaiting a user gesture
		 * @type {boolean}
		 */
		 this.locked = true;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	static hasVideoExtension(src) {
		let rgx = new RegExp("(\\."+CONST.VIDEO_FILE_EXTENSIONS.join("|\\.")+")(\\?.*)?", "i");
		return rgx.test(src);
	}

	/* -------------------------------------------- */

	/**
	 * Play a single video source
	 * If playback is not yet enabled, add the video to the pending queue
	 * @param {HTMLElement} video   The VIDEO element to play
	 */
	play(video) {
		video.play().catch(err => {
			if ( this.locked ) this.pending.add(video);
			else throw new Error(err.toString());
		});
	}

	/* -------------------------------------------- */

	/**
	 * Stop a single video source
	 * @param {HTMLElement} video   The VIDEO element to stop
	 */
	stop(video) {
		video.pause();
		video.currentTime = 0;
	}

	/* -------------------------------------------- */

	/**
	 * Register an event listener to await the first mousemove gesture and begin playback once observed
	 * A user interaction must involve a mouse click or keypress.
	 * Listen for any of these events, and handle the first observed gesture.
	 */
	awaitFirstGesture() {
		if ( !this.locked ) return;
		const interactions = ['contextmenu', 'auxclick', 'mousedown', 'mouseup', 'keydown'];
		interactions.forEach(event => document.addEventListener(event, this._onFirstGesture.bind(this), {once: true}));
	}

	/* -------------------------------------------- */

	/**
	 * Handle the first observed user gesture
	 * We need a slight delay because unfortunately Chrome is stupid and doesn't always acknowledge the gesture fast enough.
	 * @param {Event} event   The mouse-move event which enables playback
	 */
	_onFirstGesture(event) {
		if ( !this.pending.size ) return;
		console.log(`${vtt} | Activating pending video playback with user gesture.`);
		this.locked = false;
		for ( let video of Array.from(this.pending) ) {
			this.play(video);
		}
		this.pending.clear();
	}

	/* -------------------------------------------- */

	/**
	 * Create and cache a static thumbnail to use for the video.
	 * The thumbnail is cached using the video file path or URL.
	 * @param {string} src        The source video URL
	 * @param {object} options    Thumbnail creation options, including width and height
	 * @return {Promise<string>}  The created and cached base64 thumbnail image
	 */
	async createThumbnail(src, options) {
		const t = await ImageHelper.createThumbnail(src, options);
		this.thumbs.set(src, t.thumb);
		return t.thumb;
	}
}

/**
 * A namespace containing the user interface applications which are defined throughout the Foundry VTT ecosystem.
 * @namespace applications
 */

let _appId = 0;
let _maxZ = 100;

const MIN_WINDOW_WIDTH = 200;
const MIN_WINDOW_HEIGHT = 50;

/**
 * The standard application window that is rendered for a large variety of UI elements in Foundry VTT.
 * @abstract
 * @param {Object} options                      Configuration options which control how the application is rendered.
 *                                              Application subclasses may add additional supported options, but the
 *                                              following configurations are supported for all Applications. The values
 *                                              passed to the constructor are combined with the defaultOptions defined
 *                                              at the class level.
 * @param {string} [options.baseApplication]      A named "base application" which generates an additional hook
 * @param {number} [options.width]                The default pixel width for the rendered HTML
 * @param {number} [options.height]               The default pixel height for the rendered HTML
 * @param {number} [options.top]                  The default offset-top position for the rendered HTML
 * @param {number} [options.left]                 The default offset-left position for the rendered HTML
 * @param {boolean} [options.popOut]              Whether to display the application as a pop-out container
 * @param {boolean} [options.minimizable]         Whether the rendered application can be minimized (popOut only)
 * @param {boolean} [options.resizable]           Whether the rendered application can be drag-resized (popOut only)
 * @param {string} [options.id]                   The default CSS id to assign to the rendered HTML
 * @param {string[]} [options.classes]            An array of CSS string classes to apply to the rendered HTML
 * @param {string} [options.title]                A default window title string (popOut only)
 * @param {string} [options.template]             The default HTML template path to render for this Application
 * @param {string[]} [options.scrollY]            A list of unique CSS selectors which target containers that should
 *                                                have their vertical scroll positions preserved during a re-render.
 * @param {TabsConfiguration[]} [options.tabs]    An array of tabbed container configurations which should be enabled
 *                                                for the application.
 */
class Application {
	constructor(options={}) {

		/**
		 * The options provided to this application upon initialization
		 * @type {Object}
		 */
		this.options = foundry.utils.mergeObject(this.constructor.defaultOptions, options, {
			insertKeys: true,
			insertValues: true,
			overwrite: true,
			inplace: false
		});

		/**
		 * The application ID is a unique incrementing integer which is used to identify every application window
		 * drawn by the VTT
		 * @type {number}
		 */
		this.appId = _appId += 1;

		/**
		 * An internal reference to the HTML element this application renders
		 * @type {jQuery}
		 */
		this._element = null;

		/**
		 * Track the current position and dimensions of the Application UI
		 * @type {Object}
		 */
		this.position = {
			width: this.options.width,
			height: this.options.height,
			left: this.options.left,
			top: this.options.top,
			scale: this.options.scale
		};

		/**
		 * DragDrop workflow handlers which are active for this Application
		 * @type {DragDrop[]}
		 */
		this._dragDrop = this._createDragDropHandlers();

		/**
		 * Tab navigation handlers which are active for this Application
		 * @type {Tabs[]}
		 */
		this._tabs = this._createTabHandlers();

		/**
		 * SearchFilter handlers which are active for this Application
		 * @type {SearchFilter[]}
		 */
		this._searchFilters = this._createSearchFilters();

		/**
		 * Track whether the Application is currently minimized
		 * @type {boolean}
		 */
		this._minimized = false;

		/**
		 * The current render state of the Application
		 * @see {Application.RENDER_STATES}
		 * @type {number}
		 * @protected
		 */
		this._state = Application.RENDER_STATES.NONE;

		/**
		 * The prior render state of this Application.
		 * This allows for rendering logic to understand if the application is being rendered for the first time.
		 * @see {Application.RENDER_STATES}
		 * @type {number}
		 * @protected
		 */
		this._priorState = this._state;

		/**
		 * Track the most recent scroll positions for any vertically scrolling containers
		 * @type {Object|null}
		 */
		this._scrollPositions = null;
	}

	/**
	 * The sequence of rendering states that track the Application life-cycle.
	 * @enum {number}
	 */
	static RENDER_STATES = {
		CLOSING: -2,
		CLOSED: -1,
		NONE: 0,
		RENDERING: 1,
		RENDERED: 2,
		ERROR: 3
	};

	/* -------------------------------------------- */

	/**
	 * Create drag-and-drop workflow handlers for this Application
	 * @return {DragDrop[]}     An array of DragDrop handlers
	 * @private
	 */
	_createDragDropHandlers() {
		return this.options.dragDrop.map(d => {
			d.permissions = {
				dragstart: this._canDragStart.bind(this),
				drop: this._canDragDrop.bind(this)
			};
			d.callbacks = {
				dragstart: this._onDragStart.bind(this),
				dragover: this._onDragOver.bind(this),
				drop: this._onDrop.bind(this)
			};
			return new DragDrop(d);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Create tabbed navigation handlers for this Application
	 * @return {Tabs[]}     An array of Tabs handlers
	 * @private
	 */
	_createTabHandlers() {
		return this.options.tabs.map(t => {
			t.callback = this._onChangeTab.bind(this);
			return new Tabs(t);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Create search filter handlers for this Application
	 * @return {SearchFilter[]}  An array of SearchFilter handlers
	 * @private
	 */
	_createSearchFilters() {
		return this.options.filters.map(f => {
			f.callback = this._onSearchFilter.bind(this);
			return new SearchFilter(f);
		})
	}

	/* -------------------------------------------- */

	/**
	 * Assign the default options configuration which is used by this Application class. The options and values defined
	 * in this object are merged with any provided option values which are passed to the constructor upon initialization.
	 * Application subclasses may include additional options which are specific to their usage.
	 */
	static get defaultOptions() {
		return {
			baseApplication: null,
			width: null,
			height: null,
			top: null,
			left: null,
			popOut: true,
			minimizable: true,
			resizable: false,
			id: "",
			classes: [],
			dragDrop: [],
			tabs: [],
			filters: [],
			title: "",
			template: null,
			scrollY: []
		};
	};

	/* -------------------------------------------- */

	/**
	 * Return the CSS application ID which uniquely references this UI element
	 * @type {string}
	 */
	get id() {
		return this.options.id ? this.options.id : `app-${this.appId}`;
	}

	/* -------------------------------------------- */

	/**
	 * Return the active application element, if it currently exists in the DOM
	 * @type {jQuery|HTMLElement}
	 */
	get element() {
		if ( this._element ) return this._element;
		let selector = "#"+this.id;
		return $(selector);
	}

	/* -------------------------------------------- */

	/**
	 * The path to the HTML template file which should be used to render the inner content of the app
	 * @type {string}
	 */
	get template() {
		return this.options.template;
	}

	/* -------------------------------------------- */

	/**
	 * Control the rendering style of the application. If popOut is true, the application is rendered in its own
	 * wrapper window, otherwise only the inner app content is rendered
	 * @type {boolean}
	 */
	get popOut() {
		return this.options.popOut ?? true;
	}

	/* -------------------------------------------- */

	/**
	 * Return a flag for whether the Application instance is currently rendered
	 * @type {boolean}
	 */
	get rendered() {
		return this._state === Application.RENDER_STATES.RENDERED;
	}

	/* -------------------------------------------- */

	/**
	 * An Application window should define its own title definition logic which may be dynamic depending on its data
	 * @type {string}
	 */
	get title() {
		return game.i18n.localize(this.options.title);
	}

	/* -------------------------------------------- */
	/* Application rendering
	/* -------------------------------------------- */

	/**
	 * An application should define the data object used to render its template.
	 * This function may either return an Object directly, or a Promise which resolves to an Object
	 * If undefined, the default implementation will return an empty object allowing only for rendering of static HTML
	 *
	 * @return {Object|Promise}
	 */
	getData(options={}) {
		return {};
	}

	/* -------------------------------------------- */

	/**
	 * Render the Application by evaluating it's HTML template against the object of data provided by the getData method
	 * If the Application is rendered as a pop-out window, wrap the contained HTML in an outer frame with window controls
	 *
	 * @param {boolean} force   Add the rendered application to the DOM if it is not already present. If false, the
	 *                          Application will only be re-rendered if it is already present.
	 * @param {Object} options  Additional rendering options which are applied to customize the way that the Application
	 *                          is rendered in the DOM.
	 *
	 * @param {number} [options.left]           The left positioning attribute
	 * @param {number} [options.top]            The top positioning attribute
	 * @param {number} [options.width]          The rendered width
	 * @param {number} [options.height]         The rendered height
	 * @param {number} [options.scale]          The rendered transformation scale
	 * @param {boolean} [options.focus=false]   Apply focus to the application, maximizing it and bringing it to the top
	 *                                          of the vertical stack.
	 * @param {string} [options.renderContext]  A context-providing string which suggests what event triggered the render
	 * @param {object} [options.renderData]     The data change which motivated the render request
	 *
	 * @returns {Application}                 The rendered Application instance
	 *
	 */
	render(force=false, options={}) {
		this._render(force, options).catch(err => {
			err.message = `An error occurred while rendering ${this.constructor.name} ${this.appId}: ${err.message}`;
			console.error(err);
			this._state = Application.RENDER_STATES.ERROR;
		});
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * An asynchronous inner function which handles the rendering of the Application
	 * @param {boolean} force     Render and display the application even if it is not currently displayed.
	 * @param {Object} options    New Application options which update the current values of the Application#options object
	 * @return {Promise<void>}    A Promise that resolves to the Application once rendering is complete
	 * @protected
	 */
	async _render(force=false, options={}) {

		// Do not render under certain conditions
		const states = Application.RENDER_STATES;
		this._priorState = this._state;
		if ( [states.CLOSING, states.RENDERING].includes(this._state) ) return;

		// Applications which are not currently rendered must be forced
		if ( !force && (this._state <= states.NONE) ) return;

		// Begin rendering the application
		if ( [states.NONE, states.CLOSED, states.ERROR].includes(this._state) ) {
			console.log(`${vtt} | Rendering ${this.constructor.name}`);
		}
		this._state = states.RENDERING;

		// Merge provided options with those supported by the Application class
		foundry.utils.mergeObject(this.options, options, { insertKeys: false });

		// Get the existing HTML element and application data used for rendering
		const element = this.element;
		const data = await this.getData(this.options);

		// Store scroll positions
		if ( element.length && this.options.scrollY ) this._saveScrollPositions(element);

		// Render the inner content
		const inner = await this._renderInner(data);
		let html = inner;

		// If the application already exists in the DOM, replace the inner content
		if ( element.length ) this._replaceHTML(element, html);

		// Otherwise render a new app
		else {

			// Wrap a popOut application in an outer frame
			if ( this.popOut ) {
				html = await this._renderOuter();
				html.find('.window-content').append(inner);
				ui.windows[this.appId] = this;
			}

			// Add the HTML to the DOM and record the element
			this._injectHTML(html);
		}

		// Activate event listeners on the inner HTML
		this._activateCoreListeners(inner);
		this.activateListeners(inner);

		// Set the application position (if it's not currently minimized)
		if ( !this._minimized ) {
			foundry.utils.mergeObject(this.position, options, {insertKeys: false});
			this.setPosition(this.position);
		}

		// Apply focus to the application, maximizing it and bringing it to the top
		if ( options.focus === true ) {
			this.maximize().then(() => this.bringToTop());
		}

		// Dispatch Hooks for rendering the base and subclass applications
		for ( let cls of this.constructor._getInheritanceChain() ) {

			/**
			 * A hook event that fires whenever this Application is rendered.
			 * The hook provides the pending application HTML which will be added to the DOM.
			 * Hooked functions may modify that HTML or attach interactive listeners to it.
			 *
			 * @function renderApplication
			 * @memberof hookEvents
			 * @param {Application} app     The Application instance being rendered
			 * @param {jQuery} html         The inner HTML of the document that will be displayed and may be modified
			 * @param {object} data         The object of data used when rendering the application
			 */
			Hooks.call(`render${cls.name}`, this, html, data);
		}

		// Restore prior scroll positions
		if ( this.options.scrollY ) this._restoreScrollPositions(html);
		this._state = states.RENDERED;
	}

	/* -------------------------------------------- */

	/**
	 * Return the inheritance chain for this Application class up to (and including) it's base Application class.
	 * @return {Application[]}
	 * @private
	 */
	static _getInheritanceChain() {
		const parents = getParentClasses(this);
		const base = this.defaultOptions.baseApplication;
		const chain = [this];
		for ( let cls of parents ) {
			chain.push(cls);
			if ( cls.name === base ) break;
		}
		return chain;
	}

	/* -------------------------------------------- */

	/**
	 * Persist the scroll positions of containers within the app before re-rendering the content
	 * @param {jQuery} html           The HTML object being traversed
	 * @private
	 */
	_saveScrollPositions(html) {
		const selectors = this.options.scrollY || [];
		this._scrollPositions = selectors.reduce((pos, sel) => {
			const el = html.find(sel);
			if ( el.length === 1 ) pos[sel] = el[0].scrollTop;
			return pos;
		}, {});
	}

	/* -------------------------------------------- */

	/**
	 * Restore the scroll positions of containers within the app after re-rendering the content
	 * @param {jQuery} html           The HTML object being traversed
	 * @private
	 */
	_restoreScrollPositions(html) {
		const selectors = this.options.scrollY || [];
		const positions = this._scrollPositions || {};
		for ( let sel of selectors ) {
			const el = html.find(sel);
			if ( el.length === 1 ) el[0].scrollTop = positions[sel] || 0;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Render the outer application wrapper
	 * @return {Promise.<HTMLElement>}   A promise resolving to the constructed jQuery object
	 * @private
	 */
	async _renderOuter() {

		// Gather basic application data
		const classes = this.options.classes;
		const windowData = {
			id: this.id,
			classes: classes.join(" "),
			appId: this.appId,
			title: this.title,
			headerButtons: this._getHeaderButtons()
		};

		// Render the template and return the promise
		let html = await renderTemplate("templates/app-window.html", windowData);
		html = $(html);

		// Activate header button click listeners after a slight timeout to prevent immediate interaction
		setTimeout(() => {
			html.find(".header-button").click(event => {
				event.preventDefault();
				const button = windowData.headerButtons.find(b => event.currentTarget.classList.contains(b.class));
				button.onclick(event);
			});
		}, 500);

		// Make the outer window draggable
		const header = html.find('header')[0];
		new Draggable(this, html, header, this.options.resizable);

		// Make the outer window minimizable
		if ( this.options.minimizable ) {
			header.addEventListener('dblclick', this._onToggleMinimize.bind(this));
		}

		// Set the outer frame z-index
		if ( Object.keys(ui.windows).length === 0 ) _maxZ = 100 - 1;
		html.css({zIndex: Math.min(++_maxZ, 9999)});

		// Return the outer frame
		return html;
	}

	/* -------------------------------------------- */

	/**
	 * Render the inner application content
	 * @param {Object} data         The data used to render the inner template
	 * @return {Promise.<jQuery>}   A promise resolving to the constructed jQuery object
	 * @private
	 */
	async _renderInner(data) {
		let html = await renderTemplate(this.template, data);
		if ( html === "" ) throw new Error(`No data was returned from template ${this.template}`);
		return $(html);
	}

	/* -------------------------------------------- */

	/**
	 * Customize how inner HTML is replaced when the application is refreshed
	 * @param {HTMLElement|jQuery} element  The original HTML element
	 * @param {HTMLElement|jQuery} html     New updated HTML
	 * @private
	 */
	_replaceHTML(element, html) {
		if ( !element.length ) return;

		// For pop-out windows update the inner content and the window title
		if ( this.popOut ) {
			element.find('.window-content').html(html);
			element.find('.window-title').text(this.title);
		}

		// For regular applications, replace the whole thing
		else {
			element.replaceWith(html);
			this._element = html;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Customize how a new HTML Application is added and first appears in the DOM
	 * @param {jQuery} html       The HTML element which is ready to be added to the DOM
	 * @private
	 */
	_injectHTML(html) {
		$('body').append(html);
		this._element = html;
		html.hide().fadeIn(200);
	}

	/* -------------------------------------------- */

	/**
	 * Specify the set of config buttons which should appear in the Application header.
	 * Buttons should be returned as an Array of objects.
	 * The header buttons which are added to the application can be modified by the getApplicationHeaderButtons hook.
	 * @typedef {{label: string, class: string, icon: string, onclick: Function|null}} ApplicationHeaderButton
	 * @fires Application#hook:getApplicationHeaderButtons
	 * @return {ApplicationHeaderButton[]}
	 * @private
	 */
	_getHeaderButtons() {
		const buttons = [
			{
				label: "Close",
				class: "close",
				icon: "fas fa-times",
				onclick: () => this.close()
			}
		];
		for ( let cls of this.constructor._getInheritanceChain() ) {

			/**
			 * A hook event that fires whenever this Application is first rendered to add buttons to its header.
			 * @function getApplicationHeaderButtons
			 * @memberof hookEvents
			 * @param {Application} app                     The Application instance being rendered
			 * @param {ApplicationHeaderButton[]} buttons   The array of header buttons which will be displayed
			 */
			Hooks.call(`get${cls.name}HeaderButtons`, this, buttons);
		}
		return buttons;
	}

	/* -------------------------------------------- */
	/* Event Listeners and Handlers
	/* -------------------------------------------- */

	/**
	 * Activate required listeners which must be enabled on every Application.
	 * These are internal interactions which should not be overridden by downstream subclasses.
	 * @param {jQuery} html
	 * @protected
	 */
	_activateCoreListeners(html) {
		const el = html[0];
		this._tabs.forEach(t => t.bind(el));
		this._dragDrop.forEach(d => d.bind(el));
		this._searchFilters.forEach(f => f.bind(el));
	}

	/* -------------------------------------------- */

	/**
	 * After rendering, activate event listeners which provide interactivity for the Application.
	 * This is where user-defined Application subclasses should attach their event-handling logic.
	 * @param {jQuery} html
	 */
	activateListeners(html) {}

	/* -------------------------------------------- */

	/**
	 * Handle changes to the active tab in a configured Tabs controller
	 * @param {MouseEvent} event    A left click event
	 * @param {Tabs} tabs           The Tabs controller
	 * @param {string} active       The new active tab name
	 * @private
	 */
	_onChangeTab(event, tabs, active) {
		this.setPosition();
	}

	/* -------------------------------------------- */

	/**
	 * Handle changes to search filtering controllers which are bound to the Application
	 * @param {KeyboardEvent} event   The key-up event from keyboard input
	 * @param {string} query          The raw string input to the search field
	 * @param {RegExp} rgx            The regular expression to test against
	 * @param {HTMLElement} html      The HTML element which should be filtered
	 * @private
	 */
	_onSearchFilter(event, query, rgx, html) {}

	/* -------------------------------------------- */

	/**
	 * Define whether a user is able to begin a dragstart workflow for a given drag selector
	 * @param {string} selector       The candidate HTML selector for dragging
	 * @return {boolean}              Can the current user drag this selector?
	 * @private
	 */
	_canDragStart(selector) {
		return game.user.isGM;
	}

	/* -------------------------------------------- */

	/**
	 * Define whether a user is able to conclude a drag-and-drop workflow for a given drop selector
	 * @param {string} selector       The candidate HTML selector for the drop target
	 * @return {boolean}              Can the current user drop on this selector?
	 * @private
	 */
	_canDragDrop(selector) {
		return game.user.isGM;
	}

	/* -------------------------------------------- */

	/**
	 * Callback actions which occur at the beginning of a drag start workflow.
	 * @param {DragEvent} event       The originating DragEvent
	 * @private
	 */
	_onDragStart(event) {}

	/* -------------------------------------------- */

	/**
	 * Callback actions which occur when a dragged element is over a drop target.
	 * @param {DragEvent} event       The originating DragEvent
	 * @private
	 */
	_onDragOver(event) {}

	/* -------------------------------------------- */

	/**
	 * Callback actions which occur when a dragged element is dropped on a target.
	 * @param {DragEvent} event       The originating DragEvent
	 * @private
	 */
	_onDrop(event) {}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Bring the application to the top of the rendering stack
	 */
	bringToTop() {
		const element = this.element[0];
		const z = document.defaultView.getComputedStyle(element).zIndex;
		if ( z < _maxZ ) {
			element.style.zIndex = Math.min(++_maxZ, 99999);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Close the application and un-register references to it within UI mappings
	 * This function returns a Promise which resolves once the window closing animation concludes
	 * @return {Promise<void>}    A Promise which resolves once the application is closed
	 */
	async close(options={}) {
		const states = Application.RENDER_STATES;
		if ( !options.force && ![states.RENDERED, states.ERROR].includes(this._state) ) return;
		this._state = states.CLOSING;

		// Get the element
		let el = this.element;
		if ( !el ) return this._state = states.CLOSED;
		el.css({minHeight: 0});

		// Dispatch Hooks for closing the base and subclass applications
		for ( let cls of this.constructor._getInheritanceChain() ) {

			/**
			 * A hook event that fires whenever this Application is closed.
			 * @function closeApplication
			 * @memberof hookEvents
			 * @param {Application} app                     The Application instance being closed
			 * @param {jQuery[]} html                       The application HTML when it is closed
			 */
			Hooks.call(`close${cls.name}`, this, el);
		}

		// Animate closing the element
		return new Promise(resolve => {
			el.slideUp(200, () => {
				el.remove();

				// Clean up data
				this._element = null;
				delete ui.windows[this.appId];
				this._minimized = false;
				this._scrollPositions = null;
				this._state = states.CLOSED;
				resolve();
			});
		});
	}

	/* -------------------------------------------- */

	/**
	 * Minimize the pop-out window, collapsing it to a small tab
	 * Take no action for applications which are not of the pop-out variety or apps which are already minimized
	 * @return {Promise<void>}  A Promise which resolves once the minimization action has completed
	 */
	async minimize() {
		if ( !this.rendered || !this.popOut || [true, null].includes(this._minimized) ) return;
		this._minimized = null;

		// Get content
		let window = this.element,
				header = window.find('.window-header'),
				content = window.find('.window-content');

		// Remove minimum width and height styling rules
		window.css({minWidth: 100, minHeight: 30});

		// Slide-up content
		content.slideUp(100);

		// Slide up window height
		return new Promise((resolve) => {
			window.animate({height: `${header[0].offsetHeight+1}px`}, 100, () => {
				header.children().not(".window-title").not(".close").hide();
				window.animate({width: MIN_WINDOW_WIDTH}, 100, () => {
					window.addClass("minimized");
					this._minimized = true;
					resolve();
				});
			});
		})
	}

	/* -------------------------------------------- */

	/**
	 * Maximize the pop-out window, expanding it to its original size
	 * Take no action for applications which are not of the pop-out variety or are already maximized
	 * @return {Promise<void>}    A Promise which resolves once the maximization action has completed
	 */
	async maximize() {
		if ( !this.popOut || [false, null].includes(this._minimized) ) return;
		this._minimized = null;

		// Get content
		let window = this.element,
				header = window.find('.window-header'),
				content = window.find('.window-content');

		// Expand window
		return new Promise((resolve) => {
			window.animate({width: this.position.width, height: this.position.height}, 100, () => {
				header.children().show();
				content.slideDown(100, () => {
					window.removeClass("minimized");
					this._minimized = false;
					window.css({minWidth: '', minHeight: ''});
					this.setPosition(this.position);
					resolve();
				});
			});
		})
	}

	/* -------------------------------------------- */

	/**
	 * Set the application position and store it's new location.
	 *
	 * @param {number|null} left            The left offset position in pixels
	 * @param {number|null} top             The top offset position in pixels
	 * @param {number|null} width           The application width in pixels
	 * @param {number|string|null} height   The application height in pixels
	 * @param {number|null} scale           The application scale as a numeric factor where 1.0 is default
	 *
	 * @returns {{left: number, top: number, width: number, height: number, scale:number}}
	 * The updated position object for the application containing the new values
	 */
	setPosition({left, top, width, height, scale}={}) {
		if ( !this.popOut ) return; // Only configure position for popout apps
		const el = this.element[0];
		const currentPosition = this.position;
		const pop = this.popOut;
		const styles = window.getComputedStyle(el);

		// If Height is "auto" unset current preference
		if ( (height === "auto") || (this.options.height === "auto") ) {
			el.style.height = "";
			height = null;
		}

		// Update width if an explicit value is passed, or if no width value is set on the element
		if ( !el.style.width || width ) {
			const tarW = width || el.offsetWidth;
			const minW = parseInt(styles.minWidth) || (pop ? MIN_WINDOW_WIDTH : 0);
			const maxW = el.style.maxWidth || window.innerWidth;
			currentPosition.width = width = Math.clamped(tarW, minW, maxW);
			el.style.width = width+"px";
			if ( (width + currentPosition.left) > window.innerWidth ) left = currentPosition.left;
		}
		width = el.offsetWidth;

		// Update height if an explicit value is passed, or if no height value is set on the element
		if ( !el.style.height || height ) {
			const tarH = height || (el.offsetHeight + 1);
			const minH = parseInt(styles.minHeight) || (pop ? MIN_WINDOW_HEIGHT : 0);
			const maxH = el.style.maxHeight || window.innerHeight;
			currentPosition.height = height = Math.clamped(tarH, minH, maxH);
			el.style.height = height+"px";
			if ( (height + currentPosition.top) > window.innerHeight + 1 ) top = currentPosition.top - 1;
		}
		height = el.offsetHeight;

		// Update Left
		if ( (pop && !el.style.left) || Number.isFinite(left) ) {
			const tarL = Number.isFinite(left) ? left : (window.innerWidth - width) / 2;
			const maxL = Math.max(window.innerWidth - width, 0);
			currentPosition.left = left = Math.clamped(tarL, 0, maxL);
			el.style.left = left+"px";
		}

		// Update Top
		if ( (pop && !el.style.top) || Number.isFinite(top) ) {
			const tarT = Number.isFinite(top) ? top : (window.innerHeight - height) / 2;
			const maxT = Math.max(window.innerHeight - height, 0);
			currentPosition.top = top = Math.clamped(tarT, 0, maxT);
			el.style.top = currentPosition.top+"px";
		}

		// Update Scale
		if ( scale ) {
			currentPosition.scale = Math.max(scale, 0);
			if ( scale === 1 ) el.style.transform = "";
			else el.style.transform = `scale(${scale})`;
		}

		// Return the updated position object
		return currentPosition;
	}

	/* -------------------------------------------- */

	/**
	 * Handle application minimization behavior - collapsing content and reducing the size of the header
	 * @param {Event} ev
	 * @private
	 */
	_onToggleMinimize(ev) {
		ev.preventDefault();
		if ( this._minimized ) this.maximize(ev);
		else this.minimize(ev);
	}

	/* -------------------------------------------- */

	/**
	 * Additional actions to take when the application window is resized
	 * @param {Event} event
	 * @private
	 */
	_onResize(event) {}
}
Object.freeze(Application.RENDER_STATES);

/**
 * @typedef {Object} ApplicationOptions
 * @property {boolean} [closeOnSubmit=true]     Whether to automatically close the application when it's contained
 *                                              form is submitted.
 * @property {boolean} [submitOnChange=false]   Whether to automatically submit the contained HTML form when an input
 *                                              or select element is changed.
 * @property {boolean} [submitOnClose=false]    Whether to automatically submit the contained HTML form when the
 *                                              application window is manually closed.
 * @property {boolean} [editable=true]          Whether the application form is editable - if true, it's fields will
 *                                              be unlocked and the form can be submitted. If false, all form fields
 *                                              will be disabled and the form cannot be submitted.
 */

/**
 * An abstract pattern for defining an Application responsible for updating some object using an HTML form
 *
 * A few critical assumptions:
 * 1) This application is used to only edit one object at a time
 * 2) The template used contains one (and only one) HTML form as it's outer-most element
 * 3) This abstract layer has no knowledge of what is being updated, so the implementation must define _updateObject
 *
 * @extends {Application}
 * @abstract
 * @interface
 *
 * @param {Object} object                 Some object which is the target data structure to be be updated by the form.
 * @param {ApplicationOptions} options    Additional options which modify the rendering of the sheet.
 */
class FormApplication extends Application {
	constructor(object={}, options={}) {
		super(options);

		/**
		 * The object target which we are using this form to modify
		 * @type {*}
		 */
		this.object = object;

		/**
		 * A convenience reference to the form HTMLElement
		 * @type {HTMLElement}
		 */
		this.form = null;

		/**
		 * Keep track of any FilePicker instances which are associated with this form
		 * The values of this Array are inner-objects with references to the FilePicker instances and other metadata
		 * @type {FilePicker[]}
		 */
		this.filepickers = [];

		/**
		 * Keep track of any mce editors which may be active as part of this form
		 * The values of this object are inner-objects with references to the MCE editor and other metadata
		 * @type {Object<string, object>}
		 */
		this.editors = {};
	}

	/* -------------------------------------------- */

	/**
	 * Assign the default options which are supported by the entity edit sheet.
	 * In addition to the default options object supported by the parent Application class, the Form Application
	 * supports the following additional keys and values:
	 *
	 * @returns {ApplicationOptions}    The default options for this FormApplication class
	 */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["form"],
			closeOnSubmit: true,
			submitOnChange: false,
			submitOnClose: false,
			editable: true
		});
	}

	/* -------------------------------------------- */

	/**
	 * Is the Form Application currently editable?
	 * @type {boolean}
	 */
	get isEditable() {
		return this.options.editable;
	}

	/* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options={}) {
		return {
			object: this.object,
			options: this.options,
			title: this.title
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _render(force, options) {

		// Identify the focused element
		let focus = this.element.find(":focus");
		focus = focus.length ? focus[0] : null;

		// Render the application and restore focus
		await super._render(force, options);
		if ( focus && focus.name ) {
			const input = this.form[focus.name];
			if ( input && (input.focus instanceof Function) ) input.focus();
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _renderInner(...args) {
		const html = await super._renderInner(...args);
		this.form = html[0] instanceof HTMLFormElement ? html[0] : html.find("form")[0];
		return html;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_activateCoreListeners(html) {
		super._activateCoreListeners(html);
		if ( !this.isEditable ) {
			return this._disableFields(this.form);
		}
		this.form.onsubmit = this._onSubmit.bind(this);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		super.activateListeners(html);
		if ( !this.isEditable ) return;
		html.on("change", "input,select,textarea", this._onChangeInput.bind(this));
		html.find('.editor-content[data-edit]').each((i, div) => this._activateEditor(div));
		for ( let fp of html.find('button.file-picker') ) {
			fp.onclick = this._activateFilePicker.bind(this);
		}
	}

	/* -------------------------------------------- */

	/**
	 * If the form is not editable, disable its input fields
	 * @param {HTMLElement} form    The form HTML
	 * @protected
	 */
	_disableFields(form) {
		const inputs = ["INPUT", "SELECT", "TEXTAREA", "BUTTON"];
		for ( let i of inputs ) {
			for ( let el of form.getElementsByTagName(i) ) el.setAttribute("disabled", "");
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle standard form submission steps
	 * @param {Event} event               The submit event which triggered this handler
	 * @param {Object|null} [updateData]  Additional specific data keys/values which override or extend the contents of
	 *                                    the parsed form. This can be used to update other flags or data fields at the
	 *                                    same time as processing a form submission to avoid multiple database operations.
	 * @param {boolean} [preventClose]    Override the standard behavior of whether to close the form on submit
	 * @param {boolean} [preventRender]   Prevent the application from re-rendering as a result of form submission
	 * @returns {Promise}                 A promise which resolves to the validated update data
	 * @protected
	 */
	async _onSubmit(event, {updateData=null, preventClose=false, preventRender=false}={}) {
		event.preventDefault();

		// Prevent double submission
		const states = this.constructor.RENDER_STATES;
		if ( (this._state === states.NONE) || !this.isEditable || this._submitting ) return false;
		this._submitting = true;

		// Process the form data
		const formData = this._getSubmitData(updateData);

		// Handle the form state prior to submission
		let closeForm = this.options.closeOnSubmit && !preventClose;
		const priorState = this._state;
		if ( preventRender ) this._state = states.RENDERING;
		if ( closeForm ) this._state = states.CLOSING;

		// Trigger the object update
		try {
			await this._updateObject(event, formData);
		}
		catch (err) {
			console.error(err);
			closeForm = false;
			this._state = priorState;
		}

		// Restore flags and optionally close the form
		this._submitting = false;
		if ( preventRender ) this._state = priorState;
		if ( closeForm ) await this.close({submit: false, force: true});
		return formData;
	}

	/* -------------------------------------------- */

	/**
	 * Get an object of update data used to update the form's target object
	 * @param {object} updateData     Additional data that should be merged with the form data
	 * @return {object}               The prepared update data
	 * @protected
	 */
	_getSubmitData(updateData={}) {
		if ( !this.form ) throw new Error(`The FormApplication subclass has no registered form element`);
		const fd = new FormDataExtended(this.form, {editors: this.editors});
		let data = fd.toObject();
		if ( updateData ) data = foundry.utils.flattenObject(foundry.utils.mergeObject(data, updateData));
		return data;
	}

	/* -------------------------------------------- */

	/**
	 * Handle changes to an input element, submitting the form if options.submitOnChange is true.
	 * Do not preventDefault in this handler as other interactions on the form may also be occurring.
	 * @param {Event} event  The initial change event
	 * @protected
	 */
	async _onChangeInput(event) {

		// Handle changes to specific input types
		const el = event.target;
		if ( (el.type === "color") && el.dataset.edit ) this._onChangeColorPicker(event);
		else if ( el.type === "range" ) this._onChangeRange(event);

		// Maybe submit the form
		if ( this.options.submitOnChange ) {
			return this._onSubmit(event);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle the change of a color picker input which enters it's chosen value into a related input field
	 * @protected
	 */
	_onChangeColorPicker(event) {
		const input = event.target;
		const form = input.form;
		form[input.dataset.edit].value = input.value;
	}

	/* -------------------------------------------- */

	/**
	 * Handle changes to a range type input by propagating those changes to the sibling range-value element
	 * @param {Event} event  The initial change event
	 * @protected
	 */
	_onChangeRange(event) {
		const field = event.target.parentElement.querySelector(".range-value");
		if ( field ) {
			if ( field.tagName === "INPUT" ) field.value = event.target.value;
			else field.innerHTML = event.target.value;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Additional handling which should trigger when a FilePicker contained within this FormApplication is submitted.
	 * @param {string} selection          The target path which was selected
	 * @param {FilePicker} filePicker     The FilePicker instance which was submitted
	 * @protected
	 */
	_onSelectFile(selection, filePicker) {}

	/* -------------------------------------------- */

	/**
	 * This method is called upon form submission after form data is validated
	 * @param {Event} event       The initial triggering submission event
	 * @param {object} formData   The object of validated form data with which to update the object
	 * @returns {Promise}         A Promise which resolves once the update operation has completed 
	 * @abstract
	 */
	async _updateObject(event, formData) {
		throw new Error("A subclass of the FormApplication must implement the _updateObject method.");
	}

	/* -------------------------------------------- */
	/*  TinyMCE Editor                              */
	/* -------------------------------------------- */

	/**
	 * Activate a named TinyMCE text editor
	 * @param {string} name             The named data field which the editor modifies.
	 * @param {object} options          TinyMCE initialization options passed to TextEditor.create
	 * @param {string} initialContent   Initial text content for the editor area.
	 */
	activateEditor(name, options={}, initialContent="") {
		const editor = this.editors[name];
		if ( !editor ) throw new Error(`${name} is not a registered editor name!`);
		options = foundry.utils.mergeObject(editor.options, options);
		options.height = options.target.offsetHeight;
		TextEditor.create(options, initialContent || editor.initial).then(mce => {
			editor.mce = mce;
			editor.changed = false;
			editor.active = true;
			mce.focus();
			mce.on('change', ev => editor.changed = true);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Handle saving the content of a specific editor by name
	 * @param {string} name           The named editor to save
	 * @param {boolean} [remove]      Remove the editor after saving its content
	 * @return {Promise<void>}
	 */
	async saveEditor(name, {remove=true}={}) {
		const editor = this.editors[name];
		if ( !editor || !editor.mce ) throw new Error(`${name} is not an active editor name!`);
		editor.active = false;

		// Submit the form if the editor has changes
		const mce = editor.mce;
		const isDirty = mce.getContent() !== editor.initial;
		if ( editor.hasButton ) editor.button.style.display = "block";
		if ( isDirty ) await this._onSubmit(new Event("mcesave"));

		// Remove the editor
		if ( remove ) {
			if ( !isDirty ) this.render();
			mce.destroy();
			editor.mce = null;
		}
		editor.changed = false;
	}

	/* -------------------------------------------- */

	/**
	 * Activate a TinyMCE editor instance present within the form
	 * @param {HTMLElement} div     The element which contains the editor
	 * @protected
	 */
	_activateEditor(div) {

		// Get the editor content div
		const name = div.getAttribute("data-edit");
		const button = div.nextElementSibling;
		const hasButton = button && button.classList.contains("editor-edit");
		const wrap = div.parentElement.parentElement;
		const wc = $(div).parents(".window-content")[0];

		// Determine the preferred editor height
		const heights = [wrap.offsetHeight, wc ? wc.offsetHeight : null];
		if ( div.offsetHeight > 0 ) heights.push(div.offsetHeight);
		let height = Math.min(...heights.filter(h => Number.isFinite(h)));

		// Get initial content
		const data = this.object instanceof foundry.abstract.Document ? this.object.data : this.object;
		const mceOptions = {
			target: div,
			height: height,
			save_onsavecallback: mce => this.saveEditor(name)
		};

		// Define the editor configuration
		const editor = this.editors[name] = {
			target: name,
			button: button,
			hasButton: hasButton,
			mce: null,
			active: !hasButton,
			changed: false,
			options: mceOptions,
			initial: foundry.utils.getProperty(data, name)
		};

		// Activate the editor immediately, or upon button click
		const activate = () => {
			editor.initial = foundry.utils.getProperty(data, name);
			this.activateEditor(name, mceOptions, editor.initial);
		}
		if (hasButton) button.onclick = activate;
		else activate();
	}

	/* -------------------------------------------- */
	/*  FilePicker UI
	/* -------------------------------------------- */

	/**
	 * Activate a FilePicker instance present within the form
	 * @param {PointerEvent} event    The mouse click event on a file picker activation button
	 * @protected
	 */
	_activateFilePicker(event) {
		event.preventDefault();
		const options = this._getFilePickerOptions(event);
		const fp = new FilePicker(options);
		this.filepickers.push(fp);
		return fp.browse();
	}

	/* -------------------------------------------- */

	/**
	 * Determine the configuration options used to initialize a FilePicker instance within this FormApplication.
	 * Subclasses can extend this method to customize the behavior of pickers within their form.
	 * @param {PointerEvent} event        The initiating mouse click event which opens the picker
	 * @returns {object}                  Options passed to the FilePicker constructor
	 * @protected
	 */
	_getFilePickerOptions(event) {
		const button = event.currentTarget;
		const target = button.dataset.target;
		const field = button.form[target] || null;
		return {
			field: field,
			type: button.dataset.type,
			current: field?.value ?? "",
			button: button,
			callback: this._onSelectFile.bind(this)
		}
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async close(options={}) {
		const states = Application.RENDER_STATES;
		if ( !options.force && ![states.RENDERED, states.ERROR].includes(this._state) ) return;

		// Trigger saving of the form
		const submit = options.submit ?? this.options.submitOnClose;
		if ( submit ) await this.submit({preventClose: true, preventRender: true});

		// Close any open FilePicker instances
		for ( let fp of this.filepickers ) {
			fp.close();
		}
		this.filepickers = [];

		// Close any open MCE editors
		for ( let ed of Object.values(this.editors) ) {
			if ( ed.mce ) ed.mce.destroy();
		}
		this.editors = {};

		// Close the application itself
		return super.close(options);
	}

	/* -------------------------------------------- */

	/**
	 * Submit the contents of a Form Application, processing its content as defined by the Application
	 * @param {object} [options]        Options passed to the _onSubmit event handler
	 * @returns {FormApplication}       Return a self-reference for convenient method chaining
	 */
	async submit(options={}) {
		if ( this._submitting ) return; 
		const submitEvent = new Event("submit");
		await this._onSubmit(submitEvent, options);
		return this;
	}
}


/* -------------------------------------------- */


/**
 * Extend the FormApplication pattern to incorporate specific logic for viewing or editing Document instances.
 * See the FormApplication documentation for more complete description of this interface.
 *
 * @extends {FormApplication}
 * @abstract
 * @interface
 *
 * @param {Document} object                         A Document instance which should be managed by this form.
 * @param {ApplicationOptions} [options={}]         Optional configuration parameters for how the form behaves.
 */
class DocumentSheet extends FormApplication {

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["sheet"],
			template: `templates/sheets/${this.name.toLowerCase()}.html`,
			viewPermission: CONST.ENTITY_PERMISSIONS.LIMITED
		});
	}

	/* -------------------------------------------- */

	/**
	 * A semantic convenience reference to the Document instance which is the target object for this form.
	 * @return {Document}
	 */
	get document() {
		return this.object;
	}

	/* -------------------------------------------- */

	/** @override */
	get id() {
		const name = this.options.id ?? `${this.document.documentName.toLowerCase()}-sheet`;
		return `${name}-${this.document.id}`
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get isEditable() {
		let editable = this.options["editable"] && this.document.isOwner;
		if ( this.document.pack ) {
			const pack = game.packs.get(this.document.pack);
			if ( pack.locked ) editable = false;
		}
		return editable;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get title() {
		const name = this.document.name ?? this.document.id;
		const reference = name ? `: ${name}` : "";
		return `${game.i18n.localize(this.document.constructor.metadata.label)}${reference}`;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async close(options={}) {
		await super.close(options);
		delete this.object.apps[this.appId];
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const data = this.document.data.toObject(false);
		const isEditable = this.isEditable;
		const templateData = {
			cssClass: isEditable ? "editable" : "locked",
			editable: isEditable,
			document: this.document,
			data: data,
			limited: this.document.limited,
			options: this.options,
			owner: this.document.isOwner,
			title: this.title
		};
		/**
		 * @deprecated since 0.8.0
		 * @ignore
		 */
		Object.defineProperty(templateData, "entity", { get: () => {
			console.warn(`Template ${this.template} is referencing the entity attribute of provided sheet rendering data which is deprecated in favor of the data attribute. Support will be removed in 0.9.0`);
			return templateData.data;
		}});
		return templateData;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	render(force, options={}) {
		if ( !this.object.compendium && !this.object.testUserPermission(game.user, this.options.viewPermission) ) {
			if ( !force ) return; // If rendering is not being forced, fail silently
			const err = game.i18n.localize("SHEETS.EntitySheetPrivate");
			ui.notifications.warn(err);
			return console.warn(err);
		}

		// Update editable permission
		options.editable = options.editable ?? this.object.isOwner;

		// Register the active Application with the referenced Documents
		this.object.apps[this.appId] = this;
		return super.render(force, options);
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_getHeaderButtons() {
		let buttons = super._getHeaderButtons();
		if ( this.document.compendium && this.document.constructor.canUserCreate(game.user) ) {
			buttons.unshift({
				label: "Import",
				class: "import",
				icon: "fas fa-download",
				onclick: async () => {
					await this.close();
					return this.document.collection.importFromCompendium(this.document.compendium, this.document.id);
				}
			});
		}
		return buttons
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _updateObject(event, formData) {
		if ( !this.object.id ) return;
		return this.object.update(formData);
	}

	/* -------------------------------------------- */
	/*  DEPRECATED                                  */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	get entity() {
		console.warn("You are referencing DocumentSheet#entity which has been deprecated in favor of DocumentSheet#document");
		return this.object;
	}
}

/**
 * @deprecated since 0.8.0
 * @ignore
 */
class BaseEntitySheet extends DocumentSheet {
	constructor(...args) {
		super(...args)
		console.warn("You are extending the BaseEntitySheet class which is now renamed to DocumentSheet. Support for the old class name will be removed in 0.9.0")
	}
}
/**
 * A helper class which assists with localization and string translation
 * @param {string} serverLanguage       The default language configuration setting for the server
 */
class Localization {
	constructor(serverLanguage) {

		// Obtain the default language from application settings
		const [defaultLanguage, defaultModule] = (serverLanguage || "en.core").split(".");

		/**
		 * The target language for localization
		 * @type {string}
		 */
		this.lang = defaultLanguage;

		/**
		 * The package authorized to provide default language configurations
		 * @type {string}
		 */
		this.defaultModule = defaultModule;

		/**
		 * The translation dictionary for the target language
		 * @type {Object}
		 */
		this.translations = {};

		/**
		 * Fallback translations if the target keys are not found
		 * @type {Object}
		 */
		this._fallback = {};
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the Localization module
	 * Discover available language translations and apply the current language setting
	 * @return {Promise<void>}      A Promise which resolves once languages are initialized
	 */
	async initialize() {
		const clientLanguage = await game.settings.get("core", "language") || this.lang;

		// Discover which modules available to the client
		this._discoverSupportedLanguages();

		// Activate the configured language
		if ( clientLanguage !== this.lang ) this.defaultModule = "core";
		await this.setLanguage(clientLanguage || this.lang);

		// Define type labels
		if ( game.system && isObjectEmpty(CONFIG.Actor.typeLabels) ) {
			CONFIG.Actor.typeLabels = game.system.entityTypes.Actor.reduce((obj, t) => {
				obj[t] = `ACTOR.Type${t.titleCase()}`;
				return obj;
			}, {});
		}
		if ( game.system && isObjectEmpty(CONFIG.Item.typeLabels) ) {
			CONFIG.Item.typeLabels = game.system.entityTypes.Item.reduce((obj, t) => {
				obj[t] = `ITEM.Type${t.titleCase()}`;
				return obj;
			}, {});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Set a language as the active translation source for the session
	 * @param {string} lang       A language string in CONFIG.supportedLanguages
	 * @returns {Promise<void>}   A Promise which resolves once the translations for the requested language are ready
	 */
	async setLanguage(lang) {
		if ( !Object.keys(CONFIG.supportedLanguages).includes(lang) ) {
			console.error(`Cannot set language ${lang}, as it is not in the supported set. Falling back to English`);
			lang = "en";
		}
		this.lang = lang;

		// Load translations and English fallback strings
		this.translations = await this._getTranslations(lang);
		if ( lang !== "en" ) this._fallback = await this._getTranslations("en");
	}

	/* -------------------------------------------- */

	/**
	 * Discover the available supported languages from the set of packages which are provided
	 * @return {object}         The resulting configuration of supported languages
	 * @private
	 */
	_discoverSupportedLanguages() {
		const sl = CONFIG.supportedLanguages;

		// Define packages
		const systems = game.data.systems || [game.data.system];
		const modules = game.data.modules;
		const worlds =  game.data.worlds || [game.data.world];
		const packages = systems.concat(modules).concat(worlds);

		// Registration function
		const register = (pkg) => {
			if ( !pkg.languages.length ) return;
			for ( let l of pkg.languages ) {
				if ( !sl.hasOwnProperty(l.lang) ) sl[l.lang] = l.name;
			}
		}

		// Register core translation languages first
		for ( let m of modules ) {
			if ( !m.data.coreTranslation ) continue;
			register(m);
		}

		// Discover and register languages
		for ( let p of packages ) {
			if ( p.data.coreTranslation ) continue;
			register(p);
		}
		return sl;
	}

	/* -------------------------------------------- */

	/**
	 * Prepare the dictionary of translation strings for the requested language
	 * @param {string} lang         The language for which to load translations
	 * @return {Promise<object>}    The retrieved translations object
	 * @private
	 */
	async _getTranslations(lang) {
		const translations = {};
		const promises = [];

		// Include core supported translations
		if ( CONST.CORE_SUPPORTED_LANGUAGES.includes(lang) ) {
			promises.push(this._loadTranslationFile(`lang/${lang}.json`));
		}

		// Default module translations
		if ( (this.defaultModule !== "core") && game.modules?.has(this.defaultModule) ) {
			const defaultModule = game.modules.get(this.defaultModule);
			this._filterLanguagePaths(defaultModule, lang).forEach(path => {
				promises.push(this._loadTranslationFile(path));
			});
		}

		// Game system translations
		if ( game.system ) {
			this._filterLanguagePaths(game.system, lang).forEach(path => {
				promises.push(this._loadTranslationFile(path));
			});
		}

		// Additional (non-default) module translations
		if ( game.modules ) {
			for ( let module of game.modules.values() ) {
				if ( !module.active || (module.id === this.defaultModule) ) continue;
				this._filterLanguagePaths(module, lang).forEach(path => {
					promises.push(this._loadTranslationFile(path));
				});
			}
		}

		// Merge translations in load order and return the prepared dictionary
		await Promise.all(promises);
		for ( let p of promises ) {
			let json = await p;
			foundry.utils.mergeObject(translations, json, {inplace: true});
		}
		return translations;
	}

	/* -------------------------------------------- */

	/**
	 * Reduce the languages array provided by a package to an array of file paths of translations to load
	 * @param {object} pkg          The package data
	 * @param {string} lang         The target language to filter on
	 * @return {string[]}           An array of translation file paths
	 * @private
	 */
	_filterLanguagePaths(pkg, lang) {
		return pkg.languages.reduce((arr, l) => {
			if ( l.lang !== lang ) return arr;
			let checkSystem = !l.system || (game.system && (l.system === game.system.id));
			let checkModule = !l.module || game.modules.get(l.module)?.active;
			if (checkSystem && checkModule) arr.push(l.path);
			return arr;
		}, []);
	}

	/* -------------------------------------------- */

	/**
	 * Load a single translation file and return its contents as processed JSON
	 * @param {string} src        The translation file path to load
	 * @return {Promise.<object>} The loaded translation dictionary
	 * @private
	 */
	async _loadTranslationFile(src) {

		// Load the referenced translation file
		const resp = await fetch(src).catch(err => { return {} });
		if ( resp.status !== 200 ) {
			console.error(`${vtt} | Unable to load requested localization file ${src}`);
			return {};
		}

		// Parse and expand the provided translation object
		let json;
		try {
			json = await resp.json();
			console.log(`${vtt} | Loaded localization file ${src}`);
			json = foundry.utils.expandObject(json);
		} catch(err) {
			err.message = `Unable to parse localization file ${src}: ${err.message}`;
			console.error(err);
			json = {};
		}
		return json;
	}

	/* -------------------------------------------- */
	/*  Localization API                            */
	/* -------------------------------------------- */

	/**
	 * Return whether a certain string has a known translation defined.
	 * @param {string} stringId     The string key being translated
	 * @param {boolean} [fallback]  Allow fallback translations to count?
	 * @return {boolean}
	 */
	has(stringId, fallback=true) {
		return hasProperty(this.translations, stringId) || hasProperty(this._fallback, stringId);
	}

	/* -------------------------------------------- */

	/**
	 * Localize a string by drawing a translation from the available translations dictionary, if available
	 * If a translation is not available, the original string is returned
	 * @param {string} stringId     The string ID to translate
	 * @return {string}             The translated string
	 *
	 * @example <caption>Localizing a simple string in JavaScript</caption>
	 * {
	 *   "MYMODULE.MYSTRING": "Hello, this is my module!"
	 * }
	 * game.i18n.localize("MYMODULE.MYSTRING"); // Hello, this is my module!
	 *
	 * @example <caption>Localizing a simple string in Handlebars</caption>
	 * {{localize "MYMODULE.MYSTRING"}} <!-- Hello, this is my module! -->
	 */
	localize(stringId) {
		return getProperty(this.translations, stringId) || getProperty(this._fallback, stringId) || stringId;
	}

	/* -------------------------------------------- */

	/**
	 * Localize a string including variable formatting for input arguments.
	 * Provide a string ID which defines the localized template.
	 * Variables can be included in the template enclosed in braces and will be substituted using those named keys.
	 *
	 * @param {string} stringId     The string ID to translate
	 * @param {object} data         Provided input data
	 * @return {string}             The translated and formatted string
	 *
	 * @example <caption>Localizing a formatted string in JavaScript</caption>
	 * {
	 *   "MYMODULE.GREETING": "Hello {name}, this is my module!"
	 * }
	 * game.i18n.format("MYMODULE.GREETING" {name: "Andrew"}); // Hello Andrew, this is my module!
	 *
	 * @example <caption>Localizing a formatted string in Handlebars</caption>
	 * {{localize "MYMODULE.GREETING" name="Andrew"}} <!-- Hello, this is my module! -->
	 */
	format(stringId, data={}) {
		let str = this.localize(stringId);
		const fmt = /\{[^\}]+\}/g;
		str = str.replace(fmt, k => {
			return data[k.slice(1, -1)];
		});
		return str;
	}
}



/* -------------------------------------------- */
/*  HTML Template Loading                       */
/* -------------------------------------------- */

// Global template cache
_templateCache = {};

/**
 * Get a template from the server by fetch request and caching the retrieved result
 * @param {string} path           The web-accessible HTML template URL
 * @returns {Promise<Function>}	  A Promise which resolves to the compiled Handlebars template
 */
async function getTemplate(path) {
	if ( !_templateCache.hasOwnProperty(path) ) {
		await new Promise((resolve, reject) => {
			game.socket.emit('template', path, resp => {
				if ( resp.error ) return reject(new Error(resp.error));
				const compiled = Handlebars.compile(resp.html);
				Handlebars.registerPartial(path, compiled);
				_templateCache[path] = compiled;
				console.log(`Foundry VTT | Retrieved and compiled template ${path}`);
				resolve(compiled);
			});
		});
	} 
	return _templateCache[path];
}

/* -------------------------------------------- */

/**
 * Load and cache a set of templates by providing an Array of paths
 * @param {string[]} paths    An array of template file paths to load
 * @return {Promise<Function[]>}
 */
async function loadTemplates(paths) {
	return Promise.all(paths.map(p => getTemplate(p)));
}

/* -------------------------------------------- */


/**
 * Get and render a template using provided data and handle the returned HTML
 * Support asynchronous file template file loading with a client-side caching layer
 *
 * Allow resolution of prototype methods and properties since this all occurs within the safety of the client.
 * @see {@link https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access}
 *
 * @param {string} path             The file path to the target HTML template
 * @param {Object} data             A data object against which to compile the template
 *
 * @return {Promise<string>}        Returns the compiled and rendered template as a string
 */
async function renderTemplate(path, data) {
	const template = await getTemplate(path);
	return template(data || {}, {
		allowProtoMethodsByDefault: true,
		allowProtoPropertiesByDefault: true
	});
}


/* -------------------------------------------- */
/*  Handlebars Template Helpers                 */
/* -------------------------------------------- */

// Register Handlebars Extensions
HandlebarsIntl.registerWith(Handlebars);

/**
 * A collection of Handlebars template helpers which can be used within HTML templates.
 */
class HandlebarsHelpers {

	/**
	 * For checkboxes, if the value of the checkbox is true, add the "checked" property, otherwise add nothing.
	 * @return {string}
	 */
	static checked(value) {
		return Boolean(value) ? "checked" : "";
	}

	/* -------------------------------------------- */

	/**
	 * Render a pair of inputs for selecting a color.
	 * @param {object} options              Helper options
	 * @param {string} [options.name]       The name of the field to create
	 * @param {string} [options.value]      The current color value
	 * @param {string} [options.default]    A default color string if a value is not provided
	 * @return {Handlebars.SafeString}
	 */
	static colorPicker(options) {
		let {name, value} = options.hash;
		name = name || color;
		value = value || "";
		const safeValue = value || options.hash["default"] || "#000000";
		const html =
		`<input class="color" type="text" name="${name}" value="${value}"/>
		<input type="color" value="${safeValue}" data-edit="${name}"/>`;
		return new Handlebars.SafeString(html);
	}

	/* -------------------------------------------- */

	/**
	 * Construct an editor element for rich text editing with TinyMCE
	 * @param {object} options              Helper options
	 * @param {string} [options.target]     The named target data element
	 * @param {boolean} [options.owner]     Is the current user an owner of the data?
	 * @param {boolean} [options.button]    Include a button used to activate the editor later?
	 * @param {boolean} [options.editable]  Is the text editor area currently editable?
	 * @return {Handlebars.SafeString}
	 */
	static editor(options) {
		const target = options.hash['target'];
		if ( !target ) throw new Error("You must define the name of a target field.");

		// Enrich the content
		const owner = Boolean(options.hash['owner']);
		const rollData = options.hash["rollData"];
		const content = TextEditor.enrichHTML(options.hash['content'] || "", {secrets: owner, entities: true, rollData});

		// Construct the HTML
		let editor = $(`<div class="editor"><div class="editor-content" data-edit="${target}">${content}</div></div>`);

		// Append edit button
		const button = Boolean(options.hash['button']);
		const editable = Boolean(options.hash['editable']);
		if ( button && editable ) editor.append($('<a class="editor-edit"><i class="fas fa-edit"></i></a>'));
		return new Handlebars.SafeString(editor[0].outerHTML);
	}

	/* -------------------------------------------- */

	/**
	 * Render a file-picker button linked to an <input> field
	 * @param {object} options              Helper options
	 * @param {string} [options.type]       The type of FilePicker instance to display
	 * @param {boolean} [options.target]    The field name in the target data
	 * @return {Handlebars.SafeString|string}
	 */
	static filePicker(options) {
		const type = options.hash['type'];
		const target = options.hash['target'];
		if ( !target ) throw new Error("You must define the name of the target field.");

		// Do not display the button for users who do not have browse permission
		if ( game.world && !game.user.can("FILES_BROWSE" ) ) return "";

		// Construct the HTML
		const tooltip = game.i18n.localize("FILES.BrowseTooltip");
		return new Handlebars.SafeString(`
		<button type="button" class="file-picker" data-type="${type}" data-target="${target}" title="${tooltip}" tabindex="-1">
				<i class="fas fa-file-import fa-fw"></i>
		</button>`);
	}

	/* -------------------------------------------- */

	/**
	 * Translate a provided string key by using the loaded dictionary of localization strings.
	 * @return {string}
	 *
	 * @example <caption>Translate a provided localization string, optionally including formatting parameters</caption>
	 * <label>{{localize "ACTOR.Create"}}</label> <!-- "Create Actor" -->
	 * <label>{{localize "CHAT.InvalidCommand", command=foo}}</label> <!-- "foo is not a valid chat message command." -->
	 */
	static localize(value, options) {
		const data = options.hash;
		return isObjectEmpty(data) ? game.i18n.localize(value) : game.i18n.format(value, data);
	}

	/* -------------------------------------------- */

	/**
	 * A string formatting helper to display a number with a certain fixed number of decimals and an explicit sign.
	 * @return {string}
	 */
	static numberFormat(value, options) {
		const dec = options.hash['decimals'] ?? 0;
		const sign = options.hash['sign'] || false;
		value = parseFloat(value).toFixed(dec);
		if (sign ) return ( value >= 0 ) ? "+"+value : value;
		return value;
	}

	/* -------------------------------------------- */

	/**
	 * A helper to create a set of radio checkbox input elements in a named set.
	 * The provided keys are the possible radio values while the provided values are human readable labels.
	 *
	 * @param {string} name         The radio checkbox field name
	 * @param {object} choices      A mapping of radio checkbox values to human readable labels
	 * @param {object} options      Options which customize the radio boxes creation
	 * @param {string} options.checked    Which key is currently checked?
	 * @param {boolean} options.localize  Pass each label through string localization?
	 * @return {Handlebars.SafeString}
	 *
	 * @example <caption>The provided input data</caption>
	 * let groupName = "importantChoice";
	 * let choices = {a: "Choice A", b: "Choice B"};
	 * let chosen = "a";
	 *
	 * @example <caption>The template HTML structure</caption>
	 * <div class="form-group">
	 *   <label>Radio Group Label</label>
	 *   <div class="form-fields">
	 *     {{radioBoxes groupName choices checked=chosen localize=true}}
	 *   </div>
	 * </div>
	 */
	static radioBoxes(name, choices, options) {
		const checked = options.hash['checked'] || null;
		const localize = options.hash['localize'] || false;
		let html = "";
		for ( let [key, label] of Object.entries(choices) ) {
			if ( localize ) label = game.i18n.localize(label);
			const isChecked = checked === key;
			html += `<label class="checkbox"><input type="radio" name="${name}" value="${key}" ${isChecked ? "checked" : ""}> ${label}</label>`;
		}
		return new Handlebars.SafeString(html);
	}

	/* -------------------------------------------- */

	/**
	 * Render a pair of inputs for selecting a color.
	 * @param {object} options            Helper options
	 * @param {string} [options.name]     The name of the field to create
	 * @param {number} [options.value]    The current range value
	 * @param {number} [options.min]      The minimum allowed value
	 * @param {number} [options.max]      The maximum allowed value
	 * @param {number} [options.step]     The allowed step size
	 * @return {Handlebars.SafeString}
	 */
	static rangePicker(options) {
		let {name, value, min, max, step} = options.hash;
		name = name || "range";
		value = value ?? "";
		if ( Number.isNaN(value) ) value = "";
		const html =
		`<input type="range" name="${name}" value="${value}" min="${min}" max="${max}" step="${step}"/>
		 <span class="range-value">${value}</span>`;
		return new Handlebars.SafeString(html);
	}

	/* -------------------------------------------- */

	/**
	* A helper to assign an <option> within a <select> block as selected based on its value
	* Escape the string as handlebars would, then escape any regexp characters in it
	* @return {Handlebars.SafeString}
	*/
	static select(selected, options) {
		const escapedValue = RegExp.escape(Handlebars.escapeExpression(selected));
		const rgx = new RegExp(' value=[\"\']' + escapedValue + '[\"\']');
		const html = options.fn(this);
		return html.replace(rgx, "$& selected");
	}

	/* -------------------------------------------- */

	/**
	 * A helper to create a set of <option> elements in a <select> block based on a provided dictionary.
	 * The provided keys are the option values while the provided values are human readable labels.
	 * This helper supports both single-select as well as multi-select input fields.
	 *
	 * @param {object} choices      A mapping of radio checkbox values to human readable labels
	 * @param {string|string[]} options.selected    Which key or array of keys that are currently selected?
	 * @param {boolean} options.localize  Pass each label through string localization?
	 * @return {Handlebars.SafeString}
	 *
	 * @example <caption>The provided input data</caption>
	 * let choices = {a: "Choice A", b: "Choice B"};
	 * let value = "a";
	 *
	 * @example <caption>The template HTML structure</caption>
	 * <select name="importantChoice">
	 *   {{selectOptions choices selected=value localize=true}}
	 * </select>
	 */
	static selectOptions(choices, options) {
		const localize = options.hash['localize'] ?? false;
		let selected = options.hash['selected'] ?? null;
		let blank = options.hash['blank'] ?? null;
		let nameAttr = options.hash["nameAttr"];
		let labelAttr = options.hash["labelAttr"];
		let inverted = !!options.hash["inverted"];
		selected = selected instanceof Array ? selected.map(String) : [String(selected)];

		// Create an option
		const option = (name, label) => {
			if ( localize ) label = game.i18n.localize(label);
			let isSelected = selected.includes(name);
			html += `<option value="${name}" ${isSelected ? "selected" : ""}>${label}</option>`
		};

		// Create the options
		let html = "";
		if ( blank !== null ) option("", blank);

		// Options as an Array
		if ( choices instanceof Array ) {
			for ( let choice of choices ) {
				option(choice[nameAttr], choice[labelAttr]);
			}
		}

		// Choices as an Object
		else {
			for ( let choice of Object.entries(choices) ) {
				let [key, value] = inverted ? choice.reverse() : choice;
				if ( nameAttr ) key = value[nameAttr];
				if ( labelAttr ) value = value[labelAttr];
				option(key, value);
			}
		}
		return new Handlebars.SafeString(html);
	}
}

// Register all handlebars helpers
Handlebars.registerHelper({
	checked: HandlebarsHelpers.checked,
	colorPicker: HandlebarsHelpers.colorPicker,
	editor: HandlebarsHelpers.editor,
	filePicker: HandlebarsHelpers.filePicker,
	numberFormat: HandlebarsHelpers.numberFormat,
	localize: HandlebarsHelpers.localize,
	radioBoxes: HandlebarsHelpers.radioBoxes,
	rangePicker: HandlebarsHelpers.rangePicker,
	select: HandlebarsHelpers.select,
	selectOptions: HandlebarsHelpers.selectOptions,
	timeSince: timeSince,
	eq: (v1, v2) => v1 === v2,
	ne: (v1, v2) => v1 !== v2,
	lt: (v1, v2) => v1 < v2,
	gt: (v1, v2) => v1 > v2,
	lte: (v1, v2) => v1 <= v2,
	gte: (v1, v2) => v1 >= v2,
	and() { return Array.prototype.every.call(arguments, Boolean) },
	or() { return Array.prototype.slice.call(arguments, 0, -1).some(Boolean) }
});
/**
 * The core Game instance which encapsulates the data, settings, and states relevant for managing the game experience.
 * The singleton instance of the Game class is available as the global variable game.
 *
 * @param {string} view         The named view which is active for this game instance.
 * @param {Object} data         An object of all the World data vended by the server when the client first connects
 * @param {string} sessionId    The ID of the currently active client session retrieved from the browser cookie
 * @param {Socket} socket       The open web-socket which should be used to transact game-state data
 */
class Game {
	constructor(view, data, sessionId, socket) {

		/**
		 * The named view which is currently active.
		 * Game views include: join, setup, players, license, game, stream
		 * @type {string}
		 */
		this.view = view;

		/**
		 * The object of world data passed from the server
		 * @type {Object}
		 */
		this.data = data;

		/**
		 * The id of the active World user, if any
		 * @type {string}
		 */
		this.userId = data.userId || null;

		// Set up package data
		this.setupPackages(data);

		/**
		 * A mapping of WorldCollection instances, one per primary Document type.
		 * @type {Collection<string,WorldCollection>}
		 */
		this.collections = new foundry.utils.Collection();

		/**
		 * A mapping of CompendiumCollection instances, one per Compendium pack.
		 * @type {Collection<string,CompendiumCollection>}
		 */
		this.packs = new foundry.utils.Collection();

		/**
		 * Localization support
		 * @type {Localization}
		 */
		this.i18n = new Localization(data?.options?.language);

		/**
		 * The Keyboard Manager
		 * @type {KeyboardManager}
		 */
		this.keyboard = null;

		/**
		 * A mapping of installed modules
		 * @type {Map}
		 */
		this.modules = new Map((data.modules || []).map(m => [m.id, m]));

		/**
		 * The user role permissions setting
		 * @type {Object}
		 */
		this.permissions = null;

		/**
		 * The client session id which is currently active
		 * @type {string}
		 */
		this.sessionId = sessionId;

		/**
		 * Client settings which are used to configure application behavior
		 * @type {ClientSettings}
		 */
		this.settings = new ClientSettings(data.settings || []);

		/**
		 * A reference to the open Socket.io connection
		 * @type {WebSocket|null}
		 */
		this.socket = socket;

		/**
		 * A singleton GameTime instance which manages the progression of time within the game world.
		 * @type {GameTime}
		 */
		this.time = new GameTime(socket);

		/**
		 * A singleton reference to the Canvas object which may be used.
		 * @type {Canvas}
		 */
		this.canvas = new Canvas();
		globalThis.canvas = this.canvas;

		/**
		 * A singleton instance of the Audio Helper class
		 * @type {AudioHelper}
		 */
		this.audio = new AudioHelper();

		/**
		 * A singleton instance of the Video Helper class
		 * @type {VideoHelper}
		 */
		this.video = new VideoHelper();

		/**
		 * Whether the Game is running in debug mode
		 * @type {boolean}
		 */
		this.debug = false;

		/**
		 * A flag for whether texture assets for the game canvas are currently loading
		 * @type {boolean}
		 */
		this.loading = false;

		/**
		 * A flag for whether the Game has successfully reached the "ready" hook
		 * @type {boolean}
		 */
		this.ready = false;
	}

	/* -------------------------------------------- */

	/**
	 * Fetch World data and return a Game instance
	 * @param {string} view             The named view being created
	 * @param {string|null} sessionId   The current sessionId of the connecting client
	 * @return {Promise<Game>}          A Promise which resolves to the created Game instance
	 */
	static async create(view, sessionId) {
		socket = sessionId ? await this.connect(sessionId) : null;
		let gameData = socket ? await this.getData(socket) : {};
		return new this(view, gameData, sessionId, socket);
	}

	/* -------------------------------------------- */

	/**
	 * Establish a live connection to the game server through the socket.io URL
	 * @param {string} sessionId  The client session ID with which to establish the connection
	 * @return {Promise<object>}  A promise which resolves to the connected socket, if successful
	 */
	static async connect(sessionId) {
		return new Promise((resolve, reject) => {
			const socket = io.connect({
				path: foundry.utils.getRoute("socket.io"),
				transports: ["websocket"],    // Require websocket transport instead of XHR polling
				upgrade: false,               // Prevent "upgrading" to websocket since it is enforced
				reconnection: true,           // Automatically reconnect
				reconnectionDelay: 1000,
				reconnectionAttempts: 3,
				reconnectionDelayMax: 5000,
				query: {session: sessionId},  // Pass session info
				cookie: false
			});
			socket.on("connect", () => {
				console.log(`${vtt} | Connected to server socket using session ${sessionId}`);
				resolve(socket)
			});
			socket.on("connectTimeout", () => {
				reject(new Error("Failed to establish a socket connection within allowed timeout."))
			});
			socket.on("connectError", err => reject(err));
		});
	}

	/* -------------------------------------------- */

	/**
	 * Retrieve the cookies which are attached to the client session
	 * @return {Object}   The session cookies
	 */
	static getCookies() {
		const cookies = {};
		for (let cookie of document.cookie.split('; ')) {
			let [name, value] = cookie.split("=");
			cookies[name] = decodeURIComponent(value);
		}
		return cookies;
	}

	/* -------------------------------------------- */

	/**
	 * Request World data from server and return it
	 * @return {Promise<object>}
	 */
	static async getData(socket) {
		return new Promise(resolve => {
			socket.emit("world", resolve);
		})
	}

	/* -------------------------------------------- */

	/**
	 * Get the current World status upon initial connection.
	 * @return {Promise<boolean>}
	 */
	static async getWorldStatus(socket) {
		const status = await new Promise(resolve => {
			socket.emit("getWorldStatus", resolve);
		});
		console.log(`${vtt} | The game World is currently ${status ? "active" : "not active"}`);
		return status;
	}

	/* -------------------------------------------- */

	/**
	 * Configure package data that is currently enabled for this world
	 */
	setupPackages(data) {

		/**
		 * The game World which is currently active
		 * @type {Object}
		 */
		if ( this.data.world ) {
			this.world = this.data.world;
			this.world.data = new foundry.packages.WorldData(this.world.data);
		}

		/**
		 * The System which is used to power this game world
		 * @type {Object}
		 */
		if ( this.data.system ) {
			this.system = this.data.system;
			this.system.data = new foundry.packages.SystemData(this.system.data);
		}

		/**
		 * A Map of active modules which are currently enabled in this World
		 * @type {Map<string,Object>}
		 */
		this.modules = new Map((data.modules || []).map(m => [m.id, m]));
		for ( let m of this.modules.values() ) {
			m.data = new foundry.packages.ModuleData(m.data);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Return the named scopes which can exist for packages.
	 * Scopes are returned in the prioritization order that their content is loaded.
	 * @return {Array<string>}    An array of string package scopes
	 */
	getPackageScopes() {
		return CONFIG.DatabaseBackend.getFlagScopes();
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the Game for the current window location
	 */
	async initialize() {
		console.log(`${vtt} | Initializing Foundry Virtual Tabletop Game`);
		this.ready = false;
		Hooks.callAll('init');

		// Register game settings
		this.registerSettings();

		// Initialize language translations
		await this.i18n.initialize();

		// Activate event listeners
		this.activateListeners();

		// Initialize the current view
		await this._initializeView();

		// Display usability warnings or errors
		this._displayUsabilityErrors();
	}

	/* -------------------------------------------- */

	/**
	 * Display certain usability error messages which are likely to result in the player having a bad experience.
	 * @private
	 */
	_displayUsabilityErrors() {

		// Validate required resolution
		const MIN_WIDTH = 1024;
		const MIN_HEIGHT = 700;
		if ( window.innerHeight < MIN_HEIGHT || window.innerWidth < MIN_WIDTH ) {
			if ( ui.notifications && !game.data.options.debug ) {
				ui.notifications.error(game.i18n.format("ERROR.LowResolution", {
					width: window.innerWidth,
					reqWidth: MIN_WIDTH,
					height: window.innerHeight,
					reqHeight: MIN_HEIGHT
				}), {permanent: true});
			}
		}

		// Display browser compatibility error
		const browserError = (browser, version, minimum) => {
			if ( parseInt(version) < minimum ) {
				const err = game.i18n.format("ERROR.BrowserVersion", {browser, version, minimum});
				if ( ui.notifications ) ui.notifications.error(err, {permanent: true});
				console.error(err);
			}
		}

		// Chromium Version
		const chromium = navigator.userAgent.match(/Chrom(?:e|ium)\/([0-9]+)\./);
		if ( chromium ) return browserError("Chromium", chromium[1], 80);

		// Firefox Version
		const firefox = navigator.userAgent.match(/Firefox\/([0-9]+)\./);
		if ( firefox ) return browserError("Firefox", firefox[1], 78);

		// Safari Version
		const safari = navigator.userAgent.match(/Version\/([0-9]+)\.(?:.*)Safari\//);
		if ( safari ) return browserError("Safari", safari[1], 14);
	}

	/* -------------------------------------------- */

	/**
	 * Shut down the currently active Game. Requires GameMaster user permission.
	 * @return {Promise<Object>}    A Promise which resolves to the response object from the server
	 */
	async shutDown() {
		if ( !game.ready || !game.user.isGM ) {
			throw new Error("Only a GM user may shut down the currently active world");
		}
		const setupUrl = foundry.utils.getRoute("setup");
		const request = await fetch(setupUrl, {
			method: "POST",
			headers: {'Content-Type': 'application/json'},
			body: JSON.stringify({shutdown: true}),
			redirect: "manual"
		});
		if ( request.status < 400 ) setTimeout(() => window.location.href = setupUrl, 1000);
	}

	/* -------------------------------------------- */
	/*  Primary Game Initialization
	/* -------------------------------------------- */

	/**
	 * Fully set up the game state, initializing Entities, UI applications, and the Canvas
	 * @returns {Promise<void>}
	 */
	async setupGame() {
		Hooks.callAll('setup');

		// Store permission settings
		this.permissions = await this.settings.get("core", "permissions");

		// Data initialization
		this.initializePacks();     // Do this first since entities may reference compendium content
		this.initializeEntities();  // Next initialize world-level entities
		this.initializeRTC();       // Intentionally async

		// Interface initialization
		this.initializeKeyboard();
		this.initializeUI();
		EntitySheetConfig.initializeSheets();

		// Canvas initialization
		await this.initializeCanvas();
		this.activateSocketListeners();

		// If the player is not a GM and does not have an impersonated character, prompt for selection
		if (!this.user.isGM && !this.user.character) {
			new UserConfig(this.user).render(true);
		}

		// Call all game ready hooks
		this.ready = true;
		Hooks.callAll('ready');
	}

	/* -------------------------------------------- */

	/**
	 * Initialize game state data by creating WorldCollection instances for every primary Document type
	 */
	initializeEntities() {
		const initOrder = ["User", "Folder", "Actor", "Item", "Scene", "Combat", "JournalEntry", "Macro", "Playlist", "RollTable", "ChatMessage"];
		if ( initOrder.length !== CONST.ENTITY_TYPES.length ) {
			throw new Error("Missing Document initialization type!");
		}
		const t0 = performance.now();
		for ( let documentName of initOrder ) {
			const documentClass = CONFIG[documentName].documentClass;
			const collectionClass = CONFIG[documentName].collection;
			const collectionName = documentClass.metadata.collection;
			this[collectionName] = new collectionClass(this.data[collectionName]);
			this.collections.set(documentName, this[collectionName]);
		}

		// Special-case - world settings
		this.collections.set("Setting", this.settings.storage.get("world"));

		// Special case - fog explorations
		const fogCollectionCls = CONFIG.FogExploration.collection;
		this.collections.set("FogExploration", new fogCollectionCls());
		const dt = performance.now() - t0;
		console.debug(`${vtt} | Prepared World Documents in ${Math.round(dt)}ms`);
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the Compendium packs which are present within this Game
	 * Create a Collection which maps each Compendium pack using it's collection ID
	 * @returns {Collection<string,CompendiumCollection>}
	 */
	initializePacks() {
		const prior = this.packs;
		const packs = new foundry.utils.Collection();
		for ( let metadata of this.data.packs ) {

			// Update the compendium collection
			const collection = `${metadata.package}.${metadata.name}`;
			let pack = null;
			if ( prior && prior.has(collection) ) pack = prior.get(collection);
			else pack = new CompendiumCollection(metadata);
			packs.set(collection, pack);

			// Re-render any applications associated with pack content
			for ( let document of pack.contents ) {
				document.render(false, {editable: !pack.locked});
			}
		}
		return this.packs = packs;
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the WebRTC implementation
	 */
	initializeRTC() {
		this.webrtc = new AVMaster();
		return this.webrtc.connect()
	}

	/* -------------------------------------------- */

	/**
	 * Initialize core UI elements
	 */
	initializeUI() {

		// Initialize all singleton applications
		for ( let [k, cls] of Object.entries(CONFIG.ui) ) {
			ui[k] = new cls();
		}

		// Render some applications (asynchronously)
		ui.nav.render(true);
		ui.notifications.render(true);
		ui.sidebar.render(true);
		ui.players.render(true);
		ui.hotbar.render(true);
		ui.webrtc.render(true);
		ui.pause.render(true);
		ui.controls.render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the game Canvas
	 * @returns {Promise<void>}
	 */
	async initializeCanvas() {

		// Don't do anything if we are in no-canvas mode
		const board = document.getElementById("board");
		if ( !board || game.settings.get("core", "noCanvas") ) return;
		const scene = game.scenes.current;

		// Ensure that necessary fonts have loaded
		await this._checkFontsReady(3000);

		// Render the canvas
		try {
			this.canvas.initialize();
			if ( scene ) await scene.view();
			else await canvas.draw(null);
		} catch(err) {
			err.message = `Failed to render WebGL canvas: ${err.message}`;
			console.error(err);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Ensure that necessary fonts have loaded and are ready for use
	 * Enforce a maximum timeout in milliseconds.
	 * Proceed with rendering after that point even if fonts are not yet available.
	 * @param {number} ms   The timeout to delay
	 * @return {Promise<void>}
	 * @private
	 */
	async _checkFontsReady(ms) {
		for ( let f of CONFIG.fontFamilies ) {
			document.fonts.load(`1rem ${f}`);
		}
		const timeout = new Promise(resolve => setTimeout(resolve, ms));
		return Promise.race([document.fonts.ready, timeout]).then(() => {
			console.log(`${vtt} | Document fonts loaded and ready`);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Initialize Keyboard and Mouse controls
	 */
	initializeKeyboard() {
		window.keyboard = this.keyboard = new KeyboardManager();
	}

	/* -------------------------------------------- */

	/**
	 * Register core game settings
	 */
	registerSettings() {

		// Permissions Control Menu
		game.settings.registerMenu("core", "permissions", {
			name: "PERMISSION.Configure",
			label: "PERMISSION.ConfigureLabel",
			hint: "PERMISSION.ConfigureHint",
			icon: "fas fa-user-lock",
			type: PermissionConfig,
			restricted: true
		});

		// User Role Permissions
		game.settings.register("core", "permissions", {
			name: "Permissions",
			scope: "world",
			default: {},
			type: Object,
			config: false,
			onChange: permissions => {
				game.permissions = permissions;
				if ( ui.controls ) ui.controls.initialize();
				if ( ui.sidebar ) ui.sidebar.render();
			}
		});

		// WebRTC Control Menu
		game.settings.registerMenu("core", "webrtc", {
			name: "WEBRTC.Title",
			label: "WEBRTC.MenuLabel",
			hint: "WEBRTC.MenuHint",
			icon: "fas fa-headset",
			type: AVConfig,
			restricted: false
		});

		// RTC World Settings
		game.settings.register("core", "rtcWorldSettings", {
			name: "WebRTC (Audio/Video Conferencing) World Settings",
			scope: "world",
			default: AVSettings.DEFAULT_WORLD_SETTINGS,
			type: Object,
			onChange: () => game.webrtc.settings.changed()
		});

		// RTC Client Settings
		game.settings.register("core", "rtcClientSettings", {
			name: "WebRTC (Audio/Video Conferencing) Client specific Configuration",
			scope: "client",
			default: AVSettings.DEFAULT_CLIENT_SETTINGS,
			type: Object,
			onChange: () => game.webrtc.settings.changed()
		});

		// Default Token Configuration
		game.settings.registerMenu("core", DefaultTokenConfig.SETTING, {
			name: "SETTINGS.DefaultTokenN",
			label: "SETTINGS.DefaultTokenL",
			hint: "SETTINGS.DefaultTokenH",
			icon: "fas fa-user-alt",
			type: DefaultTokenConfig,
			restricted: true
		});

		// Default Token Settings
		game.settings.register("core", DefaultTokenConfig.SETTING, {
			name: "SETTINGS.DefaultTokenN",
			hint: "SETTINGS.DefaultTokenL",
			scope: "world",
			type: Object,
			default: {}
		});

		// No-Canvas Mode
		game.settings.register("core", "noCanvas", {
			name: "SETTINGS.NoCanvasN",
			hint: "SETTINGS.NoCanvasL",
			scope: "client",
			config: true,
			type: Boolean,
			default: false,
			onChange: () => window.location.reload()
		})

		// Language preference
		game.settings.register("core", "language", {
			name: "SETTINGS.LangN",
			hint: "SETTINGS.LangL",
			scope: "client",
			config: true,
			default: game.i18n.lang,
			type: String,
			choices: CONFIG.supportedLanguages,
			onChange: () => window.location.reload()
		});

		// Chat message roll mode
		game.settings.register("core", "rollMode", {
			name: "Default Roll Mode",
			scope: "client",
			config: false,
			default: "roll",
			type: String,
			choices: CONFIG.Dice.rollModes,
			onChange: ChatLog._setRollMode
		});

		// World time
		game.settings.register("core", "time", {
			name: "World Time",
			scope: "world",
			config: false,
			default: 0,
			type: Number,
			onChange: time => this.time.onUpdateWorldTime(time)
		});

		// Register module configuration settings
		game.settings.register("core", ModuleManagement.CONFIG_SETTING, {
			name: "Module Configuration Settings",
			scope: "world",
			config: false,
			default: {},
			type: Object,
			onChange: () => window.location.reload()
		});

		// Register compendium visibility setting
		game.settings.register("core", CompendiumCollection.CONFIG_SETTING, {
			name: "Compendium Configuration",
			scope: "world",
			config: false,
			default: {},
			type: Object,
			onChange: () => {
				this.initializePacks();
				ui.compendium.render();
			}
		});

		// Combat Tracker Configuration
		game.settings.register("core", Combat.CONFIG_SETTING, {
			name: "Combat Tracker Configuration",
			scope: "world",
			config: false,
			default: {},
			type: Object,
			onChange: () => {
				if (game.combat) {
					game.combat.setupTurns();
					game.combats.render();
				}
			}
		});

		// Entity Sheet Class Configuration
		game.settings.register("core", "sheetClasses", {
			name: "Sheet Class Configuration",
			scope: "world",
			config: false,
			default: {},
			type: Object,
			onChange: setting => EntitySheetConfig.updateDefaultSheets(setting)
		});

		// Are Chat Bubbles Enabled?
		game.settings.register("core", "chatBubbles", {
			name: "SETTINGS.CBubN",
			hint: "SETTINGS.CBubL",
			scope: "client",
			config: true,
			default: true,
			type: Boolean
		});

		// Pan to Token Speaker
		game.settings.register("core", "chatBubblesPan", {
			name: "SETTINGS.CBubPN",
			hint: "SETTINGS.CBubPL",
			scope: "client",
			config: true,
			default: true,
			type: Boolean
		});

		// Disable Resolution Scaling
		game.settings.register("core", "disableResolutionScaling", {
			name: "SETTINGS.ResScaleN",
			hint: "SETTINGS.ResScaleL",
			scope: "client",
			config: window.devicePixelRatio !== 1,
			default: false,
			type: Boolean,
			onChange: () => window.location.reload()
		});

		// Left-Click Deselection
		game.settings.register("core", "leftClickRelease", {
			name: "SETTINGS.LClickReleaseN",
			hint: "SETTINGS.LClickReleaseL",
			scope: "client",
			config: true,
			default: false,
			type: Boolean
		});

		// Maximum Framerate
		game.settings.register("core", "maxFPS", {
			name: "SETTINGS.MaxFPSN",
			hint: "SETTINGS.MaxFPSL",
			scope: "client",
			config: true,
			type: Number,
			range: {min: 10, max: 60, step: 10},
			default: 60,
			onChange: () => canvas.ready ? canvas.draw() : null
		});

		// Live Token Drag Preview
		game.settings.register("core", "tokenDragPreview", {
			name: "SETTINGS.TokenDragPreviewN",
			hint: "SETTINGS.TokenDragPreviewL",
			scope: "world",
			config: true,
			default: false,
			type: Boolean
		});

		// Soft Shadows
		game.settings.register("core", "softShadows", {
			name: "SETTINGS.SoftSN",
			hint: "SETTINGS.SoftSL",
			config: true,
			type: Boolean,
			default: true,
			onChange: () => canvas.ready ? canvas.draw() : null
		});

		// Animated Token Vision
		game.settings.register("core", "visionAnimation", {
			name: "SETTINGS.AnimVisionN",
			hint: "SETTINGS.AnimVisionL",
			config: true,
			type: Boolean,
			default: true
		});

		// Light Source Flicker
		game.settings.register("core", "lightAnimation", {
			name: "SETTINGS.AnimLightN",
			hint: "SETTINGS.AnimLightL",
			config: true,
			type: Boolean,
			default: true,
			onChange: () => canvas.lighting?.activateAnimation()
		});

		// Mipmap Antialiasing
		game.settings.register("core", "mipmap", {
			name: "SETTINGS.MipMapN",
			hint: "SETTINGS.MipMapL",
			config: true,
			type: Boolean,
			default: true,
			onChange: () => canvas.ready ? canvas.draw() : null
		});

		// Default Drawing Configuration
		game.settings.register("core", DrawingsLayer.DEFAULT_CONFIG_SETTING, {
			name: "Default Drawing Configuration",
			scope: "client",
			config: false,
			default: {},
			type: Object
		});

		// Entity-specific settings
		RollTables.registerSettings();

		// Audio playback settings
		AudioHelper.registerSettings();

		// Register CanvasLayer settings
		NotesLayer.registerSettings();
		TemplateLayer.registerSettings();
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * Is the current session user authenticated as an application administrator?
	 * @type {boolean}
	 */
	get isAdmin() {
		return this.data.isAdmin;
	}

	/* -------------------------------------------- */

	/**
	 * The currently connected User entity, or null if Users is not yet initialized
	 * @type {User|null}
	 */
	get user() {
		return this.users ? this.users.current : null;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor for the currently viewed Combat encounter
	 * @type {Combat}
	 */
	get combat() {
		return this.combats.viewed;
	}

	/* -------------------------------------------- */

	/**
	 * A state variable which tracks whether or not the game session is currently paused
	 * @type {boolean}
	 */
	get paused() {
		return this.data.paused;
	}

	/* -------------------------------------------- */

	/**
	 * A convenient reference to the currently active canvas tool
	 * @type {string}
	 */
	get activeTool() {
		return ui.controls.activeTool;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Toggle the pause state of the game
	 * Trigger the `pauseGame` Hook when the paused state changes
	 * @param {boolean} pause         The desired pause state. When true, the game will be paused, when false the game will be un-paused.
	 * @param {boolean} [push=false]  Push the pause state change to other connected clients? Requires an GM user.
	 */
	togglePause(pause, push=false) {
		this.data.paused = pause || !this.data.paused;
		if (push && game.user.isGM) game.socket.emit("pause", this.data.paused);
		ui.pause.render();
		/**
		 * A hook event that fires when the game is paused or un-paused.
		 * @function pauseGame
		 * @memberof hookEvents
		 * @param {boolean} paused    Is the game now paused (true) or un-paused (false)
		 */
		Hooks.callAll("pauseGame", this.data.paused);
	}

	/* -------------------------------------------- */

	/**
	 * Log out of the game session by returning to the Join screen
	 */
	logOut() {
		if ( this.socket ) this.socket.disconnect();
		window.location.href = foundry.utils.getRoute("join");
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/**
	 * Activate Socket event listeners which are used to transact game state data with the server
	 */
	activateSocketListeners() {

		// Disconnection and reconnection attempts
		this.socket.on('disconnect', () => {
			ui.notifications.error("You have lost connection to the server, attempting to re-establish.");
		});

		// Reconnect failed
		this.socket.on('reconnect_failed', () => {
			ui.notifications.error("Server connection lost.");
			window.location.href = foundry.utils.getRoute("no");
		});

		// Reconnect succeeded
		this.socket.on('reconnect', () => {
			ui.notifications.info("Server connection re-established.");
		});

		// Game pause
		this.socket.on('pause', pause => {
			game.togglePause(pause, false);
		});

		// Game shutdown
		this.socket.on("shutdown", () => {
			ui.notifications.info("The game world is shutting down and you will be returned to the server homepage.", {
				permanent: true
			});
			setTimeout(() => window.location.href = foundry.utils.getRoute("/"), 1000);
		});

		// Database Operations
		CONFIG.DatabaseBackend.activateSocketListeners(this.socket);

		// Additional events
		AudioHelper._activateSocketListeners(this.socket);
		Users._activateSocketListeners(this.socket);
		Scenes._activateSocketListeners(this.socket);
		Journal._activateSocketListeners(this.socket);
		FogExploration._activateSocketListeners(this.socket);
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Activate Event Listeners which apply to every Game View
	 */
	activateListeners() {

		// Disable touch zoom
		document.addEventListener("touchmove", ev => {
			if (ev.scale !== 1) ev.preventDefault();
		});

		// Disable right-click
		document.addEventListener("contextmenu", ev => ev.preventDefault());

		// Disable mouse 3, 4, and 5
		document.addEventListener("pointerdown", this._onPointerDown);
		document.addEventListener("pointerup", this._onPointerUp);

		// Prevent dragging and dropping unless a more specific handler allows it
		document.addEventListener("dragstart", this._onPreventDragstart);
		document.addEventListener("dragover", this._onPreventDragover);
		document.addEventListener("drop", this._onPreventDrop);

		// Support mousewheel interaction for range input elements
		window.addEventListener("wheel", Game._handleMouseWheelInputChange, {passive: false});

		// Entity links
		TextEditor.activateListeners();
	
		// Await gestures to begin audio and video playback
		game.audio.awaitFirstGesture();
		game.video.awaitFirstGesture();

		// Handle changes to the state of the browser window
		window.addEventListener("beforeunload", this._onWindowBeforeUnload);
		window.addEventListener("blur", this._onWindowBlur);
		window.addEventListener("resize", this._onWindowResize);
		if ( this.view === "game" ) {
			history.pushState(null, null, location.href);
			window.addEventListener("popstate", this._onWindowPopState);
		}

		// Force hyperlinks to a separate window/tab
		document.addEventListener("click", this._onClickHyperlink);
	}

	/* -------------------------------------------- */

	/**
	 * Support mousewheel control for range type input elements
	 * @param {WheelEvent} event    A Mouse Wheel scroll event
	 * @private
	 */
	static _handleMouseWheelInputChange(event) {
		const r = event.target;
		if ( (r.tagName !== "INPUT") || (r.type !== "range") || r.disabled ) return;
		event.preventDefault();
		event.stopPropagation();

		// Adjust the range slider by the step size
		const step = (parseFloat(r.step) || 1.0) * Math.sign(-1 * event.deltaY);
		r.value = Math.clamped(parseFloat(r.value) + step, parseFloat(r.min), parseFloat(r.max));

		// Dispatch a change event that can bubble upwards to the parent form
		const ev = new Event("change", {bubbles: true});
		r.dispatchEvent(ev);
	}

	/* -------------------------------------------- */

	/**
	 * On left mouse clicks, check if the element is contained in a valid hyperlink and open it in a new tab.
	 * @param {MouseEvent} event
	 * @private
	 */
	_onClickHyperlink(event) {
		const a = event.target.closest("a[href]");
		if ( !a || (a.href === "javascript:void(0)") ) return;
		event.preventDefault();
		window.open(a.href, "_blank");
	}

	/* -------------------------------------------- */

	/**
	 * Prevent starting a drag and drop workflow on elements within the document unless the element has the draggable
	 * attribute explicitly defined or overrides the dragstart handler.
	 * @param {DragEvent} event   The initiating drag start event
	 * @private
	 */
	_onPreventDragstart(event) {
		if ( event.target.getAttribute("draggable") === "true" ) return;
		event.preventDefault();
		return false;
	}

	/* -------------------------------------------- */

	/**
	 * Disallow dragging of external content onto anything but a file input element
	 * @param {DragEvent} event   The requested drag event
	 * @private
	 */
	_onPreventDragover(event) {
		const target = event.target;
		if ( (target.tagName !== "INPUT") || (target.type !== "file") ) event.preventDefault();
	}

	/* -------------------------------------------- */

	/**
	 * Disallow dropping of external content onto anything but a file input element
	 * @param {DragEvent} event   The requested drag event
	 * @private
	 */
	_onPreventDrop(event) {
		const target = event.target;
		if ( (target.tagName !== "INPUT") || (target.type !== "file") ) event.preventDefault();
	}

	/* -------------------------------------------- */

	/**
	 * On a left-click event, remove any currently displayed inline roll tooltip
	 * @param {PointerEvent} event    The mousedown pointer event
	 * @private
	 */
	_onPointerDown(event) {
		if ([3, 4, 5].includes(event.button)) event.preventDefault();
		const inlineRoll = document.querySelector(".inline-roll.expanded");
		if ( inlineRoll && !event.target.closest(".inline-roll") ) {
			return Roll.collapseInlineResult(inlineRoll);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Fallback handling for mouse-up events which aren't handled further upstream.
	 * @param {PointerEvent} event    The mouseup pointer event
	 * @private
	 */
	_onPointerUp(event) {
		const cmm = canvas.currentMouseManager;
		if ( !cmm || event.defaultPrevented ) return;
		cmm.cancel(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle resizing of the game window
	 * Reposition any active UI windows
	 * @private
	 */
	_onWindowResize(event) {
		Object.values(ui.windows).forEach(app => app.setPosition());
		if (canvas && canvas.ready) return canvas._onResize(event)
	}

	/* -------------------------------------------- */

	/**
	 * Handle window unload operations to clean up any data which may be pending a final save
	 * @param {Event} event     The window unload event which is about to occur
	 * @private
	 */
	_onWindowBeforeUnload(event) {
		if ( canvas.ready ) return canvas.sight.saveFog();
	}

	/* -------------------------------------------- */

	/**
	 * Handle cases where the browser window loses focus to reset detection of currently pressed keys
	 * @param {Event} event   The originating window.blur event
	 * @private
	 */
	_onWindowBlur(event) {
		if ( !game.keyboard ) return;
		const dk = game.keyboard._downKeys;
		if (dk.has("Alt")) game.keyboard._onAlt(event, true, {});
		dk.clear();
		game.keyboard._handled.clear();
	}

	/* -------------------------------------------- */

	_onWindowPopState(event) {
		if ( game._goingBack ) return;
		history.pushState(null, null, location.href);
		if ( confirm(game.i18n.localize("APP.NavigateBackConfirm")) ) {
			game._goingBack = true;
			history.back();
			history.back();
		}
	}

	/* -------------------------------------------- */
	/*  View Handlers                               */
	/* -------------------------------------------- */

	/**
	 * Initialize elements required for the current view
	 * @private
	 */
	async _initializeView() {
		switch (this.view) {
			case "game":
				return this._initializeGameView();
			case "stream":
				return this._initializeStreamView();
			default:
				throw new Error(`Unknown view URL ${this.view} provided`);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Initialization steps for the primary Game view
	 * @private
	 */
	async _initializeGameView() {

		// Require a valid user cookie and EULA acceptance
		if ( !SIGNED_EULA ) window.location.href = foundry.utils.getRoute("license");
		if (!this.userId) {
			console.error("Invalid user session provided - returning to login screen.");
			this.logOut();
		}

		// Setup the game
		await this.setupGame();

		// Set a timeout of 10 minutes before kicking the user off
		setTimeout(() => {
			if (this.user.isGM || !this.data.demo) return;
			console.log(`${vtt} | Ending demo session after 10 minutes. Thanks for testing!`);
			this.logOut();
		}, 1000 * 60 * 10);

		// Context menu listeners
		ContextMenu.eventListeners();
	};

	/* -------------------------------------------- */

	/**
	 * Initialization steps for the Stream helper view
	 * @private
	 */
	async _initializeStreamView() {
		if ( !SIGNED_EULA ) window.location.href = foundry.utils.getRoute("license");
		this.initializeEntities();
		ui.chat = new ChatLog({stream: true});
		ui.chat.render(true);
		CONFIG.DatabaseBackend.activateSocketListeners(this.socket);
	}
}

/**
 * This class provides an interface and API for conducting dice rolls.
 * The basic structure for a dice roll is a string formula and an object of data against which to parse it.
 *
 * @param {string} formula    The string formula to parse
 * @param {object} data       The data object against which to parse attributes within the formula
 *
 * @example
 * // Attack with advantage!
 * let r = new Roll("2d20kh + @prof + @strMod", {prof: 2, strMod: 4});
 *
 * // The parsed terms of the roll formula
 * console.log(r.terms);    // [Die, OperatorTerm, NumericTerm, OperatorTerm, NumericTerm]
 *
 * // Execute the roll
 * r.evaluate();
 *
 * // The resulting equation after it was rolled
 * console.log(r.result);   // 16 + 2 + 4
 *
 * // The total resulting from the roll
 * console.log(r.total);    // 22
 */
class Roll {
	constructor(formula, data={}, options={}) {

		/**
		 * The original provided data object which substitutes into attributes of the roll formula
		 * @type {Object}
		 */
		this.data = this._prepareData(data);

		/**
		 * Options which modify or describe the Roll
		 * @type {object}
		 */
		this.options = options;

		/**
		 * The identified terms of the Roll
		 * @type {RollTerm[]}
		 */
		this.terms = this.constructor.parse(formula, this.data);

		/**
		 * An array of inner DiceTerms which were evaluated as part of the Roll evaluation
		 * @type {DiceTerm[]}
		 */
		this._dice = [];

		/**
		 * Store the original cleaned formula for the Roll, prior to any internal evaluation or simplification
		 * @type {string}
		 */
		this._formula = this.constructor.getFormula(this.terms);

		/**
		 * Track whether this Roll instance has been evaluated or not. Once evaluated the Roll is immutable.
		 * @type {boolean}
		 */
		this._evaluated = false;

		/**
		 * Cache the numeric total generated through evaluation of the Roll.
		 * @type {number}
		 * @private
		 */
		this._total = undefined;
	}

	/**
	 * A Proxy environment for safely evaluating a string using only available Math functions
	 * @type {Math}
	 */
	static MATH_PROXY = new Proxy(Math, {has: () => true, get: (t, k) => k === Symbol.unscopables ? undefined : t[k]});

	/**
	 * The HTML template path used to render a complete Roll object to the chat log
	 * @type {string}
	 */
	static CHAT_TEMPLATE = "templates/dice/roll.html";

	/**
	 * The HTML template used to render an expanded Roll tooltip to the chat log
	 * @type {string}
	 */
	static TOOLTIP_TEMPLATE = "templates/dice/tooltip.html";

	/* -------------------------------------------- */

	/**
	 * Prepare the data structure used for the Roll.
	 * This is factored out to allow for custom Roll classes to do special data preparation using provided input.
	 * @param {object} data   Provided roll data
	 * @returns {object}      The prepared data object
	 * @protected
	 */
	_prepareData(data) {
		return data;
	}

	/* -------------------------------------------- */
	/*  Roll Attributes                             */
	/* -------------------------------------------- */

	/**
	 * Return an Array of the individual DiceTerm instances contained within this Roll.
	 * @return {DiceTerm[]}
	 */
	get dice() {
		return this._dice.concat(this.terms.reduce((dice, t) => {
			if ( t instanceof DiceTerm ) dice.push(t);
			else if ( t instanceof PoolTerm ) dice = dice.concat(t.dice);
			return dice;
		}, []));
	}

	/* -------------------------------------------- */

	/**
	 * Return a standardized representation for the displayed formula associated with this Roll.
	 * @return {string}
	 */
	get formula() {
		return this.constructor.getFormula(this.terms);
	}

	/* -------------------------------------------- */

	/**
	 * The resulting arithmetic expression after rolls have been evaluated
	 * @return {string}
	 */
	get result() {
		return this.terms.map(t => t.total).join("");
	}

	/* -------------------------------------------- */

	/**
	 * Return the total result of the Roll expression if it has been evaluated.
	 * @type {number}
	 */
	get total() {
		return this._total;
	}

	/* -------------------------------------------- */
	/*  Roll Instance Methods                       */
	/* -------------------------------------------- */

	/**
	 * Alter the Roll expression by adding or multiplying the number of dice which are rolled
	 * @param {number} multiply   A factor to multiply. Dice are multiplied before any additions.
	 * @param {number} add        A number of dice to add. Dice are added after multiplication.
	 * @param {boolean} [multiplyNumeric]  Apply multiplication factor to numeric scalar terms
	 * @return {Roll}             The altered Roll expression
	 */
	alter(multiply, add, {multiplyNumeric=false}={}) {
		if ( this._evaluated ) throw new Error("You may not alter a Roll which has already been evaluated");

		// Alter dice and numeric terms
		this.terms = this.terms.map(term => {
			if ( term instanceof DiceTerm ) return term.alter(multiply, add);
			else if ( (term instanceof NumericTerm) && multiplyNumeric ) term.number *= multiply;
			return term;
		});

		// Update the altered formula and return the altered Roll
		this._formula = this.constructor.getFormula(this.terms);
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Clone the Roll instance, returning a new Roll instance that has not yet been evaluated.
	 * @return {Roll}
	 */
	clone() {
		return new this.constructor(this._formula, this.data, this.options);
	}

	/* -------------------------------------------- */

	/**
	 * Execute the Roll, replacing dice and evaluating the total result
	 * @param {object} [options={}]     Options which inform how the Roll is evaluated
	 * @param {boolean} [options.minimize=false]    Minimize the result, obtaining the smallest possible value.
	 * @param {boolean} [options.maximize=false]    Maximize the result, obtaining the largest possible value.
	 * @param {boolean} [options.async=false]       Evaluate the roll asynchronously, receiving a Promise as the returned value.
	 *                                              This will become the default behavior in version 10.x
	 * @returns {Roll|Promise<Roll>}    The evaluated Roll instance
	 *
	 * @example
	 * let r = new Roll("2d6 + 4 + 1d4");
	 * r.evaluate();
	 * console.log(r.result); // 5 + 4 + 2
	 * console.log(r.total);  // 11
	 */
	evaluate({minimize=false, maximize=false, async}={}) {
		if ( this._evaluated ) {
			throw new Error(`The ${this.constructor.name} has already been evaluated and is now immutable`);
		}
		this._evaluated = true;
		if ( CONFIG.debug.dice ) console.debug(`Evaluating roll with formula ${this.formula}`);

		// Migration path for async rolls
		if ( minimize || maximize ) async = false;
		if ( async === undefined ) {
			console.warn(`Roll#evaluate is becoming asynchronous. In the short term you may pass async=true or async=false to evaluation options to nominate your preferred behavior.`);
			async = false;
		}
		return async ? this._evaluate({minimize, maximize}) : this._evaluateSync({minimize, maximize});
	}

	/* -------------------------------------------- */

	/**
	 * Evaluate the roll asynchronously.
	 * A temporary helper method used to migrate behavior from 0.7.x (sync by default) to 0.9.x (async by default).
	 * @returns {Promise<Roll>}
	 * @private
	 */
	async _evaluate({minimize=false, maximize=false}={}) {

		// Step 1 - Replace intermediate terms with evaluated numbers
		const intermediate = [];
		for ( let term of this.terms ) {
			if ( !(term instanceof RollTerm) ) {
				throw new Error("Roll evaluation encountered an invalid term which was not a RollTerm instance");
			}
			if ( term.isIntermediate ) {
				await term.evaluate({minimize, maximize, async: true});
				this._dice = this._dice.concat(term.dice);
				term = new NumericTerm({number: term.total, options: term.options});
			}
			intermediate.push(term);
		}
		this.terms = intermediate;

		// Step 2 - Simplify remaining terms
		this.terms = this.constructor.simplifyTerms(this.terms);

		// Step 3 - Evaluate remaining terms
		for ( let term of this.terms ) {
			if ( !term._evaluated ) await term.evaluate({minimize, maximize, async: true});
		}

		// Step 4 - Evaluate the final expression
		this._total = this._evaluateTotal();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Evaluate the roll synchronously.
	 * A temporary helper method used to migrate behavior from 0.7.x (sync by default) to 0.9.x (async by default).
	 * @returns {Roll}
	 * @private
	 */
	_evaluateSync({minimize=false, maximize=false}={}) {

		// Step 1 - Replace intermediate terms with evaluated numbers
		this.terms = this.terms.map(term => {
			if ( !(term instanceof RollTerm) ) {
				throw new Error("Roll evaluation encountered an invalid term which was not a RollTerm instance");
			}
			if ( term.isIntermediate ) {
				term.evaluate({minimize, maximize, async: false});
				this._dice = this._dice.concat(term.dice);
				return new NumericTerm({number: term.total, options: term.options});
			}
			return term;
		});

		// Step 2 - Simplify remaining terms
		this.terms = this.constructor.simplifyTerms(this.terms);

		// Step 3 - Evaluate remaining terms
		for ( let term of this.terms ) {
			if ( !term._evaluated ) term.evaluate({minimize, maximize, async: false});
		}

		// Step 4 - Evaluate the final expression
		this._total = this._evaluateTotal();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Safely evaluate the final total result for the Roll using its component terms.
	 * @returns {number}    The evaluated total
	 * @private
	 */
	_evaluateTotal() {
		const expression = this.terms.map(t => t.total).join(" ");
		const total = Roll.safeEval(expression);
		if ( !Number.isNumeric(total) ) {
			throw new Error(game.i18n.format("DICE.ErrorNonNumeric", {formula: this.formula}));
		}
		return total;
	}

	/* -------------------------------------------- */

	/**
	 * Alias for evaluate.
	 * @see {Roll#evaluate}
	 */
	roll(options={}) {
		return this.evaluate(options);
	}

	/* -------------------------------------------- */

	/**
	 * Create a new Roll object using the original provided formula and data.
	 * Each roll is immutable, so this method returns a new Roll instance using the same data.
	 * @param {object} [options={}]     Evaluation options passed to Roll#evaluate
	 * @return {Roll}                   A new Roll object, rolled using the same formula and data
	 */
	reroll(options={}) {
		const r = this.clone();
		return r.evaluate(options);
	}

	/* -------------------------------------------- */
	/*  Static Class Methods                        */
	/* -------------------------------------------- */

	/**
	 * A factory method which constructs a Roll instance using the default configured Roll class.
	 * @param {string} formula        The formula used to create the Roll instance
	 * @param {object} [data={}]      The data object which provides component data for the formula
	 * @param {object} [options={}]   Additional options which modify or describe this Roll
	 * @return {Roll}                 The constructed Roll instance
	 */
	static create(formula, data={}, options={}) {
		const cls = CONFIG.Dice.rolls[0];
		return new cls(formula, data, options);
	}

	/* -------------------------------------------- */

	/**
	 * Transform an array of RollTerm objects into a cleaned string formula representation.
	 * @param {RollTerm[]} terms      An array of terms to represent as a formula
	 * @returns {string}              The string representation of the formula
	 */
	static getFormula(terms) {
		return terms.map(t => t.formula).join("");
	}

	/* -------------------------------------------- */

	/**
	 * A sandbox-safe evaluation function to execute user-input code with access to scoped Math methods.
	 * @param {string} expression   The input string expression
	 * @returns {number}            The numeric evaluated result
	 */
	static safeEval(expression) {
		let result;
		try {
			const src = 'with (sandbox) { return ' + expression + '}';
			const evl = new Function('sandbox', src);
			result = evl(Roll.MATH_PROXY);
		} catch {
			result = undefined;
		}
		if ( !Number.isNumeric(result) ) {
			throw new Error(`Roll.safeEval produced a non-numeric result from expression "${expression}"`);
		}
		return result;
	};

	/* -------------------------------------------- */

	/**
	 * After parenthetical and arithmetic terms have been resolved, we need to simplify the remaining expression.
	 * Any remaining string terms need to be combined with adjacent non-operators in order to construct parsable terms.
	 * @param {RollTerm[]} terms      An array of terms which is eligible for simplification
	 * @returns {RollTerm[]}          An array of simplified terms
	 */
	static simplifyTerms(terms) {

		// Simplify terms by combining with pending strings
		let simplified = terms.reduce((terms, term) => {
			const prior = terms[terms.length - 1];
			const isOperator = term instanceof OperatorTerm;

			// Combine a non-operator term with prior StringTerm
			if ( !isOperator && (prior instanceof StringTerm) ) {
				prior.term += term.total;
				foundry.utils.mergeObject(prior.options, term.options);
				return terms;
			}

			// Combine StringTerm with a prior non-operator term
			const priorOperator = prior instanceof OperatorTerm;
			if ( prior && !priorOperator && (term instanceof StringTerm) ) {
				term.term = String(prior.total) + term.term;
				foundry.utils.mergeObject(term.options, prior.options);
				terms[terms.length - 1] = term;
				return terms;
			}

			// Otherwise continue
			terms.push(term);
			return terms;
		}, []);

		// Convert remaining String terms to a RollTerm which can be evaluated
		simplified = simplified.map(term => {
			if ( !(term instanceof StringTerm) ) return term;
			const t = this._classifyStringTerm(term.formula, {intermediate: false});
			t.options = term.options;
			return t;
		});

		// Eliminate leading or trailing arithmetic
		if ( (simplified[0] instanceof OperatorTerm) && (simplified[0].operator !== "-") ) simplified.shift();
		if ( simplified[terms.length-1] instanceof OperatorTerm) simplified.pop();
		return simplified;
	}

	/* -------------------------------------------- */

	/**
	 * Simulate a roll and evaluate the distribution of returned results
	 * @param {string} formula    The Roll expression to simulate
	 * @param {number} n          The number of simulations
	 * @return {number[]}         The rolled totals
	 */
	static simulate(formula, n=10000) {
		const results = [...Array(n)].map(i => {
			let r = new this(formula);
			return r.evaluate().total;
		}, []);
		const summary = results.reduce((sum, v) => {
			sum.total = sum.total + v;
			if ( (sum.min === null) || (v < sum.min) ) sum.min = v;
			if ( (sum.max === null) || (v > sum.max) ) sum.max = v;
			return sum;
		}, {total: 0, min: null, max: null});
		summary.mean = summary.total / n;
		console.log(`Formula: ${formula} | Iterations: ${n} | Mean: ${summary.mean} | Min: ${summary.min} | Max: ${summary.max}`);
		return results;
	}

	/* -------------------------------------------- */
	/*  Roll Formula Parsing                        */
	/* -------------------------------------------- */

	/**
	 * Parse a formula by following an order of operations:
	 *
	 * Step 1: Replace formula data
	 * Step 2: Split outer-most parenthetical groups
	 * Step 3: Further split outer-most dice pool groups
	 * Step 4: Further split string terms on arithmetic operators
	 * Step 5: Classify all remaining strings
	 *
	 * @param {string} formula      The original string expression to parse
	 * @param {object} data         A data object used to substitute for attributes in the formula
	 * @returns {RollTerm[]}        A parsed array of RollTerm instances
	 */
	static parse(formula, data) {
		if ( !formula ) return [];

		// Step 1: Replace formula data and remove all spaces
		let replaced = this.replaceFormulaData(formula, data, {missing: "0"});

		// Step 2: Split outer-most outer-most parenthetical groups
		let terms = this._splitParentheses(replaced);

		// Step 3: Split additional dice pool groups which may contain inner rolls
		terms = terms.flatMap(term => {
			return typeof term === "string" ? this._splitPools(term) : term;
		});

		// Step 4: Further split string terms on arithmetic operators
		terms = terms.flatMap(term => {
			return typeof term === "string" ? this._splitOperators(term) : term;
		});

		// Step 5: Classify all remaining strings
		terms = terms.map((t, i) => this._classifyStringTerm(t, {
			intermediate: true,
			prior: terms[i-1],
			next: terms[i+1]
		}));
		return terms;
	}

	/* -------------------------------------------- */

	/**
	 * Replace referenced data attributes in the roll formula with values from the provided data.
	 * Data references in the formula use the @attr syntax and would reference the corresponding attr key.
	 *
	 * @param {string} formula          The original formula within which to replace
	 * @param {object} data             The data object which provides replacements
	 * @param {string} [missing]        The value that should be assigned to any unmatched keys.
	 *                                  If null, the unmatched key is left as-is.
	 * @param {boolean} [warn]          Display a warning notification when encountering an un-matched key.
	 * @static
	 */
	static replaceFormulaData(formula, data, {missing, warn=false}={}) {
		let dataRgx = new RegExp(/@([a-z.0-9_\-]+)/gi);
		return formula.replace(dataRgx, (match, term) => {
			let value = foundry.utils.getProperty(data, term);
			if ( value === undefined ) {
				if ( warn && ui.notifications ) ui.notifications.warn(game.i18n.format("DICE.WarnMissingData", {match}));
				return (missing !== undefined) ? String(missing) : match;
			}
			return String(value).trim();
		});
	}

	/* -------------------------------------------- */

	/**
	 * Validate that a provided roll formula can represent a valid
	 * @param {string} formula    A candidate formula to validate
	 * @return {boolean}          Is the provided input a valid dice formula?
	 */
	static validate(formula) {

		// Replace all data references with an arbitrary number
		formula = formula.replace(/@([a-z.0-9_\-]+)/gi, "1");

		// Attempt to evaluate the roll
		try {
			const r = new this(formula);
			r.evaluate({async: false});
			return true;
		}

		// If we weren't able to evaluate, the formula is invalid
		catch(err) {
			return false;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Split a formula by identifying its outer-most parenthetical and math terms
	 * @param {string} _formula      The raw formula to split
	 * @returns {string[]}          An array of terms, split on parenthetical terms
	 * @private
	 */
	static _splitParentheses(_formula) {
		return this._splitGroup(_formula, {
			openRegexp: ParentheticalTerm.OPEN_REGEXP,
			closeRegexp: ParentheticalTerm.CLOSE_REGEXP,
			openSymbol: "(",
			closeSymbol: ")",
			onClose: group => {

				// Extract group arguments
				const fn = group.open.slice(0, -1);
				const expression = group.terms.join("");
				const options = { flavor: group.flavor ? group.flavor.slice(1, -1) : undefined };

				// Classify the resulting terms
				const terms = [];
				if ( fn in Math ) {
					const args = this._splitMathArgs(expression);
					terms.push(new MathTerm({fn, terms: args, options}));
				}
				else {
					if ( fn ) terms.push(fn);
					terms.push(new ParentheticalTerm({term: expression, options}));
				}
				return terms;
			}
		});
	}

	/* -------------------------------------------- */

	/**
	 * Handle closing of a parenthetical term to create a MathTerm expression with a function and arguments
	 * @returns {MathTerm[]}
	 * @private
	 */
	static _splitMathArgs(expression) {
		return expression.split(",").reduce((args, t) => {
			t = t.trim();
			if ( !t ) return args;  // Blank args
			if ( !args.length ) {   // First arg
				args.push(t);
				return args;
			}
			const p = args[args.length-1];  // Prior arg
			const priorValid = Roll.validate(p);
			if ( priorValid ) args.push(t);
			else args[args.length-1] = [p, t].join(","); // Collect inner parentheses or pools
			return args;
		}, []);
	}

	/* -------------------------------------------- */

	/**
	 * Split a formula by identifying its outer-most dice pool terms
	 * @param {string} _formula      The raw formula to split
	 * @returns {string[]}          An array of terms, split on parenthetical terms
	 * @private
	 */
	static _splitPools(_formula) {
		return this._splitGroup(_formula, {
			openRegexp: PoolTerm.OPEN_REGEXP,
			closeRegexp: PoolTerm.CLOSE_REGEXP,
			openSymbol: "{",
			closeSymbol: "}",
			onClose: group => {
				const terms = this._splitMathArgs(group.terms.join(""));
				const modifiers = Array.from(group.close.slice(1).matchAll(DiceTerm.MODIFIER_REGEXP)).map(m => m[0]);
				const options = { flavor: group.flavor ? group.flavor.slice(1, -1) : undefined };
				return [new PoolTerm({terms, modifiers, options})];
			}
		})
	}

	/* -------------------------------------------- */

	/**
	 * Split a formula by identifying its outer-most groups using a certain group symbol like parentheses or brackets.
	 * @param {string} _formula     The raw formula to split
	 * @param {object} options      Options that configure how groups are split
	 * @returns {string[]}          An array of terms, split on dice pool terms
	 * @private
	 */
	static _splitGroup(_formula, {openRegexp, closeRegexp, openSymbol, closeSymbol, onClose}={}) {
		let {formula, flavors} = this._extractFlavors(_formula);

		// Split the formula on parentheses
		const parts = formula.replace(openRegexp, ";$&;").replace(closeRegexp, ";$&;").split(";");
		let terms = [];
		let nOpen = 0;
		let group = {openIndex: undefined, open: "", terms: [], close: "", closeIndex: undefined, flavor: undefined};

		// Handle closing a group
		const closeGroup = t => {

			// Identify closing flavor text (and remove it)
			const flavor = t.match(/%F[0-9]+%/);
			if ( flavor ) {
				group.flavor = this._restoreFlavor(flavor[0], flavors);
				t = t.slice(0, flavor.index);
			}

			// Treat the remainder as the closing symbol
			group.close = t;

			// Restore flavor to member terms
			group.terms = group.terms.map(t => this._restoreFlavor(t, flavors));
			terms = terms.concat(onClose(group));
		}

		// Map parts to parenthetical groups
		for ( let t of parts ) {
			t = t.trim();
			if ( !t ) continue;

			// New open group
			if ( t.endsWith(openSymbol) ) {
				nOpen++;

				// Open a new group
				if ( nOpen === 1 ) {
					group = {open: t, terms: [], close: "", flavor: undefined};
					continue;
				}
			}

			// Continue an opened group
			if ( nOpen > 0 ) {
				if ( t.startsWith(closeSymbol) ) {
					nOpen--;

					// Close the group
					if ( nOpen === 0 ) {
						closeGroup(t);
						continue;
					}
				}
				group.terms.push(t);
				continue;
			}

			// Regular remaining terms
			terms.push(t);
		}

		// If the group was not completely closed, continue closing it
		if ( nOpen !== 0 ) {
			throw new Error(`Unbalanced group missing opening ${openSymbol} or closing ${closeSymbol}`);
		}

		// Restore withheld flavor text and re-combine strings
		terms = terms.reduce((terms, t) => {
			if ( typeof t === "string" ) { // Re-combine string terms
				t = this._restoreFlavor(t, flavors);
				if ( typeof terms[terms.length-1] === "string" ) terms[terms.length-1] = terms[terms.length-1] + t;
				else terms.push(t);
			}
			else terms.push(t); // Intermediate terms
			return terms;
		}, []);
		return terms;
	}

	/* -------------------------------------------- */

	/**
	 * Split a formula by identifying arithmetic terms
	 * @param {string} _formula                 The raw formula to split
	 * @returns {Array<(string|OperatorTerm)>}  An array of terms, split on arithmetic operators
	 * @private
	 */
	static _splitOperators(_formula) {
		let {formula, flavors} = this._extractFlavors(_formula);
		const parts = formula.replace(OperatorTerm.REGEXP, ";$&;").split(";");
		return parts.reduce((terms, t) => {
			t = t.trim();
			if ( !t ) return terms;
			const isOperator = OperatorTerm.OPERATORS.includes(t)
			terms.push(isOperator ? new OperatorTerm({operator: t}) : this._restoreFlavor(t, flavors));
			return terms;
		},[]);
	}

	/* -------------------------------------------- */

	/**
	 * Temporarily remove flavor text from a string formula allowing it to be accurately parsed.
	 * @param {string} formula                        The formula to extract
	 * @returns {{formula: string, flavors: object}}  The cleaned formula and extracted flavor mapping
	 * @private
	 */
	static _extractFlavors(formula) {
		const flavors = {};
		let fn = 0;
		formula = formula.replace(RollTerm.FLAVOR_REGEXP, flavor => {
			let key = `%F${fn++}%`;
			flavors[key] = flavor;
			return key;
		});
		return {formula, flavors};
	}

	/* -------------------------------------------- */

	/**
	 * Restore flavor text to a string term
	 * @param {string} term         The string term possibly containing flavor symbols
	 * @param {object} flavors      The extracted flavors object
	 * @returns {string}            The restored term containing flavor text
	 * @private
	 */
	static _restoreFlavor(term, flavors) {
		for ( let [key, flavor] of Object.entries(flavors) ) {
			if ( term.indexOf(key) !== -1 ) {
				delete flavors[key];
				term = term.replace(key, flavor);
			}
		}
		return term;
	}

	/* -------------------------------------------- */

	/**
	 * Classify a remaining string term into a recognized RollTerm class
	 * @param {string} term         A remaining un-classified string
	 * @param {object} [options={}] Options which customize classification
	 * @param {boolean} [options.intermediate=false]  Allow intermediate terms
	 * @param {RollTerm|string} [options.prior]       The prior classified term
	 * @param {RollTerm|string} [options.next]        The next term to classify
	 * @returns {RollTerm}          A classified RollTerm instance
	 * @private
	 */
	static _classifyStringTerm(term, {intermediate=true, prior, next}={}) {

		// Terms already classified
		if ( term instanceof RollTerm ) return term;

		// Numeric terms
		const numericMatch = NumericTerm.matchTerm(term);
		if ( numericMatch ) return NumericTerm.fromMatch(numericMatch);

		// Dice terms
		const diceMatch = DiceTerm.matchTerm(term, {imputeNumber: !intermediate});
		if ( diceMatch ) {
			if ( intermediate && (prior?.isIntermediate || next?.isIntermediate) ) return new StringTerm({term});
			return DiceTerm.fromMatch(diceMatch);
		}

		// Remaining strings
		return new StringTerm({term});
	}

	/* -------------------------------------------- */
	/*  Chat Messages                               */
	/* -------------------------------------------- */

	/**
	 * Render the tooltip HTML for a Roll instance
	 * @return {Promise<string>}      The rendered HTML tooltip as a string
	 */
	async getTooltip() {
		const parts = this.dice.map(d => d.getTooltipData());
		return renderTemplate(this.constructor.TOOLTIP_TEMPLATE, { parts });
	}

	/* -------------------------------------------- */

	/**
	 * Render a Roll instance to HTML
	 * @param {object} [chatOptions]      An object configuring the behavior of the resulting chat message.
	 * @return {Promise<string>}          The rendered HTML template as a string
	 */
	async render(chatOptions={}) {
		chatOptions = foundry.utils.mergeObject({
			user: game.user.id,
			flavor: null,
			template: this.constructor.CHAT_TEMPLATE,
			blind: false
		}, chatOptions);
		const isPrivate = chatOptions.isPrivate;

		// Execute the roll, if needed
		if (!this._evaluated) this.evaluate();

		// Define chat data
		const chatData = {
			formula: isPrivate ? "???" : this._formula,
			flavor: isPrivate ? null : chatOptions.flavor,
			user: chatOptions.user,
			tooltip: isPrivate ? "" : await this.getTooltip(),
			total: isPrivate ? "?" : Math.round(this.total * 100) / 100
		};

		// Render the roll display template
		return renderTemplate(chatOptions.template, chatData);
	}

	/* -------------------------------------------- */

	/**
	 * Transform a Roll instance into a ChatMessage, displaying the roll result.
	 * This function can either create the ChatMessage directly, or return the data object that will be used to create.
	 *
	 * @param {object} messageData          The data object to use when creating the message
	 * @param {options} [options]           Additional options which modify the created message.
	 * @param {string} [options.rollMode]   The template roll mode to use for the message from CONFIG.Dice.rollModes
	 * @param {boolean} [options.create=true]   Whether to automatically create the chat message, or only return the
	 *                                          prepared chatData object.
	 * @return {Promise<ChatMessage>}       A promise which resolves to the created ChatMessage entity, if create is true
	 *                                      or the Object of prepared chatData otherwise.
	 */
	async toMessage(messageData={}, {rollMode, create=true}={}) {

		// Perform the roll, if it has not yet been rolled
		if (!this._evaluated) await this.evaluate({async: true});

		// Prepare chat data
		messageData = foundry.utils.mergeObject({
			user: game.user.id,
			type: CONST.CHAT_MESSAGE_TYPES.ROLL,
			content: this.total,
			sound: CONFIG.sounds.dice,
		}, messageData);
		messageData.roll = this;

		// Either create the message or just return the chat data
		const cls = getDocumentClass("ChatMessage");
		const msg = new cls(messageData);
		if ( rollMode ) msg.applyRollMode(rollMode);

		// Either create or return the data
		if ( create ) return cls.create(msg.data);
		else return msg.data;
	}

	/* -------------------------------------------- */
	/*  Interface Helpers                           */
	/* -------------------------------------------- */

	/**
	 * Expand an inline roll element to display it's contained dice result as a tooltip
	 * @param {HTMLAnchorElement} a     The inline-roll button
	 * @return {Promise<void>}
	 */
	static async expandInlineResult(a) {
		if ( !a.classList.contains("inline-roll") ) return;
		if ( a.classList.contains("expanded") ) return;

		// Create a new tooltip
		const roll = Roll.fromJSON(unescape(a.dataset.roll));
		const tip = document.createElement("div");
		tip.innerHTML = await roll.getTooltip();

		// Add the tooltip
		const tooltip = tip.children[0];
		a.appendChild(tooltip);
		a.classList.add("expanded");

		// Set the position
		const pa = a.getBoundingClientRect();
		const pt = tooltip.getBoundingClientRect();
		tooltip.style.left = `${Math.min(pa.x, window.innerWidth - (pt.width + 3))}px`;
		tooltip.style.top = `${Math.min(pa.y + pa.height + 3, window.innerHeight - (pt.height + 3))}px`;
		const zi = getComputedStyle(a).zIndex;
		tooltip.style.zIndex = Number.isNumeric(zi) ? zi + 1 : 100;
	}

	/* -------------------------------------------- */

	/**
	 * Collapse an expanded inline roll to conceal it's tooltip
	 * @param {HTMLAnchorElement} a     The inline-roll button
	 */
	static collapseInlineResult(a) {
		if ( !a.classList.contains("inline-roll") ) return;
		if ( !a.classList.contains("expanded") ) return;
		const tooltip = a.querySelector(".dice-tooltip");
		if ( tooltip ) tooltip.remove();
		return a.classList.remove("expanded");
	}

	/* -------------------------------------------- */
	/*  Serialization and Loading                   */
	/* -------------------------------------------- */

	/**
	 * Represent the data of the Roll as an object suitable for JSON serialization.
	 * @return {Object}     Structured data which can be serialized into JSON
	 */
	toJSON() {
		return {
			class: this.constructor.name,
			options: this.options,
			dice: this._dice,
			formula: this._formula,
			terms: this.terms,
			total: this._total,
			evaluated: this._evaluated
		}
	}

	/* -------------------------------------------- */

	/**
	 * Recreate a Roll instance using a provided data object
	 * @param {object} data   Unpacked data representing the Roll
	 * @return {Roll}         A reconstructed Roll instance
	 */
	static fromData(data) {

		// Create the Roll instance
		const roll = new this(data.formula, {}, data.options);

		// Expand terms
		roll.terms = data.terms.map(t => {
			if ( t.class ) {
				if ( t.class === "DicePool" ) t.class = "PoolTerm"; // backwards compatibility
				return RollTerm.fromData(t);
			}
			return t;
		});

		// Repopulate evaluated state
		if ( data.evaluated ?? true ) {
			roll._total = data.total;
			roll._dice = (data.dice || []).map(t => DiceTerm.fromData(t));
			roll._evaluated = true;
		}
		return roll;
	}

	/* -------------------------------------------- */

	/**
	 * Recreate a Roll instance using a provided JSON string
	 * @param {string} json   Serialized JSON data representing the Roll
	 * @return {Roll}         A reconstructed Roll instance
	 */
	static fromJSON(json) {
		const data = JSON.parse(json);
		const cls = CONFIG.Dice.rolls.find(cls => cls.name === data.class);
		if ( !cls ) throw new Error(`Unable to recreate ${data.class} instance from provided data`);
		return cls.fromData(data);
	}

	/* -------------------------------------------- */

	/**
	 * Manually construct a Roll object by providing an explicit set of input terms
	 * @param {RollTerm[]} terms      The array of terms to use as the basis for the Roll
	 * @param {object} [options={}]   Additional options passed to the Roll constructor
	 * @returns {Roll}                The constructed Roll instance
	 *
	 * @example
	 * const t1 = new Die({number: 4, faces: 8};
	 * const plus = new OperatorTerm({operator: "+"});
	 * const t2 = new NumericTerm({number: 8});
	 * const roll = Roll.fromTerms([t1, plus, t2]);
	 * roll.formula; // 4d8 + 8
	 */
	static fromTerms(terms, options={}) {

		// Validate provided terms
		if ( !terms.every(t => t instanceof RollTerm ) ) {
			throw new Error("All provided terms must be RollTerm instances");
		}
		const allEvaluated = terms.every(t => t._evaluated);
		const noneEvaluated = !terms.some(t => t._evaluated);
		if ( !(allEvaluated || noneEvaluated) ) {
			throw new Error("You can only call Roll.fromTerms with an array of terms which are either all evaluated, or none evaluated");
		}

		// Construct the roll
		const formula = this.getFormula(terms);
		const roll = this.create(formula, {}, options);
		roll.terms = terms;
		roll._evaluated = allEvaluated;
		if ( roll._evaluated ) roll._total = roll._evaluateTotal();
		return roll;
	}

	/* -------------------------------------------- */
	/*  Deprecations                                */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.1
	 * @ignore
	 */
	get _rolled() {
		console.warn("You are referencing Roll#_rolled which is deprecated in favor of Roll#_evaluated")
		return this._evaluated;
	}
}

/**
 * @deprecated since 0.8.1
 * @ignore
 */
Roll.MATH_PROXY.safeEval = function(expression) {
	console.warn("You are calling Roll.MATH_PROXY.safeEval which has been moved to Roll.safeEval");
	return Roll.safeEval(expression);
}

/**
 * An abstract class which represents a single token that can be used as part of a Roll formula.
 * Every portion of a Roll formula is parsed into a subclass of RollTerm in order for the Roll to be fully evaluated.
 */
class RollTerm {
	constructor({options={}}={}) {

		/**
		 * An object of additional options which describes and modifies the term.
		 * @type {object}
		 */
		this.options = options;

		/**
		 * An internal flag for whether the term has been evaluated
		 * @type {boolean}
		 */
		this._evaluated = false;
	}

	/**
	 * Is this term intermediate, and should be evaluated first as part of the simplification process?
	 * @type {boolean}
	 */
	isIntermediate = false;

	/**
	 * A regular expression pattern which identifies optional term-level flavor text
	 * @type {string}
	 */
	static FLAVOR_REGEXP_STRING = "(?:\\[([^\\]]+)\\])";

	/**
	 * A regular expression which identifies term-level flavor text
	 * @type {RegExp}
	 */
	static FLAVOR_REGEXP = new RegExp(RollTerm.FLAVOR_REGEXP_STRING, "g");

	/**
	 * A regular expression used to match a term of this type
	 * @type {RegExp}
	 */
	static REGEXP = undefined;

	/**
	 * An array of additional attributes which should be retained when the term is serialized
	 * @type {string[]}
	 */
	static SERIALIZE_ATTRIBUTES = [];

	/* -------------------------------------------- */
	/*  RollTerm Attributes                         */
	/* -------------------------------------------- */

	/**
	 * A string representation of the formula expression for this RollTerm, prior to evaluation.
	 * @type {string}
	 */
	get expression() {
		throw new Error(`The ${this.constructor.name} class must implement the expression attribute`);
	}

	/**
	 * A string representation of the formula, including optional flavor text.
	 * @type {string}
	 */
	get formula() {
		let f = this.expression;
		if ( this.flavor ) f += `[${this.flavor}]`;
		return f;
	}

	/**
	 * A string or numeric representation of the final output for this term, after evaluation.
	 * @type {number|string}
	 */
	get total() {
		throw new Error(`The ${this.constructor.name} class must implement the total attribute`);
	}

	/**
	 * Optional flavor text which modifies and describes this term.
	 * @type {string}
	 */
	get flavor() {
		return this.options.flavor || "";
	}

	/* -------------------------------------------- */
	/*  RollTerm Methods                            */
	/* -------------------------------------------- */

	/**
	 * Evaluate the term, processing its inputs and finalizing its total.
	 * @param {object} [options={}]           Options which modify how the RollTerm is evaluated
	 * @param {boolean} [options.minimize=false]    Minimize the result, obtaining the smallest possible value.
	 * @param {boolean} [options.maximize=false]    Maximize the result, obtaining the largest possible value.
	 * @param {boolean} [options.async=false]       Evaluate the term asynchronously, receiving a Promise as the returned value.
	 *                                              This will become the default behavior in version 10.x
	 * @returns {RollTerm}                     The evaluated RollTerm
	 */
	evaluate({minimize=false, maximize=false, async=false}={}) {
		if ( this._evaluated ) {
			throw new Error(`The ${this.constructor.name} has already been evaluated and is now immutable`);
		}
		this._evaluated = true;
		return async ? this._evaluate({minimize, maximize}) : this._evaluateSync({minimize, maximize});
	}

	/**
	 * Evaluate the term.
	 * @param {object} [options={}]           Options which modify how the RollTerm is evaluated, see RollTerm#evaluate
	 * @returns {Promise<RollTerm>}
	 * @private
	 */
	async _evaluate({minimize=false, maximize=false}={}) {
		return this._evaluateSync({minimize, maximize});
	}

	/**
	 * This method is temporarily factored out in order to provide different behaviors synchronous evaluation.
	 * This will be removed in 0.10.x
	 * @private
	 */
	_evaluateSync({minimize=false, maximize=false}={}) {
		return this;
	}

	/* -------------------------------------------- */
	/*  Serialization and Loading                   */
	/* -------------------------------------------- */

	/**
	 * Construct a RollTerm from a provided data object
	 * @param {object} data         Provided data from an un-serialized term
	 * @return {RollTerm}           The constructed RollTerm
	 */
	static fromData(data) {
		let cls = CONFIG.Dice.termTypes[data.class];
		if ( !cls ) cls = Object.values(CONFIG.Dice.terms).find(c => c.name === data.class) || Die;
		return cls._fromData(data);
	}

	/* -------------------------------------------- */

	/**
	 * Define term-specific logic for how a de-serialized data object is restored as a functional RollTerm
	 * @param {object} data         The de-serialized term data
	 * @returns {RollTerm}          The re-constructed RollTerm object
	 * @protected
	 */
	static _fromData(data) {
		const term = new this(data);
		term._evaluated = data.evaluated ?? true;
		return term;
	}

	/* -------------------------------------------- */

	/**
	 * Reconstruct a RollTerm instance from a provided JSON string
	 * @param {string} json   A serialized JSON representation of a DiceTerm
	 * @return {RollTerm}     A reconstructed RollTerm from the provided JSON
	 */
	static fromJSON(json) {
		let data;
		try {
			data = JSON.parse(json);
		} catch(err) {
			throw new Error("You must pass a valid JSON string");
		}
		return this.fromData(data);
	}

	/* -------------------------------------------- */

	/**
	 * Serialize the RollTerm to a JSON string which allows it to be saved in the database or embedded in text.
	 * This method should return an object suitable for passing to the JSON.stringify function.
	 * @return {object}
	 */
	toJSON() {
		const data = {
			class: this.constructor.name,
			options: this.options,
			evaluated: this._evaluated
		}
		for ( let attr of this.constructor.SERIALIZE_ATTRIBUTES ) {
			data[attr] = this[attr];
		}
		return data;
	}
}
/**
 * A standalone, pure JavaScript implementation of the Mersenne Twister pseudo random number generator.
 *
 * @author Raphael Pigulla <pigulla@four66.com>
 * @version 0.2.3
 * @license
 * Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. The names of its contributors may not be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
class MersenneTwister {
	/**
	 * Instantiates a new Mersenne Twister.
	 * @param {number} [seed]   The initial seed value, if not provided the current timestamp will be used.
	 * @constructor
	 */
	constructor(seed) {

		// Initial values
		this.MAX_INT = 4294967296.0;
		this.N = 624;
		this.M = 397;
		this.UPPER_MASK = 0x80000000;
		this.LOWER_MASK = 0x7fffffff;
		this.MATRIX_A = 0x9908b0df;

		// Initialize sequences
		this.mt = new Array(this.N);
		this.mti = this.N + 1;
		this.SEED = this.seed(seed ?? new Date().getTime());
	};

	/**
	 * Initializes the state vector by using one unsigned 32-bit integer "seed", which may be zero.
	 *
	 * @since 0.1.0
	 * @param {number} seed The seed value.
	 */
	seed(seed) {
		this.SEED = seed;
		let s;
		this.mt[0] = seed >>> 0;

		for (this.mti = 1; this.mti < this.N; this.mti++) {
			s = this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >>> 30);
			this.mt[this.mti] =
				(((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253) + this.mti;
			this.mt[this.mti] >>>= 0;
		}
		return seed;
	};

	/**
	 * Initializes the state vector by using an array key[] of unsigned 32-bit integers of the specified length. If
	 * length is smaller than 624, then each array of 32-bit integers gives distinct initial state vector. This is
	 * useful if you want a larger seed space than 32-bit word.
	 *
	 * @since 0.1.0
	 * @param {array} vector The seed vector.
	 */
	seedArray(vector) {
		let i = 1, j = 0, k = this.N > vector.length ? this.N : vector.length, s;
		this.seed(19650218);
		for (; k > 0; k--) {
			s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);

			this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525))) +
				vector[j] + j;
			this.mt[i] >>>= 0;
			i++;
			j++;
			if (i >= this.N) {
				this.mt[0] = this.mt[this.N-1];
				i = 1;
			}
			if (j >= vector.length) {
				j = 0;
			}
		}

		for (k = this.N-1; k; k--) {
			s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);
			this.mt[i] =
				(this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941)) - i;
			this.mt[i] >>>= 0;
			i++;
			if (i >= this.N) {
				this.mt[0] = this.mt[this.N - 1];
				i = 1;
			}
		}
		this.mt[0] = 0x80000000;
	};

	/**
	 * Generates a random unsigned 32-bit integer.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	int() {
		let y, kk, mag01 = [0, this.MATRIX_A];

		if (this.mti >= this.N) {
			if (this.mti === this.N+1) {
				this.seed(5489);
			}

			for (kk = 0; kk < this.N - this.M; kk++) {
				y = (this.mt[kk] & this.UPPER_MASK) | (this.mt[kk + 1] & this.LOWER_MASK);
				this.mt[kk] = this.mt[kk + this.M] ^ (y >>> 1) ^ mag01[y & 1];
			}

			for (; kk < this.N - 1; kk++) {
				y = (this.mt[kk] & this.UPPER_MASK) | (this.mt[kk + 1] & this.LOWER_MASK);
				this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ (y >>> 1) ^ mag01[y & 1];
			}

			y = (this.mt[this.N - 1] & this.UPPER_MASK) | (this.mt[0] & this.LOWER_MASK);
			this.mt[this.N - 1] = this.mt[this.M - 1] ^ (y >>> 1) ^ mag01[y & 1];
			this.mti = 0;
		}

		y = this.mt[this.mti++];

		y ^= (y >>> 11);
		y ^= (y << 7) & 0x9d2c5680;
		y ^= (y << 15) & 0xefc60000;
		y ^= (y >>> 18);

		return y >>> 0;
	};

	/**
	 * Generates a random unsigned 31-bit integer.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	int31() {
		return this.int() >>> 1;
	};

	/**
	 * Generates a random real in the interval [0;1] with 32-bit resolution.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	real() {
		return this.int() * (1.0 / (this.MAX_INT - 1));
	};

	/**
	 * Generates a random real in the interval ]0;1[ with 32-bit resolution.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	realx() {
		return (this.int() + 0.5) * (1.0 / this.MAX_INT);
	};

	/**
	 * Generates a random real in the interval [0;1[ with 32-bit resolution.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	rnd() {
		return this.int() * (1.0 / this.MAX_INT);
	};

	/**
	 * Generates a random real in the interval [0;1[ with 32-bit resolution.
	 *
	 * Same as .rnd() method - for consistency with Math.random() interface.
	 *
	 * @since 0.2.0
	 * @returns {number}
	 */
	random() {
		return this.rnd();
	};

	/**
	 * Generates a random real in the interval [0;1[ with 53-bit resolution.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	rndHiRes() {
		const a = this.int() >>> 5;
		const b = this.int() >>> 6;
		return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);
	};

	/**
	 * A pseudo-normal distribution using the Box-Muller transform.
	 * @param {number} mu     The normal distribution mean
	 * @param {number} sigma  The normal distribution standard deviation
	 * @returns {number}
	 */
	normal(mu, sigma) {
		let u = 0;
		while(u === 0) u = this.random(); //Converting [0,1) to (0,1)
		let v = 0;
		while(v === 0) v = this.random(); //Converting [0,1) to (0,1)
		let n = Math.sqrt( -2.0 * Math.log(u) ) * Math.cos(2.0 * Math.PI * v);
		return (n * sigma) + mu
	}

	/**
	 * A factory method for generating random uniform rolls
	 * @return {number}
	 */
	static random() {
		return twist.random();
	}

	/**
	 * A factory method for generating random normal rolls
	 * @return {number}
	 */
	static normal(...args) {
		return twist.normal(...args);
	}
}

// Global singleton
const twist = new MersenneTwister(Date.now());

/**
 * @typedef {Object} DiceTermResult
 * @property {number} result        The numeric result
 * @property {boolean} [active]     Is this result active, contributing to the total?
 * @property {number} [count]       A value that the result counts as, otherwise the result is not used directly as
 * @property {boolean} [success]    Does this result denote a success?
 * @property {boolean} [failure]    Does this result denote a failure?
 * @property {boolean} [discarded]  Was this result discarded?
 * @property {boolean} [rerolled]   Was this result rerolled?
 * @property {boolean} [exploded]   Was this result exploded?
 */

/**
 * An abstract base class for any type of RollTerm which involves randomized input from dice, coins, or other devices.
 * @extends RollTerm
 *
 * @param {object} termData                 Data used to create the Dice Term, including the following:
 * @param {number} [termData.number=1]      The number of dice of this term to roll, before modifiers are applied
 * @param {number} termData.faces           The number of faces on each die of this type
 * @param {string[]} [termData.modifiers]   An array of modifiers applied to the results
 * @param {object[]} [termData.results]     An optional array of pre-cast results for the term
 * @param {object} [termData.options]       Additional options that modify the term
 */
class DiceTerm extends RollTerm {
	constructor({number=1, faces=6, modifiers=[], results=[], options={}}) {
		super({options});

		/**
		 * The number of dice of this term to roll, before modifiers are applied
		 * @type {number}
		 */
		this.number = number;

		/**
		 * The number of faces on the die
		 * @type {number}
		 */
		this.faces = faces;

		/**
		 * An Array of dice term modifiers which are applied
		 * @type {string[]}
		 */
		this.modifiers = modifiers;

		/**
		 * The array of dice term results which have been rolled
		 * @type {DiceTermResult[]}
		 */
		this.results = results;

		// If results were explicitly passed, the term has already been evaluated
		if ( results.length ) this._evaluated = true;
	}

	/* -------------------------------------------- */

	/**
	 * Define the denomination string used to register this DiceTerm type in CONFIG.Dice.terms
	 * @type {string}
	 */
	static DENOMINATION = "";

	/**
	 * Define the named modifiers that can be applied for this particular DiceTerm type.
	 * @type {{string: (string|Function)}}
	 */
	static MODIFIERS = {};

	/**
	 * A regular expression pattern which captures the full set of term modifiers
	 * Anything until a space, group symbol, or arithmetic operator
	 * @type {string}
	 */
	static MODIFIERS_REGEXP_STRING = "([^ (){}[\\]+\\-*/]+)";

	/**
	 * A regular expression used to separate individual modifiers
	 * @type {RegExp}
	 */
	static MODIFIER_REGEXP = /([A-z]+)([^A-z\s()+\-*\/]+)?/g


	/** @inheritdoc */
	static REGEXP = new RegExp(`^([0-9]+)?[dD]([A-z]|[0-9]+)${DiceTerm.MODIFIERS_REGEXP_STRING}?${DiceTerm.FLAVOR_REGEXP_STRING}?$`);

	/** @inheritdoc */
	static SERIALIZE_ATTRIBUTES = ["number", "faces", "modifiers", "results"];

	/* -------------------------------------------- */
	/*  Dice Term Attributes                        */
	/* -------------------------------------------- */

	/** @inheritdoc */
	get expression() {
		const x = this.constructor.DENOMINATION === "d" ? this.faces : this.constructor.DENOMINATION;
		return `${this.number}d${x}${this.modifiers.join("")}`;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get total() {
		if ( !this._evaluated ) return undefined;
		return this.results.reduce((t, r) => {
			if ( !r.active ) return t;
			if ( r.count !== undefined ) return t + r.count;
			else return t + r.result;
		}, 0);
	}

	/* -------------------------------------------- */

	/**
	 * Return an array of rolled values which are still active within this term
	 * @type {number[]}
	 */
	get values() {
		return this.results.reduce((arr, r) => {
			if ( !r.active ) return arr;
			arr.push(r.result);
			return arr;
		}, []);
	}

	/* -------------------------------------------- */
	/*  Dice Term Methods                           */
	/* -------------------------------------------- */

	/**
	 * Alter the DiceTerm by adding or multiplying the number of dice which are rolled
	 * @param {number} multiply   A factor to multiply. Dice are multiplied before any additions.
	 * @param {number} add        A number of dice to add. Dice are added after multiplication.
	 * @return {DiceTerm}         The altered term
	 */
	alter(multiply, add) {
		if ( this._evaluated ) throw new Error(`You may not alter a DiceTerm after it has already been evaluated`);
		multiply = Number.isFinite(multiply) && (multiply >= 0) ? multiply : 1;
		add = Number.isInteger(add) ? add : 0;
		if ( multiply >= 0 ) this.number = Math.round(this.number * multiply);
		if ( add ) this.number += add;
		return this;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_evaluateSync({minimize=false, maximize=false}={}) {
		if ( (this.number > 999) ) {
			throw new Error(`You may not evaluate a DiceTerm with more than 999 requested results`);
		}
		for ( let n=1; n <= this.number; n++ ) {
			this.roll({minimize, maximize});
		}
		this._evaluateModifiers();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Roll the DiceTerm by mapping a random uniform draw against the faces of the dice term.
	 * @param {object} [options={}]           Options which modify how a random result is produced
	 * @param {boolean} [options.minimize=false]    Minimize the result, obtaining the smallest possible value.
	 * @param {boolean} [options.maximize=false]    Maximize the result, obtaining the largest possible value.
	 * @return {DiceTermResult}               The produced result
	 */
	roll({minimize=false, maximize=false}={}) {
		const roll = {result: undefined, active: true};
		if ( minimize ) roll.result = Math.min(1, this.faces);
		else if ( maximize ) roll.result = this.faces;
		else roll.result = Math.ceil(CONFIG.Dice.randomUniform() * this.faces);
		this.results.push(roll);
		return roll;
	}

	/* -------------------------------------------- */

	/**
	 * Return a string used as the label for each rolled result
	 * @param {DiceTermResult} result     The rolled result
	 * @return {string}                   The result label
	 */
	getResultLabel(result) {
		return String(result.result);
	}

	/* -------------------------------------------- */

	/**
	 * Get the CSS classes that should be used to display each rolled result
	 * @param {DiceTermResult} result     The rolled result
	 * @return {string[]}                 The desired classes
	 */
	getResultCSS(result) {
		const hasSuccess = result.success !== undefined;
		const hasFailure = result.failure !== undefined;
		const isMax = result.result === this.faces;
		const isMin = result.result === 1;
		return [
			this.constructor.name.toLowerCase(),
			"d" + this.faces,
			result.success ? "success" : null,
			result.failure ? "failure" : null,
			result.rerolled ? "rerolled" : null,
			result.exploded ? "exploded" : null,
			result.discarded ? "discarded" : null,
			!(hasSuccess || hasFailure) && isMin ? "min" : null,
			!(hasSuccess || hasFailure) && isMax ? "max" : null
		]
	}

	/* -------------------------------------------- */

	/**
	 * Render the tooltip HTML for a Roll instance
	 * @return {object}      The data object used to render the default tooltip template for this DiceTerm
	 */
	getTooltipData() {
		return {
			formula: this.expression,
			total: this.total,
			faces: this.faces,
			flavor: this.flavor,
			rolls: this.results.map(r => {
				return {
					result: this.getResultLabel(r),
					classes: this.getResultCSS(r).filterJoin(" ")
				}
			})
		};
	}

	/* -------------------------------------------- */
	/*  Modifier Methods                            */
	/* -------------------------------------------- */

	/**
	 * Sequentially evaluate each dice roll modifier by passing the term to its evaluation function
	 * Augment or modify the results array.
	 * @private
	 */
	_evaluateModifiers() {
		const cls = this.constructor;
		const requested = foundry.utils.deepClone(this.modifiers);
		this.modifiers = [];

		// Iterate over requested modifiers
		for ( let m of requested ) {
			let command = m.match(/[A-z]+/)[0].toLowerCase();

			// Matched command
			if ( command in cls.MODIFIERS ) {
				this._evaluateModifier(command, m);
				continue;
			}

			// Unmatched compound command
			while ( !!command ) {
				let matched = false;
				for (let cmd of Object.keys(cls.MODIFIERS)) {
					if (command.startsWith(cmd)) {
						matched = true;
						this._evaluateModifier(cmd, cmd);
						command = command.replace(cmd, "");
					}
				}
				if (!matched) command = "";
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Evaluate a single modifier command, recording it in the array of evaluated modifiers
	 * @param {string} command        The parsed modifier command
	 * @param {string} modifier       The full modifier request
	 * @private
	 */
	_evaluateModifier(command, modifier) {
			let fn = this.constructor.MODIFIERS[command];
			if ( typeof fn === "string" ) fn = this[fn];
			if ( fn instanceof Function ) {
				const result = fn.call(this, modifier);
				const earlyReturn = (result === false) || (result === this); // handling this is backwards compatibility
				if ( !earlyReturn ) this.modifiers.push(modifier.toLowerCase());
			}
	}

	/* -------------------------------------------- */

	/**
	 * A helper comparison function.
	 * Returns a boolean depending on whether the result compares favorably against the target.
	 * @param {number} result         The result being compared
	 * @param {string} comparison     The comparison operator in [=,<,<=,>,>=]
	 * @param {number} target         The target value
	 * @return {boolean}              Is the comparison true?
	 */
	static compareResult(result, comparison, target) {
		switch ( comparison ) {
			case "=":
				return result === target;
			case "<":
				return result < target;
			case "<=":
				return result <= target;
			case ">":
				return result > target;
			case ">=":
				return result >= target;
		}
	}

	/* -------------------------------------------- */

	/**
	 * A helper method to modify the results array of a dice term by flagging certain results are kept or dropped.
	 * @param {object[]} results      The results array
	 * @param {number} number         The number to keep or drop
	 * @param {boolean} [keep]        Keep results?
	 * @param {boolean} [highest]     Keep the highest?
	 * @return {object[]}             The modified results array
	 */
	static _keepOrDrop(results, number, {keep=true, highest=true}={}) {

		// Sort remaining active results in ascending (keep) or descending (drop) order
		const ascending = keep === highest;
		const values = results.reduce((arr, r) => {
			if ( r.active ) arr.push(r.result);
			return arr;
		}, []).sort((a, b) => ascending ? a - b : b - a);

		// Determine the cut point, beyond which to discard
		number = Math.clamped(keep ? values.length - number : number, 0, values.length);
		const cut = values[number];

		// Track progress
		let discarded = 0;
		const ties = [];
		let comp = ascending ? "<" : ">";

		// First mark results on the wrong side of the cut as discarded
		results.forEach(r => {
			if ( !r.active ) return;  // Skip results which have already been discarded
			let discard = this.compareResult(r.result, comp, cut);
			if ( discard ) {
				r.discarded = true;
				r.active = false;
				discarded++;
			}
			else if ( r.result === cut ) ties.push(r);
		});

		// Next discard ties until we have reached the target
		ties.forEach(r => {
			if ( discarded < number ) {
				r.discarded = true;
				r.active = false;
				discarded++;
			}
		});
		return results;
	}

	/* -------------------------------------------- */

	/**
	 * A reusable helper function to handle the identification and deduction of failures
	 */
	static _applyCount(results, comparison, target, {flagSuccess=false, flagFailure=false}={}) {
		for ( let r of results ) {
			let success = this.compareResult(r.result, comparison, target);
			if (flagSuccess) {
				r.success = success;
				if (success) delete r.failure;
			}
			else if (flagFailure ) {
				r.failure = success;
				if (success) delete r.success;
			}
			r.count = success ? 1 : 0;
		}
	}

	/* -------------------------------------------- */

	/**
	 * A reusable helper function to handle the identification and deduction of failures
	 */
	static _applyDeduct(results, comparison, target, {deductFailure=false, invertFailure=false}={}) {
		for ( let r of results ) {

			// Flag failures if a comparison was provided
			if (comparison) {
				const fail = this.compareResult(r.result, comparison, target);
				if ( fail ) {
					r.failure = true;
					delete r.success;
				}
			}

			// Otherwise treat successes as failures
			else {
				if ( r.success === false ) {
					r.failure = true;
					delete r.success;
				}
			}

			// Deduct failures
			if ( deductFailure ) {
				if ( r.failure ) r.count = -1;
			}
			else if ( invertFailure ) {
				if ( r.failure ) r.count = -1 * r.result;
			}
		}
	}

	/* -------------------------------------------- */
	/*  Factory Methods                             */
	/* -------------------------------------------- */

	/**
	 * Determine whether a string expression matches this type of term
	 * @param {string} expression               The expression to parse
	 * @param {object} [options={}]             Additional options which customize the match
	 * @param {boolean} [options.imputeNumber=true]  Allow the number of dice to be optional, i.e. "d6"
	 * @return {RegExpMatchArray|null}
	 */
	static matchTerm(expression, {imputeNumber=true}={}) {
		const match = expression.match(this.REGEXP);
		if ( !match ) return null;
		if ( (match[1] === undefined) && !imputeNumber ) return null;
		return match;
	}

	/* -------------------------------------------- */

	/**
	 * Construct a term of this type given a matched regular expression array.
	 * @param {RegExpMatchArray} match          The matched regular expression array
	 * @return {DiceTerm}                      The constructed term
	 */
	static fromMatch(match) {
		let [number, denomination, modifiers, flavor] = match.slice(1);

		// Get the denomination of DiceTerm
		denomination = denomination.toLowerCase();
		const term = denomination in CONFIG.Dice.terms ? CONFIG.Dice.terms[denomination] : Die;
		if ( !term ) throw new Error(`Die denomination ${denomination} not registered in CONFIG.Dice.terms`);

		// Get the term arguments
		number = Number.isNumeric(number) ? parseInt(number) : 1;
		const faces = Number.isNumeric(denomination) ? parseInt(denomination) : null;

		// Match modifiers
		modifiers = Array.from((modifiers || "").matchAll(DiceTerm.MODIFIER_REGEXP)).map(m => m[0]);

		// Construct a term of the appropriate denomination
		return new term({number, faces, modifiers, options: {flavor}});
	}

	/* -------------------------------------------- */
	/*  Deprecations                                */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.1
	 * @ignore
	 */
	static fromExpression(expression, options={}) {
		console.warn("You are calling DiceTerm.fromExpression which has been deprecated in favor of the matchTerm and fromMatch methods");
		const match = this.matchTerm(expression);
		if ( !match ) return null;
		const term = this.fromMatch(match);
		term.options = options;
		return term;
	}

	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.1
	 * @ignore
	 */
	static fromResults(options, results) {
		console.warn("You are calling DiceTerm.fromResults which has been deprecated in favor passing results directly to the DiceTerm constructor");
		return new this({results, options});
	}

	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.1
	 * @ignore
	 */
	static getResultLabel(result) {
		console.warn("You are calling the DiceTerm.getResultLabel static method which has been deprecated in favor of a DiceTerm#getResultLabel instance method");
		return this.prototype.getResultLabel.call(this, result);
	}
}

/**
 * A type of RollTerm used to apply a function from the Math library.
 * @extends {RollTerm}
 */
class MathTerm extends RollTerm {
	constructor({fn, terms, options}={}) {
		super({options});

		/**
		 * The named function in the Math environment which should be applied to the term
		 * @type {string}
		 */
		this.fn = fn;

		/**
		 * An array of string argument terms for the function
		 * @type {string[]}
		 */
		this.terms = terms;
	}

	/**
	 * The cached Roll instances for each function argument
	 * @type {Roll[]}
	 */
	rolls = [];

	/**
	 * The cached result of evaluating the method arguments
	 * @type {number}
	 */
	result = undefined;

	/** @inheritdoc */
	isIntermediate = true;

	/** @inheritdoc */
	static SERIALIZE_ATTRIBUTES = ["fn", "term"];

	/* -------------------------------------------- */
	/*  Math Term Attributes                        */
	/* -------------------------------------------- */

	/**
	 * An array of evaluated DiceTerm instances that should be bubbled up to the parent Roll
	 * @type {DiceTerm[]}
	 */
	get dice() {
		return this._evaluated ? this.rolls.reduce((arr, r) => arr.concat(r.dice), []) : undefined;
	}

	/** @inheritdoc */
	get total() {
		return this.result;
	}

	/** @inheritdoc */
	get expression() {
		return `${this.fn}(${this.terms.join(",")})`;
	}

	/* -------------------------------------------- */
	/*  Math Term Methods                           */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_evaluateSync({minimize=false, maximize=false}={}) {
		this.rolls = this.terms.map(a => {
			const roll = new Roll(a);
			roll.evaluate({minimize, maximize, async: false});
			if ( this.flavor ) roll.terms.forEach(t => t.options.flavor = t.options.flavor ?? this.flavor);
			return roll;
		});
		const args = this.rolls.map(r => r.total).join(", ");
		this.result = Roll.safeEval(`${this.fn}(${args})`);
		return this;
	}

	/** @inheritdoc */
	async _evaluate({minimize=false, maximize=false}={}) {
		for ( let term of this.terms ) {
			const roll = new Roll(term);
			await roll.evaluate({minimize, maximize, async: true});
			if ( this.flavor ) roll.terms.forEach(t => t.options.flavor = t.options.flavor ?? this.flavor);
			this.rolls.push(roll);
		}
		const args = this.rolls.map(r => r.total).join(", ");
		this.result = Roll.safeEval(`${this.fn}(${args})`);
		return this;
	}
}
/**
 * A type of RollTerm used to capture static numbers.
 * @extends {RollTerm}
 */
class NumericTerm extends RollTerm {
	constructor({number, options}={}) {
		super({options});
		this.number = Number(number);
	}

	/** @inheritdoc */
	static REGEXP = new RegExp(`^([0-9]+(?:\\.[0-9]+)?)${RollTerm.FLAVOR_REGEXP_STRING}?$`);

	/** @inheritdoc */
	static SERIALIZE_ATTRIBUTES = ["number"];

	/** @inheritdoc */
	get expression() {
		return String(this.number);
	}

	/** @inheritdoc */
	get total() {
		return this.number;
	}

	/* -------------------------------------------- */
	/*  Factory Methods                             */
	/* -------------------------------------------- */

	/**
	 * Determine whether a string expression matches a NumericTerm
	 * @param {string} expression               The expression to parse
	 * @return {RegExpMatchArray|null}
	 */
	static matchTerm(expression) {
		return expression.match(this.REGEXP) || null;
	}

	/* -------------------------------------------- */

	/**
	 * Construct a term of this type given a matched regular expression array.
	 * @param {RegExpMatchArray} match          The matched regular expression array
	 * @return {NumericTerm}                    The constructed term
	 */
	static fromMatch(match) {
		let [number, flavor] = match.slice(1);
		return new this({number, options: {flavor}});
	}
}

/**
 * A type of RollTerm used to denote and perform an arithmetic operation.
 * @extends {RollTerm}
 */
class OperatorTerm extends RollTerm {
	constructor({operator, options}={}) {
		super({options});
		this.operator = operator;
	}

	/**
	 * An array of operators which represent arithmetic operations
	 * @type {string[]}
	 */
	static OPERATORS = ["+", "-", "*", "/"];

	/** @inheritdoc */
	static REGEXP = new RegExp(OperatorTerm.OPERATORS.map(o => "\\"+o).join("|"), "g");

	/** @inheritdoc */
	static SERIALIZE_ATTRIBUTES = ["operator"];

	/** @inheritdoc */
	get flavor() {
		return ""; // Operator terms cannot have flavor text
	}

	/** @inheritdoc */
	get expression() {
		return ` ${this.operator} `;
	}

	/** @inheritdoc */
	get total() {
		return ` ${this.operator} `;
	}
}
/**
 * A type of RollTerm used to enclose a parenthetical expression to be recursively evaluated.
 * @extends {RollTerm}
 */
class ParentheticalTerm extends RollTerm {
	constructor({term, roll, options}) {
		super({options});

		/**
		 * The original provided string term used to construct the parenthetical
		 * @type {string}
		 */
		this.term = term;

		/**
		 * Alternatively, an already-evaluated Roll instance may be passed directly
		 * @type {Roll}
		 */
		this.roll = roll;

		// If a roll was explicitly passed in, the parenthetical has already been evaluated
		if ( this.roll ) {
			this.term = roll.formula;
			this._evaluated = this.roll._evaluated;
		}
	}

	/** @inheritdoc */
	isIntermediate = true;

	/**
	 * The regular expression pattern used to identify the opening of a parenthetical expression.
	 * This could also identify the opening of a math function.
	 * @type {RegExp}
	 */
	static OPEN_REGEXP = /([A-z][A-z0-9]+)?\(/g;

	/**
	 * A regular expression pattern used to identify the closing of a parenthetical expression.
	 * @type {RegExp}
	 */
	static CLOSE_REGEXP = new RegExp("\\)(?:%F[0-9]+%)?", "g");

	/** @inheritdoc */
	static SERIALIZE_ATTRIBUTES = ["term"];

	/* -------------------------------------------- */
	/*  Parenthetical Term Attributes               */
	/* -------------------------------------------- */

	/**
	 * An array of evaluated DiceTerm instances that should be bubbled up to the parent Roll
	 * @type {DiceTerm[]}
	 */
	get dice() {
		return this.roll?.dice;
	}

	/** @inheritdoc */
	get total() {
		return this.roll.total;
	}

	/** @inheritdoc */
	get expression() {
		return `(${this.term})`;
	}

	/* -------------------------------------------- */
	/*  Parenthetical Term Methods                  */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_evaluateSync({minimize=false, maximize=false}={}) {

		// Evaluate the inner Roll
		const roll = this.roll || new Roll(this.term);
		this.roll = roll.evaluate({minimize, maximize, async: false});

		// Propagate flavor text to inner terms
		if ( this.flavor ) this.roll.terms.forEach(t => t.options.flavor = t.options.flavor ?? this.flavor);
		return this;
	}

	/** @inheritdoc */
	async _evaluate({minimize=false, maximize=false}={}) {

		// Evaluate the inner Roll
		const roll = this.roll || new Roll(this.term);
		this.roll = await roll.evaluate({minimize, maximize, async: true});

		// Propagate flavor text to inner terms
		if ( this.flavor ) this.roll.terms.forEach(t => t.options.flavor = t.options.flavor ?? this.flavor);
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Construct a ParentheticalTerm from an Array of component terms which should be wrapped inside the parentheses.
	 * @param {RollTerm[]} terms      The array of terms to use as internal parts of the parenthetical
	 * @param {object} [options={}]   Additional options passed to the ParentheticalTerm constructor
	 * @returns {ParentheticalTerm}   The constructed ParentheticalTerm instance
	 *
	 * @example <caption>Create a Parenthetical Term from an array of component RollTerm instances</caption>
	 * const d6 = new Die({number: 4, faces: 6});
	 * const plus = new OperatorTerm({operator: "+"});
	 * const bonus = new NumericTerm({number: 4});
	 * t = ParentheticalTerm.fromTerms([d6, plus, bonus]);
	 * t.formula; // (4d6 + 4)
	 */
	static fromTerms(terms, options) {
		const roll = Roll.fromTerms(terms);
		return new this({roll, options});
	}
}

/**
 * A dice pool represents a set of Roll expressions which are collectively modified to compute an effective total
 * across all Rolls in the pool. The final total for the pool is defined as the sum over kept rolls, relative to any
 * success count or margin.
 *
 * @example
 * // Keep the highest of the 3 roll expressions
 * let pool = new PoolTerm({
 *   rolls: ["4d6", "3d8 - 1", "2d10 + 3"],
 *   modifiers: ["kh"]
 * });
 * pool.evaluate();
 */
class PoolTerm extends RollTerm {
	constructor({terms=[], modifiers=[], rolls=[], results=[], options={}}={}) {
		super({options});

		/**
		 * The original provided terms to the Dice Pool
		 * @type {string[]}
		 */
		this.terms = terms;

		/**
		 * The string modifiers applied to resolve the pool
		 * @type {string[]}
		 */
		this.modifiers = modifiers;

		/**
		 * Each component term of a dice pool is evaluated as a Roll instance
		 * @type {Roll[]}
		 */
		this.rolls = (rolls.length === terms.length) ? rolls : this.terms.map(t => new Roll(t))

		/**
		 * The array of dice pool results which have been rolled
		 * @type {DiceTermResult[]}
		 */
		this.results = results;

		// If rolls and results were explicitly passed, the term has already been evaluated
		if ( rolls.length && results.length ) this._evaluated = true;
	}

	/* -------------------------------------------- */

	/**
	 * Define the modifiers that can be used for this particular DiceTerm type.
	 * @type {Object<string, Function>}
	 */
	static MODIFIERS = {
		"k": "keep",
		"kh": "keep",
		"kl": "keep",
		"d": "drop",
		"dh": "drop",
		"dl": "drop",
		"cs": "countSuccess",
		"cf": "countFailures"
	};

	/**
	 * The regular expression pattern used to identify the opening of a dice pool expression.
	 * @type {RegExp}
	 */
	static OPEN_REGEXP = /{/g;

	/**
	 * A regular expression pattern used to identify the closing of a dice pool expression.
	 * @type {RegExp}
	 */
	static CLOSE_REGEXP = new RegExp(`}${DiceTerm.MODIFIERS_REGEXP_STRING}?(?:%F[0-9]+%)?`, "g");

	/** @inheritdoc */
	static SERIALIZE_ATTRIBUTES = ["terms", "modifiers", "rolls", "results"];

	/* -------------------------------------------- */
	/*  Dice Pool Attributes                        */
	/* -------------------------------------------- */

	/**
	 * Return an Array of each individual DiceTerm instances contained within the PoolTerm.
	 * @return {DiceTerm[]}
	 */
	get dice() {
		return this.rolls.reduce((dice, r) => dice.concat(r.dice), []);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get expression() {
		return `{${this.terms.join(",")}}${this.modifiers.join("")}`;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get total() {
		if ( !this._evaluated ) return undefined;
		return this.results.reduce((t, r) => {
			if ( !r.active ) return t;
			if ( r.count !== undefined ) return t + r.count;
			else return t + r.result;
		}, 0);
	}

	/* -------------------------------------------- */

	/**
	 * Return an array of rolled values which are still active within the PoolTerm
	 * @type {number[]}
	 */
	get values() {
		return this.results.reduce((arr, r) => {
			if ( !r.active ) return arr;
			arr.push(r.result);
			return arr;
		}, []);
	}

	/* -------------------------------------------- */

	/**
	 * Alter the DiceTerm by adding or multiplying the number of dice which are rolled
	 * @param {any[]} args        Arguments passed to each contained Roll#alter method.
	 * @return {PoolTerm}         The altered pool
	 */
	alter(...args) {
		this.rolls.forEach(r => r.alter(...args));
		return this;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_evaluateSync({minimize=false, maximize=false}={}) {
		for ( let roll of this.rolls ) {
			roll.evaluate({minimize, maximize, async: false});
			if ( this.flavor ) roll.terms.forEach(t => t.options.flavor = t.options.flavor ?? this.flavor);
			this.results.push({
				result: roll.total,
				active: true
			});
		}
		this._evaluateModifiers();
		return this;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _evaluate({minimize=false, maximize=false}={}) {
		for ( let roll of this.rolls ) {
			await roll.evaluate({minimize, maximize, async: true});
			if ( this.flavor ) roll.terms.forEach(t => t.options.flavor = t.options.flavor ?? this.flavor);
			this.results.push({
				result: roll.total,
				active: true
			});
		}
		this._evaluateModifiers();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Use the same logic as for the DiceTerm to avoid duplication
	 * @see DiceTerm#_evaluateModifiers
	 */
	_evaluateModifiers() {
		return DiceTerm.prototype._evaluateModifiers.call(this);
	}

	/* -------------------------------------------- */

	/**
	 * Use the same logic as for the DiceTerm to avoid duplication
	 * @see DiceTerm#_evaluateModifier
	 */
	_evaluateModifier(command, modifier) {
		return DiceTerm.prototype._evaluateModifier.call(this, command, modifier);
	}

	/* -------------------------------------------- */
	/*  Saving and Loading                          */
	/* -------------------------------------------- */

	/** @inheritdoc */
	static _fromData(data) {
		data.rolls = (data.rolls || []).map(r => Roll.fromData(r));
		return super._fromData(data);
	}

	/* -------------------------------------------- */

	/**
	 * Given a string formula, create and return an evaluated PoolTerm object
	 * @param {string} formula    The string formula to parse
	 * @param {object} [options]  Additional options applied to the PoolTerm
	 * @return {PoolTerm|null}    The evaluated PoolTerm object or null if the formula is invalid
	 */
	static fromExpression(formula, options={}) {
		const rgx = formula.trim().match(this.REGEXP);
		if ( !rgx ) return null;
		let [terms, modifiers] = rgx.slice(1);
		terms = terms.split(",");
		modifiers = Array.from((modifiers || "").matchAll(DiceTerm.MODIFIER_REGEXP)).map(m => m[0]);
		return new this({terms, modifiers, options});
	}

	/* -------------------------------------------- */

	/**
	 * Create a PoolTerm by providing an array of existing Roll objects
	 * @param {Roll[]} rolls      An array of Roll objects from which to create the pool
	 * @returns {RollTerm}        The constructed PoolTerm comprised of the provided rolls
	 */
	static fromRolls(rolls=[]) {
		const allEvaluated = rolls.every(t => t._evaluated);
		const noneEvaluated = !rolls.some(t => t._evaluated);
		if ( !(allEvaluated || noneEvaluated) ) {
			throw new Error("You can only call PoolTerm.fromRolls with an array of Roll instances which are either all evaluated, or none evaluated");
		}
		const pool = new this({
			terms: rolls.map(r => r.formula),
			modifiers: [],
			rolls: rolls,
			results: allEvaluated ? rolls.map(r => ({result: r.total, active: true})) : []
		});
		pool._evaluated = allEvaluated;
		return pool;
	}

	/* -------------------------------------------- */
	/*  Modifiers                                   */
	/* -------------------------------------------- */

	/**
	 * Keep a certain number of highest or lowest dice rolls from the result set.
	 *
	 * {1d6,1d8,1d10,1d12}kh2       Keep the 2 best rolls from the pool
	 * {1d12,6}kl                   Keep the lowest result in the pool
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	keep(modifier) {
		return Die.prototype.keep.call(this, modifier);
	}

	/* -------------------------------------------- */

	/**
	 * Keep a certain number of highest or lowest dice rolls from the result set.
	 *
	 * {1d6,1d8,1d10,1d12}dl3       Drop the 3 worst results in the pool
	 * {1d12,6}dh                   Drop the highest result in the pool
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	drop(modifier) {
		return Die.prototype.drop.call(this, modifier);
	}

	/* -------------------------------------------- */

	/**
	 * Count the number of successful results which occurred in the pool.
	 * Successes are counted relative to some target, or relative to the maximum possible value if no target is given.
	 * Applying a count-success modifier to the results re-casts all results to 1 (success) or 0 (failure)
	 *
	 * 20d20cs      Count the number of dice which rolled a 20
	 * 20d20cs>10   Count the number of dice which rolled higher than 10
	 * 20d20cs<10   Count the number of dice which rolled less than 10
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	countSuccess(modifier) {
		return Die.prototype.countSuccess.call(this, modifier);
	}

	/* -------------------------------------------- */

	/**
	 * Count the number of failed results which occurred in a given result set.
	 * Failures are counted relative to some target, or relative to the lowest possible value if no target is given.
	 * Applying a count-failures modifier to the results re-casts all results to 1 (failure) or 0 (non-failure)
	 *
	 * 6d6cf      Count the number of dice which rolled a 1 as failures
	 * 6d6cf<=3   Count the number of dice which rolled less than 3 as failures
	 * 6d6cf>4    Count the number of dice which rolled greater than 4 as failures
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	countFailures(modifier) {
		return Die.prototype.countFailures.call(this, modifier);
	}
}

/**
 * @deprecated since 0.8.1
 * @ignore
 */
const DicePool = PoolTerm;
/**
 * A type of RollTerm used to capture residual strings which have not yet been matched
 * @extends {RollTerm}
 */
class StringTerm extends RollTerm {
	constructor({term, options}={}) {
		super({options});
		this.term = term;
	}

	/** @inheritdoc */
	static SERIALIZE_ATTRIBUTES = ["term"];

	/** @inheritdoc */
	get expression() {
		return this.term;
	}

	/** @inheritdoc */
	get total() {
		return this.term;
	}

	/** @inheritdoc */
	evaluate(options={}) {
		throw new Error(`Unresolved StringTerm ${this.term} requested for evaluation`);
	}
}

/**
 * Define a two-sided coin term that can be used as part of a Roll formula
 * @implements {DiceTerm}
 */
class Coin extends DiceTerm {
	constructor(termData) {
		super(termData);
		this.faces = 2;
	}

	/** @inheritdoc */
	static DENOMINATION = "c";

	/** @inheritdoc */
	static MODIFIERS = {
		"c": "call"
	};

	/* -------------------------------------------- */

	/** @inheritdoc */
	roll({minimize=false, maximize=false}={}) {
		const roll = {result: undefined, active: true};
		if ( minimize ) roll.result = 0;
		else if ( maximize ) roll.result = 1;
		else roll.result = Math.round(CONFIG.Dice.randomUniform());
		this.results.push(roll);
		return roll;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getResultLabel(result) {
		return {
			"0": "T",
			"1": "H"
		}[result.result];
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getResultCSS(result) {
		return [
			this.constructor.name.toLowerCase(),
			result.result === 1 ? "heads" : "tails",
			result.success ? "success" : null,
			result.failure ? "failure" : null
		]
	}

	/* -------------------------------------------- */
	/*  Term Modifiers                              */
	/* -------------------------------------------- */

	/**
	 * Call the result of the coin flip, marking any coins that matched the called target as a success
	 * 3dcc1      Flip 3 coins and treat "heads" as successes
	 * 2dcc0      Flip 2 coins and treat "tails" as successes
	 * @param {string} modifier     The matched modifier query
	 */
	call(modifier) {

		// Match the modifier
		const rgx = /c([01])/i;
		const match = modifier.match(rgx);
		if ( !match ) return false;
		let [target] = match.slice(1);
		target = parseInt(target);

		// Treat each result which matched the call as a success
		for ( let r of this.results ) {
			const match = r.result === target;
			r.count = match ? 1 : 0;
			r.success = match;
		}
	}
}

/**
 * Define a fair n-sided die term that can be used as part of a Roll formula
 * @implements {DiceTerm}
 *
 * @example
 * // Roll 4 six-sided dice
 * let die = new Die({faces: 6, number: 4}).evaluate();
 */
class Die extends DiceTerm {
	constructor(termData={}) {
		super(termData);
		if ( typeof this.faces !== "number" ) {
			throw new Error("A Die term must have a numeric number of faces.");
		}
	}

	/** @inheritdoc */
	static DENOMINATION = "d";

	/** @inheritdoc */
	static MODIFIERS = {
		"r": "reroll",
		"rr": "rerollRecursive",
		"x": "explode",
		"xo": "explodeOnce",
		"k": "keep",
		"kh": "keep",
		"kl": "keep",
		"d": "drop",
		"dh": "drop",
		"dl": "drop",
		"min": "minimum",
		"max": "maximum",
		"even": "countEven",
		"odd": "countOdd",
		"cs": "countSuccess",
		"cf": "countFailures",
		"df": "deductFailures",
		"sf": "subtractFailures",
		"ms": "marginSuccess",
	};

	/* -------------------------------------------- */

	/** @inheritdoc */
	get total() {
		const total = super.total;
		if ( this.options.marginSuccess ) return total - parseInt(this.options.marginSuccess);
		else if ( this.options.marginFailure ) return parseInt(this.options.marginFailure) - total;
		else return total;
	}

	/* -------------------------------------------- */
	/*  Term Modifiers                              */
	/* -------------------------------------------- */

	/**
	 * Re-roll the Die, rolling additional results for any values which fall within a target set.
	 * If no target number is specified, re-roll the lowest possible result.
	 *
	 * 20d20r         reroll all 1s
	 * 20d20r1        reroll all 1s
	 * 20d20r=1       reroll all 1s
	 * 20d20r1=1      reroll a single 1
	 *
	 * @param {string} modifier     The matched modifier query
	 * @param {boolean} recursive   Reroll recursively, continuing to reroll until the condition is no longer met
	 * @returns {boolean|void}      False if the modifier was unmatched
	 */
	reroll(modifier, {recursive=false}={}) {

		// Match the re-roll modifier
		const rgx = /rr?([0-9]+)?([<>=]+)?([0-9]+)?/i;
		const match = modifier.match(rgx);
		if ( !match ) return false;
		let [max, comparison, target] = match.slice(1);

		// If no comparison or target are provided, treat the max as the target
		if ( max && !(target || comparison) ) {
			target = max;
			max = null;
		}

		// Determine target values
		max = Number.isNumeric(max) ? parseInt(max) : null;
		target = Number.isNumeric(target) ? parseInt(target) : 1;
		comparison = comparison || "=";

		// Recursively reroll until there are no remaining results to reroll
		let checked = 0;
		let initial = this.results.length;
		while ( checked < this.results.length ) {
			let r = this.results[checked];
			checked++;
			if (!r.active) continue;

			// Maybe we have run out of rerolls
			if ( (max !== null) && (max <= 0) ) break;

			// Determine whether to re-roll the result
			if ( DiceTerm.compareResult(r.result, comparison, target) ) {
				r.rerolled = true;
				r.active = false;
				this.roll();
				if ( max !== null ) max -= 1;
			}

			// Limit recursion
			if ( !recursive && (checked >= initial) ) checked = this.results.length;
			if ( checked > 1000 ) throw new Error("Maximum recursion depth for exploding dice roll exceeded");
		}
	}

	/**
	 * @see {@link Die#reroll}
	 */
	rerollRecursive(modifier) {
		return this.reroll(modifier, {recursive: true});
	}

	/* -------------------------------------------- */

	/**
	 * Explode the Die, rolling additional results for any values which match the target set.
	 * If no target number is specified, explode the highest possible result.
	 * Explosion can be a "small explode" using a lower-case x or a "big explode" using an upper-case "X"
	 *
	 * @param {string} modifier     The matched modifier query
	 * @param {boolean} recursive   Explode recursively, such that new rolls can also explode?
	 */
	explode(modifier, {recursive=true}={}) {

		// Match the explode or "explode once" modifier
		const rgx = /xo?([0-9]+)?([<>=]+)?([0-9]+)?/i;
		const match = modifier.match(rgx);
		if ( !match ) return false;
		let [max, comparison, target] = match.slice(1);

		// If no comparison or target are provided, treat the max as the target
		if ( max && !(target || comparison) ) {
			target = max;
			max = null;
		}

		// Determine target values
		target = Number.isNumeric(target) ? parseInt(target) : this.faces;
		comparison = comparison || "=";
		max = Number.isNumeric(max) ? parseInt(max) : null;

		// Recursively explode until there are no remaining results to explode
		let checked = 0;
		let initial = this.results.length;
		while ( checked < this.results.length ) {
			let r = this.results[checked];
			checked++;
			if (!r.active) continue;

			// Maybe we have run out of explosions
			if ( (max !== null) && (max <= 0) ) break;

			// Determine whether to explode the result and roll again!
			if ( DiceTerm.compareResult(r.result, comparison, target) ) {
				r.exploded = true;
				this.roll();
				if ( max !== null ) max -= 1;
			}

			// Limit recursion
			if ( !recursive && (checked >= initial) ) checked = this.results.length;
			if ( checked > 1000 ) throw new Error("Maximum recursion depth for exploding dice roll exceeded");
		}
	}

	/**
	 * @see {@link Die#explode}
	 */
	explodeOnce(modifier) {
		return this.explode(modifier, {recursive: false});
	}

	/* -------------------------------------------- */

	/**
	 * Keep a certain number of highest or lowest dice rolls from the result set.
	 *
	 * 20d20k       Keep the 1 highest die
	 * 20d20kh      Keep the 1 highest die
	 * 20d20kh10    Keep the 10 highest die
	 * 20d20kl      Keep the 1 lowest die
	 * 20d20kl10    Keep the 10 lowest die
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	keep(modifier) {
		const rgx = /k([hl])?([0-9]+)?/i;
		const match = modifier.match(rgx);
		if ( !match ) return false;
		let [direction, number] = match.slice(1);
		direction = direction ? direction.toLowerCase() : "h";
		number = parseInt(number) || 1;
		DiceTerm._keepOrDrop(this.results, number, {keep: true, highest: direction === "h"});
	}

	/* -------------------------------------------- */

	/**
	 * Drop a certain number of highest or lowest dice rolls from the result set.
	 *
	 * 20d20d       Drop the 1 lowest die
	 * 20d20dh      Drop the 1 highest die
	 * 20d20dl      Drop the 1 lowest die
	 * 20d20dh10    Drop the 10 highest die
	 * 20d20dl10    Drop the 10 lowest die
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	drop(modifier) {
		const rgx = /d([hl])?([0-9]+)?/i;
		const match = modifier.match(rgx);
		if ( !match ) return false;
		let [direction, number] = match.slice(1);
		direction = direction ? direction.toLowerCase() : "l";
		number = parseInt(number) || 1;
		DiceTerm._keepOrDrop(this.results, number, {keep: false, highest: direction !== "l"});
	}

	/* -------------------------------------------- */

	/**
	 * Count the number of successful results which occurred in a given result set.
	 * Successes are counted relative to some target, or relative to the maximum possible value if no target is given.
	 * Applying a count-success modifier to the results re-casts all results to 1 (success) or 0 (failure)
	 *
	 * 20d20cs      Count the number of dice which rolled a 20
	 * 20d20cs>10   Count the number of dice which rolled higher than 10
	 * 20d20cs<10   Count the number of dice which rolled less than 10
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	countSuccess(modifier) {
		const rgx = /(?:cs)([<>=]+)?([0-9]+)?/i;
		const match = modifier.match(rgx);
		if ( !match ) return false;
		let [comparison, target] = match.slice(1);
		comparison = comparison || "=";
		target = parseInt(target) ?? this.faces;
		DiceTerm._applyCount(this.results, comparison, target, {flagSuccess: true});
	}

	/* -------------------------------------------- */

	/**
	 * Count the number of failed results which occurred in a given result set.
	 * Failures are counted relative to some target, or relative to the lowest possible value if no target is given.
	 * Applying a count-failures modifier to the results re-casts all results to 1 (failure) or 0 (non-failure)
	 *
	 * 6d6cf      Count the number of dice which rolled a 1 as failures
	 * 6d6cf<=3   Count the number of dice which rolled less than 3 as failures
	 * 6d6cf>4    Count the number of dice which rolled greater than 4 as failures
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	countFailures(modifier) {
		const rgx = /(?:cf)([<>=]+)?([0-9]+)?/i;
		const match = modifier.match(rgx);
		if ( !match ) return false;
		let [comparison, target] = match.slice(1);
		comparison = comparison || "=";
		target = parseInt(target) ?? 1;
		DiceTerm._applyCount(this.results, comparison, target, {flagFailure: true});
	}

	/* -------------------------------------------- */

	/**
	 * Count the number of even results which occurred in a given result set.
	 * Even numbers are marked as a success and counted as 1
	 * Odd numbers are marked as a non-success and counted as 0.
	 *
	 * 6d6even    Count the number of even numbers rolled
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	countEven(modifier) {
		for ( let r of this.results ) {
			r.success = ( (r.result % 2) === 0 );
			r.count = r.success ? 1 : 0;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Count the number of odd results which occurred in a given result set.
	 * Odd numbers are marked as a success and counted as 1
	 * Even numbers are marked as a non-success and counted as 0.
	 *
	 * 6d6odd    Count the number of odd numbers rolled
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	countOdd(modifier) {
		for ( let r of this.results ) {
			r.success = ( (r.result % 2) !== 0 );
			r.count = r.success ? 1 : 0;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Deduct the number of failures from the dice result, counting each failure as -1
	 * Failures are identified relative to some target, or relative to the lowest possible value if no target is given.
	 * Applying a deduct-failures modifier to the results counts all failed results as -1.
	 *
	 * 6d6df      Subtract the number of dice which rolled a 1 from the non-failed total.
	 * 6d6cs>3df  Subtract the number of dice which rolled a 3 or less from the non-failed count.
	 * 6d6cf<3df  Subtract the number of dice which rolled less than 3 from the non-failed count.
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	deductFailures(modifier) {
		const rgx = /(?:df)([<>=]+)?([0-9]+)?/i;
		const match = modifier.match(rgx);
		if ( !match ) return false;
		let [comparison, target] = match.slice(1);
		if ( comparison || target ) {
			comparison = comparison || "=";
			target = parseInt(target) ?? 1;
		}
		DiceTerm._applyDeduct(this.results, comparison, target, {deductFailure: true});
	}

	/* -------------------------------------------- */

	/**
	 * Subtract the value of failed dice from the non-failed total, where each failure counts as its negative value.
	 * Failures are identified relative to some target, or relative to the lowest possible value if no target is given.
	 * Applying a deduct-failures modifier to the results counts all failed results as -1.
	 *
	 * 6d6df<3    Subtract the value of results which rolled less than 3 from the non-failed total.
	 *
	 * @param {string} modifier     The matched modifier query
	 */
	subtractFailures(modifier) {
		const rgx = /(?:sf)([<>=]+)?([0-9]+)?/i;
		const match = modifier.match(rgx);
		if ( !match ) return false;
		let [comparison, target] = match.slice(1);
		if ( comparison || target ) {
			comparison = comparison || "=";
			target = parseInt(target) ?? 1;
		}
		DiceTerm._applyDeduct(this.results, comparison, target, {invertFailure: true});
	}

	/* -------------------------------------------- */

	/**
	 * Subtract the total value of the DiceTerm from a target value, treating the difference as the final total.
	 * Example: 6d6ms>12    Roll 6d6 and subtract 12 from the resulting total.
	 * @param {string} modifier     The matched modifier query
	 */
	marginSuccess(modifier) {
		const rgx = /(?:ms)([<>=]+)?([0-9]+)?/i;
		const match = modifier.match(rgx);
		if ( !match ) return false;
		let [comparison, target] = match.slice(1);
		target = parseInt(target);
		if ( [">", ">=", "=", undefined].includes(comparison) ) this.options["marginSuccess"] = target;
		else if ( ["<", "<="].includes(comparison) ) this.options["marginFailure"] = target;
	}

	/* -------------------------------------------- */

	/**
	 * Constrain each rolled result to be at least some minimum value.
	 * Example: 6d6min2    Roll 6d6, each result must be at least 2
	 * @param {string} modifier     The matched modifier query
	 */
	minimum(modifier) {
		const rgx = /(?:min)([0-9]+)/i;
		const match = modifier.match(rgx);
		if ( !match ) return false;
		let [target] = match.slice(1);
		target = parseInt(target);
		for ( let r of this.results ) {
			if ( r.result < target ) {
				r.count = target;
				r.rerolled = true;
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Constrain each rolled result to be at most some maximum value.
	 * Example: 6d6max5    Roll 6d6, each result must be at most 5
	 * @param {string} modifier     The matched modifier query
	 */
	maximum(modifier) {
		const rgx = /(?:max)([0-9]+)/i;
		const match = modifier.match(rgx);
		if ( !match ) return false;
		let [target] = match.slice(1);
		target = parseInt(target);
		for ( let r of this.results ) {
			if ( r.result > target ) {
				r.count = target;
				r.rerolled = true;
			}
		}
	}
}

/**
 * Define a three-sided Fate/Fudge dice term that can be used as part of a Roll formula
 * Mathematically behaves like 1d3-2
 * @extends {DiceTerm}
 */
class FateDie extends DiceTerm {
	constructor(termData) {
		super(termData);
		this.faces = 3;
	}

	/** @inheritdoc */
	static DENOMINATION = "f";

	/* -------------------------------------------- */

	/** @inheritdoc */
	roll({minimize=false, maximize=false}={}) {
		const roll = {result: undefined, active: true};
		if ( minimize ) roll.result = -1;
		else if ( maximize ) roll.result = 1;
		else roll.result = Math.ceil((CONFIG.Dice.randomUniform() * this.faces) - 2);
		if ( roll.result === -1 ) roll.failure = true;
		if ( roll.result === 1 ) roll.success = true;
		this.results.push(roll);
		return roll;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getResultLabel(result) {
		return {
			"-1": "-",
			"0": "&nbsp;",
			"1": "+"
		}[result.result];
	}
}

/**
 * A specialized sub-class of the ClientDocumentMixin which is used for document types that are intended to be represented upon the game Canvas.
 * @mixin
 * @extends ClientDocumentMixin
 * @augments abstract.Document
 */
const CanvasDocumentMixin = Base => class extends ClientDocumentMixin(Base) {
	constructor(data={}, context) {
		super(data, context);

		/**
		 * A reference to the PlaceableObject instance which represents this Embedded Document.
		 * @type {PlaceableObject|null}
		 */
		this._object = null;
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * A lazily constructed PlaceableObject instance which can represent this Document on the game canvas.
	 * @type {PlaceableObject|null}
	 * @name CanvasDocumentMixin#object
	 */
	get object() {
		if ( this._object ) return this._object;
		if ( !this.parent.isView ) return null;
		this._object = this.layer.createObject(this);
		return this._object;
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the CanvasLayer which contains Document objects of this type.
	 * @type {PlaceablesLayer|null}
	 */
	get layer() {
		return canvas.getLayerByEmbeddedName(this.documentName);
	}

	/* -------------------------------------------- */

	/**
	 * An indicator for whether this document is currently rendered on the game canvas.
	 * @type {boolean}
	 * @name CanvasDocumentMixin#rendered
	 */
	get rendered() {
		return this.object !== null;
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/**
	 * @see abstract.Document#_onCreate
	 * @memberof CanvasDocumentMixin#
	 */
	_onCreate(data, options, userId) {
		super._onCreate(data, options, userId);
		if ( this.parent.isView ) this.object._onCreate(data, options, userId);
	}

	/* -------------------------------------------- */

	/**
	 * @see abstract.Document#_onUpdate
	 * @memberof CanvasDocumentMixin#
	 */
	_onUpdate(changed, options, userId) {
		super._onUpdate(changed, options, userId);
		if ( this.rendered ) this.object._onUpdate(changed, options, userId);
	}

	/* -------------------------------------------- */

	/**
	 * @see abstract.Document#_onDelete
	 * @memberof CanvasDocumentMixin#
	 */
	_onDelete(options, userId) {
		super._onDelete(options, userId);
		if ( this.rendered ) this.object._onDelete(options, userId);
	}
};


/**
 * The client-side database backend implementation which handles Document modification operations.
 * @extends {abstract.DatabaseBackend}
 * @implements {abstract.DatabaseBackend}
 */
class ClientDatabaseBackend extends foundry.abstract.DatabaseBackend {

	/* -------------------------------------------- */
	/*  Socket Workflows                            */
	/* -------------------------------------------- */

	/**
	 * Activate the Socket event listeners used to receive responses from events which modify database documents
	 * @param {Socket} socket   The active game socket
	 */
	activateSocketListeners(socket) {

		// Document Operations
		socket.on("modifyDocument", response => {
			const { request } = response;
			const isEmbedded = CONST.ENTITY_TYPES.includes(request.parentType);
			switch ( request.action ) {
				case "create":
					if ( isEmbedded ) return this._handleCreateEmbeddedDocuments(response);
					else return this._handleCreateDocuments(response);
				case "update":
					if ( isEmbedded ) return this._handleUpdateEmbeddedDocuments(response);
					else return this._handleUpdateDocuments(response);
				case "delete":
					if ( isEmbedded ) return this._handleDeleteEmbeddedDocuments(response);
					else return this._handleDeleteDocuments(response);
				default:
					throw new Error(`Invalid Document modification action ${request.action} provided`);
			}
		});
	}

	/* -------------------------------------------- */
	/*  Get Operations                              */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async _getDocuments(documentClass, {query, options, pack}, user) {
		const type = documentClass.documentName;

		// Dispatch the request
		const response = await SocketInterface.dispatch("modifyDocument", {
			type: type,
			action: "get",
			query: query,
			options: options,
			pack: pack
		});

		// Return the index only
		if ( options.index ) return response.result;

		// Create Document objects
		return response.result.map(data => {
			return new documentClass(data, {pack});
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _getEmbeddedDocuments(documentClass, parent, {query, options, pack}, user) {
		throw new Error("Get operations for embedded Documents are currently un-supported");
	}

	/* -------------------------------------------- */
	/*  Create Operations                           */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async _createDocuments(documentClass, {data, options, pack}, user) {
		const toCreate = await this._preCreateDocumentArray(documentClass, {data, options, pack, user});
		if ( !toCreate.length || options.temporary ) return toCreate;
		const response = await SocketInterface.dispatch("modifyDocument", {
			type: documentClass.documentName,
			action: "create",
			data: toCreate,
			options: options,
			pack: pack
		});
		return this._handleCreateDocuments(response);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _createEmbeddedDocuments(documentClass, parent, {data, options, pack}, user) {

		// Special Case
		if ( parent.parent instanceof TokenDocument ) {
			return parent.parent.createActorEmbeddedDocuments(documentClass.documentName, data, options);
		}
		if ( parent.parent ) {
			throw new Error(`Managing embedded Documents which are not direct descendants of a primary Document is un-supported at this time.`);
		}

		// Standard Case
		const toCreate = await this._preCreateDocumentArray(documentClass, {data, options, pack, parent, user});
		if ( !toCreate.length || options.temporary ) return toCreate;
		const response = await SocketInterface.dispatch("modifyDocument", {
			action: "create",
			type: documentClass.documentName,
			parentType: parent.documentName,
			parentId: parent.id,
			data: toCreate,
			options: options,
			pack: pack
		});
		return this._handleCreateEmbeddedDocuments(response);
	}

	/* -------------------------------------------- */

	/**
	 * Perform a standardized pre-creation workflow for all Document types. For internal use only.
	 * @private
	 */
	async _preCreateDocumentArray(documentClass, {data, options, pack, parent, user}) {
		user = user || game.user;
		const type = documentClass.documentName;
		const toCreate = [];
		for ( let d of data ) {

			// Handle DocumentData or expand flattened objects
			if ( d instanceof foundry.abstract.DocumentData ) d = d.toObject();
			else if ( Object.keys(d).some(k => k.indexOf(".") !== -1) ) d = foundry.utils.expandObject(d);
			const createData = foundry.utils.deepClone(d);

			// Perform pre-creation operations
			let doc;
			try {
				doc = new documentClass(d, {parent, pack});
			} catch(err) {
				ui.notifications.error(err.message);
				console.error(err);
				continue;
			}
			await doc._preCreate(createData, options, user);

			/**
			 * A hook event that fires for every Document type before execution of a creation workflow. Substitute the
			 * Document name in the hook event to target a specific Document type, for example "preCreateActor". This hook
			 * only fires for the client who is initiating the creation request.
			 *
			 * The hook provides the pending document instance which will be used for the Document creation. Hooked functions
			 * may modify that data or prevent the workflow entirely by explicitly returning false.
			 *
			 * @function preCreateDocument
			 * @memberof hookEvents
			 * @param {Document} document     The pending document which is requested for creation
			 * @param {object} data           The initial data object provided to the document creation request
			 * @param {object} options        Additional options which modify the creation request
			 * @param {string} userId         The ID of the requesting user, always game.user.id
			 * @return {boolean|void}         Explicitly return false to prevent creation of this Document
			 */
			const allowed = options.noHook || Hooks.call(`preCreate${type}`, doc, createData, options, user.id);
			if ( allowed === false ) {
				console.debug(`${vtt} | ${type} creation prevented by preCreate hook`);
				continue;
			}
			toCreate.push(doc);
		}
		return toCreate;
	}

	/* -------------------------------------------- */

	/**
	 * Handle a SocketResponse from the server when one or multiple documents were created
	 * @param {SocketResponse} response               The provided Socket response
	 * @param {SocketRequest} [response.request]      The initial socket request
	 * @param {object[]} [response.result]            An Array of created data objects
	 * @param {string} [response.userId]              The id of the requesting User
	 * @return {Document[]}                           An Array of created Document instances
	 */
	_handleCreateDocuments({request, result=[], userId}) {
		const { type, options, pack } = request;

		// Pre-operation collection actions
		const collection = pack ? game.packs.get(pack) : game.collections.get(type);
		collection._preCreateDocuments(result, options, userId);

		// Perform creations and execute callbacks
		const callbacks = this._postCreateDocumentCallbacks(type, collection, result, {options, userId, pack});
		const documents = callbacks.map(fn => fn());

		// Post-operation collection actions
		collection._onCreateDocuments(documents, result, options, userId);
		this._logOperation("Created", type, documents, {level: "info", pack});
		return documents;
	}

	/* -------------------------------------------- */

	/**
	 * Handle a SocketResponse from the server when one or multiple documents were created
	 * @param {SocketResponse} response               The provided Socket response
	 * @param {SocketRequest} [response.request]      The initial socket request
	 * @param {object[]} [response.result]            An Array of created data objects
	 * @param {string} [response.userId]              The id of the requesting User
	 * @return {Document[]}                           An Array of created Document instances
	 */
	_handleCreateEmbeddedDocuments({request, result=[], userId}) {
		const {type, parentType, parentId, options, pack} = request;
		const parentCollection = pack ? game.packs.get(pack) : game.collections.get(parentType);
		const parent = parentCollection.get(parentId, {strict: !pack});
		if ( !parent || !result.length ) return [];

		// Pre-operation parent actions
		const collection = parent.getEmbeddedCollection(type);
		parent._preCreateEmbeddedDocuments(type, result, options, userId);

		// Perform creations and execute callbacks
		const callbacks = this._postCreateDocumentCallbacks(type, collection, result, {options, userId, parent, pack});
		parent.prepareData();
		const documents = callbacks.map(fn => fn());

		// Perform follow-up operations for the parent Document
		parent._onCreateEmbeddedDocuments(type, documents, result, options, userId);
		this._logOperation("Created", type, documents, {level: "info", parent, pack});
		return documents;
	}

	/* -------------------------------------------- */

	/**
	 * Perform a standardized post-creation workflow for all Document types. For internal use only.
	 * @return {Function[]}   An array of callback operations to perform once every Document is created
	 * @private
	 */
	_postCreateDocumentCallbacks(type, collection, result, {options, userId, parent, pack}) {
		const cls = getDocumentClass(type);
		const callback = (doc, data) => {
			doc._onCreate(data, options, userId);
			/**
			 * A hook event that fires for every embedded Document type after conclusion of a creation workflow.
			 * Substitute the Document name in the hook event to target a specific type, for example "createToken".
			 * This hook fires for all connected clients after the creation has been processed.
			 *
			 * @function createDocument
			 * @memberof hookEvents
			 * @param {Document} document     The new Document instance which has been created
			 * @param {object} options        Additional options which modified the creation request
			 * @param {string} userId         The ID of the User who triggered the creation workflow
			 */
			Hooks.callAll(`create${type}`, doc, options, userId);
			return doc;
		}
		return result.map(data => {
			const doc = new cls(data, {parent, pack});
			collection.set(doc.id, doc);
			return callback.bind(this, doc, data);
		});
	}

	/* -------------------------------------------- */
	/*  Update Operations                           */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async _updateDocuments(documentClass, {updates, options, pack}, user) {
		const collection = pack ? game.packs.get(pack) : game.collections.get(documentClass.documentName);
		const toUpdate = await this._preUpdateDocumentArray(collection, {updates, options, user});
		if ( !toUpdate.length ) return [];
		const response = await SocketInterface.dispatch("modifyDocument", {
			type: documentClass.documentName,
			action: "update",
			updates: toUpdate,
			options: options,
			pack: pack
		});
		return this._handleUpdateDocuments(response);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _updateEmbeddedDocuments(documentClass, parent, {updates, options, pack}, user) {

		// Special Cases
		if ( (parent instanceof TokenDocument) && (updates.length === 1) ) {
			return parent.modifyActorDocument(updates[0], options);
		}
		if ( parent.parent instanceof TokenDocument ) {
			return parent.parent.updateActorEmbeddedDocuments(documentClass.documentName, updates, options);
		}
		if ( parent.parent ) {
			throw new Error(`Managing embedded Documents which are not direct descendants of a primary Document is un-supported at this time.`);
		}

		// Normal case
		const collection = parent.getEmbeddedCollection(documentClass.documentName);
		const toUpdate = await this._preUpdateDocumentArray(collection, {updates, options, user});
		if ( !toUpdate.length ) return [];
		const response = await SocketInterface.dispatch("modifyDocument", {
			action: "update",
			type: documentClass.documentName,
			parentType: parent.documentName,
			parentId: parent.id,
			updates: toUpdate,
			options: options,
			pack: pack
		});
		return this._handleUpdateEmbeddedDocuments(response);
	}

	/* -------------------------------------------- */

	/**
	 * Perform a standardized pre-update workflow for all Document types. For internal use only.
	 * @private
	 */
	async _preUpdateDocumentArray(collection, {updates, options, user}) {
		user = user || game.user;
		const toUpdate = [];
		for ( let update of updates ) {

			// Get the document being updated
			if ( !update._id ) throw new Error(`You must provide an _id for every object in the update data Array.`);
			const doc = collection.get(update._id, {strict: true});

			// Validate the changes against current data
			if ( options.diff ) {
				update = foundry.utils.diffObject(doc.data._source, foundry.utils.expandObject(update));
				if ( foundry.utils.isObjectEmpty(update) ) continue;
				update._id = doc.id;
			}

			// Validate the changes and perform pre-update operations
			try {
				doc.data.validate({changes: update, clean: true, strict: true});
			} catch(err) {
				ui.notifications.error(err.message.split("] ").pop());
				console.error(err);
				continue;
			}
			await doc._preUpdate(update, options, user);

			/**
			 * A hook event that fires for every Document type before execution of an update workflow. Substitute the Document
			 * name in the hook event to target a specific Document type, for example "preUpdateActor". This hook only fires
			 * for the client who is initiating the update request.
			 *
			 * The hook provides the differential data which will be used to update the Document. Hooked functions may modify
			 * that data or prevent the workflow entirely by explicitly returning false.
			 *
			 * @function preUpdateDocument
			 * @memberof hookEvents
			 * @param {Document} document     The Document instance being updated
			 * @param {object} change         Differential data that will be used to update the document
			 * @param {object} options        Additional options which modify the update request
			 * @param {string} userId         The ID of the requesting user, always game.user.id
			 * @return {boolean|void}         Explicitly return false to prevent update of this Document
			 */
			const allowed = options.noHook || Hooks.call(`preUpdate${doc.documentName}`, doc, update, options, user.id);
			if ( allowed === false ) {
				console.debug(`${vtt} | ${doc.documentName} update prevented by preUpdate hook`);
				continue;
			}
			toUpdate.push(update);
		}
		return toUpdate;
	}

	/* -------------------------------------------- */

	/**
	 * Handle a SocketResponse from the server when one or multiple documents were updated
	 * @param {SocketResponse} response               The provided Socket response
	 * @param {SocketRequest} [response.request]      The initial socket request
	 * @param {object[]} [response.result]            An Array of incremental data objects
	 * @param {string} [response.userId]              The id of the requesting User
	 * @return {Document[]}                           An Array of updated Document instances
	 */
	_handleUpdateDocuments({request, result=[], userId}={}) {
		const { type, options, pack } = request;
		const collection = pack ? game.packs.get(pack) : game.collections.get(type);

		// Pre-operation collection actions
		collection._preUpdateDocuments(result, options, userId);

		// Perform updates and execute callbacks
		const callbacks = this._postUpdateDocumentCallbacks(collection, result, {options, userId});
		const documents = callbacks.map(fn => fn());

		// Post-operation collection actions
		collection._onUpdateDocuments(documents, result, options, userId);
		if ( CONFIG.debug.documents ) this._logOperation("Updated", type, documents, {level: "debug", pack});
		return documents;
	}

	/* -------------------------------------------- */

	/**
	 * Handle a SocketResponse from the server when embedded Documents are updated in a parent Document.
	 * @param {SocketResponse} response               The provided Socket response
	 * @param {SocketRequest} [response.request]      The initial socket request
	 * @param {object[]} [response.result]            An Array of incremental data objects
	 * @param {string} [response.userId]              The id of the requesting User
	 * @return {Document[]}                           An Array of updated Document instances
	 */
	_handleUpdateEmbeddedDocuments({request, result=[], userId}) {
		const { type, parentType, parentId, options, pack } = request;
		const parentCollection = pack ? game.packs.get(pack) : game.collections.get(parentType);
		const parent = parentCollection.get(parentId, {strict: !pack});
		if ( !parent || !result.length ) return [];

		// Pre-operation parent actions
		const collection = parent.getEmbeddedCollection(type);
		parent._preUpdateEmbeddedDocuments(type, result, options, userId);

		// Perform updates and execute callbacks
		const callbacks = this._postUpdateDocumentCallbacks(collection, result, {options, userId});
		parent.prepareData();
		const documents = callbacks.map(fn => fn());

		// Perform follow-up operations for the parent Document
		parent._onUpdateEmbeddedDocuments(type, documents, result, options, userId);
		if ( CONFIG.debug.documents ) this._logOperation("Updated", type, documents, {level: "debug", parent, pack});
		return documents;
	}

	/* -------------------------------------------- */

	/**
	 * Perform a standardized post-update workflow for all Document types. For internal use only.
	 * @return {Function[]}   An array of callback operations to perform after every Document is updated
	 * @private
	 */
	_postUpdateDocumentCallbacks(collection, result, {options, userId}) {
		const callback = (doc, change) => {
			doc._onUpdate(change, options, userId);
			/**
			 * A hook event that fires for every Document type after conclusion of an update workflow.
			 * Substitute the Document name in the hook event to target a specific Document type, for example "updateActor".
			 * This hook fires for all connected clients after the update has been processed.
			 *
			 * @function updateDocument
			 * @memberof hookEvents
			 * @param {Document} document     The existing Document which was updated
			 * @param {object} change         Differential data that was used used to update the document
			 * @param {object} options        Additional options which modified the update request
			 * @param {string} userId         The ID of the User who triggered the update workflow
			 */
			Hooks.callAll(`update${doc.documentName}`, doc, change, options, userId);
			return doc;
		}
		const callbacks = [];
		for ( let change of result ) {
			const doc = collection.get(change._id, {strict: false});
			if ( !doc ) continue;
			doc.data.update(change, options);
			doc.prepareData();
			callbacks.push(callback.bind(this, doc, change));
		}
		return callbacks;
	}

	/* -------------------------------------------- */
	/*  Delete Operations                           */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async _deleteDocuments(documentClass, {ids, options, pack}, user) {
		user = user || game.user;
		const collection = pack ? game.packs.get(pack) : game.collections.get(documentClass.documentName);
		const deleteIds = options.deleteAll ? collection.keys() : ids;
		const toDelete = await this._preDeleteDocumentArray(collection, {ids: deleteIds, options, user});
		if ( !toDelete.length ) return [];
		const response = await SocketInterface.dispatch("modifyDocument", {
			type: documentClass.documentName,
			action: "delete",
			ids: toDelete,
			options: options,
			pack: pack
		});
		return this._handleDeleteDocuments(response);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _deleteEmbeddedDocuments(documentClass, parent, {ids, options, pack}, user) {

		// Special Cases
		if ( parent.parent instanceof TokenDocument ) {
			return parent.parent.deleteActorEmbeddedDocuments(documentClass.documentName, ids, options);
		}
		if ( parent.parent ) {
			throw new Error(`Managing embedded Documents which are not direct descendants of a primary Document is un-supported at this time.`);
		}

		// Normal case
		const collection = parent.getEmbeddedCollection(documentClass.documentName);
		const deleteIds = options.deleteAll ? collection.keys() : ids;
		const toDelete = await this._preDeleteDocumentArray(collection, {ids: deleteIds, options, user});
		if ( !toDelete.length ) return [];
		const response = await SocketInterface.dispatch("modifyDocument", {
			action: "delete",
			type: documentClass.documentName,
			parentType: parent.documentName,
			parentId: parent.id,
			ids: toDelete,
			options: options,
			pack: pack
		});
		return this._handleDeleteEmbeddedDocuments(response);
	}

	/* -------------------------------------------- */

	/**
	 * Perform a standardized pre-delete workflow for all Document types. For internal use only.
	 * @private
	 */
	async _preDeleteDocumentArray(collection, {ids, options, user}) {
		user = user || game.user;
		const toDelete = [];
		for ( let id of ids ) {
			const doc = collection.get(id, {strict: true});
			await doc._preDelete(options, user);
			/**
			 * A hook event that fires for every Document type before execution of a deletion workflow. Substitute the
			 * Document name in the hook event to target a specific Document type, for example "preDeleteActor". This hook
			 * only fires for the client who is initiating the update request.
			 *
			 * The hook provides the Document instance which is requested for deletion. Hooked functions may prevent the
			 * workflow entirely by explicitly returning false.
			 *
			 * @function preDeleteDocument
			 * @memberof hookEvents
			 * @param {Document} document     The Document instance being deleted
			 * @param {object} options        Additional options which modify the deletion request
			 * @param {string} userId         The ID of the requesting user, always game.user.id
			 * @return {boolean|void}         Explicitly return false to prevent deletion of this Document
			 */
			const allowed = options.noHook || Hooks.call(`preDelete${doc.documentName}`, doc, options, user.id);
			if ( allowed === false ) {
				console.debug(`${vtt} | ${doc.documentName} deletion prevented by preDelete hook`);
				continue;
			}
			toDelete.push(id);
		}
		return toDelete;
	}

	/* -------------------------------------------- */

	/**
	 * Handle a SocketResponse from the server where Documents are deleted.
	 * @param {SocketResponse} response               The provided Socket response
	 * @param {SocketRequest} [response.request]      The initial socket request
	 * @param {object[]} [response.result]            An Array of deleted Document ids
	 * @param {string} [response.userId]              The id of the requesting User
	 * @return {Document[]}                           An Array of deleted Document instances
	 */
	_handleDeleteDocuments({request, result=[], userId}={}) {
		const {type, options, pack} = request;
		const collection = pack ? game.packs.get(pack) : game.collections.get(type);
		result = options.deleteAll ? Array.from(collection.keys()) : result;

		// Pre-operation collection actions
		collection._preDeleteDocuments(result, options, userId);

		// Perform deletions and execute callbacks
		const callbacks = this._postDeleteDocumentCallbacks(collection, result, {options, userId});
		const documents = callbacks.map(fn => fn());

		// Post-operation collection actions
		collection._onDeleteDocuments(documents, result, options, userId);
		this._logOperation("Deleted", type, documents, {level: "info", pack});
		return documents;
	}

	/* -------------------------------------------- */

	/**
	 * Handle a SocketResponse from the server when embedded Documents are deleted from a parent Document.
	 * @param {SocketResponse} response               The provided Socket response
	 * @param {SocketRequest} [response.request]      The initial socket request
	 * @param {object[]} [response.result]            An Array of deleted Document ids
	 * @param {string} [response.userId]              The id of the requesting User
	 * @return {Document[]}                           An Array of deleted Document instances
	 */
	_handleDeleteEmbeddedDocuments({request, result=[], userId}) {
		const { type, parentType, parentId, options, pack } = request;
		const parentCollection = pack ? game.packs.get(pack) : game.collections.get(parentType);
		const parent = parentCollection.get(parentId, {strict: !pack});
		if ( !parent || !result.length ) return [];

		// Pre-operation parent actions
		const collection = parent.getEmbeddedCollection(type);
		parent._preDeleteEmbeddedDocuments(type, result, options, userId);

		// Perform updates and execute callbacks
		const callbacks = this._postDeleteDocumentCallbacks(collection, result, {options, userId});
		parent.prepareData();
		const documents = callbacks.map(fn => fn());

		// Perform follow-up operations for the parent Document
		parent._onDeleteEmbeddedDocuments(type, documents, result, options, userId);
		this._logOperation("Deleted", type, documents, {level: "info", parent, pack});
		return documents;
	}

	/* -------------------------------------------- */

	/**
	 * Perform a standardized post-deletion workflow for all Document types. For internal use only.
	 * @return {Function[]}   An array of callback operations to perform after every Document is deleted
	 * @private
	 */
	_postDeleteDocumentCallbacks(collection, result, {options, userId}) {
		const callback = doc => {
			doc._onDelete(options, userId);
			/**
			 * A hook event that fires for every Document type after conclusion of an deletion workflow.
			 * Substitute the Document name in the hook event to target a specific Document type, for example "deleteActor".
			 * This hook fires for all connected clients after the deletion has been processed.
			 *
			 * @function deleteDocument
			 * @memberof hookEvents
			 * @param {Document} document     The existing Document which was deleted
			 * @param {object} options        Additional options which modified the deletion request
			 * @param {string} userId         The ID of the User who triggered the deletion workflow
			 */
			Hooks.callAll(`delete${doc.documentName}`, doc, options, userId);
			return doc;
		}
		const callbacks = [];
		for ( let id of result ) {
			const doc = collection.get(id, {strict: false});
			if ( !doc ) continue;
			collection.delete(id);
			callbacks.push(callback.bind(this, doc));
		}
		return callbacks;
	}

	/* -------------------------------------------- */
	/*  Helper Methods                              */
	/* -------------------------------------------- */

	/** @inheritdoc */
	getFlagScopes() {
		let scopes = ["core", game.system.id];
		scopes = scopes.concat(Array.from(game.modules.keys()));
		scopes.push("world");
		return scopes;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getCompendiumScopes() {
		return Array.from(game.packs.keys());
	}
}

/**
 * The client-side document mixin which is used to extend the common BaseDocument.
 * This mixin provides the client-side interface for database operations and common document behaviors.
 * @mixin
 * @augments abstract.Document
 */
const ClientDocumentMixin = Base => class extends Base {
	constructor(data, context) {
		super(data, context);
	}

	/**
	 * A collection of Application instances which should be re-rendered whenever this document is updated.
	 * The keys of this object are the application ids and the values are Application instances. Each
	 * Application in this object will have its render method called by {@link Document#render}.
	 * @type {Object<Application>}
	 * @see {@link Document#render}
	 * @memberof ClientDocumentMixin#
	 */
	apps = {};

	/**
	 * A cached reference to the FormApplication instance used to configure this Document.
	 * @type {FormApplication|null}
	 * @private
	 */
	_sheet = null;

	/**
	 * @see abstract.Document#_initialize
	 * @memberof ClientDocumentMixin#
	 */
	_initialize() {
		super._initialize();
		this.prepareData();
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * Return a reference to the parent Collection instance which contains this Document.
	 * @type {Collection}
	 * @memberof ClientDocumentMixin#
	 */
	get collection() {
		if ( this.isEmbedded ) return this.parent[this.constructor.metadata.collection];
		else return CONFIG[this.documentName].collection.instance;
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the Compendium Collection which contains this Document, if any, otherwise undefined.
	 * @type {CompendiumCollection}
	 * @name ClientDocumentMixin#compendium
	 */
	get compendium() {
		return game.packs.get(this.pack);
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the Folder to which this Document belongs, if any.
	 * @type {Folder|null}
	 * @memberof ClientDocumentMixin#
	 *
	 * @example <caption>A Document may belong to a Folder</caption>
	 * let folder = game.folders.entities[0];
	 * let actor = await Actor.create({name: "New Actor", folder: folder.id});
	 * console.log(actor.data.folder); // folder.id;
	 * console.log(actor.folder); // folder;
	 */
	get folder() {
		if ( !this.data.folder ) return null;
		return game.folders.get(this.data.folder);
	}

	/* -------------------------------------------- */

	/**
	 * A boolean indicator for whether or not the current game User has ownership rights for this Document.
	 * Different Document types may have more specialized rules for what constitutes ownership.
	 * @type {boolean}
	 * @memberof ClientDocumentMixin#
	 */
	get isOwner() {
		return this.testUserPermission(game.user, "OWNER");
	}

	/* -------------------------------------------- */

	/**
	 * Test whether this Document is owned by any non-Gamemaster User.
	 * @type {boolean}
	 * @memberof ClientDocumentMixin#
	 */
	get hasPlayerOwner() {
		for ( let u of game.users ) {
			if ( u.isGM ) continue;
			if ( this.testUserPermission(u, "OWNER") ) return true;
		}
		return false;
	}

	/* ---------------------------------------- */

	/**
	 * A boolean indicator for whether the current game User has exactly LIMITED visibility (and no greater).
	 * @type {boolean}
	 * @memberof ClientDocumentMixin#
	 */
	get limited() {
		return this.testUserPermission(game.user, "LIMITED", {exact: true});
	}

	/* -------------------------------------------- */

	/**
	 * Return a string which creates a dynamic link to this Document instance.
	 * @return {string}
	 * @memberof ClientDocumentMixin#
	 */
	get link() {
		let id = this.isEmbedded ? this.uuid : this.id;
		return `@${this.documentName}[${id}]{${this.name}}`;
	}

	/* ---------------------------------------- */

	/**
	 * Return the permission level that the current game User has over this Document.
	 * See the CONST.ENTITY_PERMISSIONS object for an enumeration of these levels.
	 * @type {number}
	 * @memberof ClientDocumentMixin#
	 *
	 * @example
	 * game.user.id; // "dkasjkkj23kjf"
	 * actor.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
	 * actor.permission; // 2
	 */
	get permission() {
		if ( game.user.isGM ) return CONST.ENTITY_PERMISSIONS.OWNER;
		if ( this.isEmbedded ) return this.parent.permission;
		return this.getUserLevel(game.user);
	}

	/* -------------------------------------------- */

	/**
	 * Lazily obtain a FormApplication instance used to configure this Document, or null if no sheet is available.
	 * @type {FormApplication|null}
	 * @memberof ClientDocumentMixin#
	 */
	get sheet() {
		if ( !this._sheet ) {
			const cls = this._getSheetClass();
			if ( !cls ) return null;
			this._sheet = new cls(this, {editable: this.isOwner});
		}
		return this._sheet;
	}

	/* -------------------------------------------- */

	/**
	 * A Universally Unique Identifier (uuid) for this Document instance.
	 * @type {string}
	 * @memberof ClientDocumentMixin#
	 */
	get uuid() {
		let parts = [this.documentName, this.id];
		if ( this.parent ) parts = [this.parent.uuid].concat(parts);
		else if ( this.pack ) parts = ["Compendium", this.pack].concat(parts.slice(1));
		return parts.join(".");
	}

	/* -------------------------------------------- */

	/**
	 * A boolean indicator for whether or not the current game User has at least limited visibility for this Document.
	 * Different Document types may have more specialized rules for what determines visibility.
	 * @type {boolean}
	 * @memberof ClientDocumentMixin#
	 */
	get visible() {
		if ( this.isEmbedded ) return this.parent.visible;
		return this.testUserPermission(game.user, "LIMITED");
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Obtain the FormApplication class constructor which should be used to configure this Document.
	 * @returns {Function|null}
	 * @private
	 */
	_getSheetClass() {
		const cfg = CONFIG[this.documentName];
		return cfg?.sheetClass || null;
	}

	/* -------------------------------------------- */

	/**
	 * Prepare data for the Document.
	 * Begin by resetting the prepared data back to its source state.
	 * Next prepare any embedded Documents and compute any derived data elements.
	 * @memberof ClientDocumentMixin#
	 */
	prepareData() {
		this.data.reset();
		this.prepareBaseData();
		this.prepareEmbeddedEntities();
		this.prepareDerivedData();
	}

	/* -------------------------------------------- */

	/**
	 * Prepare data related to this Document itself, before any embedded Documents or derived data is computed.
	 * @memberof ClientDocumentMixin#
	 */
	prepareBaseData() {}

	/* -------------------------------------------- */

	/**
	 * Prepare all embedded Document instances which exist within this primary Document.
	 * @memberof ClientDocumentMixin#
	 */
	prepareEmbeddedEntities() {
		const embeddedTypes = this.constructor.metadata.embedded || {};
		for ( let cls of Object.values(embeddedTypes) ) {
			const collection = cls.metadata.collection;
			for ( let e of this[collection] ) {
				e.prepareData();
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Apply transformations or derivations to the values of the source data object.
	 * Compute data fields whose values are not stored to the database.
	 * @memberof ClientDocumentMixin#
	 */
	prepareDerivedData() {}

	/* -------------------------------------------- */

	/**
	 * Render all of the Application instances which are connected to this document by calling their respective
	 * @see Application#render
	 * @param {boolean} [force=false]     Force rendering
	 * @param {object} [context={}]       Optional context
	 * @memberof ClientDocumentMixin#
	 */
	render(force=false, context={}) {
		for ( let app of Object.values(this.apps) ) {
			app.render(force, context);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Determine the sort order for this Document by positioning it relative a target sibling.
	 * See SortingHelper.performIntegerSort for more details
	 * @param {object} [options]          Sorting options provided to SortingHelper.performIntegerSort
	 * @returns {Promise<Document>}       The Document after it has been re-sorted
	 * @memberof ClientDocumentMixin#
	 */
	async sortRelative({target=null, siblings=[], sortKey="sort", sortBefore=true, updateData={}}={}) {
		const sorting = SortingHelpers.performIntegerSort(this, {target, siblings, sortKey, sortBefore});
		const updates = [];
		for ( let s of sorting ) {
			const doc = s.target;
			const update = foundry.utils.mergeObject(updateData, s.update, {inplace: false});
			update._id = doc.id;
			if ( doc.sheet && doc.sheet.rendered ) await doc.sheet.submit({updateData: update});
			else updates.push(update);
		}
		if ( updates.length ) await this.constructor.updateDocuments(updates, {parent: this.parent, pack: this.pack});
		return this;
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/**
	 * @see abstract.Document#_onCreate
	 * @memberof ClientDocumentMixin#
	 */
	_onCreate(data, options, userId) {
		if ( options.renderSheet && (userId === game.user.id) ) {
			if ( this.sheet ) this.sheet.render(true, {
				action: "create",
				data: data
			});
		}
	}

	/* -------------------------------------------- */

	/**
	 * @see abstract.Document#_onUpdate
	 * @memberof ClientDocumentMixin#
	 */
	_onUpdate(data, options, userId) {

		// Re-render associated applications
		if (options.render !== false) {
			this.render(false, {
				action: "update",
				data: data
			});
		}

		// Update Compendium index
		if (this.pack) {
			this.compendium.indexDocument(this);
		}
	}

	/* -------------------------------------------- */

	/**
	 * @see abstract.Document#_onDelete
	 * @memberof ClientDocumentMixin#
	 */
	_onDelete(options, userId) {
		Object.values(this.apps).forEach(a => a.close({submit: false}));
	}

	/* -------------------------------------------- */

	/**
	 * Preliminary actions taken before a set of embedded Documents in this parent Document are created.
	 * @param {string} embeddedName   The name of the embedded Document type
	 * @param {object[]} result       An Array of created data objects
	 * @param {object} options        Options which modified the creation operation
	 * @param {string} userId         The ID of the User who triggered the operation
	 * @memberof ClientDocumentMixin#
	 */
	_preCreateEmbeddedDocuments(embeddedName, result, options, userId) {}

	/* -------------------------------------------- */

	/**
	 * Follow-up actions taken after a set of embedded Documents in this parent Document are created.
	 * @param {string} embeddedName   The name of the embedded Document type
	 * @param {Document[]} documents  An Array of created Documents
	 * @param {object[]} result       An Array of created data objects
	 * @param {object} options        Options which modified the creation operation
	 * @param {string} userId         The ID of the User who triggered the operation
	 * @memberof ClientDocumentMixin#
	 */
	_onCreateEmbeddedDocuments(embeddedName, documents, result, options, userId) {
		this.render(false, {renderContext: `create${embeddedName}`});
	}

	/* -------------------------------------------- */

	/**
	 * Preliminary actions taken before a set of embedded Documents in this parent Document are updated.
	 * @param {string} embeddedName   The name of the embedded Document type
	 * @param {object[]} result       An Array of incremental data objects
	 * @param {object} options        Options which modified the update operation
	 * @param {string} userId         The ID of the User who triggered the operation
	 * @memberof ClientDocumentMixin#
	 */
	_preUpdateEmbeddedDocuments(embeddedName, result, options, userId) {}

	/* -------------------------------------------- */

	/**
	 * Follow-up actions taken after a set of embedded Documents in this parent Document are updated.
	 * @param {string} embeddedName   The name of the embedded Document type
	 * @param {Document[]} documents  An Array of updated Documents
	 * @param {object[]} result       An Array of incremental data objects
	 * @param {object} options        Options which modified the update operation
	 * @param {string} userId         The ID of the User who triggered the operation
	 * @memberof ClientDocumentMixin#
	 */
	_onUpdateEmbeddedDocuments(embeddedName, documents, result, options, userId) {
		this.render(false, {renderContext: `update${embeddedName}`});
	}

	/* -------------------------------------------- */

	/**
	 * Preliminary actions taken before a set of embedded Documents in this parent Document are deleted.
	 * @param {string} embeddedName   The name of the embedded Document type
	 * @param {object[]} result       An Array of document IDs being deleted
	 * @param {object} options        Options which modified the deletion operation
	 * @param {string} userId         The ID of the User who triggered the operation
	 * @memberof ClientDocumentMixin#
	 */
	_preDeleteEmbeddedDocuments(embeddedName, result, options, userId) {}

	/* -------------------------------------------- */

	/**
	 * Follow-up actions taken after a set of embedded Documents in this parent Document are deleted.
	 * @param {string} embeddedName   The name of the embedded Document type
	 * @param {Document[]} documents  An Array of deleted Documents
	 * @param {object[]} result       An Array of document IDs being deleted
	 * @param {object} options        Options which modified the deletion operation
	 * @param {string} userId         The ID of the User who triggered the operation
	 * @memberof ClientDocumentMixin#
	 */
	_onDeleteEmbeddedDocuments(embeddedName, documents, result, options, userId) {
		this.render(false, {renderContext: `delete${embeddedName}`});
	}

	/* -------------------------------------------- */
	/*  Importing and Exporting                     */
	/* -------------------------------------------- */

	/**
	 * Present a Dialog form to create a new Document of this type.
	 * Choose a name and a type from a select menu of types.
	 * @param {object} data         Initial data with which to populate the creation form
	 * @param {object} [options]    Positioning and sizing options for the resulting dialog
	 * @return {Promise<Document>}  A Promise which resolves to the created Document
	 * @memberof ClientDocumentMixin
	 */
	static async createDialog(data={}, options={}) {

		// Collect data
		const documentName = this.metadata.name;
		const types = game.system.entityTypes[documentName];
		const folders = game.folders.filter(f => (f.data.type === documentName) && f.displayed);
		const label = game.i18n.localize(this.metadata.label);
		const title = game.i18n.format("ENTITY.Create", {entity: label});

		// Render the entity creation form
		const html = await renderTemplate(`templates/sidebar/entity-create.html`, {
			name: data.name || game.i18n.format("ENTITY.New", {entity: label}),
			folder: data.folder,
			folders: folders,
			hasFolders: folders.length > 1,
			type: data.type || types[0],
			types: types.reduce((obj, t) => {
				const label = CONFIG[documentName]?.typeLabels?.[t] ?? t;
				obj[t] = game.i18n.has(label) ? game.i18n.localize(label) : t;
				return obj;
			}, {}),
			hasTypes: types.length > 1
		});

		// Render the confirmation dialog window
		return Dialog.prompt({
			title: title,
			content: html,
			label: title,
			callback: html => {
				const form = html[0].querySelector("form");
				const fd = new FormDataExtended(form);
				data = foundry.utils.mergeObject(data, fd.toObject());
				if ( !data.folder ) delete data["folder"];
				if ( types.length === 1 ) data.type = types[0];
				return this.create(data, {renderSheet: true});
			},
			rejectClose: false,
			options: options
		});
	}

	/* -------------------------------------------- */

	/**
	 * Present a Dialog form to confirm deletion of this Document.
	 * @param {object} [options]    Positioning and sizing options for the resulting dialog
	 * @return {Promise<Document>}  A Promise which resolves to the deleted Document
	 */
	async deleteDialog(options={}) {
		const type = game.i18n.localize(this.constructor.metadata.label);
		return Dialog.confirm({
			title: `${game.i18n.format("DOCUMENT.Delete", {type})}: ${this.name}`,
			content: `<h4>${game.i18n.localize("AreYouSure")}</h4><p>${game.i18n.format("SIDEBAR.DeleteWarning", {type})}</p>`,
			yes: this.delete.bind(this),
			options: options
		});
	}

	/* -------------------------------------------- */

	/**
	 * Export entity data to a JSON file which can be saved by the client and later imported into a different session.
	 * @memberof ClientDocumentMixin#
	 */
	exportToJSON() {
		const data = this.toCompendium();
		data.flags["exportSource"] = {
			world: game.world.id,
			system: game.system.id,
			coreVersion: game.data.version,
			systemVersion: game.system.data.version
		};
		const filename = `fvtt-${this.documentName}-${this.name.slugify()}.json`;
		saveDataToFile(JSON.stringify(data, null, 2), "text/json", filename);
	}

	/* -------------------------------------------- */

	/**
	 * A helper function to handle obtaining the relevant Document from dropped data provided via a DataTransfer event.
	 * The dropped data could have:
	 * 1. A compendium pack and entry id
	 * 2. A World Entity _id
	 * 3. A data object explicitly provided
	 * @memberof ClientDocumentMixin
	 *
	 * @param {object} data   The data object extracted from a DataTransfer event
	 * @param {object} [options={}]   Additional options which configure data retrieval
	 * @param {boolean} [options.importWorld=false]   Import the provided document data into the World, if it is not already a World-level Document reference
	 * @return {Promise<Document|null>}    The Document data that should be handled by the drop handler
	 */
	static async fromDropData(data, {importWorld=false}={}) {
		if ( data.type !== this.documentName ) return null;
		const collection = CONFIG[this.documentName].collection.instance;
		let document = null;

		// Case 1 - Data explicitly provided
		if (data.data) {
			document = importWorld ? await this.create(data.data) : new this(data.data);
		}

		// Case 2 - Import from a Compendium pack
		else if (data.pack) {
			const pack = game.packs.get(data.pack);
			if (pack.metadata.entity !== this.documentName) return null;
			document = importWorld ? await collection.importFromCompendium(pack, data.id) : await pack.getDocument(data.id);
		}

		// Case 3 - Import from World entity
		else document = collection.get(data.id);

		// Flag the source GUID
		if ( document && !document.getFlag("core", "sourceId") ) {
			document.data.update({"flags.core.sourceId": document.uuid});
			document.prepareData();
		}
		return document;
	}

	/* -------------------------------------------- */

	/**
	 * Update this Document using a provided JSON string.
	 * @param {string} json           JSON data string
	 * @return {Promise<Document>}    The updated Document
	 * @memberof ClientDocumentMixin#
	 */
	async importFromJSON(json) {
		const data = this.collection.fromCompendium(JSON.parse(json));
		this.data.update(data, {recursive: false});
		return this.update(this.toJSON(), {diff: false, recursive: false});
	}

	/* -------------------------------------------- */

	/**
	 * Render an import dialog for updating the data related to this Document through an exported JSON file
	 * @return {Promise<void>}
	 * @memberof ClientDocumentMixin#
	 */
	async importFromJSONDialog() {
		new Dialog({
			title: `Import Data: ${this.name}`,
			content: await renderTemplate("templates/apps/import-data.html",
					{
						hint1: game.i18n.format("DOCUMENT.ImportDataHint1", {document: this.documentName}),
						hint2: game.i18n.format("DOCUMENT.ImportDataHint2", {name: this.name})
					}),
			buttons: {
				import: {
					icon: '<i class="fas fa-file-import"></i>',
					label: "Import",
					callback: html => {
						const form = html.find("form")[0];
						if ( !form.data.files.length ) return ui.notifications.error("You did not upload a data file!");
						readTextFromFile(form.data.files[0]).then(json => this.importFromJSON(json));
					}
				},
				no: {
					icon: '<i class="fas fa-times"></i>',
					label: "Cancel"
				}
			},
			default: "import"
		}, {
			width: 400
		}).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Transform the Document data to be stored in a Compendium pack.
	 * Remove any features of the data which are world-specific.
	 * This function is asynchronous in case any complex operations are required prior to exporting.
	 * @param {CompendiumCollection} [pack]   A specific pack being exported to
	 * @return {object}                       A data object of cleaned data suitable for compendium import
	 * @memberof ClientDocumentMixin#
	 */
	toCompendium(pack) {
		const isWorld = pack?.metadata.package === "world";
		const data = this.toObject();
		const deleteKeys = ["_id", "folder"];
		if ( !isWorld ) deleteKeys.push("permission");
		for ( let k of deleteKeys ) {
			delete data[k];
		}
		if ( "sort" in data ) data.sort = 0;
		if ( "active" in data ) data.active = false;
		return data;
	}

	/* -------------------------------------------- */
	/*  DEPRECATIONS                                */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	get _id() {
		console.warn("The Document#_id property is deprecated in favor of Document#id or Document#data#_id. Support will be removed in 0.9.0");
		return this.id;
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	static get config() {
		console.warn("The Document.config object is deprecated in favor of the more generalized Document.metadata object");
		return this.metadata;
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	get entity() {
		console.warn(`The Document#entity property has been deprecated in favor of Document#documentName. Support will be removed in 0.9.0`);
		return this.documentName;
	}

	/**
	 * @memberof ClientDocumentMixin#
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	get owner() {
		console.warn(`You are using the Document#owner property which has been deprecated in favor of Document#isOwner and will be removed in 0.9.0`);
		return this.isOwner;
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	hasPerm(user, permission, exact=false) {
		console.warn(`The Document#hasPerm method has been deprecated in favor of Document#testUserPermission. Support will be removed in 0.9.0`);
		return this.testUserPermission(user, permission, {exact});
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	static async update(updates, options) {
		console.warn(`The Document.update static method has been deprecated in favor of Document.updateDocuments. Support will be removed in 0.9.0`);
		updates = updates instanceof Array ? updates : [updates];
		return this.updateDocuments(updates, options);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	static async delete(ids, options) {
		console.warn(`The Document.delete static method has been deprecated in favor of Document.deleteDocuments. Support will be removed in 0.9.0`);
		return this.deleteDocuments(ids, options);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	getEmbeddedEntity(...args) {
		console.warn("The Document#getEmbeddedEntity method has been renamed to Document#getEmbeddedDocument. Support for the old method name will be removed in 0.9.0");
		return this.getEmbeddedDocument(...args);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	async createEmbeddedEntity(documentName, data, options) {
		data = data instanceof Array ? data : [data];
		console.warn("The Document#createEmbeddedEntity method has been renamed to Document#createEmbeddedDocuments. Support for the old method name will be removed in 0.9.0");
		return this.createEmbeddedDocuments(documentName, data, options);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	async updateEmbeddedEntity(documentName, data, options) {
		data = data instanceof Array ? data : [data];
		console.warn("The Document#updateEmbeddedEntity method has been renamed to Document#updateEmbeddedDocuments. Support for the old method name will be removed in 0.9.0");
		return this.updateEmbeddedDocuments(documentName, data, options);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	async deleteEmbeddedEntity(documentName, ids, options) {
		ids = ids instanceof Array ? ids : [ids];
		console.warn("The Document#deleteEmbeddedEntity method has been renamed to Document#deleteEmbeddedDocuments. Support for the old method name will be removed in 0.9.0");
		return this.deleteEmbeddedDocuments(documentName, ids, options);
	}
};
/**
 * A Collection of Document objects within the Foundry Virtual Tabletop framework.
 * @extends {Collection}
 * @interface
 *
 * @param {object[]} data      An array of data objects from which to create document instances
 */
class DocumentCollection extends foundry.utils.Collection {
	constructor() {
		super();

		/**
		 * An Array of application references which will be automatically updated when the collection content changes
		 * @type {Application[]}
		 */
		this.apps = [];
	}

	/* -------------------------------------------- */
	/*  Collection Properties                       */
	/* -------------------------------------------- */

	/**
	 * The Collection class name
	 * @type {string}
	 */
	get name() {
		return this.constructor.name;
	}

	/**
	 * A reference to the Document class definition which is contained within this DocumentCollection.
	 * @type {Function}
	 */
	get documentClass() {
		return getDocumentClass(this.documentName);
	}

	/**
	 * A reference to the named Document class which is contained within this DocumentCollection.
	 * @type {string}
	 */
	get documentName() {
		throw new Error("A subclass of DocumentCollection must implement the documentName getter");
	}

	/* -------------------------------------------- */
	/*  Collection Methods                          */
	/* -------------------------------------------- */

	/** @inheritdoc */
	set(id, document) {
		const cls = this.documentClass;
		if (!(document instanceof cls)) {
			throw new Error(`You may only push instances of ${cls.documentName} to the ${this.name} collection`);
		}
		return super.set(document.id, document);
	}

	/* -------------------------------------------- */

	/**
	 * Render any Applications associated with this DocumentCollection.
	 */
	render(force, options) {
		for (let a of this.apps) a.render(force, options);
	}

	/* -------------------------------------------- */
	/*  Database Operations                         */
	/* -------------------------------------------- */

	/**
	 * Update all objects in this DocumentCollection with a provided transformation.
	 * Conditionally filter to only apply to Entities which match a certain condition.
	 * @param {Function|object} transformation    An object of data or function to apply to all matched objects
	 * @param {Function|null}  condition          A function which tests whether to target each object
	 * @param {object} [options]                  Additional options passed to Entity.update
	 * @return {Promise<Document[]>}              An array of updated data once the operation is complete
	 */
	async updateAll(transformation, condition=null, options={}) {
		const hasTransformer = transformation instanceof Function;
		if ( !hasTransformer && (foundry.utils.getType(transformation) !== "Object") ) {
			throw new Error("You must provide a data object or transformation function");
		}
		const hasCondition = condition instanceof Function;
		const updates = [];
		for ( let doc of this ) {
			if ( hasCondition && !condition(doc) ) continue;
			const update = hasTransformer ? transformation(doc) : foundry.utils.deepClone(transformation);
			update._id = doc.id;
			updates.push(update);
		}
		return this.documentClass.updateDocuments(updates, options);
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/**
	 * Preliminary actions taken before a set of Documents in this Collection are created.
	 * @param {object[]} result       An Array of created data objects
	 * @param {object} options        Options which modified the creation operation
	 * @param {string} userId         The ID of the User who triggered the operation
	 */
	_preCreateDocuments(result, options, userId) {}

	/* -------------------------------------------- */

	/**
	 * Follow-up actions taken after a set of Documents in this Collection are created.
	 * @param {Document[]} documents  An Array of created Documents
	 * @param {object[]} result       An Array of created data objects
	 * @param {object} options        Options which modified the creation operation
	 * @param {string} userId         The ID of the User who triggered the operation
	 */
	_onCreateDocuments(documents, result, options, userId) {
		if ( options.render !== false ) {
			this.render(false, {
				action: "create",
				entityType: this.documentName,
				entities: documents,
				data: result
			});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Preliminary actions taken before a set of Documents in this Collection are updated.
	 * @param {object[]} result       An Array of incremental data objects
	 * @param {object} options        Options which modified the update operation
	 * @param {string} userId         The ID of the User who triggered the operation
	 */
	_preUpdateDocuments(result, options, userId) {}

	/* -------------------------------------------- */

	/**
	 * Follow-up actions taken after a set of Documents in this Collection are updated.
	 * @param {Document[]} documents  An Array of updated Documents
	 * @param {object[]} result       An Array of incremental data objects
	 * @param {object} options        Options which modified the update operation
	 * @param {string} userId         The ID of the User who triggered the operation
	 */
	_onUpdateDocuments(documents, result, options, userId) {
		if ( options.render !== false ) {
			this.render(false, {
				action: "update",
				entityType: this.documentName,
				entities: documents,
				data: result
			});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Preliminary actions taken before a set of Documents in this Collection are deleted.
	 * @param {object[]} result       An Array of document IDs being deleted
	 * @param {object} options        Options which modified the deletion operation
	 * @param {string} userId         The ID of the User who triggered the operation
	 */
	_preDeleteDocuments(result, options, userId) {}

	/* -------------------------------------------- */

	/**
	 * Follow-up actions taken after a set of Documents in this Collection are deleted.
	 * @param {Document[]} documents  An Array of deleted Documents
	 * @param {object[]} result       An Array of document IDs being deleted
	 * @param {object} options        Options which modified the deletion operation
	 * @param {string} userId         The ID of the User who triggered the operation
	 */
	_onDeleteDocuments(documents, result, options, userId) {
		if ( options.render !== false ) {
			this.render(false, {
				action: "delete",
				entityType: this.documentName,
				entities: documents,
				data: result
			});
		}
	}
}

/**
 * A singleton Collection of world-level Document objects within the Foundry Virtual Tabletop.
 * Each primary Document type has an associated subclass of WorldCollection which contains them.
 * @extends {DocumentCollection}
 * @abstract
 *
 * @param {object[]} data      An array of data objects from which to create Document instances
 */
class WorldCollection extends DocumentCollection {
	constructor(data=[]) {
		super();

		/**
		 * The source data array from which the Documents in the WorldCollection are created
		 * @type {object[]}
		 * @private
		 */
		Object.defineProperty(this, "_source", {
			value: data,
			writable: false
		});

		// Initialize data
		this._initialize();
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the WorldCollection object by constructing its contained Document instances
	 * @private
	 */
	_initialize() {
		this.clear();
		for ( let d of this._source ) {
			let doc;
			try {
				doc = new this.documentClass(d);
				super.set(doc.id, doc);
			} catch(err) {
				err.message = `Failed to initialized ${this.documentName} [${d._id}]: ${err.message}`;
				console.error(err);
			}
		}
	}

	/* -------------------------------------------- */
	/*  Collection Properties                       */
	/* -------------------------------------------- */

	/** @inheritdoc */
	get documentName() {
		return this.constructor.documentName;
	}

	/* -------------------------------------------- */

	/**
	 * The base Document type which is contained within this WorldCollection
	 * @type {string|null}
	 */
	static documentName = null;

	/* -------------------------------------------- */

	/**
	 * Return a reference to the SidebarDirectory application for this WorldCollection, or null if it has not yet been created.
	 * @type {SidebarDirectory|null}
	 */
	get directory() {
		return ui[this.name.toLowerCase()] || null;
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the singleton instance of this WorldCollection, or null if it has not yet been created.
	 * @type {WorldCollection}
	 */
	static get instance() {
		return game.collections.get(this.documentName);
	}

	/* -------------------------------------------- */
	/*  Collection Methods                          */
	/* -------------------------------------------- */

	/** @inheritdoc */
	set(id, document) {
		super.set(id, document);
		this._source.push(document.toJSON());
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	delete(id) {
		super.delete(id);
		this._source.findSplice(e => e._id === id);
	}

	/* -------------------------------------------- */

	/**
	 * Import a Document from a Compendium collection, adding it to the current World.
	 * @param {CompendiumCollection} pack The CompendiumCollection instance from which to import
	 * @param {string} id             The ID of the compendium entry to import
	 * @param {Object} [updateData]   Optional additional data used to modify the imported Document before it is created
	 * @param {Object} [options]      Optional arguments passed to the Document.create method
	 * @return {Promise<Document>}    The imported Document instance
	 */
	async importFromCompendium(pack, id, updateData={}, options={}) {
		const cls = this.documentClass;
		if (pack.metadata.entity !== cls.documentName) {
			throw new Error(`The ${pack.documentName} Document type provided by Compendium ${pack.collection} is incorrect for this Collection`);
		}

		// Prepare the source data from which to create the Entity
		const document = await pack.getDocument(id);
		const sourceData = this.fromCompendium(document);
		const createData = foundry.utils.mergeObject(sourceData, updateData);

		// Create the Entity
		console.log(`${vtt} | Importing ${cls.documentName} ${document.name} from ${pack.collection}`);
		this.directory.activate();
		return this.documentClass.create(createData, options);
	}

	/* -------------------------------------------- */

	/**
	 * Apply data transformations when importing a Document from a Compendium pack
	 * @param {Document|object} document    The source Document, or a plain data object
	 * @return {Object}                     The processed data ready for world Document creation
	 */
	fromCompendium(document) {
		let data = document;
		if ( document instanceof foundry.abstract.Document ) {
			data = document.toObject();
			if ( !data.flags.core?.sourceId ) foundry.utils.setProperty(data, "flags.core.sourceId", document.uuid);
		}

		// Eliminate some fields that should never be preserved
		const deleteKeys = ["_id", "folder"];
		for ( let k of deleteKeys ) {
			delete data[k];
		}

		// Reset some fields to default values
		if ( "sort" in data ) data.sort = 0;
		if ( "permissions" in data ) data.permissions = {[game.user.id]: CONST.ENTITY_PERMISSIONS.OWNER};
		return data;
	}

	/* -------------------------------------------- */
	/*  DEPRECATIONS                                */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	insert(document) {
		console.warn(`The WorldCollection#insert method is deprecated in favor of the WorldCollection#set method and will be removed in 0.9.0`);
		return this.set(document.id, document);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	remove(id) {
		console.warn(`The WorldCollection#remove method is deprecated in favor of the WorldCollection#delete method and will be removed in 0.9.0`);
		return this.delete(id);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	get entities() {
		console.warn(`The WorldCollection#entities property is deprecated in favor of the Collection#contents attribute and will be removed in 0.9.0`);
		return this.contents;
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	get object() {
		console.warn("The WorldCollection#object property has been deprecated in favor of WorldCollection#documentClass. Support will be removed in 0.9.0");
		return this.documentClass;
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	importFromCollection(packName, ...args) {
		console.warn(`The WorldCollection#importFromCollection method has been deprecated in favor of WorldCollection#importFromCompendium. Support for the old method name will be removed in 0.9.0`);
		const pack = game.packs.get(packName);
		return this.importFromCompendium(pack, ...args);
	}
}

/**
 * The Collection of Actor documents which exist within the active World.
 * This Collection is accessible within the Game object as game.actors.
 * @extends {WorldCollection}
 *
 * @see {@link Actor} The Actor entity
 * @see {@link ActorDirectory} The ActorDirectory sidebar directory
 *
 * @example <caption>Retrieve an existing Actor by its id</caption>
 * let actor = game.actors.get(actorId);
 */
class Actors extends WorldCollection {
	constructor(...args) {
		super(...args);

		/**
		 * A mapping of synthetic Token Actors which are currently active within the viewed Scene.
		 * Each Actor is referenced by the Token.id.
		 * @type {Object}
		 */
		this.tokens = {};
	}

	/* -------------------------------------------- */

	/** @override */
	static documentName = "Actor";

	/* -------------------------------------------- */

	/** @inheritdoc */
	fromCompendium(document) {
		const data = super.fromCompendium(document);
		const token = foundry.utils.deepClone(game.settings.get("core", DefaultTokenConfig.SETTING));
		if ( game.system.data.primaryTokenAttribute || !token.bar1 ) {
			token.bar1 =  {"attribute": game.system.data.primaryTokenAttribute};
		}
		if ( game.system.data.secondaryTokenAttribute || !token.bar2 ) {
			token.bar2 =  {"attribute": game.system.data.secondaryTokenAttribute};
		}
		data.token = foundry.utils.mergeObject(data.token || {}, token);
		return data;
	}

	/* -------------------------------------------- */
	/*  Sheet Registration Methods                  */
	/* -------------------------------------------- */

	/**
	 * Register an Actor sheet class as a candidate which can be used to display Actors of a given type
	 * See EntitySheetConfig.registerSheet for details
	 * @static
	 *
	 * @example <caption>Register a new ActorSheet subclass for use with certain Actor types.</caption>
	 * Actors.registerSheet("dnd5e", ActorSheet5eCharacter, { types: ["character"], makeDefault: true });
	 */
	static registerSheet(...args) {
		EntitySheetConfig.registerSheet(Actor, ...args);
	}

	/* -------------------------------------------- */

	/**
	 * Unregister an Actor sheet class, removing it from the list of avaliable sheet Applications to use
	 * See EntitySheetConfig.unregisterSheet for details
	 * @static
	 *
	 * @example <caption>Deregister the default ActorSheet subclass to replace it with others.</caption>
	 * Actors.unregisterSheet("core", ActorSheet);
	 */
	static unregisterSheet(...args) {
		EntitySheetConfig.unregisterSheet(Actor, ...args)
	}

	/* -------------------------------------------- */

	/**
	 * Return an Array of currently registered sheet classes for this Entity type
	 * @type {ActorSheet[]}
	 */
	static get registeredSheets() {
		const sheets = new Set();
		for (let t of Object.values(CONFIG.Actor.sheetClasses)) {
			for (let s of Object.values(t)) {
				sheets.add(s.cls);
			}
		}
		return Array.from(sheets);
	}
}

/**
 * The Collection of Combat documents which exist within the active World.
 * This Collection is accessible within the Game object as game.combats.
 * @extends {WorldCollection}
 *
 * @see {@link Combat} The Combat entity
 * @see {@link CombatTracker} The CombatTracker sidebar directory
 */
class CombatEncounters extends WorldCollection {

	/** @override */
	static documentName = "Combat";

	/* -------------------------------------------- */

	/**
	 * Provide the settings object which configures the Combat entity
	 * @type {object}
	 */
	static get settings() {
		return game.settings.get("core", Combat.CONFIG_SETTING);
	}

	/* -------------------------------------------- */

	/**
	 * Get an Array of Combat instances which apply to the current canvas scene
	 * @type {Combat[]}
	 */
	get combats() {
		let scene = game.scenes.active;
		if ( !scene ) return [];
		return this.filter(c => c.data.scene === scene.id);
	}

	/* -------------------------------------------- */

	/**
	 * The currently active Combat instance
	 * @type {Combat}
	 */
	get active() {
		return this.combats.find(c => c.data.active);
	}

	/* -------------------------------------------- */

	/**
	 * The currently viewed Combat encounter
	 * @type {Combat|null}
	 */
	get viewed() {
		return ui.combat?.viewed ?? null;
	}

	/* -------------------------------------------- */

	/**
	 * When a Token is deleted, remove it as a combatant from any combat encounters which included the Token
	 * @param {string} sceneId      The Scene id within which a Token is being deleted
	 * @param {string} tokenId      The Token id being deleted
	 * @protected
	 */
	async _onDeleteToken(sceneId, tokenId) {
		const combats = game.combats.filter(c => c.data.scene === sceneId);
		for ( let combat of combats ) {
			if ( combat.data.scene && (combat.data.scene !== sceneId) ) continue;
			const toDelete = [];
			for ( let c of combat.combatants ) {
				if ( c.data.tokenId !== tokenId ) continue;
				toDelete.push(c.id);
			}
			if ( toDelete.length ) await combat.deleteEmbeddedDocuments("Combatant", toDelete);
		}
	}
}

/**
 * A singleton Collection of Compendium-level Document objects within the Foundry Virtual Tabletop.
 * Each Compendium pack has its own associated instance of the CompendiumCollection class which contains its contents.
 * @extends {DocumentCollection}
 * @abstract
 *
 * @param {object} metadata   The compendium metadata, an object provided by game.data
 */
class CompendiumCollection extends DocumentCollection {
	constructor(metadata) {
		super([]);

		/**
		 * The compendium metadata which defines the compendium content and location
		 * @type {object}
		 */
		this.metadata = metadata;

		/**
		 * A subsidiary collection which contains the more minimal index of the pack
		 * @type {Collection<string, object>}
		 */
		this.index = new foundry.utils.Collection();

		/**
		 * A debounced function which will clear the contents of the Compendium pack if it is not accessed frequently.
		 * @type {Function}
		 * @private
		 */
		this._flush = foundry.utils.debounce(this.clear.bind(this), this.constructor.CACHE_LIFETIME_SECONDS * 1000);

		// Asynchronously retrieve the index
		this.getIndex().then(index => {
			console.log(`${vtt} | Constructed index of Compendium pack ${this.collection} containing ${index.size} entries`);
		})

		// Define the Compendium directory application
		this.apps.push(new Compendium(this));
	}

	/* -------------------------------------------- */

	/**
	 * The amount of time that Document instances within this CompendiumCollection are held in memory.
	 * Accessing the contents of the Compendium pack extends the duration of this lifetime.
	 * @type {number}
	 */
	static CACHE_LIFETIME_SECONDS = 300;

	/**
	 * The named game setting which contains Compendium configurations.
	 * @type {string}
	 */
	static CONFIG_SETTING = "compendiumConfiguration";

	/* -------------------------------------------- */

	/**
	 * The canonical Compendium name - comprised of the originating package and the pack name
	 * @type {string}
	 */
	get collection() {
		return `${this.metadata.package}.${this.metadata.name}`
	}

	/**
	 * Access the compendium configuration data for this pack
	 * @type {object}
	 */
	get config() {
		const setting = game.settings.get("core", "compendiumConfiguration");
		return setting[this.collection] || {};
	}

	/** @inheritdoc */
	get documentName() {
		return this.metadata.entity;
	}

	/**
	 * Track whether the Compendium Collection is locked for editing
	 * @type {boolean}
	 */
	get locked() {
		return this.config.locked ?? (this.metadata.package !== "world");
	}

	/**
	 * Track whether the Compendium Collection is private
	 * @type {boolean}
	 */
	get private() {
		return this.config.private ?? this.metadata.private;
	}

	/**
	 * A convenience reference to the label which should be used as the title for the Compendium pack.
	 * @type {string}
	 */
	get title() {
		return this.metadata.label;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/** @inheritdoc */
	get(key, options) {
		this._flush();
		return super.get(key, options);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	set(id, document) {
		this._flush();
		this.indexDocument(document);
		return super.set(id, document);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	delete(id) {
		this.index.delete(id);
		return super.delete(id);
	}

	/* -------------------------------------------- */

	/**
	 * Load the Compendium index and cache it as the keys and values of the Collection.
	 * @returns {Promise<Collection>}
	 */
	async getIndex() {
		const cls = this.documentClass;
		const index = await cls.database.get(cls, {
			query: {},
			options: {index: true},
			pack: this.collection,
		}, game.user);

		// Assign the index to the collection
		for ( let i of index ) {
			if ( i.thumb ) {
				i.img = i.thumb;
				delete i.thumb;
			}
			this.index.set(i._id, i);
		}
		return this.index;
	}

	/* -------------------------------------------- */

	/**
	 * Get a single Document from this Compendium by ID.
	 * The document may already be locally cached, otherwise it is retrieved from the server.
	 * @param {string} id               The requested Document id
	 * @returns {Promise<Document>|undefined}     The retrieved Document instance
	 */
	async getDocument(id) {
		if ( !id ) return undefined;
		const cached = this.get(id);
		if ( cached instanceof foundry.abstract.Document ) return cached;
		const documents = await this.getDocuments({_id: id});
		return documents.length ? documents.shift() : null;
	}

	/* -------------------------------------------- */

	/**
	 * Load multiple documents from the Compendium pack using a provided query object.
	 * @param {object} query            A database query used to retrieve documents from the underlying database
	 * @returns {Promise<Document[]>}   The retrieved Document instances
	 */
	async getDocuments(query={}) {
		const cls = this.documentClass;
		const documents = await cls.database.get(cls, {
			query: query,
			pack: this.collection,
		}, game.user);
		for ( let d of documents ) {
			this.set(d.id, d);
		}
		return documents;
	}

	/* -------------------------------------------- */

	/**
	 * Import a Document into this Compendium Collection.
	 * @param {Document} document     The existing Document you wish to import
	 * @return {Promise<Document>}   The imported Document instance
	 */
	importDocument(document) {
		if ( !(document instanceof this.documentClass) ) {
			const err = Error(`You may not import a ${document.documentName} Document into the ${this.collection} Compendium which contains ${this.documentName} Documents.`);
			ui.notifications.error(err.message);
			throw err;
		}
		return this.documentClass.create(document.toCompendium(this), {pack: this.collection});
	}

	/* -------------------------------------------- */

	/**
	 * Fully import the contents of a Compendium pack into a World folder.
	 * @param {string|null} [folderId]  An existing Folder _id to use.
	 * @param {string} [folderName]     A new Folder name to create.
	 * @param {object} [options]        Additional options forwarded to Document.createDocuments
	 * @return {Promise<Document[]>}    The imported Documents, now existing within the World
	 */
	async importAll({folderId=null, folderName="", options={}}={}) {

		// Optionally, create a folder
		if ( CONST.FOLDER_ENTITY_TYPES.includes(this.documentName) ) {
			const f = folderId ? game.folders.get(folderId, {strict: true}) : await Folder.create({
				name: folderName || this.title,
				type: this.documentName,
				parent: null
			});
			folderId = f.id;
			folderName = f.name;
		}

		// Load all content
		const documents = await this.getDocuments();
		ui.notifications.info(game.i18n.format("COMPENDIUM.ImportAllStart", {
			number: documents.length,
			type: this.documentName,
			folder: folderName
		}));

		// Prepare import data
		const collection = game.collections.get(this.documentName);
		const createData = documents.map(doc => {
			const data = collection.fromCompendium(doc);
			data.folder = folderId;
			return data;
		})

		// Create World Documents in batches
		const chunkSize = 100;
		const nBatches = Math.ceil(createData.length / chunkSize);
		let created = [];
		for ( let n=0; n<nBatches; n++ ) {
			const chunk = createData.slice(n*chunkSize, (n+1)*chunkSize);
			const docs = await this.documentClass.createDocuments(chunk, options);
			created = created.concat(docs);
		}

		// Notify of success
		ui.notifications.info(game.i18n.format("COMPENDIUM.ImportAllFinish", {
			number: created.length,
			type: this.documentName,
			folder: folderName
		}));
		return created;
	}

	/* -------------------------------------------- */

	/**
	 * Add a Document to the index, capturing it's relevant index attributes
	 * @param {Document} document       The document to index
	 */
	indexDocument(document) {
		const img = document.data.thumb ?? document.data.img;
		this.index.set(document.id, {_id: document.id, name: document.name, type: document.type, img});
	}

	/* -------------------------------------------- */
	/*  Compendium Management                       */
	/* -------------------------------------------- */

	/**
	 * Create a new Compendium Collection using provided metadata.
	 * @param {object} metadata   The compendium metadata used to create the new pack
	 * @param {object} options   Additional options which modify the Compendium creation request
	 * @return {Promise<CompendiumCollection>}
	 */
	static async createCompendium(metadata, options={}) {
		if ( !game.user.isGM ) return ui.notifications.error("You do not have permission to modify this compendium pack");
		const response = await SocketInterface.dispatch("manageCompendium", {
			action: "create",
			data: metadata,
			options: options
		});

		// Add the new pack to the World
		game.data.packs.push(response.result);
		const pack = new CompendiumCollection(response.result);
		game.packs.set(pack.collection, pack);
		ui.compendium.render();
		return pack;
	}

	/* ----------------------------------------- */

	/**
	 * Assign configuration metadata settings to the compendium pack
	 * @param {object} settings   The object of compendium settings to define
	 * @return {Promise}          A Promise which resolves once the setting is updated
	 */
	configure(settings={}) {
		const config = game.settings.get("core", this.constructor.CONFIG_SETTING);
		const pack = config[this.collection] || {private: false, locked: this.metadata.package !== "world"};
		config[this.collection] = foundry.utils.mergeObject(pack, settings);
		return game.settings.set("core", this.constructor.CONFIG_SETTING, config);
	}
	/* ----------------------------------------- */


	/**
	 * Delete an existing world-level Compendium Collection.
	 * This action may only be performed for world-level packs by a Gamemaster User.
	 * @return {Promise<CompendiumCollection>}
	 */
	async deleteCompendium() {
		this._assertUserCanModify();
		this.apps.forEach(app => app.close());
		await SocketInterface.dispatch("manageCompendium", {
			action: "delete",
			data: this.metadata.name
		});

		// Remove the pack from the game World
		game.data.packs.findSplice(p => (p.package === "world") && (p.name === this.metadata.name) );
		game.packs.delete(this.collection);
		ui.compendium.render();
		return this;
	}

	/* ----------------------------------------- */

	/**
	 * Duplicate a compendium pack to the current World.
	 * @param {string} label    A new Compendium label
	 * @return {Promise<CompendiumCollection>}
	 */
	async duplicateCompendium({label}={}) {
		this._assertUserCanModify({requireUnlocked: false});
		label = label || this.title;
		const metadata = foundry.utils.mergeObject(this.metadata, {
			name: label.slugify({strict: true}),
			label: label
		}, {inplace: false});
		return this.constructor.createCompendium(metadata, {source: this.collection});
	}

	/* ----------------------------------------- */

	/**
	 * Validate that the current user is able to modify content of this Compendium pack
	 * @return {boolean}
	 * @private
	 */
	_assertUserCanModify({requireUnlocked=true}={}) {
		const config = game.settings.get("core", this.constructor.CONFIG_SETTING)[this.collection] || {};
		let err;
		if ( !game.user.isGM ) err = new Error("You do not have permission to modify this compendium pack");
		if ( requireUnlocked && config.locked ) {
			err = new Error(`You cannot modify content in this compendium pack because it is locked.`);
		}
		if ( err ) {
			ui.notifications.error(err.message);
			throw err;
		}
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Request that a Compendium pack be migrated to the latest System data template
	 * @return {Promise<CompendiumCollection>}
	 */
	async migrate(options={}) {
		this._assertUserCanModify();
		ui.notifications.info(`Beginning migration for Compendium pack ${this.collection}, please be patient.`);
		await SocketInterface.dispatch("manageCompendium", {
			type: this.collection,
			action: "migrate",
			data: this.collection,
			options: options
		});
		ui.notifications.info(`Successfully migrated Compendium pack ${this.collection}.`);
		return this;
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_onCreateDocuments(documents, result, options, userId) {
		super._onCreateDocuments(documents, result, options, userId);
		this._onModifyContents(documents, options, userId);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onUpdateDocuments(documents, result, options, userId) {
		super._onUpdateDocuments(documents, result, options, userId);
		this._onModifyContents(documents, options, userId);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDeleteDocuments(documents, result, options, userId) {
		super._onDeleteDocuments(documents, result, options, userId);
		this._onModifyContents(documents, options, userId);
	}

	/* -------------------------------------------- */

	/**
	 * Follow-up actions taken when Documents within this Compendium pack are modified
	 * @private
	 */
	_onModifyContents(documents, options, userId) {
		/**
		 * A hook event that fires whenever the contents of a Compendium pack were modified.
		 * This hook fires for all connected clients after the update has been processed.
		 *
		 * @function updateCompendium
		 * @memberof hookEvents
		 * @param {CompendiumCollection} pack   The Compendium pack being modified
		 * @param {Document[]} documents        The locally-cached Documents which were modified in the operation
		 * @param {object} options              Additional options which modified the modification request
		 * @param {string} userId               The ID of the User who triggered the modification workflow
		 */
		Hooks.callAll("updateCompendium", this, documents, options, userId);
	}

	/* -------------------------------------------- */
	/*  Deprecations                                */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.9.0
	 * @ignore
	 */
	get entity() {
		console.warn("You are calling CompendiumCollection#entity which has been deprecated in favor of CompendiumCollection#documentClass#documentName. Support will be removed in 0.9.0.");
		return this.documentClass.documentName;
	}

	/**
	 * @deprecated since 0.9.0
	 * @ignore
	 */
	async getContent() {
		console.warn("You are calling CompendiumCollection#getContent which has been renamed to of CompendiumCollection#getDocuments. Support will be removed in 0.9.0.");
		return this.getDocuments();
	}

	/**
	 * @deprecated since 0.9.0
	 * @ignore
	 */
	async getEntry(id) {
		console.warn("You are calling CompendiumCollection#getEntry which has been deprecated in favor of CompendiumCollection#getDocument. Support will be removed in 0.9.0.");
		const document = await this.getDocument(id);
		return document.data;
	}

	/**
	 * @deprecated since 0.9.0
	 * @ignore
	 */
	async getEntity(id) {
		console.warn("You are calling CompendiumCollection#getEntity which has been renamed to CompendiumCollection#getDocument. Support will be removed in 0.9.0.");
		return this.getDocument(id);
	}

	/**
	 * @deprecated since 0.9.0
	 * @ignore
	 */
	async importEntity(document) {
		console.warn("You are calling CompendiumCollection#importEntity which has been renamed to CompendiumCollection#importDocument. Support will be removed in 0.9.0.");
		return this.importDocument(document);
	}

	/**
	 * @deprecated since 0.9.0
	 * @ignore
	 */
	async createEntity(data, options={}) {
		console.warn("You are calling CompendiumCollection#createEntity which has been deprecated in favor of Document.create. Support will be removed in 0.9.0");
		options.pack = this.collection;
		return this.documentClass.create(data, options);
	}

	/**
	 * @deprecated since 0.9.0
	 * @ignore
	 */
	async updateEntity(data, options={}) {
		console.warn("You are calling CompendiumCollection#updateEntity which has been deprecated in favor of Document#update. Support will be removed in 0.9.0");
		const document = await this.getDocument(data._id);
		options.pack = this.collection;
		return document.update(data, options);
	}

	/**
	 * @deprecated since 0.9.0
	 * @ignore
	 */
	async deleteEntity(id, options={}) {
		console.warn("You are calling CompendiumCollection#deleteEntity which has been deprecated in favor of Document#delete. Support will be removed in 0.9.0");
		const document = await this.getDocument(id);
		options.pack = this.collection;
		return document.delete(options);
	}
}

/**
 * The Collection of FogExploration documents which exist within the active World.
 * This Collection is accessible within the Game object as game.fog.
 * @extends {WorldCollection}
 *
 * @see {@link FogExploration} The FogExploration document
 */
class FogExplorations extends WorldCollection {
	static documentName = "FogExploration";
}

/**
 * The Collection of Folder documents which exist within the active World.
 * This Collection is accessible within the Game object as game.folders.
 * @extends {WorldCollection}
 *
 * @see {@link Folder} The Folder entity
 */
class Folders extends WorldCollection {
	constructor(...args) {
		super(...args);

		/**
		 * Track which Folders are currently expanded in the UI
		 */
		this._expanded = {};
	}

	/* -------------------------------------------- */

	/** @override */
	static documentName = "Folder";

	/* -------------------------------------------- */

	/** @override */
	render(force, context) {
		if ( context && context.entities.length ) {
			const folder = context.entities[0];
			const collection = game.collections.get(folder.type);
			collection.render(force, context);
			if ( collection.entity === "JournalEntry" ) {
				this._refreshJournalEntrySheets();
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the display of any active JournalSheet instances where the folder list will change.
	 * @private
	 */
	_refreshJournalEntrySheets() {
		for ( let app of Object.values(ui.windows) ) {
			if ( !(app instanceof JournalSheet) ) continue;
			app.submit();
		}
	}
}

/**
 * The Collection of Item documents which exist within the active World.
 * This Collection is accessible within the Game object as game.items.
 * @extends {WorldCollection}
 *
 * @see {@link Item} The Item entity
 * @see {@link ItemDirectory} The ItemDirectory sidebar directory
 */
class Items extends WorldCollection {

	/** @override */
	static documentName = "Item";

	/* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */

	/**
	 * Register an Actor sheet class as a candidate which can be used to display Actors of a given type
	 * See EntitySheetConfig.registerSheet for details
	 */
	static registerSheet(...args) {
		EntitySheetConfig.registerSheet(Item, ...args);
	}

	/* -------------------------------------------- */

	/**
	 * Unregister an Actor sheet class, removing it from the list of avaliable sheet Applications to use
	 * See EntitySheetConfig.unregisterSheet for details
	 */
	static unregisterSheet(...args) {
		EntitySheetConfig.unregisterSheet(Item, ...args)
	}

	/* -------------------------------------------- */

	/**
	 * Return an Array of currently registered sheet classes for this Entity type
	 * @type {ItemSheet[]}
	 */
	static get registeredSheets() {
		const sheets = new Set();
		for (let t of Object.values(CONFIG.Item.sheetClasses)) {
			for (let s of Object.values(t)) {
				sheets.add(s.cls);
			}
		}
		return Array.from(sheets);
	}
}

/**
 * The Collection of JournalEntry documents which exist within the active World.
 * This Collection is accessible within the Game object as game.journal.
 * @extends {WorldCollection}
 *
 * @see {@link JournalEntry} The JournalEntry entity
 * @see {@link JournalDirectory} The JournalDirectory sidebar directory
 */
class Journal extends WorldCollection {

	/** @override */
	static documentName = "JournalEntry";

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/**
	 * Open Socket listeners which transact JournalEntry data
	 */
	static _activateSocketListeners(socket) {
		socket.on("showEntry", this._showEntry.bind(this));
		socket.on("shareImage", ImagePopout._handleShareImage);
	}

	/* -------------------------------------------- */

	/**
	 * Handle a received request to show a JournalEntry to the current client
	 * @param {string} entryId      The ID of the journal entry to display for other players
	 * @param {string} mode         The JournalEntry mode to display
	 * @param {boolean} force       Display the entry to all players regardless of normal permissions
	 * @private
	 */
	static async _showEntry(entryId, mode="text", force=true) {
		let entry = await fromUuid(entryId);
		if ( entry.entity !== "JournalEntry" ) return;
		if ( !force && !entry.visible ) return;

		// Don't show an entry that has no content
		if ( mode === "image" && !entry.data.img ) return;
		else if ( mode === "text" && !entry.data.content ) return;

		// Show the sheet with the appropriate mode
		entry.sheet.render(true, {sheetMode: mode});
	}
}

/**
 * The Collection of Macro documents which exist within the active World.
 * This Collection is accessible within the Game object as game.macros.
 * @extends {WorldCollection}
 *
 * @see {@link Macro} The Macro entity
 * @see {@link MacroDirectory} The MacroDirectory sidebar directory
 */
class Macros extends WorldCollection {

	/** @override */
	static documentName = "Macro";

	/* -------------------------------------------- */

	/** @override */
	get directory() {
		return ui.macros;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	fromCompendium(document) {
		const data = super.fromCompendium(document);
		data.author = game.user.id;
		return data;
	}

	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.1
	 * @ignore
	 */
	static canUseScripts(user) {
		console.warn("You are calling Macros.canUseScripts which has been deprecated in favor of User#can('MACRO_SCRIPT')");
		return game.user.can("MACRO_SCRIPT");
	}
}

/**
 * The Collection of ChatMessage documents which exist within the active World.
 * This Collection is accessible within the Game object as game.messages.
 * @extends {WorldCollection}
 *
 * @see {@link ChatMessage} The ChatMessage entity
 * @see {@link ChatLog} The ChatLog sidebar directory
 */
class Messages extends WorldCollection {

	/** @override */
	static documentName = "ChatMessage";

	/* -------------------------------------------- */

	/** @override */
	render(force=false) {}

	/* -------------------------------------------- */

	/**
	 * If requested, dispatch a Chat Bubble UI for the newly created message
	 * @param {ChatMessage} message     The ChatMessage entity to say
	 * @private
	 */
	sayBubble(message) {
		const {content, type, speaker} = message.data;
		if ( speaker.scene === canvas.scene.id ) {
			const token = canvas.tokens.get(speaker.token);
			if ( token ) canvas.hud.bubbles.say(token, content, {
				emote: type === CONST.CHAT_MESSAGE_TYPES.EMOTE
			});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle export of the chat log to a text file
	 * @private
	 */
	export() {
		const log = this.contents.map(m => m.export()).join("\n---------------------------\n");
		let date = new Date().toDateString().replace(/\s/g, "-");
		const filename = `fvtt-log-${date}.txt`;
		saveDataToFile(log, "text/plain", filename);
	}

	/* -------------------------------------------- */

	/**
	 * Allow for bulk deletion of all chat messages, confirm first with a yes/no dialog.
	 * @see {@link Dialog.confirm}
	 */
	async flush() {
		return Dialog.confirm({
			title: game.i18n.localize("CHAT.FlushTitle"),
			content: `<h4>${game.i18n.localize("AreYouSure")}</h4><p>${game.i18n.localize("CHAT.FlushWarning")}</p>`,
			yes: () => this.documentClass.deleteDocuments([], {deleteAll: true}),
			options: {
				top: window.innerHeight - 150,
				left: window.innerWidth - 720
			}
		});
	}
}

/**
 * The Collection of Playlist documents which exist within the active World.
 * This Collection is accessible within the Game object as game.playlists.
 * @extends {WorldCollection}
 *
 * @see {@link Playlist} The Playlist entity
 * @see {@link PlaylistDirectory} The PlaylistDirectory sidebar directory
 */
class Playlists extends WorldCollection {
	constructor(...args) {
		super(...args);
		this.initialize();
	}

	/* -------------------------------------------- */

	/** @override */
	static documentName = "Playlist";

	/* -------------------------------------------- */

	/**
	 * Return the subset of Playlist entities which are currently playing
	 * @type {Playlist[]}
	 */
	get playing() {
		return this.filter(s => s.data.playing);
	}

	/* -------------------------------------------- */

	/**
	 * Perform one-time initialization to begin playback of audio
	 */
	initialize() {
		for ( let playlist of this ) {
			for ( let sound of playlist.sounds ) {
				sound.sync();
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle changes to a Scene to determine whether to trigger changes to Playlist entities.
	 * @param {Scene} scene       The Scene entity being updated
	 * @param {Object} data       The incremental update data
	 */
	async _onChangeScene(scene, data) {
		const currentScene = game.scenes.active;

		// Deactivate the current scene
		if (currentScene) {
			const p0 = currentScene.playlist;
			const s0 = currentScene.playlistSound;
			if (s0) await s0.update({playing: false});
			else if (p0) await p0.stopAll();
		}

		// Activate a new Scene
		if (data.active !== false) {
			const p1 = ("playlist" in data) ? game.playlists.get(data.playlist) : scene.playlist;
			if (!p1) return;
			const s1 = p1.sounds.get("playlistSound" in data ? data.playlistSound : scene.data.playlistSound);
			if (s1) await s1.update({playing: true});
			else if (p1) await p1.playAll();
		}
	}
}

/**
 * The Collection of Scene documents which exist within the active World.
 * This Collection is accessible within the Game object as game.scenes.
 * @extends {WorldCollection}
 *
 * @see {@link Scene} The Scene entity
 * @see {@link SceneDirectory} The SceneDirectory sidebar directory
 */
class Scenes extends WorldCollection {

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/** @override */
	static documentName = "Scene";

	/* -------------------------------------------- */

	/**
	 * Return a reference to the Scene which is currently active
	 * @return {Scene}
	 */
	get active() {
		return this.find(s => s.active);
	}

	/* -------------------------------------------- */

	/**
	 * Return the current Scene target.
	 * This is the viewed scene if the canvas is active, otherwise it is the currently active scene.
	 * @returns {Scene}
	 */
	get current() {
		return canvas.ready ? this.viewed : this.active;
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the Scene which is currently viewed
	 * @return {Scene}
	 */
	get viewed() {
		return this.find(s => s.isView);
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Handle pre-loading the art assets for a Scene
	 * @param {string} sceneId    The Scene id to begin loading
	 * @param {boolean} push      Trigger other connected clients to also pre-load Scene resources
	 */
	async preload(sceneId, push=false) {
		if ( push ) return game.socket.emit('preloadScene', sceneId, () => this.preload(sceneId));
		let scene = this.get(sceneId);
		const promises = [];

		// Preload sounds
		if ( scene.playlistSound?.data.path ) promises.push(AudioHelper.preloadSound(scene.playlistSound.data.path));
		else if ( scene.playlist?.playbackOrder.length ) {
			const first = scene.playlist.sounds.get(scene.playlist.playbackOrder[0]);
			if ( first ) promises.push(AudioHelper.preloadSound(first.data.path))
		}

		// Preload textures without expiring current ones
		promises.push(TextureLoader.loadSceneTextures(scene, {expireCache: false}));
		return Promise.all(promises);
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @override */
	static _activateSocketListeners(socket) {
		socket.on('modifyDocument', this._resetFog.bind(this));
		socket.on('preloadScene', sceneId => this.instance.preload(sceneId));
		socket.on('pullToScene', this._pullToScene);
	}

	/* -------------------------------------------- */

	/**
	 * Augment the standard modifyDocument listener to flush fog exploration
	 * @private
	 */
	static _resetFog(response) {
		const { request, result } = response;
		if ( (request.type === "FogExploration") && ( request.action === "delete" ) && result.reset && (result.scene === canvas.scene.id) ) {
			return canvas.sight._onResetFog(result);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle requests pulling the current User to a specific Scene
	 * @param {string} sceneId
	 * @private
	 */
	static _pullToScene(sceneId) {
		const scene = game.scenes.get(sceneId);
		if ( scene ) scene.view();
	}

	/* -------------------------------------------- */
	/*  Importing and Exporting                     */
	/* -------------------------------------------- */

	/** @inheritdoc */
	fromCompendium(document) {
		const data = super.fromCompendium(document);
		data.active = false;
		data.navigation = false;
		data.navOrder = 0;
		return data;
	}
}
/**
 * The Collection of Setting documents which exist within the active World.
 * This collection is accessible as game.settings.storages.get("world")
 * @extends {WorldCollection}
 *
 * @see {@link Setting} The Setting document
 * @see {@link RollTableDirectory} The RollTableDirectory sidebar directory
 */
class WorldSettings extends WorldCollection {

	/** @override */
	static documentName = "Setting";

	/* -------------------------------------------- */

	/** @override */
	get directory() {
		return null;
	}

	/* -------------------------------------------- */
	/* World Settings Methods                       */
	/* -------------------------------------------- */

	/**
	 * Return the serialized value of the world setting as a string
	 * @param {string} key    The setting key
	 * @return {string}       The serialized setting string
	 */
	getSetting(key) {
		return this.find(s => s.key === key);
	}

	/**
	 * Return the serialized value of the world setting as a string
	 * @param {string} key    The setting key
	 * @return {string}       The serialized setting string
	 */
	getItem(key) {
		const setting = this.getSetting(key);
		return setting?.data.value ?? null;
	}
}

/**
 * The Collection of RollTable documents which exist within the active World.
 * This Collection is accessible within the Game object as game.tables.
 * @extends {WorldCollection}
 *
 * @see {@link RollTable} The RollTable document
 * @see {@link RollTableDirectory} The RollTableDirectory sidebar directory
 */
class RollTables extends WorldCollection {

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/** @override */
	static documentName = "RollTable";

	/* -------------------------------------------- */

	/** @override */
	get directory() {
		return ui.tables;
	}

	/* -------------------------------------------- */

	/**
	 * Register world settings related to RollTable entities
	 */
	static registerSettings() {

		// Show Player Cursors
		game.settings.register("core", "animateRollTable", {
			name: "TABLE.AnimateSetting",
			hint: "TABLE.AnimateSettingHint",
			scope: "world",
			config: true,
			default: true,
			type: Boolean
		});
	}
}

/**
 * The Collection of User documents which exist within the active World.
 * This Collection is accessible within the Game object as game.users.
 * @extends {WorldCollection}
 *
 * @see {@link User} The User entity
 * @see {@link UserDirectory} The UserDirectory sidebar directory
 */
class Users extends WorldCollection {
	constructor(...args) {
		super(...args);

		/**
		 * The User entity of the currently connected user
		 * @type {User|null}
		 */
		this.current = this.current || null;
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the Map object and all its contained entities
	 * @param {Object[]} data
	 * @private
	 */
	_initialize(data) {
		super._initialize(data);

		// Flag the current user
		this.current = this.get(game.data.userId) || null;
		if ( this.current ) this.current.active = true;

		// Set initial user activity state
		for ( let activeId of game.data.activeUsers || [] ) {
			this.get(activeId).active = true;
		}
	}

	/* -------------------------------------------- */

	/** @override */
	static documentName = "User";

	/* -------------------------------------------- */

	/**
	 * Get the users with player roles
	 * @return {User[]}
	 */
	get players() {
		return this.filter(u => !u.isGM && u.hasRole("PLAYER"));
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/** @override */
	static _activateSocketListeners(socket) {
		socket.on('userActivity', this._handleUserActivity)
	}

	/* -------------------------------------------- */

	/**
	 * Handle receipt of activity data from another User connected to the Game session
	 * @param {string} userId         The User id who generated the activity data
	 * @param {Object} activityData   The object of activity data
	 * @private
	 */
	static _handleUserActivity(userId, activityData={}) {
		const user = game.users.get(userId);
		if ( !user ) return;

		// Update User active state
		let active = "active" in activityData ? activityData.active : true;
		if ( user.active !== active ) {
			user.active = active;
			game.users.render();
			if ( (active === false) && ui.nav ) ui.nav.render();
		}

		// Everything below here requires the game to be ready
		if ( !game.ready ) return;

		// Set viewed scene
		const sceneChange = ("sceneId" in activityData) && (activityData.sceneId !== user.viewedScene)
		if ( sceneChange ) {
			user.viewedScene = activityData.sceneId;
			ui.nav.render();
		}

		// Everything below requires an active canvas
		if ( !canvas.ready ) return;

		// User control deactivation
		if ( canvas.ready && ((active === false) || (user.viewedScene !== canvas.id)) ) {
			canvas.controls.updateCursor(user, null);
			canvas.controls.updateRuler(user, null);
			user.updateTokenTargets([]);
			return;
		}

		// Cursor position
		if ( "cursor" in activityData ) {
			canvas.controls.updateCursor(user, activityData.cursor);
		}

		// Ruler measurement
		if ( "ruler" in activityData ) {
			canvas.controls.updateRuler(user, activityData.ruler);
		}

		// Token targets
		if ( "targets" in activityData ) {
			user.updateTokenTargets(activityData.targets);
		}
	}
}

/**
 * The ActiveEffect embedded document within an Actor or Item document which extends the BaseRollTable abstraction.
 * Each ActiveEffect belongs to the effects collection of its parent Document.
 * Each ActiveEffect contains a ActiveEffectData object which provides its source data.
 *
 * @extends abstract.Document
 * @extends abstract.BaseActiveEffect
 * @extends ClientDocumentMixin
 *
 * @see {@link data.ActiveEffectData}               The ActiveEffect data schema
 * @see {@link documents.Actor}                     The Actor document which contains ActiveEffect embedded documents
 * @see {@link documents.Item}                      The Item document which contains ActiveEffect embedded documents
 *
 * @param {ActiveEffectData} [data={}]    Initial data provided to construct the ActiveEffect document
 * @param {Actor|documents.Item} parent   The parent document to which this ActiveEffect belongs
 */
class ActiveEffect extends ClientDocumentMixin(foundry.documents.BaseActiveEffect) {
	constructor(data, context) {
		super(data, context);

		/**
		 * A cached reference to the source name to avoid recurring database lookups
		 * @type {string|null}
		 */
		this._sourceName = null;

		/**
		 * A cached reference to the ActiveEffectConfig instance which configures this effect
		 * @type {ActiveEffectConfig|null}
		 */
		this._sheet = null;
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * Summarize the active effect duration
	 * @type {{type: string, duration: number|null, remaining: number|null, label: string}}
	 */
	get duration() {
		const d = this.data.duration;

		// Time-based duration
		if ( Number.isNumeric(d.seconds) ) {
			const start = (d.startTime || game.time.worldTime);
			const elapsed = game.time.worldTime - start;
			const remaining = d.seconds - elapsed;
			return {
				type: "seconds",
				duration: d.seconds,
				remaining: remaining,
				label: `${remaining} Seconds`
			};
		}

		// Turn-based duration
		else if ( d.rounds || d.turns ) {

			// Determine the current combat duration
			const cbt = game.combat;
			const c = {round: cbt?.round ?? 0, turn: cbt?.turn ?? 0, nTurns: cbt?.turns.length ?? 1};
			const current = this._getCombatTime(c.round, c.turn);
			const duration = this._getCombatTime(d.rounds, d.turns);
			const start = this._getCombatTime(d.startRound, d.startTurn, c.nTurns);

			// If the effect has not started yet display the full duration
			if ( current <= start ) {
				return {
					type: "turns",
					duration: duration,
					remaining: duration,
					label: this._getDurationLabel(d.rounds, d.turns)
				}
			}

			// Some number of remaining rounds and turns (possibly zero)
			const remaining = Math.max(((start + duration) - current).toNearest(0.01), 0);
			const remainingRounds = Math.floor(remaining);
			const remainingTurns = Math.min(((remaining - remainingRounds) * 100).toNearest(0.01), c.nTurns-1);
			return {
				type: "turns",
				duration: duration,
				remaining: remaining,
				label: this._getDurationLabel(remainingRounds, remainingTurns)
			}
		}

		// No duration
		else return {
			type: "none",
			duration: null,
			remaining: null,
			label: game.i18n.localize("None")
		}
	}

	/* -------------------------------------------- */

	/**
	 * Format a round+turn combination as a decimal
	 * @param {number} round    The round number
	 * @param {number} turn     The turn number
	 * @param {number} [nTurns] The maximum number of turns in the encounter
	 * @returns {number}        The decimal representation
	 * @private
	 */
	_getCombatTime(round, turn, nTurns) {
		if ( nTurns !== undefined ) turn = Math.min(turn, nTurns)
		round = Math.max(round, 0);
		turn = Math.max(turn, 0);
		return (round || 0) + ((turn || 0) / 100);
	}

	/* -------------------------------------------- */

	/**
	 * Format a number of rounds and turns into a human-readable duration label
	 * @param {number} rounds   The number of rounds
	 * @param {number} turns    The number of turns
	 * @returns {string}        The formatted label
	 * @private
	 */
	_getDurationLabel(rounds, turns) {
		const parts = [];
		if ( rounds > 0 ) parts.push(`${rounds} ${game.i18n.localize(rounds === 1 ? "COMBAT.Round": "COMBAT.Rounds")}`);
		if ( turns > 0 ) parts.push(`${turns} ${game.i18n.localize(turns === 1 ? "COMBAT.Turn": "COMBAT.Turns")}`);
		if (( rounds + turns ) === 0 ) parts.push(game.i18n.localize("None"));
		return parts.filterJoin(", ");
	}

	/* -------------------------------------------- */

	/**
	 * Describe whether the ActiveEffect has a temporary duration based on combat turns or rounds.
	 * @type {boolean}
	 */
	get isTemporary() {
		const duration = this.data.duration.seconds ?? (this.data.duration.rounds || this.data.duration.turns) ?? 0;
		return (duration > 0) || this.getFlag("core", "statusId");
	}

	/* -------------------------------------------- */

	/**
	 * A cached property for obtaining the source name
	 * @type {string}
	 */
	get sourceName() {
		if ( this._sourceName === null ) this._getSourceName();
		return this._sourceName ?? "Unknown";
	}

	/* -------------------------------------------- */

	/**
	 * An instance of the ActiveEffectConfig sheet to use for this ActiveEffect instance.
	 * The reference to the sheet is cached so the same sheet instance is reused.
	 * @type {ActiveEffectConfig}
	 */
	get sheet() {
		if ( !this._sheet ) {
			const cls = CONFIG.ActiveEffect.sheetClass;
			this._sheet = new cls(this);
		}
		return this._sheet;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Apply this ActiveEffect to a provided Actor.
	 * @param {Actor} actor                   The Actor to whom this effect should be applied
	 * @param {data.EffectChangeData} change  The change data being applied
	 * @return {*}                            The resulting applied value
	 */
	apply(actor, change) {
		const modes = CONST.ACTIVE_EFFECT_MODES;
		switch ( change.mode ) {
			case modes.CUSTOM:
				return this._applyCustom(actor, change);
			case modes.ADD:
				return this._applyAdd(actor, change);
			case modes.MULTIPLY:
				return this._applyMultiply(actor, change);
			case modes.OVERRIDE:
				return this._applyOverride(actor, change);
			case modes.UPGRADE:
			case modes.DOWNGRADE:
				return this._applyUpgrade(actor, change);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Apply an ActiveEffect that uses an ADD application mode.
	 * The way that effects are added depends on the data type of the current value.
	 *
	 * If the current value is null, the change value is assigned directly.
	 * If the current type is a string, the change value is concatenated.
	 * If the current type is a number, the change value is cast to numeric and added.
	 * If the current type is an array, the change value is appended to the existing array if it matches in type.
	 *
	 * @param {Actor} actor                   The Actor to whom this effect should be applied
	 * @param {data.EffectChangeData} change  The change data being applied
	 * @return {*}                            The resulting applied value
	 * @private
	 */
	_applyAdd(actor, change) {
		const {key, value} = change;
		const current = foundry.utils.getProperty(actor.data, key) ?? null;
		const ct = foundry.utils.getType(current);
		let update = null;

		// Handle different types of the current data
		switch ( ct ) {
			case "null":
				update = value;
				break;
			case "string":
				update = current + String(value);
				break;
			case "number":
				if ( Number.isNumeric(value) ) update = current + Number(value);
				break;
			case "Array":
				const at = foundry.utils.getType(current[0]);
				if ( !current.length || (foundry.utils.getType(value) === at) ) update = current.concat([value]);
		}
		if ( update !== null ) foundry.utils.setProperty(actor.data, key, update);
		return update;
	}

	/* -------------------------------------------- */

	/**
	 * Apply an ActiveEffect that uses a MULTIPLY application mode.
	 * Changes which MULTIPLY must be numeric to allow for multiplication.
	 * @param {Actor} actor                   The Actor to whom this effect should be applied
	 * @param {data.EffectChangeData} change  The change data being applied
	 * @return {*}                            The resulting applied value
	 * @private
	 */
	_applyMultiply(actor, change) {
		const {key, value} = change;
		const current = foundry.utils.getProperty(actor.data, key);
		if ( (typeof(current) !== "number") || !Number.isNumeric(value ) ) return null;
		const update = current * Number(value);
		foundry.utils.setProperty(actor.data, key, update);
		return update;
	}

	/* -------------------------------------------- */

	/**
	 * Apply an ActiveEffect that uses an OVERRIDE application mode.
	 * Numeric data is overridden by numbers, while other data types are overridden by any value
	 * @param {Actor} actor                   The Actor to whom this effect should be applied
	 * @param {data.EffectChangeData} change  The change data being applied
	 * @return {*}                            The resulting applied value
	 * @private
	 */
	_applyOverride(actor, change) {
		const {key, value} = change;
		const current = foundry.utils.getProperty(actor.data, key);
		let update = value;
		switch ( foundry.utils.getType(current) ) {
			case "number":
				if (!Number.isNumeric(value)) return null;
				update = Number(value);
				break;
			case "string":
				update = String(value);
				break;
			case "Array":
				if (!(value instanceof Array)) return null;
				break;
		}
		foundry.utils.setProperty(actor.data, key, update);
		return update;
	}

	/* -------------------------------------------- */

	/**
	 * Apply an ActiveEffect that uses an UPGRADE, or DOWNGRADE application mode.
	 * Changes which UPGRADE or DOWNGRADE must be numeric to allow for comparison.
	 * @param {Actor} actor                   The Actor to whom this effect should be applied
	 * @param {data.EffectChangeData} change  The change data being applied
	 * @return {*}                            The resulting applied value
	 * @private
	 */
	_applyUpgrade(actor, change) {
		let {key, value, mode} = change;
		const current = foundry.utils.getProperty(actor.data, key);
		if ( (typeof(current) !== "number") || !Number.isNumeric(value ) ) return null;
		value = Number(value);
		if ( (mode === CONST.ACTIVE_EFFECT_MODES.UPGRADE) && (current >= value) ) return null;
		if ( (mode === CONST.ACTIVE_EFFECT_MODES.DOWNGRADE) && (current <= value) ) return null;
		foundry.utils.setProperty(actor.data, key, value);
		return value;
	}

	/* -------------------------------------------- */

	/**
	 * Apply an ActiveEffect that uses a CUSTOM application mode.
	 * @param {Actor} actor                   The Actor to whom this effect should be applied
	 * @param {data.EffectChangeData} change  The change data being applied
	 * @return {*}                            The resulting applied value
	 * @private
	 */
	_applyCustom(actor, change) {
		const preHook = foundry.utils.getProperty(actor.data, change.key);
		Hooks.call("applyActiveEffect", actor, change);
		const postHook = foundry.utils.getProperty(actor.data, change.key);
		return postHook !== preHook ? postHook : null;
	}

	/* -------------------------------------------- */

	/**
	 * Get the name of the source of the Active Effect
	 * @type {string}
	 */
	async _getSourceName() {
		if ( this._sourceName ) return this._sourceName;
		if ( !this.data.origin ) return this._sourceName = game.i18n.localize("None");
		const source = await fromUuid(this.data.origin);
		return this._sourceName = source?.name ?? "Unknown";
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async _preCreate(data, options, user) {
		await super._preCreate(data, options, user);

		// Set initial duration data for Actor-owned effects
		if ( this.parent instanceof Actor ) {
			const updates = {duration: {startTime: game.time.worldTime}, transfer: false};
			if ( game.combat ) {
				updates.duration.startRound = game.combat.round;
				updates.duration.startTurn = game.combat.turn;
			}
			this.data.update(updates);
		}
	}
}

/**
 * The client-side Actor document which extends the common BaseActor abstraction.
 * Each Actor document contains ActorData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.BaseActor
 * @extends ClientDocumentMixin
 *
 * @see {@link data.ActorData}              The Actor data schema
 * @see {@link documents.Actors}            The world-level collection of Actor documents
 * @see {@link applications.ActorConfig}    The Actor configuration application
 *
 * @param {data.ActorData} [data={}]        Initial data provided to construct the Actor document
 *
 * @example <caption>Create a new Actor</caption>
 * let actor = await Actor.create({
 *   name: "New Test Actor",
 *   type: "character",
 *   img: "artwork/character-profile.jpg"
 * });
 *
 * @example <caption>Retrieve an existing Actor</caption>
 * let actor = game.actors.get(actorId);
 */
class Actor extends ClientDocumentMixin(foundry.documents.BaseActor) {
	constructor(data, context) {
		super(data, context);

		/**
		 * An object that tracks which tracks the changes to the data model which were applied by active effects
		 * @type {object}
		 */
		this.overrides = this.overrides || {};

		/**
		 * A cached array of image paths which can be used for this Actor's token.
		 * Null if the list has not yet been populated.
		 * @type {string[]|null}
		 * @private
		 */
		this._tokenImages = null;

		/**
		 * Cache the last drawn wildcard token to avoid repeat draws
		 * @type {string|null}
		 */
		this._lastWildcard = null;
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * A convenient reference to the file path of the Actor's profile image
	 * @type {string}
	 */
	get img() {
		return this.data.img;
	}

	/* -------------------------------------------- */

	/**
	 * Provide an object which organizes all embedded Item instances by their type
	 * @type {Object<documents.Item[]>}
	 */
	get itemTypes() {
		const types = Object.fromEntries(game.system.entityTypes.Item.map(t => [t, []]));
		for ( let i of this.items.values() ) {
			types[i.data.type].push(i);
		}
		return types;
	}

	/* -------------------------------------------- */

	/**
	 * Test whether an Actor entity is a synthetic representation of a Token (if true) or a full Entity (if false)
	 * @type {boolean}
	 */
	get isToken() {
		if ( !this.parent ) return false;
		return this.parent instanceof TokenDocument;
	}

	/* -------------------------------------------- */

	/**
	 * An array of ActiveEffect instances which are present on the Actor which have a limited duration.
	 * @return {ActiveEffect[]}
	 */
	get temporaryEffects() {
		return this.effects.filter(e => e.isTemporary && !e.data.disabled);
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the TokenDocument which owns this Actor as a synthetic override
	 * @returns {TokenDocument|null}
	 */
	get token() {
		return this.parent instanceof TokenDocument ? this.parent : null;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience reference to the item type (data.type) of this Actor
	 * @type {string}
	 */
	get type() {
		return this.data.type;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get uuid() {
		if ( this.isToken ) return this.token.uuid;
		return super.uuid;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Apply any transformations to the Actor data which are caused by ActiveEffects.
	 */
	applyActiveEffects() {
		const overrides = {};

		// Organize non-disabled effects by their application priority
		const changes = this.effects.reduce((changes, e) => {
			if ( e.data.disabled ) return changes;
			return changes.concat(e.data.changes.map(c => {
				c = foundry.utils.duplicate(c);
				c.effect = e;
				c.priority = c.priority ?? (c.mode * 10);
				return c;
			}));
		}, []);
		changes.sort((a, b) => a.priority - b.priority);

		// Apply all changes
		for ( let change of changes ) {
			const result = change.effect.apply(this, change);
			if ( result !== null ) overrides[change.key] = result;
		}

		// Expand the set of final overrides
		this.overrides = foundry.utils.expandObject(overrides);
	}

	/* -------------------------------------------- */

	/**
	 * Retrieve an Array of active tokens which represent this Actor in the current canvas Scene.
	 * If the canvas is not currently active, or there are no linked actors, the returned Array will be empty.
	 * If the Actor is a synthetic token actor, only the exact Token which it represents will be returned.
	 *
	 * @param {boolean} [linked=false]  Limit results to Tokens which are linked to the Actor. Otherwise return all Tokens even those which are not linked.   *
	 * @param {boolean} [document=false]  Return the Document instance rather than the PlaceableObject
	 * @return Token[]}       An array of Token instances in the current Scene which reference this Actor.
	 */
	getActiveTokens(linked=false, document=false) {
		if ( !canvas.ready ) return [];

		// Synthetic token actors are, themselves, active tokens
		if ( this.isToken ) {
			if ( this.token.parent !== canvas.scene ) return [];
			return document ? [this.token] : [this.token.object];
		}

		// Otherwise find tokens within the current scene
		const tokens = [];
		for ( let t of canvas.scene.tokens ) {
			if ( t.data.actorId !== this.id ) continue;
			if ( !linked || t.data.actorLink ) tokens.push(document ? t : t.object);
		}
		return tokens;
	}

	/* -------------------------------------------- */

	/**
	 * Prepare a data object which defines the data schema used by dice roll commands against this Actor
	 * @return {object}
	 */
	getRollData() {
		return this.data.data;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_getSheetClass() {
		const cfg = CONFIG[this.documentName];
		const sheets = cfg.sheetClasses[this.type] || {};
		const override = this.getFlag("core", "sheetClass");
		if ( sheets[override] ) return sheets[override].cls;
		const classes = Object.values(sheets);
		if ( !classes.length ) return null;
		return (classes.find(s => s.default) ?? classes.pop()).cls;
	}

	/* -------------------------------------------- */

	/**
	 * Create a new TokenData object which can be used to create a Token representation of the Actor.
	 * @param {object} [data={}]            Additional data, such as x, y, rotation, etc. for the created token data
	 * @return {Promise<data.TokenData>}    The created TokenData instance
	 */
	async getTokenData(data={}) {
		const tokenData = this.data.token.toJSON();

		if ( tokenData.randomImg && !data.img ) {
			let images = await this.getTokenImages();
			if ( (images.length > 1) && this._lastWildcard ) {
				images = images.filter(i => i !== this._lastWildcard);
			}
			const image = images[Math.floor(Math.random() * images.length)];
			tokenData.img = this._lastWildcard = image;
		}
		foundry.utils.mergeObject(tokenData, data);
		return new foundry.data.TokenData(tokenData);
	}

	/* -------------------------------------------- */

	/**
	 * Get an Array of Token images which could represent this Actor
	 * @return {Promise<string[]>}
	 */
	async getTokenImages() {
		if (!this.data.token.randomImg) return [this.data.token.img];
		if (this._tokenImages) return this._tokenImages;
		let source = "data";
		let pattern = this.data.token.img;
		const browseOptions = { wildcard: true };

		// Support non-user sources
		if ( /\.s3\./.test(pattern) ) {
			source = "s3";
			const {bucket, keyPrefix} = FilePicker.parseS3URL(pattern);
			if ( bucket ) {
				browseOptions.bucket = bucket;
				pattern = keyPrefix;
			}
		}
		else if ( pattern.startsWith("icons/") ) source = "public";

		// Retrieve wildcard content
		try {
			const content = await FilePicker.browse(source, pattern, browseOptions);
			this._tokenImages = content.files;
		} catch(err) {
			this._tokenImages = [];
			ui.notifications.error(err);
		}
		return this._tokenImages;
	}

	/* -------------------------------------------- */

	/**
	 * Handle how changes to a Token attribute bar are applied to the Actor.
	 * This allows for game systems to override this behavior and deploy special logic.
	 * @param {string} attribute    The attribute path
	 * @param {number} value        The target attribute value
	 * @param {boolean} isDelta     Whether the number represents a relative change (true) or an absolute change (false)
	 * @param {boolean} isBar       Whether the new value is part of an attribute bar, or just a direct value
	 * @return {Promise<documents.Actor>}  The updated Actor document
	 */
	async modifyTokenAttribute(attribute, value, isDelta=false, isBar=true) {
		const current = foundry.utils.getProperty(this.data.data, attribute);

		// Determine the updates to make to the actor data
		let updates;
		if ( isBar ) {
			if (isDelta) value = Math.clamped(0, Number(current.value) + value, current.max);
			updates = {[`data.${attribute}.value`]: value};
		} else {
			if ( isDelta ) value = Number(current) + value;
			updates = {[`data.${attribute}`]: value};
		}

		// Call a hook to handle token resource bar updates
		const allowed = Hooks.call("modifyTokenAttribute", {attribute, value, isDelta, isBar}, updates);
		return allowed !== false ? this.update(updates) : this;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	prepareEmbeddedEntities() {
		super.prepareEmbeddedEntities();
		this.applyActiveEffects();
	}

	/* -------------------------------------------- */

	/**
	 * Roll initiative for all Combatants in the currently active Combat encounter which are associated with this Actor.
	 * If viewing a full Actor entity, all Tokens which map to that actor will be targeted for initiative rolls.
	 * If viewing a synthetic Token actor, only that particular Token will be targeted for an initiative roll.
	 *
	 * @param {object} options                          Configuration for how initiative for this Actor is rolled.
	 * @param {boolean} [options.createCombatants=false]    Create new Combatant entries for Tokens associated with this actor.
	 * @param {boolean} [options.rerollInitiative=false]    Re-roll the initiative for this Actor if it has already been rolled.
	 * @param {object} [options.initiativeOptions={}]       Additional options passed to the Combat#rollInitiative method.
	 * @return {Promise<documents.Combat|null>}         A promise which resolves to the Combat entity once rolls are complete.
	 */
	async rollInitiative({createCombatants=false, rerollInitiative=false, initiativeOptions={}}={}) {

		// Obtain (or create) a combat encounter
		let combat = game.combat;
		if ( !combat ) {
			if ( game.user.isGM && canvas.scene ) {
				const cls = getDocumentClass("Combat")
				combat = await cls.create({scene: canvas.scene.id, active: true});
			}
			else {
				ui.notifications.warn("COMBAT.NoneActive", {localize: true});
				return null;
			}
		}

		// Record existing combatants for this actor
		let combatants = rerollInitiative ? combat.combatants.filter(c => c.actor.id === this.id) : [];

		// Create new combatants
		if ( createCombatants ) {
			const tokens = this.getActiveTokens();
			const toCreate = [];
			if ( tokens.length ) {
				for ( let t of tokens ) {
					if ( t.inCombat ) continue;
					toCreate.push({tokenId: t.id, hidden: t.data.hidden});
				}
			} else toCreate.push({actorId: this.id, hidden: false})
			const created = await combat.createEmbeddedDocuments("Combatant", toCreate);
			combatants = combatants.concat(created);
		}

		// Roll initiative for combatants
		await combat.rollInitiative(combatants.map(c => c.id), initiativeOptions);
		return combat;
	}


	/* -------------------------------------------- */
	/*  Database Operations                         */
	/* -------------------------------------------- */

	/** @inheritdoc */
	getEmbeddedCollection(embeddedName) {
		if ( embeddedName === "OwnedItem" ) {
			console.warn('You are using "OwnedItem" as an embedded Document name within the Actor document. This has changed due to the symmetric Document standardization in 0.8.0 and you must now use "Item" as the embedded document name.')
			embeddedName = "Item";
		}
		return super.getEmbeddedCollection(embeddedName);
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async _preCreate(data, options, userId) {
		await super._preCreate(data, options, userId);
		const token = foundry.utils.deepClone(game.settings.get("core", DefaultTokenConfig.SETTING));
		this.data.token.update(foundry.utils.mergeObject(token, data.token || {}));
	}

	/* -------------------------------------------- */

	/** @override */
	_onUpdate(data, options, userId) {
		super._onUpdate(data, options, userId);

		// Get the changed attributes
		const keys = Object.keys(data).filter(k => k !== "_id");
		const changed = new Set(keys);

		// Additional options only apply to Actors which are not synthetic Tokens
		if (this.isToken) return;

		// If the prototype token was changed, expire any cached token images
		if (changed.has("token")) this._tokenImages = null;

		// Update the active TokenDocument instances which represent this Actor
		const tokens = this.getActiveTokens(false, true);
		for ( let t of tokens ) {
			t._onUpdateBaseActor(data);
		}

		// If ownership changed for the actor reset token control
		if (changed.has("permission") && tokens.length) {
			canvas.tokens.releaseAll();
			canvas.tokens.cycleTokens(true, true);
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onCreateEmbeddedDocuments(embeddedName, ...args) {
		super._onCreateEmbeddedDocuments(embeddedName, ...args);
		this._refreshTokens();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onUpdateEmbeddedDocuments(embeddedName, ...args) {
		super._onUpdateEmbeddedDocuments(embeddedName, ...args);
		this._refreshTokens();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDeleteEmbeddedDocuments(embeddedName, ...args) {
		super._onDeleteEmbeddedDocuments(embeddedName, ...args);
		this._refreshTokens();
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the display of active Tokens for this Actor if ActiveEffects were changed
	 * @private
	 */
	_refreshTokens() {
		const tokens = this.getActiveTokens();
		let refreshCombat = false;
		for ( let token of tokens ) {
			token.drawEffects();    // Update active effect icons
			token.drawBars();       // The active effect may have changed token bar values
			if ( token.inCombat ) refreshCombat = true;
			if ( token.hasActiveHUD ) canvas.tokens.hud.render();
		}
		if ( refreshCombat ) ui.combat.render();
	}

	/* -------------------------------------------- */
	/*  Deprecated                                  */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	get _data() {
		console.warn(`You are referencing Actor#_data which has been deprecated in favor of Actor#data#_source. Support for this reference will be removed in 0.9.0`);
		return this.data._source;
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	getOwnedItem(itemId) {
		console.warn("You are referencing Actor#getOwnedItem(itemId) which is deprecated in favor of Actor#items#get(itemId). Support will be removed in 0.9.0");
		return this.items.get(itemId);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	async createOwnedItem(itemData, options = {}) {
		console.warn("You are referencing Actor#createOwnedItem which is deprecated in favor of Item.create or Actor#createEmbeddedDocuments. Support will be removed in 0.9.0");
		itemData = itemData instanceof Array ? itemData : [itemData];
		return this.createEmbeddedDocuments("Item", itemData, options);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	async updateOwnedItem(itemData, options = {}) {
		console.warn("You are referencing Actor#updateOwnedItem which is deprecated in favor of Item#update or Actor#updateEmbeddedDocuments. Support will be removed in 0.9.0");
		itemData = itemData instanceof Array ? itemData : [itemData];
		return this.updateEmbeddedDocuments("Item", itemData, options);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	async deleteOwnedItem(itemId, options = {}) {
		console.warn("You are referencing Actor#deleteOwnedItem which is deprecated in favor of Item#delete or Actor#deleteEmbeddedDocuments. Support will be removed in 0.9.0");
		itemId = itemId instanceof Array ? itemId : [itemId];
		return this.deleteEmbeddedDocuments("Item", itemId, options);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	static fromToken(token) {
		console.warn("You are referencing Actor.fromToken which is deprecated in favor of TokenDocument#getActor. Support will be removed in 0.9.0");
		if ( token instanceof Token ) token = token.document;
		return token.getActor();
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	static createTokenActor(baseActor, token) {
		console.warn("You are referencing Actor.createTokenActor which is deprecated in favor of TokenDocument#getActor. Support will be removed in 0.9.0");
		if ( token instanceof Token ) token = token.document;
		return token.getActor();
	}
}

/**
 * The client-side AmbientLight embedded document which extends the common BaseAmbientLight abstraction.
 * Each AmbientLight document contains AmbientLightData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.BaseAmbientLight
 * @extends ClientDocumentMixin
 *
 * @see {@link data.AmbientLightData}             The AmbientLight data schema
 * @see {@link documents.Scene}                   The Scene document type which contains AmbientLight embedded documents
 * @see {@link applications.LightConfig}          The AmbientLight configuration application
 *
 * @param {data.AmbientLightData} [data={}]       Initial data provided to construct the AmbientLight document
 * @param {Scene} parent                The parent Scene document to which this AmbientLight belongs
 */
class AmbientLightDocument extends CanvasDocumentMixin(foundry.documents.BaseAmbientLight) {

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * Is this ambient light source global in nature?
	 * @type {boolean}
	 */
	get isGlobal() {
		return this.data.t === "g";
	}
}

/**
 * The client-side AmbientSound embedded document which extends the common BaseAmbientSound abstraction.
 * Each AmbientSound document contains AmbientSoundData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.BaseAmbientSound
 * @extends ClientDocumentMixin
 *
 * @see {@link data.AmbientSoundData}             The AmbientSound data schema
 * @see {@link documents.Scene}                   The Scene document type which contains AmbientSound embedded documents
 * @see {@link applications.AmbientSoundConfig}   The AmbientSound configuration application
 *
 * @param {data.AmbientSoundData} [data={}]       Initial data provided to construct the AmbientSound document
 * @param {Scene} parent                The parent Scene document to which this AmbientSound belongs
 */
class AmbientSoundDocument extends CanvasDocumentMixin(foundry.documents.BaseAmbientSound) {

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * A convenience accessor for the sound type
	 * @return {string}
	 */
	get type() {
		return this.data.type;
	}
}

/**
 * The client-side ChatMessage document which extends the common BaseChatMessage abstraction.
 * Each ChatMessage document contains ChatMessageData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.Document
 * @extends abstract.BaseChatMessage
 * @extends ClientDocumentMixin
 *
 * @see {@link data.ChatMessageData}              The ChatMessage data sche
 * ma
 * @see {@link documents.Messages}                The world-level collection of ChatMessage documents
 *
 * @param {data.ChatMessageData} [data={}]        Initial data provided to construct the ChatMessage document
 */
class ChatMessage extends ClientDocumentMixin(foundry.documents.BaseChatMessage) {
	constructor(data, context) {
		super(data, context);

		/**
		 * If the chat message contains a Roll instance, cache it here
		 * @type {Roll|null}
		 * @private
		 */
		this._roll = null;
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * Return the recommended String alias for this message.
	 * The alias could be a Token name in the case of in-character messages or dice rolls.
	 * Alternatively it could be a User name in the case of OOC chat or whispers.
	 * @type {string}
	 */
	get alias() {
		const speaker = this.data.speaker;
		if ( speaker.alias ) return speaker.alias;
		else if ( speaker.actor ) return game.actors.get(speaker.actor).name;
		else return this.user ? this.user.name : "";
	}

	/* -------------------------------------------- */

	/**
	 * Is the current User the author of this message?
	 * @type {boolean}
	 */
	get isAuthor() {
		return game.user.id === this.data.user;
	}

	/* -------------------------------------------- */

	/**
	 * Return whether the content of the message is visible to the current user.
	 * For certain dice rolls, for example, the message itself may be visible while the content of that message is not.
	 * @type {boolean}
	 */
	get isContentVisible() {
		if ( this.isRoll ) {
			const whisper = this.data.whisper || [];
			const isBlind = whisper.length && this.data.blind;
			if ( whisper.length ) return whisper.includes(game.user.id) || (this.isAuthor && !isBlind);
			return true;
		}
		else return this.visible;
	}

	/* -------------------------------------------- */

	/**
	 * Test whether the chat message contains a dice roll
	 * @type {boolean}
	 */
	get isRoll() {
		return this.data.type === CONST.CHAT_MESSAGE_TYPES.ROLL;
	}

	/* -------------------------------------------- */

	/**
	 * Return the Roll instance contained in this chat message, if one is present
	 * @type {Roll|null}
	 */
	get roll() {
		if ( this._roll === null ) {
			try {
				if ( !this.data.roll ) throw new Error("ChatMessage does not contain a Roll");
				this._roll = Roll.fromJSON(this.data.roll);
			} catch(err) {
				console.error(err);
				this._roll = null;
			}
		}
		return this._roll;
	}

	/* -------------------------------------------- */

	/**
	 * Return whether the ChatMessage is visible to the current User.
	 * Messages may not be visible if they are private whispers.
	 * @type {boolean}
	 */
	get visible() {
		if ( this.data.whisper.length ) {
			if ( this.data.type === CONST.CHAT_MESSAGE_TYPES.ROLL ) return true;
			return (this.data.user === game.user.id) || (this.data.whisper.indexOf(game.user.id) !== -1);
		}
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * The User who created the chat message.
	 * @type {User}
	 */
	get user() {
		return game.users.get(this.data.user);
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/** @inheritdoc */
	prepareData() {
		super.prepareData();
		const actor = this.constructor.getSpeakerActor(this.data.speaker) || this.user?.character;
		const rollData = actor ? actor.getRollData() : {};
		this.data.content = TextEditor.enrichHTML(this.data.content, {rollData});
	}

	/* -------------------------------------------- */

	/**
	 * Transform a provided object of ChatMessage data by applying a certain rollMode to the data object.
	 * @param {object} chatData     The object of ChatMessage data prior to applying a rollMode preference
	 * @param {string} rollMode     The rollMode preference to apply to this message data
	 * @returns {object}            The modified ChatMessage data with rollMode preferences applied
	 */
	static applyRollMode(chatData, rollMode) {
		if ( ["gmroll", "blindroll"].includes(rollMode) ) {
			chatData.whisper = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
		}
		else if ( rollMode === "selfroll" ) chatData.whisper = [game.user.id];
		if ( rollMode === "blindroll" ) chatData.blind = true;
		return chatData;
	}

	/* -------------------------------------------- */

	/**
	 * Update the data of a ChatMessage instance to apply a requested rollMode
	 * @param {string} rollMode     The rollMode preference to apply to this message data
	 */
	applyRollMode(rollMode) {
		const updates = {};
		if ( ["gmroll", "blindroll"].includes(rollMode) ) {
			updates.whisper = ChatMessage.getWhisperRecipients("GM").map(u => u.id);
		}
		else if ( rollMode === "selfroll" ) updates.whisper = [game.user.id];
		if ( rollMode === "blindroll" ) updates.blind = true;
		this.data.update(updates);
	}

	/* -------------------------------------------- */

	/**
	 * Attempt to determine who is the speaking character (and token) for a certain Chat Message
	 * First assume that the currently controlled Token is the speaker
	 *
	 * @param {Scene} [scene]     The Scene in which the speaker resides
	 * @param {Actor} [actor]     The Actor whom is speaking
	 * @param {Token} [token]     The Token whom is speaking
	 * @param {string} [alias]     The name of the speaker to display
	 *
	 * @returns {Object}  The identified speaker data
	 */
	static getSpeaker({scene, actor, token, alias}={}) {

		// CASE 1 - A Token is explicitly provided
		if ( token instanceof Token ) return this._getSpeakerFromToken({token, alias});
		const hasActor = actor instanceof Actor;
		if ( hasActor && actor.isToken ) return this._getSpeakerFromToken({token: actor.token, alias});

		// CASE 2 - An Actor is explicitly provided
		if ( hasActor ) {
			alias = alias || actor.name;
			const tokens = actor.getActiveTokens();
			if ( !tokens.length ) return this._getSpeakerFromActor({scene, actor, alias});
			const controlled = tokens.filter(t => t._controlled);
			token = controlled.length ? controlled.shift() : tokens.shift();
			return this._getSpeakerFromToken({token, alias});
		}

		// CASE 3 - Not the viewed Scene
		else if ( ( scene instanceof Scene ) && !scene.isView ) {
			const char = game.user.character;
			if ( char ) return this._getSpeakerFromActor({scene, actor: char, alias});
			return this._getSpeakerFromUser({scene, user: game.user, alias});
		}

		// CASE 4 - Infer from controlled tokens
		if ( canvas.ready ) {
			let controlled = canvas.tokens.controlled;
			if (controlled.length) return this._getSpeakerFromToken({token: controlled.shift(), alias});
		}

		// CASE 5 - Infer from impersonated Actor
		const char = game.user.character;
		if ( char ) {
			const tokens = char.getActiveTokens();
			if ( tokens.length ) return this._getSpeakerFromToken({token: tokens.shift(), alias});
			return this._getSpeakerFromActor({actor: char, alias});
		}

		// CASE 6 - From the alias and User
		return this._getSpeakerFromUser({scene, user: game.user, alias});
	}

	/* -------------------------------------------- */

	/**
	 * A helper to prepare the speaker object based on a target Token
	 * @private
	 */
	static _getSpeakerFromToken({token, alias}) {
		return {
			scene: token.scene?.id || null,
			token: token.id,
			actor: token.actor?.id || null,
			alias: alias || token.name
		}
	}

	/* -------------------------------------------- */

	/**
	 * A helper to prepare the speaker object based on a target Actor
	 * @private
	 */
	static _getSpeakerFromActor({scene, actor, alias}) {
		return {
			scene: (scene || canvas.scene)?.id || null,
			actor: actor.id,
			token: null,
			alias: alias || actor.name
		}
	}
	/* -------------------------------------------- */

	/**
	 * A helper to prepare the speaker object based on a target User
	 * @private
	 */
	static _getSpeakerFromUser({scene, user, alias}) {
		return {
			scene: (scene || canvas.scene)?.id || null,
			actor: null,
			token: null,
			alias: alias || user.name
		}
	}

	/* -------------------------------------------- */

	/**
	 * Obtain an Actor instance which represents the speaker of this message (if any)
	 * @param {Object} speaker    The speaker data object
	 * @return {Actor|null}
	 */
	static getSpeakerActor(speaker) {
		if ( !speaker ) return null;
		let actor = null;

		// Case 1 - Token actor
		if ( speaker.scene && speaker.token ) {
			const scene = game.scenes.get(speaker.scene);
			const token = scene ? scene.tokens.get(speaker.token) : null;
			actor = token?.actor;
		}

		// Case 2 - explicit actor
		if ( speaker.actor && !actor ) {
			actor = game.actors.get(speaker.actor);
		}
		return actor || null;
	}

	/* -------------------------------------------- */

	/**
	 * Obtain a data object used to evaluate any dice rolls associated with this particular chat message
	 * @return {object}
	 */
	getRollData() {
		const actor = this.constructor.getSpeakerActor(this.data.speaker);
		return actor ? actor.getRollData() : {};
	}

	/* -------------------------------------------- */

	/**
	 * Given a string whisper target, return an Array of the user IDs which should be targeted for the whisper
	 *
	 * @param {string} name   The target name of the whisper target
	 * @return {User[]}       An array of User instances
	 */
	static getWhisperRecipients(name) {

		// Whisper to groups
		if (["GM", "DM"].includes(name.toUpperCase())) {
			return game.users.filter(u => u.isGM);
		}
		else if (name.toLowerCase() === "players") {
			return game.users.players;
		}

		// Whisper to a single person
		const lname = name.toLowerCase();
		let user = game.users.find(u => u.name.toLowerCase() === lname);
		if (user) return [user];
		let actor = game.users.find(a => a.character && a.character.name.toLowerCase() === lname);
		if (actor) return [actor];

		// Otherwise return an empty array
		return [];
	}

	/* -------------------------------------------- */

	/**
	 * Render the HTML for the ChatMessage which should be added to the log
	 * @return {Promise<jQuery>}
	 */
	async getHTML() {

		// Determine some metadata
		const data = this.toObject(false);
		const isWhisper = this.data.whisper.length;
		const isVisible = this.isContentVisible;

		// Construct message data
		const messageData = {
			message: data,
			user: game.user,
			author: this.user,
			alias: this.alias,
			cssClass: [
				this.data.type === CONST.CHAT_MESSAGE_TYPES.IC ? "ic" : null,
				this.data.type === CONST.CHAT_MESSAGE_TYPES.EMOTE ? "emote" : null,
				isWhisper ? "whisper" : null,
				this.data.blind ? "blind": null
			].filterJoin(" "),
			isWhisper: this.data.whisper.some(id => id !== game.user.id),
			whisperTo: this.data.whisper.map(u => {
				let user = game.users.get(u);
				return user ? user.name : null;
			}).filterJoin(", ")
		};

		// Enrich some data for dice rolls
		if ( this.isRoll ) {
			let hasContent = data.content && (Number(data.content) !== this.roll.total);
			if ( !hasContent ) data.content = await this.roll.render({isPrivate: !isVisible});
			if ( !isVisible ) {
				data.flavor = game.i18n.format("CHAT.PrivateRollContent", {user: this.user.name});
				messageData.isWhisper = false;
				messageData.alias = this.user.name;
			}
		}

		// Define a border color
		if ( this.data.type === CONST.CHAT_MESSAGE_TYPES.OOC ) {
			messageData.borderColor = this.user.color;
		}

		// Render the chat message
		let html = await renderTemplate(CONFIG.ChatMessage.template, messageData);
		html = $(html);

		/**
		 * A hook event that fires for each ChatMessage which is rendered for addition to the ChatLog.
		 * This hook allows for final customization of the message HTML before it is added to the log.
		 * @function renderChatMessage
		 * @memberof hookEvents
		 * @param {ChatMessage} message   The ChatMessage document being rendered
		 * @param {jQuery} html           The pending HTML as a jQuery object
		 * @param {object} data           The input data provided for template rendering
		 */
		Hooks.call("renderChatMessage", this, html, messageData);
		return html;
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @override */
	async _preCreate(data, options, user) {
		await super._preCreate(data, options, user);
		if ( this.isRoll ) {
			const rollMode = options.rollMode || data.rollMode || game.settings.get("core", "rollMode");
			if ( rollMode ) this.applyRollMode(rollMode);
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onCreate(data, options, userId) {
		super._onCreate(data, options, userId);
		if ( options.temporary ) return;
		ui.chat.postOne(this, true);
		if ( options.chatBubble && canvas.ready ) {
			this.collection.sayBubble(this);
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onUpdate(data, options, userId) {
		if ( "roll" in data ) this._roll = null;
		if ( !this.visible ) ui.chat.deleteMessage(this.id);
		else ui.chat.updateMessage(this);
		super._onUpdate(data, options, userId);
	}

	/* -------------------------------------------- */

	/** @override */
	_onDelete(options, userId) {
		ui.chat.deleteMessage(this.id, options);
		super._onDelete(options, userId);
	}

	/* -------------------------------------------- */
	/*  Importing and Exporting                     */
	/* -------------------------------------------- */

	/**
	 * Export the content of the chat message into a standardized log format
	 * @return {string}
	 */
	export() {
		let content = [];

		// Handle Roll content
		if ( this.isRoll ) {
			let r = this.roll;
			if ( this.data.content && (this.data.content !== "undefined")) {
				content.push($(`<div>${this.data.content}</div>`).text().trim());
			}
			let flavor = this.data.flavor;
			if ( flavor && flavor !== r.formula ) content.push(flavor);
			content.push(`${r.formula} = ${r.result} = ${r.total}`);
		}

		// Handle HTML content
		else {
			const html = $("<article>").html(this.data["content"].replace(/<\/div>/g, "</div>|n"));
			const text = html.length ? html.text() : this.data["content"];
			const lines = text.replace(/\n/g, "").split("  ").filter(p => p !== "").join(" ");
			content = lines.split("|n").map(l => l.trim());
		}

		// Author and timestamp
		const time = new Date(this.data.timestamp).toLocaleDateString('en-US', {
			hour: "numeric",
			minute: "numeric",
			second: "numeric"
		});

		// Format logged result
		return `[${time}] ${this.alias}\n${content.filterJoin("\n")}`;
	}
}

/**
 * The client-side Combat document which extends the common BaseCombat abstraction.
 * Each Combat document contains CombatData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.Document
 * @extends abstract.BaseCombat
 * @extends ClientDocumentMixin
 *
 * @see {@link data.CombatData}               The Combat data schema
 * @see {@link documents.Combats}             The world-level collection of Combat documents
 * @see {@link embedded.Combatant}            The Combatant embedded document which exists within a Combat document
 * @see {@link applications.CombatConfig}     The Combat configuration application
 *
 * @param {data.CombatData} [data={}]         Initial data provided to construct the Combat document
 */
class Combat extends ClientDocumentMixin(foundry.documents.BaseCombat) {
	constructor(data, context) {
		super(data, context);

		/**
		 * Track the sorted turn order of this combat encounter
		 * @type {Combatant[]}
		 */
		this.turns = this.turns || [];

		/**
		 * Record the current round, turn, and tokenId to understand changes in the encounter state
		 * @type {{round: number|null, turn: number|null, tokenId: string|null, combatantId: string|null}}
		 * @private
		 */
		this.current = this.current || {
			round: null,
			turn: null,
			tokenId: null,
			combatantId: null
		};

		/**
		 * Track the previous round, turn, and tokenId to understand changes in the encounter state
		 * @type {{round: number|null, turn: number|null, tokenId: string|null, combatantId: string|null}}
		 * @private
		 */
		this.previous = this.previous || {
			round: null,
			turn: null,
			tokenId: null,
			combatantId: null
		};

		/**
		 * Track whether a sound notification is currently being played to avoid double-dipping
		 * @type {boolean}
		 * @private
		 */
		this._soundPlaying = false;
	}

	/**
	 * The configuration setting used to record Combat preferences
	 * @type {string}
	 */
	static CONFIG_SETTING = "combatTrackerConfig";

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * Get the Combatant who has the current turn.
	 * @type {Combatant}
	 */
	get combatant() {
		return this.turns[this.data.turn];
	}

	/* -------------------------------------------- */

	/**
	 * The numeric round of the Combat encounter
	 * @type {number}
	 */
	get round() {
		return Math.max(this.data.round, 0);
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the Scene document within which this Combat encounter occurs
	 * @type {Scene}
	 */
	get scene() {
		return game.scenes.get(this.data.scene);
	}

	/* -------------------------------------------- */

	/**
	 * Return the object of settings which modify the Combat Tracker behavior
	 * @return {object}
	 */
	get settings() {
		return CombatEncounters.settings;
	}

	/* -------------------------------------------- */

	/**
	 * Has this combat encounter been started?
	 * @type {boolean}
	 */
	get started() {
		return ( this.turns.length > 0 ) && ( this.round > 0 );
	}

	/* -------------------------------------------- */

	/**
	 * The numeric turn of the combat round in the Combat encounter
	 * @type {number}
	 */
	get turn() {
		return Math.max(this.data.turn, 0);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get visible() {
		return true;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Set the current Combat encounter as active within the Scene.
	 * Deactivate all other Combat encounters within the viewed Scene and set this one as active
	 * @return {Promise<Combat>}
	 */
	async activate() {
		const currentScene = game.scenes.current?.id;
		const updates = this.collection.reduce((arr, c) => {
			if ( (c.data.scene === currentScene) && c.data.active ) arr.push({_id: c.data._id, active: false});
			return arr;
		}, []);
		updates.push({_id: this.id, active: true});
		return this.constructor.updateDocuments(updates);
	}

	/* -------------------------------------------- */

	/**
	 * Display a dialog querying the GM whether they wish to end the combat encounter and empty the tracker
	 * @return {Promise<Combat>}
	 */
	async endCombat() {
		return Dialog.confirm({
			title: game.i18n.localize("COMBAT.EndTitle"),
			content: `<p>${game.i18n.localize("COMBAT.EndConfirmation")}</p>`,
			yes: this.delete.bind(this)
		});
	}

	/* -------------------------------------------- */

	/**
	 * Get a Combatant using its Token id
	 * @param {string} tokenId   The id of the Token for which to acquire the combatant
	 */
	getCombatantByToken(tokenId) {
		return this.combatants.find(c => c.data.tokenId === tokenId);
	}

	/* -------------------------------------------- */

	/**
	 * Advance the combat to the next round
	 * @return {Promise<Combat>}
	 */
	async nextRound() {
		let turn = 0;
		if ( this.settings.skipDefeated ) {
			turn = this.turns.findIndex(t => {
				return !(t.defeated ||
				t.actor?.effects.find(e => e.getFlag("core", "statusId") === CONFIG.Combat.defeatedStatusId ));
			});
			if (turn === -1) {
				ui.notifications.warn("COMBAT.NoneRemaining", {localize: true});
				turn = 0;
			}
		}
		let advanceTime = Math.max(this.turns.length - this.data.turn, 1) * CONFIG.time.turnTime;
		advanceTime += CONFIG.time.roundTime;
		return this.update({round: this.round+1, turn: turn}, {advanceTime});
	}

	/* -------------------------------------------- */

	/**
	 * Advance the combat to the next turn
	 * @return {Promise<Combat>}
	 */
	async nextTurn() {
		let turn = this.turn;
		let skip = this.settings.skipDefeated;

		// Determine the next turn number
		let next = null;
		if ( skip ) {
			for ( let [i, t] of this.turns.entries() ) {
				if ( i <= turn ) continue;
				if ( t.defeated ) continue;
				if ( t.actor?.effects.find(e => e.getFlag("core", "statusId") === CONFIG.Combat.defeatedStatusId ) ) continue;
				next = i;
				break;
			}
		}
		else next = turn + 1;

		// Maybe advance to the next round
		let round = this.round;
		if ( (this.round === 0) || (next === null) || (next >= this.turns.length) ) {
			return this.nextRound();
		}

		// Update the encounter
		const advanceTime = CONFIG.time.turnTime;
		return this.update({round: round, turn: next}, {advanceTime});
	}

	/* -------------------------------------------- */

	/** @override */
	prepareDerivedData() {
		if ( this.combatants.size && !this.turns?.length ) this.setupTurns();
	}

	/* -------------------------------------------- */

	/**
	 * Rewind the combat to the previous round
	 * @return {Promise<Combat>}
	 */
	async previousRound() {
		let turn = ( this.round === 0 ) ? 0 : Math.max(this.turns.length - 1, 0);
		const round = Math.max(this.round - 1, 0);
		let advanceTime = -1 * this.data.turn * CONFIG.time.turnTime;
		if ( round > 0 ) advanceTime -= CONFIG.time.roundTime;
		return this.update({round, turn}, {advanceTime});
	}

	/* -------------------------------------------- */

	/**
	 * Rewind the combat to the previous turn
	 * @return {Promise<Combat>}
	 */
	async previousTurn() {
		if ( this.turn === 0 && this.round === 0 ) return this;
		else if ( this.turn <= 0 ) return this.previousRound();
		const advanceTime = -1 * CONFIG.time.turnTime;
		return this.update({turn: this.turn - 1}, {advanceTime});
	}

	/* -------------------------------------------- */

	/**
	 * Reset all combatant initiative scores, setting the turn back to zero
	 * @return {Promise<Combat>}
	 */
	async resetAll() {
		for ( let c of this.combatants ) {
			c.data.update({initiative: null});
		}
		return this.update({turn: 0, combatants: this.combatants.toJSON()}, {diff: false});
	}

	/* -------------------------------------------- */

	/**
	 * Roll initiative for one or multiple Combatants within the Combat entity
	 * @param {string|string[]} ids     A Combatant id or Array of ids for which to roll
	 * @param {object} [options={}]     Additional options which modify how initiative rolls are created or presented.
	 * @param {string|null} [options.formula]         A non-default initiative formula to roll. Otherwise the system default is used.
	 * @param {boolean} [options.updateTurn=true]     Update the Combat turn after adding new initiative scores to keep the turn on the same Combatant.
	 * @param {object} [options.messageOptions={}]    Additional options with which to customize created Chat Messages
	 * @return {Promise<Combat>}        A promise which resolves to the updated Combat entity once updates are complete.
	 */
	async rollInitiative(ids, {formula=null, updateTurn=true, messageOptions={}}={}) {

		// Structure input data
		ids = typeof ids === "string" ? [ids] : ids;
		const currentId = this.combatant.id;
		const rollMode = messageOptions.rollMode || game.settings.get("core", "rollMode");

		// Iterate over Combatants, performing an initiative roll for each
		const updates = [];
		const messages = [];
		for ( let [i, id] of ids.entries() ) {

			// Get Combatant data (non-strictly)
			const combatant = this.combatants.get(id);
			if ( !combatant?.isOwner ) return results;

			// Produce an initiative roll for the Combatant
			const roll = combatant.getInitiativeRoll(formula);
			updates.push({_id: id, initiative: roll.total});

			// Construct chat message data
			let messageData = foundry.utils.mergeObject({
				speaker: {
					scene: this.scene.id,
					actor: combatant.actor?.id,
					token: combatant.token?.id,
					alias: combatant.name
				},
				flavor: game.i18n.format("COMBAT.RollsInitiative", {name: combatant.name}),
				flags: {"core.initiativeRoll": true}
			}, messageOptions);
			const chatData = await roll.toMessage(messageData, {
				create: false,
				rollMode: combatant.hidden && (rollMode === "roll") ? "gmroll" : rollMode
			});

			// Play 1 sound for the whole rolled set
			if ( i > 0 ) chatData.sound = null;
			messages.push(chatData);
		}
		if ( !updates.length ) return this;

		// Update multiple combatants
		await this.updateEmbeddedDocuments("Combatant", updates);

		// Ensure the turn order remains with the same combatant
		if ( updateTurn ) {
			await this.update({turn: this.turns.findIndex(t => t.id === currentId)});
		}

		// Create multiple chat messages
		await ChatMessage.implementation.create(messages);
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Roll initiative for all combatants which have not already rolled
	 * @param {object} [options={}]   Additional options forwarded to the Combat.rollInitiative method
	 */
	async rollAll(options) {
		const ids = this.combatants.reduce((ids, c) => {
			if ( c.isOwner && !c.initiative) ids.push(c.id);
			return ids;
		}, []);
		return this.rollInitiative(ids, options);
	}

	/* -------------------------------------------- */

	/**
	 * Roll initiative for all non-player actors who have not already rolled
	 * @param {object} [options={}]   Additional options forwarded to the Combat.rollInitiative method
	 */
	async rollNPC(options={}) {
		const ids = this.combatants.reduce((ids, c) => {
			if ( c.isOwner && c.isNPC && !c.initiative) ids.push(c.id);
			return ids;
		}, []);
		return this.rollInitiative(ids, options);
	}

	/* -------------------------------------------- */

	/**
	 * Assign initiative for a single Combatant within the Combat encounter.
	 * Update the Combat turn order to maintain the same combatant as the current turn.
	 * @param {string} id         The combatant ID for which to set initiative
	 * @param {number} value      A specific initiative value to set
	 */
	async setInitiative(id, value) {
		const currentId = this.combatant.id;
		const combatant = this.combatants.get(id, {strict: true});
		await combatant.update({initiative: value});
		await this.update({turn: this.turns.findIndex(c => c.id === currentId)});
	}

	/* -------------------------------------------- */

	/**
	 * Return the Array of combatants sorted into initiative order, breaking ties alphabetically by name.
	 * @return {Combatant[]}
	 */
	setupTurns() {

		// Determine the turn order and the current turn
		const turns = this.combatants.contents.sort(this._sortCombatants);
		this.data.turn = Math.clamped(this.data.turn, 0, turns.length-1);

		// Update state tracking
		let c = turns[this.data.turn];
		this.current = {
			round: this.data.round,
			turn: this.data.turn,
			combatantId: c ? c.id : null,
			tokenId: c ? c.data.tokenId : null
		};
		return this.turns = turns;
	}

	/* -------------------------------------------- */

	/**
	 * Begin the combat encounter, advancing to round 1 and turn 1
	 * @return {Promise<Combat>}
	 */
	async startCombat() {
		return this.update({round: 1, turn: 0});
	}

	/* -------------------------------------------- */

	/**
	 * Define how the array of Combatants is sorted in the displayed list of the tracker.
	 * This method can be overridden by a system or module which needs to display combatants in an alternative order.
	 * By default sort by initiative, next falling back to name, lastly tie-breaking by combatant id.
	 * @private
	 */
	_sortCombatants(a, b) {
		const ia = Number.isNumeric(a.initiative) ? a.initiative : -9999;
		const ib = Number.isNumeric(b.initiative) ? b.initiative : -9999;
		let ci = ib - ia;
		if ( ci !== 0 ) return ci;
		let cn = a.name.localeCompare(b.name);
		if ( cn !== 0 ) return cn;
		return a.id - b.id;
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_onCreate(data, options, userId) {
		super._onCreate(data, options, userId);
		if ( !this.collection.viewed ) ui.combat.initialize({combat: this});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onUpdate(data, options, userId) {
		super._onUpdate(data, options, userId);

		// Set up turn data
		if ( ["combatants", "round", "turn"].some(k => data.hasOwnProperty(k)) ) {
			if ( data.combatants ) this.setupTurns();
			else {
				const c = this.combatant;
				this.previous = this.current;
				this.current = {
					round: this.data.round,
					turn: this.data.turn,
					combatantId: c ? c.id : null,
					tokenId: c ? c.data.tokenId : null
				};
			}

			// Render the sidebar
			if ( data.active === true ) ui.combat.initialize({combat: this});
			return ui.combat.scrollToTurn();
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDelete(options, userId) {
		super._onDelete(options, userId);
		if ( this.collection.viewed === this ) ui.combat.initialize();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onCreateEmbeddedDocuments(type, documents, result, options, userId) {
		super._onCreateEmbeddedDocuments(type, documents, result, options, userId);

		// Update the turn order and adjust the combat to keep the combatant the same
		const current = this.combatant;
		this.setupTurns();

		// Keep the current Combatant the same after adding new Combatants to the Combat
		if ( current ) {
			let turn = Math.max(this.turns.findIndex(t => t.id === current.id), 0);
			if ( game.user.id === userId ) this.update({turn});
			else this.data.update({turn});
		}

		// Render the collection
		if ( this.data.active ) this.collection.render();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onUpdateEmbeddedDocuments(...args) {
		super._onUpdateEmbeddedDocuments(...args);
		this.setupTurns();
		if ( this.data.active ) this.collection.render();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDeleteEmbeddedDocuments(embeddedName, documents, result, options, userId) {
		super._onDeleteEmbeddedDocuments(embeddedName, documents, result, options, userId);

		// Update the turn order and adjust the combat to keep the combatant the same (unless they were deleted)
		const current = this.combatant;
		const nextSurvivor = this.turns.find((i, t) => {
			return !result.includes(t.id) && (i >= this.turn) && !t.defeated;
		});
		this.setupTurns();

		// If the current combatant was removed, update the turn order to the next survivor
		let turn = this.data.turn;
		if ( result.includes(current.id) ) {
			if ( nextSurvivor ) turn = this.turns.findIndex(t => t.id === nextSurvivor.id);
		}

		// Otherwise keep the combatant the same
		else turn = this.turns.findIndex(t => t.id === current.id);

		// Update database or perform a local override
		turn = Math.max(turn, 0);
		if ( game.user.id === userId ) this.update({turn});
		else this.data.update({turn});

		// Render the collection
		if ( this.data.active ) this.collection.render();
	}

	/* -------------------------------------------- */
	/*  Deprecated                                  */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	getCombatant(id) {
		console.warn("The Combat#getCombatant method has been deprecated in favor of Combat#combatants#get. Support for the old method will be removed in 0.9.0")
		return this.combatants.get(id);
	}

	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	async createCombatant(data, options) {
		console.warn("The Combat#createCombatant method has been deprecated in favor of Combatant.create and will be removed in 0.9.0");
		return this.createEmbeddedDocuments("Combatant", [data], options);
	}

	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	async updateCombatant(data, options) {
		console.warn("The Combat#updateCombatant method has been deprecated in favor of Combatant#update and will be removed in 0.9.0");
		const combatant = this.combatants.get(data._id, {strict: true});
		return combatant.update(data, options);
	}

	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	async deleteCombatant(id, options) {
		console.warn("The Combat#deleteCombatant method has been deprecated in favor of Combatant#delete and will be removed in 0.9.0");
		const combatant = this.combatants.get(id, {strict: true});
		return combatant.delete(options);
	}
}

/**
 * The Combatant embedded document within a Combat document which extends the BaseRollTable abstraction.
 * Each Combatant belongs to the effects collection of its parent Document.
 * Each Combatant contains a CombatantData object which provides its source data.
 *
 * @extends abstract.Document
 * @extends abstract.BaseCombatant
 * @extends ClientDocumentMixin
 *
 * @see {@link data.CombatantData}                  The Combatant data schema
 * @see {@link documents.Combat}                    The Combat document which contains Combatant embedded documents
 *
 * @param {CombatantData} [data={}]    Initial data provided to construct the Combatant document
 * @param {Combat|documents.Item} parent   The parent document to which this Combatant belongs
 */
class Combatant extends ClientDocumentMixin(foundry.documents.BaseCombatant) {
	constructor(data, context) {
		super(data, context);

		/**
		 * A cached reference to the Token which this Combatant represents, if any
		 * @type {Token|null}
		 * @private
		 */
		this._token = undefined;

		/**
		 * A cached reference to the Actor which this Combatant represents, if any
		 * @type {Actor|null}
		 * @private
		 */
		this._actor = undefined;

		/**
		 * The current value of the special tracked resource which pertains to this Combatant
		 * @type {object|null}
		 */
		this.resource = this.resource || null;
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * Determine the image icon path that should be used to portray this Combatant in the combat tracker or elsewhere
	 * @type {string}
	 */
	get img() {
		return this.data.img || this.token?.img || this.actor?.img || CONST.DEFAULT_TOKEN;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience reference to the current initiative score of this Combatant
	 * @type {number|null}
	 */
	get initiative() {
		return Number.isNumeric(this.data.initiative) ? Number(this.data.initiative) : null;
	}

	/* -------------------------------------------- */

	/**
	 * This is treated as a non-player combatant if it has no associated actor and no player users who can control it
	 * @type {boolean}
	 */
	get isNPC() {
		return !this.actor || !this.players.length;
	}

	/* -------------------------------------------- */

	/** @override */
	get isOwner() {
		return game.user.isGM || this.actor?.isOwner || false;
	}

	/* -------------------------------------------- */

	/**
	 * Is this Combatant entry currently visible in the Combat Tracker?
	 * @type {boolean}
	 */
	get isVisible() {
		return this.isOwner || !this.hidden;
	}

	/* -------------------------------------------- */

	/**
	 * Is this Combatant "hidden", either because they are explicitly marked as hidden or because their token is hidden
	 * @type {boolean}
	 */
	get hidden() {
		return this.data.hidden || this.token?.hidden || false;
	}

	/* -------------------------------------------- */

	/**
	 * The displayed name for the Combatant is based off its own configured data, or the data of its represented Token.
	 * @type {string}
	 */
	get name() {
		return this.data.name || this.token?.name || this.actor?.name || game.i18n.localize("COMBAT.UnknownCombatant");
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the Actor document which this Combatant represents, if any
	 * @type {Actor|null}
	 */
	get actor() {
		const token = this.token;
		if ( token ) this._actor = token.actor;
		if ( this._actor === undefined ) {
			this._actor = game.actors.get(this.data.actorId) || null;
		}
		return this._actor;
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the Token document which this Combatant represents, if any
	 * @type {Token|null}
	 */
	get token() {
		if ( this._token === undefined ) {
			const scene = game.scenes.get(this.parent.data.scene);
			const token = scene?.tokens.get(this.data.tokenId);
			this._token = token || null;
		}
		return this._token;
	}

	/* -------------------------------------------- */

	/**
	 * An array of User documents who have ownership of this Document
	 * @type {User[]}
	 */
	get players() {
		const playerOwners = [];
		for ( let u of game.users ) {
			if ( u.isGM ) continue;
			if ( this.testUserPermission(u, "OWNER") ) playerOwners.push(u);
		}
		return playerOwners;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/** @inheritdoc */
	testUserPermission(user, permission, {exact=false}={}) {
		// Combatants should be controlled by anyone who can update the Actor they represent
		return this.actor.testUserPermission(user, "update");
	}

	/* -------------------------------------------- */

	/**
	 * Get a Roll object which represents the initiative roll for this Combatant.
	 * @param {string} formula        An explicit Roll formula to use for the combatant.
	 * @return {Roll}                 The Roll instance to use for the combatant.
	 */
	getInitiativeRoll(formula) {
		formula = formula || this._getInitiativeFormula();
		const rollData = this.actor?.getRollData() || {};
		const roll = Roll.create(formula, rollData);
		return roll.evaluate({async: false});
	}

	/* -------------------------------------------- */

	/**
	 * Roll initiative for this particular combatant.
	 * @param {string} [formula]      A dice formula which overrides the default for this Combatant.
	 * @return {Roll}                 The Roll instance to use for the combatant.
	 */
	rollInitiative(formula) {
		const roll = this.getInitiativeRoll(formula);
		return this.update({initiative: roll.total});
	}

	/* -------------------------------------------- */

	/** @override */
	prepareDerivedData() {
		if ( !this.parent.data ) return;
		this.updateResource();
	}

	/* -------------------------------------------- */

	/**
	 * Update the value of the tracked resource for this Combatant.
	 * @returns {null|object}
	 */
	updateResource() {
		if ( !this.actor ) return this.resource = null;
		return this.resource = foundry.utils.getProperty(this.actor.data.data, this.parent.settings.resource) || null;
	}

	/* -------------------------------------------- */

	/**
	 * Acquire the default dice formula which should be used to roll initiative for this combatant.
	 * Modules or systems could choose to override or extend this to accommodate special situations.
	 * @return {string}               The initiative formula to use for this combatant.
	 * @protected
	 */
	_getInitiativeFormula() {
		return String(CONFIG.Combat.initiative.formula || game.system.data.initiative);
	}
}

/**
 * The client-side Drawing embedded document which extends the common BaseDrawing abstraction.
 * Each Drawing document contains DrawingData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.BaseDrawing
 * @extends ClientDocumentMixin
 *
 * @see {@link data.DrawingData}              The Drawing data schema
 * @see {@link documents.Scene}               The Scene document type which contains Drawing embedded documents
 * @see {@link applications.DrawingConfig}    The Drawing configuration application
 *
 * @param {data.DrawingData} [data={}]        Initial data provided to construct the Drawing document
 * @param {Scene} parent            The parent Scene document to which this Drawing belongs
 */
class DrawingDocument extends CanvasDocumentMixin(foundry.documents.BaseDrawing) {

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * A reference to the User who created the Drawing document.
	 * @type {User}
	 */
	get author() {
		return game.users.get(this.data.author);
	}

	/* -------------------------------------------- */

	/**
	 * A flag for whether the current User has full ownership over the Drawing document.
	 * @type {boolean}
	 */
	get isOwner() {
		return game.user.isGM || (this.data.author === game.user.id);
	}
}

/**
 * The client-side FogExploration document which extends the common BaseFogExploration abstraction.
 * Each FogExploration document contains FogExplorationData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.Document
 * @extends abstract.BaseFogExploration
 * @extends ClientDocumentMixin
 *
 * @see {@link data.FogExplorationData}              The FogExploration data schema
 *
 * @param {data.FogExplorationData} [data={}]        Initial data provided to construct the FogExploration document
 */
class FogExploration extends ClientDocumentMixin(foundry.documents.BaseFogExploration) {
	constructor(data={}, context) {
		data.user = data.user || game.user.id;
		data.scene = data.scene || canvas.scene?.id || null;
		super(data, context);
	}

	/* -------------------------------------------- */

	/**
	 * Explore fog of war for a new point source position.
	 * @param {PointSource} source    The candidate source of exploration
	 * @param {boolean} [force=false] Force the position to be re-explored
	 * @returns {boolean}             Is the source position newly explored?
	 */
	explore(source, force=false) {
		const r = canvas.lighting.globalLight ? canvas.dimensions.maxR : source.radius;
		if ( r <= 0 ) return false;
		const coords = canvas.grid.getCenter(source.x, source.y).map(Math.round).join("_");
		const position = this.data.positions[coords];

		// Check whether the position has already been explored
		let explored = position && (position.limit !== true) && (position.radius >= r);
		if ( explored && !force ) return false;

		// Update explored positions
		if ( CONFIG.debug.fog ) console.debug("SightLayer | Updating fog exploration for new explored position.");
		this.data.update({
			positions: {
				[coords]: {radius: source.radius, limit: source.limited}
			}
		});
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Obtain the fog of war exploration progress for a specific Scene and User.
	 * @returns {FogExploration|null}
	 */
	static async get({scene, user}={}, options={}) {
		const collection = game.collections.get("FogExploration");
		const sceneId = (scene || canvas.scene)?.id || null;
		const userId = (user || game.user)?.id;
		if ( !sceneId || !userId ) return null;
		if ( !(game.user.isGM || (userId === game.user.id)) ) {
			throw new Error("You do not have permission to access the FogExploration object of another user");
		}

		// Return cached exploration
		let exploration = collection.find(x => (x.data.user === userId) && (x.data.scene === sceneId) );
		if ( exploration ) return exploration;

		// Return persisted exploration
		const response = await this.database.get(this, {
			query: { scene: sceneId, user: userId },
			options: options
		});
		exploration = response.length ? response.shift() : null;
		if ( exploration ) collection.set(exploration.id, exploration);
		return exploration;
	}

	/* -------------------------------------------- */

	/**
	 * Transform the explored base64 data into a PIXI.Texture object
	 * @returns {PIXI.Texture|null}
	 */
	getTexture() {
		if ( this.data.explored === null ) return null;
		const bt = new PIXI.BaseTexture(this.data.explored);
		return new PIXI.Texture(bt);
	}

	/* -------------------------------------------- */

	/**
	 * Open Socket listeners which transact JournalEntry data
	 */
	static _activateSocketListeners(socket) {
		socket.on("resetFog", this._onResetFog.bind(this));
	}

	/* -------------------------------------------- */

	/**
	 * Handle a request from the server to reset fog of war for a particular scene.
	 * @param {string} sceneId
	 * @private
	 */
	static _onResetFog(sceneId) {
		const fogs = game.collections.get("FogExploration");
		for ( let fog of fogs ) {
			if ( fog.data.scene === sceneId ) fogs.delete(fog.id);
		}
		if ( sceneId !== canvas.scene.id ) return;
		return canvas.sight._handleResetFog();
	}
}

/**
 * The client-side Folder document which extends the common BaseFolder abstraction.
 * Each Folder document contains FolderData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.Document
 * @extends abstract.BaseFolder
 * @extends ClientDocumentMixin
 *
 * @see {@link data.FolderData}              The Folder data schema
 * @see {@link documents.Folders}            The world-level collection of Folder documents
 * @see {@link embedded.FolderSound}         The FolderSound embedded document within a parent Folder
 * @see {@link applications.FolderConfig}    The Folder configuration application
 *
 * @param {data.FolderData} [data={}]       Initial data provided to construct the Folder document
 */
class Folder extends ClientDocumentMixin(foundry.documents.BaseFolder) {

	/**
	 * The depth of this folder in its sidebar tree
	 * @type {number}
	 */
	depth;

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * Return an array of the Document instances which are contained within this Folder.
	 * @type {Document[]}
	 */
	get contents() {
		return this.documentCollection.filter(d => d.data.folder === this.id);
	}

	/* -------------------------------------------- */

	/**
	 * Return whether the folder is displayed in the sidebar to the current user
	 * @type {boolean}
	 */
	get displayed() {
		return game.user.isGM || !!this.content.length || this.children.some(c => c.displayed);
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the Document type which is contained within this Folder.
	 * @returns {Function}
	 */
	get documentClass() {
		return CONFIG[this.data.type].documentClass;
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the WorldCollection instance which provides Documents to this Folder.
	 * @returns {WorldCollection}
	 */
	get documentCollection() {
		return game.collections.get(this.data.type);
	}

	/* -------------------------------------------- */

	/**
	 * Return whether the folder is currently expanded within the sidebar interface.
	 * @type {boolean}
	 */
	get expanded() {
		return game.folders._expanded[this.id] || false;
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the parent Folder if one is set, otherwise null.
	 * @type {Folder|null}
	 */
	get parentFolder() {
		return this.collection.get(this.data.parent);
	}

	/* -------------------------------------------- */

	/**
	 * Return the named Entity type for elements in this folder.
	 * @return {string}
	 */
	get type() {
		return this.data.type;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Create a new Folder by rendering a dialog window to provide basic creation details
	 * @param {object} data       Initial data with which to populate the creation form
	 * @param {object} options    Initial positioning and sizing options for the dialog form
	 * @return {Application}      An active FolderConfig instance for creating the new Folder entity
	 */
	static createDialog(data={}, options={}) {
		const label = game.i18n.localize(this.metadata.label);
		const folderData = foundry.utils.mergeObject({
			name: game.i18n.format("ENTITY.New", {entity: label}),
			sorting: "a",
		}, data);
		const folder = new Folder(folderData);
		return new FolderConfig(folder, options).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Export all Documents contained in this Folder to a given Compendium pack.
	 * Optionally update existing Documents within the Pack by name, otherwise append all new entries.
	 * @param {CompendiumCollection} pack  A Compendium pack to which the entities will be exported
	 * @param {boolean} updateByName  Update existing entries in the Compendium pack, matching by name
	 * @return {Promise<CompendiumCollection>}  The updated Compendium Collection instance
	 */
	async exportToCompendium(pack, {updateByName=false}={}) {
		const index = await pack.getIndex();
		const entities = this.contents;
		ui.notifications.info(`Exporting ${entities.length} ${this.type} entities to Compendium ${pack.collection}.`);

		// Classify creations and updates
		const creations = [];
		const updates = [];
		for ( let d of this.contents ) {
			const data = d.toCompendium(pack);
			let existing = updateByName ? index.find(i => i.name === d.name) : index.find(i => i._id === d.id);
			if (existing) {
				data._id = existing._id;
				updates.push(data);
			}
			else creations.push(data);
			console.log(`Prepared ${d.name} for export to ${pack.collection}`);
		}

		// Perform changes
		const cls = pack.documentClass;
		if ( creations.length ) await cls.createDocuments(creations, {pack: pack.collection, render: false});
		if ( updates.length ) {
			await pack.getDocuments();
			await cls.updateDocuments(updates, {pack: pack.collection, render: false});
		}
		ui.notifications.info(`Finished exporting ${this.type}s to Compendium ${pack.collection}.`);
		pack.render(false);
		return pack;
	}

	/* -------------------------------------------- */

	/**
	 * Provide a dialog form that allows for exporting the contents of a Folder into an eligible Compendium pack.
	 * @param {string} pack       A pack ID to set as the default choice in the select input
	 * @param {object} options    Additional options passed to the Dialog.prompt method
	 * @return {Promise<void>}    A Promise which resolves or rejects once the dialog has been submitted or closed
	 */
	async exportDialog(pack, options={}) {

		// Get eligible pack destinations
		const packs = game.packs.filter(p => (p.entity === this.type) && !p.locked);
		if ( !packs.length ) {
			return ui.notifications.warn(game.i18n.format("FOLDER.ExportWarningNone", {type: this.type}));
		}

		// Render the HTML form
		const html = await renderTemplate("templates/sidebar/apps/folder-export.html", {
			packs: packs.reduce((obj, p) => {
				obj[p.collection] = p.title;
				return obj;
			}, {}),
			pack: options.pack ?? null,
			merge: options.merge ?? true
		});

		// Display it as a dialog prompt
		return Dialog.prompt({
			title: game.i18n.localize("FOLDER.ExportTitle") + `: ${this.name}`,
			content: html,
			label: game.i18n.localize("FOLDER.ExportTitle"),
			callback: html => {
				const form = html[0].querySelector("form");
				const pack = game.packs.get(form.pack.value);
				return this.exportToCompendium(pack, {updateByName: form.merge.checked});
			},
			options
		});
	}

	/* -------------------------------------------- */

	/**
	 * Get the Folder documents which are sub-folders of the current folder, either direct children or recursively.
	 * @param {boolean} [recursive=false] Identify child folders recursively, if false only direct children are returned
	 * @returns {Folder[]}  An array of Folder documents which are subfolders of this one
	 */
	getSubfolders(recursive=false) {
		let subfolders = game.folders.filter(f => f.data.parent === this.id);
		if ( recursive && subfolders.length ) {
			for ( let f of subfolders ) {
				const children = f.getSubfolders(true);
				subfolders = subfolders.concat(children);
			}
		}
		return subfolders;
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDelete(options, userId) {
		const parentId = this.data.parent || null;
		const db = CONFIG.DatabaseBackend;
		const {deleteSubfolders, deleteContents} = options;

		// Delete or move sub-Folders
		const deleteFolderIds = [];
		for ( let f of this.getSubfolders() ) {
			if ( deleteSubfolders ) deleteFolderIds.push(f.id);
			else f.data.update({parent: parentId});
		}
		if ( deleteFolderIds.length ) {
			db._handleDeleteDocuments({
				request: { type: "Folder", options: { deleteSubfolders, deleteContents, render: false } },
				result: deleteFolderIds,
				userId
			});
		}

		// Delete or move contained Documents
		const deleteDocumentIds = [];
		for ( let d of this.documentCollection ) {
			if ( d.data.folder !== this.id ) continue;
			if ( deleteContents ) deleteDocumentIds.push(d.id);
			else d.data.update({folder: parentId});
		}
		if ( deleteDocumentIds.length ) {
			db._handleDeleteDocuments({
				request: { type: this.data.type, options: { render: false } },
				result: deleteDocumentIds,
				userId
			});
		}
		return super._onDelete(options, userId);
	}

	/* -------------------------------------------- */
	/*  Deprecated                                  */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	get entities() {
		console.warn("The Folder#entities property has been renamed to Folder#contents. Support for the old property name will be removed in 0.9.0");
		return this.contents;
	}
}

/**
 * The client-side Item document which extends the common BaseItem abstraction.
 * Each Item document contains ItemData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.Document
 * @extends abstract.BaseItem
 * @extends ClientDocumentMixin
 *
 * @see {@link data.ItemData}              The Item data schema
 * @see {@link documents.Items}            The world-level collection of Item documents
 * @see {@link applications.ItemSheet}     The Item configuration application
 *
 * @param {data.ItemData} [data={}]       Initial data provided to construct the Item document
 */
class Item extends ClientDocumentMixin(foundry.documents.BaseItem) {

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * A convenience alias of Item#parent which is more semantically intuitive
	 * @type {Actor|null}
	 */
	get actor() {
		return this.parent;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience reference to the image path (data.img) used to represent this Item
	 * @type {string}
	 */
	get img() {
		return this.data.img;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience alias of Item#isEmbedded which is preserves legacy support
	 * @type {boolean}
	 */
	get isOwned() {
		return this.isEmbedded;
	}

	/* -------------------------------------------- */

	/**
	 * Return an array of the Active Effect instances which originated from this Item.
	 * The returned instances are the ActiveEffect instances which exist on the Item itself.
	 * @type {ActiveEffect[]}
	 */
	get transferredEffects() {
		return this.effects.filter(e => e.data.transfer === true);
	}

	/* -------------------------------------------- */

	/**
	 * A convenience reference to the item type (data.type) of this Item
	 * @type {string}
	 */
	get type() {
		return this.data.type;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Prepare a data object which defines the data schema used by dice roll commands against this Item
	 * @return {object}
	 */
	getRollData() {
		return this.data.data;
	}

	/* -------------------------------------------- */

	/** @override */
	_getSheetClass() {
		const cfg = CONFIG[this.documentName];
		const sheets = cfg.sheetClasses[this.type] || {};
		const override = this.getFlag("core", "sheetClass");
		if ( sheets[override] ) return sheets[override].cls;
		const classes = Object.values(sheets);
		if ( !classes.length ) return null;
		return (classes.find(s => s.default) ?? classes.pop()).cls;
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @inheritdoc */
	static async _onCreateDocuments(items, context) {
		if ( !(context.parent instanceof Actor) ) return;
		const toCreate = [];
		for ( let item of items ) {
			for ( let e of item.effects ) {
				if ( !e.data.transfer ) continue;
				const effectData = e.toJSON();
				effectData.origin = item.uuid;
				toCreate.push(effectData);
			}
		}
		if ( !toCreate.length ) return [];
		const cls = getDocumentClass("ActiveEffect");
		return cls.createDocuments(toCreate, context);
	}


	/* -------------------------------------------- */

	/** @inheritdoc */
	static async _onDeleteDocuments(items, context) {
		if ( !(context.parent instanceof Actor) ) return;
		const deletedUUIDs = new Set(items.map(i => i.uuid));
		const toDelete = [];
		for ( let e of context.parent.effects ) {
			if ( deletedUUIDs.has(e.data.origin) )  toDelete.push(e.id);
		}
		if ( !toDelete.length ) return [];
		const cls = getDocumentClass("ActiveEffect");
		return cls.deleteDocuments(toDelete, context);
	}

	/* -------------------------------------------- */
	/*  Deprecated                                  */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	get _data() {
		console.warn(`You are referencing Item#_data which has been deprecated in favor of Item#data#_source. Support for this reference will be removed in 0.9.0`);
		return this.data._source;
	}

	/**
	 * @deprecated since 0.8.1
	 * @ignore
	 */
	static createOwned(itemData, actor) {
		const cls = CONFIG.Item.documentClass;
		return new cls(itemData, {parent: actor});
	}
}

/**
 * The client-side JournalEntry document which extends the common BaseJournalEntry abstraction.
 * Each JournalEntry document contains JournalEntryData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.Document
 * @extends abstract.BaseJournalEntry
 * @extends ClientDocumentMixin
 *
 * @see {@link data.JournalEntryData}              The JournalEntry data schema
 * @see {@link documents.Journal}                  The world-level collection of JournalEntry documents
 * @see {@link applications.JournalSheet}          The JournalEntry configuration application
 *
 * @param {data.JournalEntryData} [data={}]       Initial data provided to construct the JournalEntry document
 */
class JournalEntry extends ClientDocumentMixin(foundry.documents.BaseJournalEntry) {

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * A boolean indicator for whether or not the JournalEntry is visible to the current user in the directory sidebar
	 * @type {boolean}
	 */
	get visible() {
		return this.testUserPermission(game.user, "OBSERVER");
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the Note instance for this Journal Entry in the current Scene, if any.
	 * If multiple notes are placed for this Journal Entry, only the first will be returned.
	 * @type {Note|null}
	 */
	get sceneNote() {
		if ( !canvas.ready ) return null;
		return canvas.notes.placeables.find(n => n.data.entryId === this.id) || null;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Show the JournalEntry to connected players.
	 * By default the entry will only be shown to players who have permission to observe it.
	 * If the parameter force is passed, the entry will be shown to all players regardless of normal permission.
	 *
	 * @param {string} mode     Which JournalEntry mode to display? Default is text.
	 * @param {boolean} force   Display the entry to all players regardless of normal permissions
	 * @return {Promise<JournalEntry>}  A Promise that resolves back to the shown entry once the request is processed
	 */
	async show(mode="text", force=false) {
		if ( !this.isOwner ) throw new Error("You may only request to show Journal Entries which you own.");
		return new Promise((resolve) => {
			game.socket.emit("showEntry", this.uuid, mode, force, entry => {
				Journal._showEntry(this.uuid, mode, true);
				ui.notifications.info(game.i18n.format("JOURNAL.ActionShowSuccess", {
					mode: mode,
					title: this.name,
					which: force ? "all" : "authorized"
				}));
				return resolve(this);
			});
		});
	}

	/* -------------------------------------------- */

	/**
	 * If the JournalEntry has a pinned note on the canvas, this method will animate to that note
	 * The note will also be highlighted as if hovered upon by the mouse
	 * @param {object} [options={}]         Options which modify the pan operation
	 * @param {number} [scale=1.5]          The resulting zoom level
	 * @param {number} [duration=250]       The speed of the pan animation in milliseconds
	 * @return {Promise<void>}              A Promise which resolves once the pan animation has concluded
	 */
	panToNote({scale=1.5, duration=250}={}) {
		const note = this.sceneNote;
		if ( !note ) return;
		if ( note.visible && !canvas.notes._active ) canvas.notes.activate();
		return canvas.animatePan({x: note.x, y: note.y, scale, duration}).then(() => {
			if ( canvas.notes._hover ) canvas.notes._hover._onMouseOut(new Event("mouseout"));
			note._onMouseOver(new Event("mouseover"));
		});
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @override */
	_onUpdate(data, options, userId) {
		super._onUpdate(data, options, userId);
		if ( !canvas.ready ) return;
		if ( ["name", "permission"].some(k => k in data) ) {
			canvas.notes.placeables.filter(n => n.data.entryId === this.id).forEach(n => n.draw());
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onDelete(options, userId) {
		super._onDelete(options, userId);
		if ( !canvas.ready ) return;
		for ( let n of canvas.notes.placeables ) {
			if ( n.data.entryId === this.id ) {
				n.entry = null;
			}
		}
	}
}

/**
 * The client-side Macro document which extends the common BaseMacro abstraction.
 * Each Macro document contains MacroData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.Document
 * @extends abstract.BaseMacro
 * @extends ClientDocumentMixin
 *
 * @see {@link data.MacroData}              The Macro data schema
 * @see {@link documents.Macros}            The world-level collection of Macro documents
 * @see {@link applications.MacroConfig}    The Macro configuration application
 *
 * @param {data.MacroData} [data={}]        Initial data provided to construct the Macro document
 */
class Macro extends ClientDocumentMixin(foundry.documents.BaseMacro) {

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * Is the current User the author of this macro?
	 * @type {boolean}
	 */
	get isAuthor() {
		return game.user.id === this.data.author;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Execute the Macro command.
	 * @param {object} [scope={}]     Provide some additional scope configuration for the Macro
	 * @param {Actor} [scope.actor]   An Actor who is the protagonist of the executed action
	 * @param {Token} [scope.token]   A Token which is the protagonist of the executed action
	 */
	execute({actor, token}={}) {
		switch ( this.data.type ) {
			case "chat":
				return this._executeChat({actor, token});
			case "script":
				if ( !game.user.can("MACRO_SCRIPT") ) {
					return ui.notifications.warn(`You are not allowed to use JavaScript macros.`);
				}
				return this._executeScript({actor, token});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Execute the command as a chat macro.
	 * Chat macros simulate the process of the command being entered into the Chat Log input textarea.
	 * @private
	 */
	_executeChat({actor, token}={}) {
		ui.chat.processMessage(this.data.command).catch(err => {
			ui.notifications.error("There was an error in your chat message syntax.");
			console.error(err);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Execute the command as a script macro.
	 * Script Macros are wrapped in an async IIFE to allow the use of asynchronous commands and await statements.
	 * @private
	 */
	_executeScript({actor, token}={}) {

		// Add variables to the evaluation scope
		const speaker = ChatMessage.getSpeaker();
		const character = game.user.character;
		actor = actor || game.actors.get(speaker.actor);
		token = token || (canvas.ready ? canvas.tokens.get(speaker.token) : null);

		// Attempt script execution
		const body = `(async () => {
			${this.data.command}
		})()`;
		const fn = Function("speaker", "actor", "token", "character", body);
		try {
			fn.call(this, speaker, actor, token, character);
		} catch (err) {
			ui.notifications.error(`There was an error in your macro syntax. See the console (F12) for details`);
			console.error(err);
		}
	}
}

/**
 * The client-side MeasuredTemplate embedded document which extends the common BaseMeasuredTemplate abstraction.
 * Each MeasuredTemplate document contains MeasuredTemplateData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.BaseMeasuredTemplate
 * @extends ClientDocumentMixin
 *
 * @see {@link data.MeasuredTemplateData}              The MeasuredTemplate data schema
 * @see {@link documents.Scene}               The Scene document type which contains MeasuredTemplate embedded documents
 * @see {@link applications.MeasuredTemplateConfig}    The MeasuredTemplate configuration application
 *
 * @param {data.MeasuredTemplateData} [data={}]        Initial data provided to construct the MeasuredTemplate document
 * @param {Scene} parent            The parent Scene document to which this MeasuredTemplate belongs
 */
class MeasuredTemplateDocument extends CanvasDocumentMixin(foundry.documents.BaseMeasuredTemplate) {

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * A reference to the User who created the MeasuredTemplate document.
	 * @type {User}
	 */
	get author() {
		return game.users.get(this.data.user);
	}

	/* -------------------------------------------- */

	/**
	 * A flag for whether the current User has full ownership over the MeasuredTemplate document.
	 * @type {boolean}
	 */
	get isOwner() {
		return game.user.isGM || (this.data.author === game.user.id);
	}
}

/**
 * The client-side Note embedded document which extends the common BaseNote abstraction.
 * Each Note document contains NoteData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.BaseNote
 * @extends ClientDocumentMixin
 *
 * @see {@link data.NoteData}                 The Note data schema
 * @see {@link documents.Scene}               The Scene document type which contains Note embedded documents
 * @see {@link applications.NoteConfig}       The Note configuration application
 *
 * @param {data.NoteData} [data={}]           Initial data provided to construct the Note document
 * @param {Scene} parent            The parent Scene document to which this Note belongs
 */
class NoteDocument extends CanvasDocumentMixin(foundry.documents.BaseNote) {

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * The associated JournalEntry which is referenced by this Note
	 * @type {JournalEntry}
	 */
	get entry() {
		return game.journal.get(this.data.entryId);
	}

	/* -------------------------------------------- */

	/**
	 * The text label used to annotate this Note
	 * @type {string}
	 */
	get label() {
		return this.data.text || this.entry?.name || "Unknown";
	}
}

/**
 * The PlaylistSound embedded document within a Playlist document which extends the BasePlaylist abstraction.
 * Each PlaylistSound belongs to the results collection of a Playlist entity.
 * Each PlaylistSound contains a PlaylistSoundData object which provides its source data.
 *
 * @extends abstract.Document
 * @extends abstract.BasePlaylistSound
 * @extends ClientDocumentMixin
 *
 * @see {@link data.PlaylistSoundData}    The PlaylistSound data schema
 * @see {@link documents.Playlist}        The Playlist document which contains PlaylistSound embedded documents
 * @see {@link Sound}                     The Sound API which manages web audio playback
 *
 * @param {PlaylistSoundData} [data={}]  Initial data provided to construct the PlaylistSound document
 * @param {Playlist} parent      The parent Playlist document to which this result belongs
 */
class PlaylistSound extends ClientDocumentMixin(foundry.documents.BasePlaylistSound) {
	constructor(data, context) {
		super(data, context);

		/**
		 * The Sound which manages playback for this playlist sound
		 * @type {Sound|null}
		 */
		this.sound = this._createSound();

		/**
		 * A debounced function, accepting a single volume parameter to adjust the volume of this sound
		 * @type {Function}
		 * @param {number} volume     The desired volume level
		 */
		this.debounceVolume = foundry.utils.debounce(volume => this.update({volume}), PlaylistSound.VOLUME_DEBOUNCE_MS);
	}

	/**
	 * The debounce tolerance for processing rapid volume changes into database updates in milliseconds
	 * @type {number}
	 */
	static VOLUME_DEBOUNCE_MS = 100;

	/* -------------------------------------------- */

	/**
	 * Create a Sound used to play this PlaylistSound document
	 * @returns {Sound|null}
	 * @private
	 */
	_createSound() {
		if ( !this.id || !this.data.path ) return null;
		const sound = game.audio.create({
			src: this.data.path,
			preload: false,
			singleton: false
		});
		sound.on("start", this._onStart.bind(this));
		sound.on("end", this._onEnd.bind(this));
		sound.on("stop", this._onStop.bind(this));
		return sound;
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * A convenience reference to the HTTP path to the source audio file
	 * @type {string}
	 */
	get path() {
		return this.data.path;
	}

	/**
	 * A convenience indicator for whether this sound is currently playing.
	 * @type {boolean}
	 */
	get playing() {
		return this.data.playing;
	}

	/**
	 * The effective volume at which this PlaylistSound should be playing, including the global playlist volume modifier
	 */
	get volume() {
		return this.data.volume * game.settings.get("core", "globalPlaylistVolume");
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Synchronize playback for this particular PlaylistSound instance
	 */
	sync() {
		if ( !this.sound ) return;

		// Conclude current playback
		if ( !this.playing ) {
			const fade = this.data.fade ?? this.parent.data.fade ?? 0;
			if ( fade && !this.data.pausedTime ) return this.sound.fade(0, {duration: fade}).then(() => this.sound.stop());
			else return this.sound.stop();
		}

		// Determine playback configuration
		const playback = {
			loop: this.data.repeat,
			volume: this.volume,
			fade: 1000
		};
		if ( this.data.pausedTime && this.playing && !this.sound.playing ) playback.offset = this.data.pausedTime;

		// Load and autoplay, or play directly if already loaded
		if ( this.sound.loaded ) return this.sound.play(playback);
		return this.sound.load({autoplay: true, autoplayOptions: playback});
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @override */
	_onUpdate(changed, options, userId) {
		super._onUpdate(changed, options, userId);
		if ( "path" in changed ) {
			if ( this.sound ) this.sound.stop();
			this.sound = this._createSound();
		}
		this.sync();
	}

	/* -------------------------------------------- */

	/** @override */
	_onDelete(options, userId) {
		super._onDelete(options, userId);
		this.data.playing = false;
		this.sync();
	}

	/* -------------------------------------------- */

	/**
	 * Special handling that occurs when a PlaylistSound reaches the natural conclusion of its playback.
	 * @private
	 */
	async _onEnd() {
		if (!game.user.isGM) return;
		return this.parent._onSoundEnd(this);
	}

	/* -------------------------------------------- */

	/**
	 * Special handling that occurs when playback of a PlaylistSound is started.
	 * @private
	 */
	async _onStart() {
		if ( !this.playing ) return this.sound.stop();

		// Maybe fade in and out
		const fade = this.data.fade ?? this.parent.data.fade ?? 0;
		if ( fade ) {
			this._fadeIn(this.sound);
			this.sound.schedule(this._fadeOut.bind(this), this.sound.duration - (fade / 1000));
		}

		// Playlist-level orchestration actions
		return this.parent._onSoundStart(this);
	}

	/* -------------------------------------------- */

	/**
	 * Special handling that occurs when a PlaylistSound is manually stopped before its natural conclusion.
	 * @private
	 */
	async _onStop() {}

	/* -------------------------------------------- */

	/**
	 * Handle fading in the volume for this sound when it begins to play (or loop)
	 * @private
	 */
	_fadeIn(sound) {
		if ( !sound.node ) return;
		const fade = Math.clamped(this.data.fade ?? this.parent.data.fade ?? 0, 0, (sound.duration - 1) * 1000);
		if ( !fade || sound.pausedTime ) return;
		sound.fade(this.volume, {duration: fade, from: 0}).then(() => {
			return sound.schedule(this._fadeIn.bind(this), 0); // Recursively schedule next
		});
	}

	/* -------------------------------------------- */

	/**
	 * Handle fading out the volume for this sound when it begins to play (or loop)
	 * @private
	 */
	_fadeOut(sound) {
		if ( !sound.node ) return;
		const fade = Math.clamped(this.data.fade ?? this.parent.data.fade ?? 0, 0, (sound.duration - 1) * 1000);
		if ( !fade ) return;
		sound.fade(0, {duration: fade}).then(() => {
			return sound.schedule(this._fadeOut.bind(this), sound.duration - (fade / 1000)) // Recursively schedule next
		});
	}
}
/**
 * The client-side Playlist document which extends the common BasePlaylist abstraction.
 * Each Playlist document contains PlaylistData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.Document
 * @extends abstract.BasePlaylist
 * @extends ClientDocumentMixin
 *
 * @see {@link data.PlaylistData}               The Playlist data schema
 * @see {@link documents.Playlists}             The world-level collection of Playlist documents
 * @see {@link embedded.PlaylistSound}          The PlaylistSound embedded document within a parent Playlist
 * @see {@link applications.PlaylistConfig}     The Playlist configuration application
 *
 * @param {data.PlaylistData} [data={}]         Initial data provided to construct the Playlist document
 */
class Playlist extends ClientDocumentMixin(foundry.documents.BasePlaylist) {
	constructor(data, context) {
		super(data, context);

		/**
		 * Each sound which is played within the Playlist has a created Howl instance.
		 * The keys of this object are the sound IDs and the values are the Howl instances.
		 * @type {Object}
		 */
		this.audio = this.audio || {};

		/**
		 * Playlists may have a playback order which defines the sequence of Playlist Sounds
		 * @type {string[]}
		 */
		this._playbackOrder = undefined;
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * The playback mode for the Playlist instance
	 * @type {number}
	 */
	get mode() {
		return this.data.mode;
	}

	/* -------------------------------------------- */

	/**
	 * The order in which sounds within this playlist will be played (if sequential or shuffled)
	 * Uses a stored seed for randomization to guarantee that all clients generate the same random order.
	 * @type {string[]}
	 */
	get playbackOrder() {
		if ( this._playbackOrder !== undefined ) return this._playbackOrder;
		switch ( this.mode ) {

			// Shuffle all tracks
			case CONST.PLAYLIST_MODES.SHUFFLE:
				let ids = this.sounds.map(s => s.id);
				const mt = new MersenneTwister(this.data.seed ?? 0);
				let shuffle = ids.reduce((shuffle, id) => {
					shuffle[id] = mt.random();
					return shuffle;
				}, {});
				ids.sort((a, b) => shuffle[a] - shuffle[b]);
				return this._playbackOrder = ids;

			// Sorted sequential playback
			default:
				const sorted = this.sounds.contents.sort(this._sortSounds);
				return this._playbackOrder = sorted.map(s => s.id);
		}
	}

	/* -------------------------------------------- */

	/**
	 * An indicator for whether any Sound within the Playlist is currently playing
	 * @type {boolean}
	 */
	get playing() {
		return this.sounds.some(s => s.playing);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get visible() {
		return game.user.isGM || this.playing;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Begin simultaneous playback for all sounds in the Playlist.
	 * @returns {Promise<Playlist>} The updated Playlist entity
	 */
	async playAll() {
		if ( this.sounds.size === 0 ) return this;
		const updateData = { playing: true };
		const order = this.playbackOrder;

		// Handle different playback modes
		switch (this.mode) {

			// Soundboard Only
			case CONST.PLAYLIST_MODES.DISABLED:
				updateData.playing = false;
				break;

			// Sequential or Shuffled Playback
			case CONST.PLAYLIST_MODES.SEQUENTIAL:
			case CONST.PLAYLIST_MODES.SHUFFLE:
				const paused = this.sounds.find(s => s.data.pausedTime);
				const nextId = paused?.id || order[0];
				updateData.sounds = this.sounds.map(s => {
					return {_id: s.id, playing: s.id === nextId};
				});
				break;

			// Simultaneous - play all tracks
			case CONST.PLAYLIST_MODES.SIMULTANEOUS:
				updateData.sounds = this.sounds.map(s => {
					return {_id: s.id, playing: true};
				});
				break;
		}

		// Update the Playlist
		return this.update(updateData);
	}

	/* -------------------------------------------- */

	/**
	 * Play the next Sound within the sequential or shuffled Playlist.
	 * @param {string} [soundId]      The currently playing sound ID, if known
	 * @param {object} [options={}]   Additional options which configure the next track
	 * @param {number} [options.direction=1] Whether to advance forward (if 1) or backwards (if -1)
	 * @returns {Promise<Playlist>}   The updated Playlist document
	 */
	async playNext(soundId, {direction=1}={}) {
		if ( ![CONST.PLAYLIST_MODES.SEQUENTIAL, CONST.PLAYLIST_MODES.SHUFFLE].includes(this.mode) ) return null;

		// Determine the next sound
		if ( !soundId ) {
			const current = this.sounds.find(s => s.playing);
			soundId = current?.id || null;
		}
		let next = direction === 1 ? this._getNextSound(soundId) : this._getPreviousSound(soundId);
		if ( !this.data.playing ) next = null;

		// Enact playlist updates
		const sounds = this.sounds.map(s => {
			return {_id: s.id, playing: s.id === next?.id, pausedTime: null}
		});
		return this.update({sounds});
	}

	/* -------------------------------------------- */

	/**
	 * Begin playback of a specific Sound within this Playlist.
	 * Determine which other sounds should remain playing, if any.
	 * @param {PlaylistSound} sound       The desired sound that should play
	 * @returns {Promise<Playlist>}       The updated Playlist
	 */
	async playSound(sound) {
		const updates = {playing: true};
		switch ( this.mode ) {
			case CONST.PLAYLIST_MODES.SEQUENTIAL:
			case CONST.PLAYLIST_MODES.SHUFFLE:
				updates.sounds = this.sounds.map(s => {
					let isPlaying = s.id === sound.id;
					return {_id: s.id, playing: isPlaying, pausedTime: isPlaying ? s.pausedTime : null};
				});
				break;
			default:
				updates.sounds = [{_id: sound.id, playing: true}];
		}
		return this.update(updates);
	}

	/* -------------------------------------------- */

	/**
	 * Stop playback of a specific Sound within this Playlist.
	 * Determine which other sounds should remain playing, if any.
	 * @param {PlaylistSound} sound       The desired sound that should play
	 * @returns {Promise<Playlist>}       The updated Playlist
	 */
	async stopSound(sound) {
		return this.update({
			playing: this.sounds.some(s => (s.id !== sound.id) && s.playing),
			sounds: [{_id: sound.id, playing: false, pausedTime: null}]
		});
	}

	/* -------------------------------------------- */

	/**
	 * End playback for any/all currently playing sounds within the Playlist.
	 * @returns {Promise<Playlist>} The updated Playlist entity
	 */
	async stopAll() {
		return this.update({
			playing: false,
			sounds: this.sounds.map(s => {
				return {_id: s.id, playing: false};
			})
		});
	}

	/* -------------------------------------------- */

	/**
	 * Cycle the playlist mode
	 * @return {Promise.<Playlist>}   A promise which resolves to the updated Playlist instance
	 */
	async cycleMode() {
		const modes = Object.values(CONST.PLAYLIST_MODES);
		let mode = this.mode + 1;
		mode = mode > Math.max(...modes) ? modes[0] : mode;
		for ( let s of this.sounds ) {
			s.data.playing = false;
		}
		return this.update({sounds: this.sounds.toJSON(), mode: mode});
	}

	/* -------------------------------------------- */

	/**
	 * Get the next sound in the cached playback order. For internal use.
	 * @private
	 */
	_getNextSound(soundId) {
		const order = this.playbackOrder;
		let idx = order.indexOf(soundId);
		if (idx === order.length - 1) idx = -1;
		return this.sounds.get(order[idx+1]);
	}

	/* -------------------------------------------- */

	/**
	 * Get the previous sound in the cached playback order. For internal use.
	 * @private
	 */
	_getPreviousSound(soundId) {
		const order = this.playbackOrder;
		let idx = order.indexOf(soundId);
		if ( idx === -1 ) idx = 1;
		else if (idx === 0) idx = order.length;
		return this.sounds.get(order[idx-1]);
	}

	/* -------------------------------------------- */

	/**
	 * Define the sorting order for the Sounds within this Playlist. For internal use.
	 * @private
	 */
	_sortSounds(a, b) {
		return a.name.localeCompare(b.name);
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async _preUpdate(changed, options, user) {
		if ((("mode" in changed) || ("playing" in changed)) && !("seed" in changed)) {
			changed.seed = Math.floor(Math.random() * 1000);
		}
		return super._preUpdate(changed, options, user);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onUpdate(changed, options, userId) {
		super._onUpdate(changed, options, userId);
		if ( "seed" in changed ) this._playbackOrder = undefined;
		if ( "sounds" in changed ) this.sounds.forEach(s => s.sync());
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDelete(options, userId) {
		super._onDelete(options, userId);
		this.sounds.forEach(s => s.sound.stop());
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onCreateEmbeddedDocuments(embeddedName, ...args) {
		super._onCreateEmbeddedDocuments(embeddedName, ...args);
		this.collection.render();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onUpdateEmbeddedDocuments(embeddedName, ...args) {
		super._onUpdateEmbeddedDocuments(embeddedName, ...args);
		this.collection.render();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDeleteEmbeddedDocuments(embeddedName, ...args) {
		super._onDeleteEmbeddedDocuments(embeddedName, ...args);
		this.collection.render();
	}

	/* -------------------------------------------- */

	/**
	 * Handle callback logic when an individual sound within the Playlist concludes playback naturally
	 * @param {PlaylistSound} sound
	 * @private
	 */
	async _onSoundEnd(sound) {
		switch ( this.mode ) {
			case CONST.PLAYLIST_MODES.SEQUENTIAL:
			case CONST.PLAYLIST_MODES.SHUFFLE:
				return this.playNext(sound.id);
			case CONST.PLAYLIST_MODES.SIMULTANEOUS:
			case CONST.PLAYLIST_MODES.DISABLED:
				const updates = {playing: true, sounds: [{_id: sound.id, playing: false, pausedTime: null}]};
				for ( let s of this.sounds ) {
					if ( (s !== sound) && s.playing ) break;
					updates.playing = false;
				}
				return this.update(updates);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle callback logic when playback for an individual sound within the Playlist is started.
	 * Schedule auto-preload of next track
	 * @param {PlaylistSound} sound
	 * @private
	 */
	async _onSoundStart(sound) {
		if ( ![CONST.PLAYLIST_MODES.SEQUENTIAL, CONST.PLAYLIST_MODES.SHUFFLE].includes(this.mode) ) return;
		const apl = CONFIG.Playlist.autoPreloadSeconds;
		if ( Number.isNumeric(apl) ) {
			setTimeout(() => {
				if ( !sound.playing ) return;
				const next = this._getNextSound(sound.id);
				if ( next ) next.sound.load();
			}, (sound.sound.duration - apl) * 1000);
		}
	}

	/* -------------------------------------------- */
	/*  Importing and Exporting                     */
	/* -------------------------------------------- */

	/** @inheritdoc */
	toCompendium(pack) {
		const data = super.toCompendium(pack);
		data.playing = false;
		for ( let s of data.sounds ) {
			s.playing = false;
		}
		return data;
	}
}

/**
 * The client-side Scene document which extends the common BaseScene abstraction.
 * Each Scene document contains SceneData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.Document
 * @extends abstract.BaseScene
 * @extends ClientDocumentMixin
 *
 * @see {@link data.SceneData}              The Scene data schema
 * @see {@link documents.Scenes}            The world-level collection of Scene documents
 * @see {@link applications.SceneConfig}    The Scene configuration application
 *
 * @param {data.SceneData} [data={}]        Initial data provided to construct the Scene document
 */
class Scene extends ClientDocumentMixin(foundry.documents.BaseScene) {
	constructor(data, context) {
		super(data, context);

		/**
		 * Determine the canvas dimensions this Scene would occupy, if rendered
		 * @type {object}
		 */
		this.dimensions = this.dimensions || {};

		/**
		 * Track whether the scene is the active view
		 * @type {boolean}
		 */
		this._view = this.data.active;

		/**
		 * Track the viewed position of each scene (while in memory only, not persisted)
		 * When switching back to a previously viewed scene, we can automatically pan to the previous position.
		 * @type {{x: number, y: number, scale: number}}
		 */
		this._viewPosition = {};
	}

	/* -------------------------------------------- */
	/*  Scene Properties                            */
	/* -------------------------------------------- */

	/**
	 * A convenience accessor for whether the Scene is currently active
	 * @type {boolean}
	 */
	get active() {
		return this.data.active;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor for the background image of the Scene
	 * @type {string}
	 */
	get img() {
		return this.data.img;
	}


	/* -------------------------------------------- */

	/**
	 * A convenience accessor for whether the Scene is currently viewed
	 * @type {boolean}
	 */
	get isView() {
		return this._view;
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the JournalEntry entity associated with this Scene, or null
	 * @return {JournalEntry|null}
	 */
	get journal() {
		return this.data.journal ? game.journal.get(this.data.journal) : null;
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the Playlist entity for this Scene, or null
	 * @type {Playlist|null}
	 */
	get playlist() {
		return this.data.playlist ? game.playlists.get(this.data.playlist) : null;
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the PlaylistSound document which should automatically play for this Scene, if any
	 * @type {Playlist|null}
	 */
	get playlistSound() {
		const playlist = this.playlist;
		if ( !playlist ) return null;
		return playlist.sounds.get(this.data.playlistSound) || null;
	}

	/* -------------------------------------------- */
	/*  Scene Methods                               */
	/* -------------------------------------------- */

	/**
	 * Set this scene as currently active
	 * @return {Promise<Scene>}  A Promise which resolves to the current scene once it has been successfully activated
	 */
	async activate() {
		if ( this.active ) return this;
		return this.update({active: true});
	}

	/* -------------------------------------------- */

	/**
	 * Set this scene as the current view
	 * @return {Promise<Scene>}
	 */
	async view() {

		// Do not switch if the loader is still running
		if ( canvas.loading ) {
			return ui.notifications.warn(`You cannot switch Scenes until resources finish loading for your current view.`);
		}

		// Switch the viewed scene
		for ( let scene of game.scenes ) {
			scene._view = scene.id === this.id
		}

		// Re-draw the canvas if the view is different
		if ( canvas.initialized && (canvas.id !== this.id) ) {
			console.log(`Foundry VTT | Viewing Scene ${this.name}`);
			await canvas.draw(this);
		}

		// Render apps for the collection
		this.collection.render();
		ui.combat.initialize();
		return this;
	}

	/* -------------------------------------------- */

	/** @override */
	clone(createData={}, options={}) {
		createData["active"] = false;
		createData["navigation"] = false;
		return super.clone(createData, options);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	prepareBaseData() {
		super.prepareBaseData();
		this.dimensions = Canvas.getDimensions(this.data);
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @override */
	async _preCreate(data, options, user) {
		await super._preCreate(data, options, user);

		// Set a Scene as active if none currently are
		if ( !("active" in data) && !game.scenes.active ) this.data.update({active: true});

		// Base64 the thumbnail for compendium Scenes
		if ( canvas.ready && this.compendium && data.img ) {
			const t = await this.createThumbnail({img: data.img});
			this.data.update({thumb: t.thumb});
		}

		// Trigger Playlist Updates
		if ( this.data.active ) game.playlists._onChangeScene(this, data);
	}

	/* -------------------------------------------- */

	/** @override */
	_onCreate(data, ...args) {
		super._onCreate(data, ...args);
		if ( data.active === true ) this._onActivate(true);
	}

	/* -------------------------------------------- */

	/** @override */
	async _preUpdate(data, options, user) {
		await super._preUpdate(data, options, user);
		const audioChange = ("active" in data) || (this.data.active && ["playlist", "playlistSound"].some(k => k in data));
		if ( audioChange ) game.playlists._onChangeScene(this, data);
	}

	/* -------------------------------------------- */

	/** @override */
	_onUpdate(data, options, userId) {
		super._onUpdate(data, options, userId);
		const changed = new Set(Object.keys(data).filter(k => k !== "_id"));

		// If the Scene became active, go through the full activation procedure
		if ( changed.has("active") ) this._onActivate(data.active);

		// If the Thumbnail was updated, bust the image cache
		if ( changed.has("thumb") && this.data.thumb ) {
			this.data.thumb = this.data.thumb.split("?")[0] + `?${Date.now()}`;
		}

		// If the scene is already active, maybe re-draw the canvas
		if ( canvas.scene === this ) {
			const redraw = [
				"img", "foreground", "shiftX", "shiftY", "width", "height", "padding", "backgroundColor", // Scene Dimensions
				"gridType", "grid", "gridAlpha", "gridColor", "gridDistance", "gridUnits",                // Grid Configuration
				"drawings", "lights", "sounds", "templates", "tiles", "tokens", "walls",                  // Placeable Objects
				"weather"                                                                                // Ambience
			];
			if ( redraw.some(k => changed.has(k)) ) return canvas.draw();

			// Modify vision conditions
			const perceptionAttrs = ["globalLight", "globalLightThreshold", "tokenVision", "fogExploration"];
			if ( perceptionAttrs.some(k => changed.has(k)) ) canvas.perception.initialize();

			// Progress darkness level
			if ( changed.has("darkness") ) {
				if ( options.animateDarkness ) {
					canvas.lighting.animateDarkness(data.darkness, {
						duration: typeof options.animateDarkness === "number" ? options.animateDarkness : undefined
					});
				}
				else canvas.lighting.refresh(data.darkness);
			}
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _preDelete(options, user) {
		await super._preDelete(options, user);
		if ( this.data.active ) game.playlists._onChangeScene(this, {active: false});
	}

	/* -------------------------------------------- */

	/** @override */
	_onDelete(options, userId) {
		super._onDelete(options, userId);
		if ( canvas.scene?.id === this.id ) canvas.draw(null);
	}

	/* -------------------------------------------- */

	/**
	 * Handle Scene activation workflow if the active state is changed to true
	 * @param {boolean} active    Is the scene now active?
	 * @protected
	 */
	_onActivate(active) {
		if ( !canvas.initialized ) return;
		if ( !active ) return canvas.draw(null);
		for ( let s of game.scenes ) {
			if ( s.data.active ) s.data.update({active: s.id === this.id});
		}
		return this.view();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_preCreateEmbeddedDocuments(embeddedName, result, options, userId) {
		super._preCreateEmbeddedDocuments(embeddedName, result, options, userId);
		if ( this.isView && !options.isUndo ) {
			const layer = canvas.getLayerByEmbeddedName(embeddedName);
			layer.storeHistory("create", result);
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onCreateEmbeddedDocuments(...args) {
		super._onCreateEmbeddedDocuments(...args);
		if ( this.isView ) canvas.triggerPendingOperations();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_preUpdateEmbeddedDocuments(embeddedName, result, options, userId) {
		super._preUpdateEmbeddedDocuments(embeddedName, result, options, userId);
		if ( this.isView && !options.isUndo ) {
			const layer = canvas.getLayerByEmbeddedName(embeddedName);
			const updatedIds = new Set(result.map(r => r._id));
			const originals = this.getEmbeddedCollection(embeddedName).reduce((arr, d) => {
				if ( updatedIds.has(d.id) ) arr.push(d.toJSON());
				return arr;
			}, []);
			layer.storeHistory("update", originals);
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onUpdateEmbeddedDocuments(...args) {
		super._onUpdateEmbeddedDocuments(...args);
		if ( this.isView ) canvas.triggerPendingOperations();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_preDeleteEmbeddedDocuments(embeddedName, result, options, userId) {
		super._preDeleteEmbeddedDocuments(embeddedName, result, options, userId);
		if ( this.isView && !options.isUndo ) {
			const layer = canvas.getLayerByEmbeddedName(embeddedName);
			const originals = this.getEmbeddedCollection(embeddedName).reduce((arr, d) => {
				if ( result.includes(d.id) ) arr.push(d.toJSON());
				return arr;
			}, []);
			layer.storeHistory("delete", originals);
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDeleteEmbeddedDocuments(...args) {
		super._onDeleteEmbeddedDocuments(...args);
		if ( this.isView ) canvas.triggerPendingOperations();
	}

	/* -------------------------------------------- */
	/*  Importing and Exporting                     */
	/* -------------------------------------------- */

	/** @inheritdoc */
	toCompendium(pack) {
		const data = super.toCompendium(pack);
		data.fogReset = null;
		data.navigation = false;
		data.navOrder = 0;
		return data;
	}

	/* -------------------------------------------- */

	/**
	 * Create a 300px by 100px thumbnail image for this scene background
	 * @param {string} [string|null]  A background image to use for thumbnail creation, otherwise the current scene
	 *                          background is used.
	 * @param {number} [width]        The desired thumbnail width. Default is 300px
	 * @param {number} [height]       The desired thumbnail height. Default is 100px;
	 * @return {Promise<object>}      The created thumbnail data.
	 */
	async createThumbnail({img, width=300, height=100}={}) {
		const newImage = img !== undefined;
		img = img ?? this.data.img;
		const tiles = this.tiles.filter(t => t.data.img).sort((a, b) => a.data.z - b.data.z);

		// Load required textures to create the thumbnail
		const toLoad = tiles.map(t => t.data.img);
		if ( img ) toLoad.push(img);
		if ( this.data.foreground ) toLoad.push(this.data.foreground);
		await TextureLoader.loader.load(toLoad);

		// First load the background texture to get dimensions
		const dims = this.toJSON();
		const tex = img ? getTexture(img) : null;
		if ( newImage ) {
			dims.width = tex.width;
			dims.height = tex.height;
		}
		const d = Canvas.getDimensions(dims);

		// Create a container and add a transparent graphic to enforce the size
		const c = new PIXI.Container();
		const r = new PIXI.Rectangle(0, 0, d.sceneWidth, d.sceneHeight);
		const g = c.addChild(new PIXI.Graphics())
		g.beginFill(0xFFFFFF, 1.0).drawShape(r).endFill();
		c.mask = g;

		// Tile drawing function
		const drawTile = async (container, tile) => {
			const t = new Tile(tile);
			container.addChild(t);
			await t.draw();
			t.x -= d.paddingX;
			t.y -= d.paddingY;
		}

		// Background container
		if ( tex ) {
			const bg = c.addChild(new PIXI.Container());
			bg.addChild(new PIXI.Sprite(tex));
			bg.width = d.sceneWidth
			bg.height = d.sceneHeight
			for ( let t of tiles ) {
				if ( t.data.overhead || t.data.hidden ) continue;
				await drawTile(bg, t);
			}
		}

		// Foreground container
		if ( this.data.foreground ) {
			const fgTex = getTexture(this.data.foreground);
			const fg = c.addChild(new PIXI.Container());
			fg.addChild(new PIXI.Sprite(fgTex));
			fg.width = d.sceneWidth
			fg.height = d.sceneHeight
			for ( let t of tiles ) {
				if ( !t.data.overhead || t.data.hidden ) continue;
				await drawTile(fg, t);
			}
		}

		// Render the container to a thumbnail
		return ImageHelper.createThumbnail(c, {width, height});
	}
}

/**
 * The client-side Setting document which extends the common BaseSetting abstraction.
 * Each Setting document contains SettingData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.Document
 * @extends abstract.BaseSetting
 * @extends ClientDocumentMixin
 *
 * @see {@link data.SettingData}              The Setting data schema
 * @see {@link documents.WorldSettings}       The world-level collection of Setting documents
 *
 * @param {data.SettingData} [data={}]        Initial data provided to construct the Setting document
 */
class Setting extends ClientDocumentMixin(foundry.documents.BaseSetting) {

	/**
	 * A convenient alias to the key attribute of the setting data
	 * @type {string}
	 */
	get key() {
		return this.data.key;
	}

	/**
	 * A convenient alias to the parsed value attribute of the setting data.
	 * @type {*}
	 */
	get value() {
		return this.data.value ? JSON.parse(this.data.value) : null;
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @override */
	_onCreate(data, options, user) {
		super._onCreate(data, options, user);
		const config = game.settings.settings.get(this.key);
		if ( config.onChange instanceof Function ) config.onChange(this.value);
	}

	/* -------------------------------------------- */

	/** @override */
	_onUpdate(changed, options, user) {
		super._onUpdate(changed, options, user);
		const config = game.settings.settings.get(this.key);
		if ( config.onChange instanceof Function ) config.onChange(this.value);
	}
}

/**
 * The TableResult embedded document within a RollTable document which extends the BaseRollTable abstraction.
 * Each TableResult belongs to the results collection of a RollTable entity.
 * Each TableResult contains a TableResultData object which provides its source data.
 *
 * @extends abstract.Document
 * @extends abstract.BaseTableResult
 * @extends ClientDocumentMixin
 *
 * @see {@link data.TableResultData}        The TableResult data schema
 * @see {@link documents.RollTable}         The RollTable document which contains TableResult embedded documents
 *
 * @param {TableResultData} [data={}]  Initial data provided to construct the TableResult document
 * @param {RollTable} parent      The parent RollTable document to which this result belongs
 */
class TableResult extends ClientDocumentMixin(foundry.documents.BaseTableResult) {

	/**
	 * A path reference to the icon image used to represent this result
	 */
	get icon() {
		return this.data.img || CONFIG.RollTable.resultIcon;
	}

	/**
	 * Prepare a string representation for the result which (if possible) will be a dynamic link or otherwise plain text
	 * @return {string}         The text to display
	 */
	getChatText() {
		const d = this.data;
		let text = d.text;
		if ( d.type === CONST.TABLE_RESULT_TYPES.ENTITY ) {
			text = `@${d.collection}[${d.resultId}]{${d.text}}`;
		}
		else if ( d.type === CONST.TABLE_RESULT_TYPES.COMPENDIUM ) {
			text = `@Compendium[${d.collection}.${d.resultId}]{${d.text}}`;
		}
		return text;
	}
}

/**
 * @typedef {Object} RollTableDraw      An object containing the executed Roll and the produced results
 * @property {Roll} roll                The Dice roll which generated the draw
 * @property {TableResult[]} results    An array of drawn TableResult documents
 */

/**
 * The client-side RollTable document which extends the common BaseRollTable abstraction.
 * Each RollTable document contains RollTableData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.BaseRollTable
 * @extends ClientDocumentMixin
 *
 * @see {@link data.RollTableData}              The RollTable data schema
 * @see {@link documents.RollTables}            The world-level collection of RollTable documents
 * @see {@link applications.RollTableConfig}    The RollTable configuration application
 *
 * @param {data.RollTableData} [data={}]        Initial data provided to construct the RollTable document
 */
class RollTable extends ClientDocumentMixin(foundry.documents.BaseRollTable) {

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Display a result drawn from a RollTable in the Chat Log along.
	 * Optionally also display the Roll which produced the result and configure aspects of the displayed messages.
	 *
	 * @param {TableResult[]} results         An Array of one or more TableResult Documents which were drawn and should be displayed
	 * @param {object} [options={}]           Additional options which modify message creation
	 * @param {Roll} [options.roll]                 An optional Roll instance which produced the drawn results
	 * @param {Object} [options.messageData={}]     Additional data which customizes the created messages
	 * @param {Object} [options.messageOptions={}]  Additional options which customize the created messages
	 */
	async toMessage(results, {roll=null, messageData={}, messageOptions={}}={}) {
		const speaker = ChatMessage.getSpeaker({user: game.user});

		// Construct chat data
		const nr = results.length > 1 ? `${results.length} results` : "a result";
		messageData = foundry.utils.mergeObject({
			flavor: `Draws ${nr} from the ${this.name} table.`,
			user: game.user.id,
			speaker: speaker,
			type: CONST.CHAT_MESSAGE_TYPES.ROLL,
			roll: roll,
			sound: roll ? CONFIG.sounds.dice : null,
			flags: {"core.RollTable": this.id}
		}, messageData);

		// Render the chat card which combines the dice roll with the drawn results
		messageData.content = await renderTemplate(CONFIG.RollTable.resultTemplate, {
			description: TextEditor.enrichHTML(this.data.description, {entities: true}),
			results: results.map(r => {
				r.text = r.getChatText();
				return r;
			}),
			rollHTML: this.data.displayRoll ? await roll.render() : null,
			table: this
		});

		// Create the chat message
		return ChatMessage.create(messageData, messageOptions);
	}

	/* -------------------------------------------- */

	/**
	 * Draw a result from the RollTable based on the table formula or a provided Roll instance
	 * @param {object} [options={}]         Optional arguments which customize the draw behavior
	 * @param {Roll} [options.roll]                   An existing Roll instance to use for drawing from the table
	 * @param {boolean} [options.recursive=true]      Allow drawing recursively from inner RollTable results
	 * @param {TableResult[]} [options.results]       One or more table results which have been drawn
	 * @param {boolean} [options.displayChat=true]    Whether to automatically display the results in chat
	 * @param {string} [options.rollMode]             The chat roll mode to use when displaying the result
	 * @returns {Promise<{RollTableDraw}>}  A Promise which resolves to an object containing the executed roll and the produced results
	 */
	async draw({roll, recursive=true, results=[], displayChat=true, rollMode}={}) {

		// If an array of results were not already provided, obtain them from the standard roll method
		if ( !results.length ) {
			const r = await this.roll({roll, recursive});
			roll = r.roll;
			results = r.results;
		}
		if ( !results.length ) return { roll, results };

		// Mark results as drawn, if replacement is not used and we are not in a Compendium pack
		if ( !this.data.replacement && !this.pack) {
			const draws = this.getResultsForRoll(roll.total);
			await this.updateEmbeddedDocuments("TableResult", draws.map(r => {
				return {_id: r.id, drawn: true};
			}));
		}

		// Forward drawn results to create chat messages
		if ( displayChat ) {
			await this.toMessage(results, {
				roll: roll,
				messageOptions: {rollMode}
			});
		}

		// Return the roll and the produced results
		return {roll, results};
	}

	/* -------------------------------------------- */

	/**
	 * Draw multiple results from a RollTable, constructing a final synthetic Roll as a dice pool of inner rolls.
	 * @param {number} number               The number of results to draw
	 * @param {object} [options={}]         Optional arguments which customize the draw
	 * @param {Roll} [options.roll]                   An optional pre-configured Roll instance which defines the dice roll to use
	 * @param {boolean} [options.recursive=true]      Allow drawing recursively from inner RollTable results
	 * @param {boolean} [options.displayChat=true]    Automatically display the drawn results in chat? Default is true
	 * @param {string} [options.rollMode]             Customize the roll mode used to display the drawn results
	 * @returns {Promise<{RollTableDraw}>}  The drawn results
	 */
	async drawMany(number, {roll=null, recursive=true, displayChat=true, rollMode=null}={}) {
		let results = [];
		let updates = [];
		const rolls = [];

		// Roll the requested number of times, marking results as drawn
		for ( let n=0; n<number; n++ ) {
			let draw = await this.roll({roll, recursive});
			if ( draw.results.length ) {
				rolls.push(draw.roll);
				results = results.concat(draw.results);
			}
			else break;

			// Mark results as drawn, if replacement is not used and we are not in a Compendium pack
			if ( !this.data.replacement && !this.pack) {
				updates = updates.concat(draw.results.map(r => {
					r.data.drawn = true;
					return {_id: r.id, drawn: true};
				}));
			}
		}

		// Construct a Roll object using the constructed pool
		const pool = PoolTerm.fromRolls(rolls);
		roll = Roll.fromTerms([pool]);

		// Commit updates to child results
		if ( updates.length ) {
			await this.updateEmbeddedDocuments("TableResult", updates, {diff: false});
		}

		// Forward drawn results to create chat messages
		if ( displayChat && results.length ) {
			await this.toMessage(results, {
				roll: roll,
				messageOptions: {rollMode}
			});
		}

		// Return the Roll and the array of results
		return {roll, results};
	}

	/* -------------------------------------------- */

	/**
	 * Normalize the probabilities of rolling each item in the RollTable based on their assigned weights
	 * @return {Promise<RollTable>}
	 */
	async normalize() {
		let totalWeight = 0;
		let counter = 1;
		const updates = [];
		for ( let result of this.results ) {
			const w = result.data.weight;
			totalWeight += w;
			updates.push({_id: result.id, range: [counter, counter + w - 1]})
			counter = counter + w;
		}
		return this.update({results: updates, formula:`1d${totalWeight}`});
	}

	/* -------------------------------------------- */

	/**
	 * Reset the state of the RollTable to return any drawn items to the table
	 * @return {Promise<RollTable>}
	 */
	async reset() {
		const updates = this.results.map(result => {
			return {_id: result.id, drawn: false};
		});
		return this.updateEmbeddedDocuments("TableResult", updates, {diff: false});
	}

	/* -------------------------------------------- */

	/**
	 * Evaluate a RollTable by rolling its formula and retrieving a drawn result.
	 *
	 * Note that this function only performs the roll and identifies the result, the RollTable#draw function should be
	 * called to formalize the draw from the table.
	 *
	 * @param {Roll} [roll]               An alternative dice Roll to use instead of the default formula for the table
	 * @param {boolean} recursive         If a RollTable entity is drawn as a result, recursively roll it
	 * @param {number} _depth             An internal flag used to track recursion depth
	 * @returns {Promise<RollTableDraw>}  The Roll and results drawn by that Roll
	 *
	 * @example
	 * // Draw results using the default table formula
	 * const defaultResults = await table.roll();
	 *
	 * // Draw results using a custom roll formula
	 * const roll = new Roll("1d20 + @abilities.wis.mod", actor.getRollData());
	 * const customResults = await table.roll({roll});
	 */
	async roll({roll, recursive=true, _depth=0}={}) {

		// Prevent excessive recursion
		if ( _depth > 5 ) {
			throw new Error(`Maximum recursion depth exceeded when attempting to draw from RollTable ${this.id}`);
		}

		// Reference the provided roll formula
		roll = roll instanceof Roll ? roll : Roll.create(this.data.formula);
		let results = [];

		// Ensure that at least one non-drawn result remains
		const available = this.data.results.filter(r => !r.data.drawn);
		if ( !this.data.formula || !available.length ) {
			ui.notifications.warn("There are no available results which can be drawn from this table.");
			return {roll, results};
		}

		// Ensure that results are available within the minimum/maximum range
		const minRoll = roll.clone().evaluate({minimize: true}).total;
		const maxRoll = roll.clone().evaluate({maximize: true}).total;
		const availableRange = available.reduce((range, result) => {
			const r = result.data.range;
			if ( !range[0] || (r[0] < range[0]) ) range[0] = r[0];
			if ( !range[1] || (r[1] > range[1]) ) range[1] = r[1];
			return range;
		}, [null, null]);
		if ( (availableRange[0] > maxRoll) || (availableRange[1] < minRoll) ) {
			ui.notifications.warn("No results can possibly be drawn from this table and formula.");
			return {roll, results};
		}

		// Continue rolling until one or more results are recovered
		let iter = 0;
		while ( !results.length ) {
			if ( iter >= 10000 ) {
				ui.notifications.error(`Failed to draw an available entry from Table ${this.name}, maximum iteration reached`);
				break;
			}
			roll = await roll.reroll({async: true});
			results = this.getResultsForRoll(roll.total);
			iter++;
		}

		// Draw results recursively from any inner Roll Tables
		if ( recursive ) {
			let inner = [];
			for ( let result of results ) {
				if ((result.data.type === CONST.TABLE_RESULT_TYPES.ENTITY) && (result.data.collection === "RollTable")) {
					const innerTable = game.tables.get(result.data.resultId);
					if (innerTable) {
						let innerRoll = await innerTable.roll({_depth: _depth + 1});
						inner = inner.concat(innerRoll.results);
					}
				}
				else inner.push(result);
			}
			results = inner;
		}

		// Return the Roll and the results
		return { roll, results }
	}

	/* -------------------------------------------- */

	/**
	 * Get an Array of valid results for a given rolled total
	 * @param {number} value    The rolled value
	 * @return {TableResult[]}  An Array of results
	 */
	getResultsForRoll(value) {
		return this.results.filter(r => !r.data.drawn && Number.between(value, ...r.data.range));
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_onCreateEmbeddedDocuments(embeddedName, documents, result, options, userId) {
		super._onCreateEmbeddedDocuments(embeddedName, documents, result, options, userId);
		this.collection.render();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDeleteEmbeddedDocuments(embeddedName, documents, result, options, userId) {
		super._onDeleteEmbeddedDocuments(embeddedName, documents, result, options, userId);
		this.collection.render();
	}

	/* -------------------------------------------- */
	/*  Importing and Exporting                     */
	/* -------------------------------------------- */

	/** @override */
	toCompendium(pack) {
		const data = super.toCompendium(pack);
		for ( let r of data.results ) {
			r.drawn = false;
		}
		return data;
	}

	/* -------------------------------------------- */

	/**
	 * Create a new RollTable entity using all of the Entities from a specific Folder as new results.
	 * @param {Folder} folder       The Folder entity from which to create a roll table
	 * @param {object} options      Additional options passed to the RollTable.create method
	 * @return {Promise<RollTable>}
	 */
	static async fromFolder(folder, options={}) {
		const results = folder.entities.map((e, i) => {
			return {
				text: e.name,
				type: CONST.TABLE_RESULT_TYPES.ENTITY,
				collection: folder.type,
				resultId: e.id,
				img: e.data.thumb || e.data.img,
				weight: 1,
				range: [i+1, i+1],
				drawn: false
			}
		});
		options.renderSheet = options.renderSheet ?? true;
		return this.create({
			name: folder.name,
			description: `A random table created from the contents of the ${folder.name} Folder.`,
			results: results,
			formula: `1d${results.length}`
		}, options);
	}

	/* ---------------------------------------- */
	/*  Deprecations                            */
	/* ---------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	getTableResult(id) {
		console.warn("The RollTable#getTableResult method is deprecated in favor of RollTable#results#get and will be removed in 0.9.0");
		return this.results.get(id);
	}
}

/**
 * The client-side Tile embedded document which extends the common BaseTile abstraction.
 * Each Tile document contains TileData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.BaseTile
 * @extends ClientDocumentMixin
 *
 * @see {@link data.TileData}                 The Tile data schema
 * @see {@link documents.Scene}               The Scene document type which contains Tile embedded documents
 * @see {@link applications.TileConfig}       The Tile configuration application
 *
 * @param {data.TileData} [data={}]           Initial data provided to construct the Tile document
 * @param {Scene} parent            The parent Scene document to which this Tile belongs
 */
class TileDocument extends CanvasDocumentMixin(foundry.documents.BaseTile) {

	/** @inheritdoc */
	prepareDerivedData() {
		super.prepareDerivedData();
		if ( !this.parent?.data ) return;
		const d = this.parent.dimensions;
		const minX = 0 - (this.data.width - d.size);
		const minY = 0 - (this.data.height - d.size);
		const maxX = d.width - d.size;
		const maxY = d.height - d.size;
		this.data.x = Math.clamped(this.data.x.toNearest(0.1), minX, maxX);
		this.data.y = Math.clamped(this.data.y.toNearest(0.1), minY, maxY);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get layer() {
		return this.data.overhead ? canvas.foreground : canvas.background;
	}
}


/**
 * The client-side Token embedded document which extends the common BaseToken abstraction.
 * Each Token document contains TokenData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.BaseToken
 * @extends ClientDocumentMixin
 *
 * @see {@link data.TokenData}                The Token data schema
 * @see {@link documents.Scene}               The Scene document type which contains Token embedded documents
 * @see {@link applications.TokenConfig}      The Token configuration application
 *
 * @param {data.TokenData} [data={}]          Initial data provided to construct the Token document
 * @param {Scene} parent            The parent Scene document to which this Token belongs
 */
class TokenDocument extends CanvasDocumentMixin(foundry.documents.BaseToken) {
	constructor(data, context) {
		super(data, context);

		/**
		 * A cached reference to the Actor document that this Token modifies.
		 * This may be a "synthetic" unlinked Token Actor which does not exist in the World.
		 * @type {Actor|null}
		 */
		this._actor = context.actor || null;
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * A lazily evaluated reference to the Actor this Token modifies.
	 * If actorLink is true, then the entity is the primary Actor document.
	 * Otherwise the Actor entity is a synthetic (ephemeral) document constructed using the Token's actorData.
	 * @returns {Actor|null}
	 */
	get actor() {
		if ( !this._actor ) {
			this._actor = this.getActor();
		}
		return this._actor;
	}

	/* -------------------------------------------- */

	/**
	 * An indicator for whether or not the current User has full control over this Token document.
	 * @type {boolean}
	 */
	get isOwner() {
		if ( game.user.isGM ) return true;
		return this.actor?.isOwner ?? false;
	}

	/* -------------------------------------------- */

	/**
	 * A convenient reference for whether this TokenDocument is linked to the Actor it represents, or is a synthetic copy
	 * @type {boolean}
	 */
	get isLinked() {
		return this.data.actorLink;
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to a Combatant that represents this Token, if one is present in the current encounter.
	 * @type {Combatant|null}
	 */
	get combatant() {
		return game.combat?.getCombatantByToken(this.id) || null;
	}

	/* -------------------------------------------- */

	/**
	 * An indicator for whether or not this Token is currently involved in the active combat encounter.
	 * @type {boolean}
	 */
	get inCombat() {
		return !!this.combatant;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/** @inheritdoc */
	clone(data={}, options={}) {
		const cloned = super.clone();
		cloned._actor = this._actor;
		return cloned;
	}

	/* -------------------------------------------- */

	/**
	 * Create a synthetic Actor using a provided Token instance
	 * If the Token data is linked, return the true Actor entity
	 * If the Token data is not linked, create a synthetic Actor using the Token's actorData override
	 * @return {Actor}
	 */
	getActor() {
		const baseActor = game.actors.get(this.data.actorId);
		if ( !baseActor ) return null;
		if ( !this.id || this.isLinked ) return baseActor;

		// Create a synthetic token Actor
		const overrideData = foundry.utils.mergeObject(baseActor.toJSON(), this.data.actorData);
		const cls = getDocumentClass("Actor");
		const tokenActor = new cls(overrideData, {parent: this});
		return game.actors.tokens[this.id] = tokenActor;
	}

	/* -------------------------------------------- */

	/**
	 * A helper method to retrieve the underlying data behind one of the Token's attribute bars
	 * @param {string} barName        The named bar to retrieve the attribute for
	 * @param {string} alternative    An alternative attribute path to get instead of the default one
	 * @return {object|null}          The attribute displayed on the Token bar, if any
	 */
	getBarAttribute(barName, {alternative}={}) {
		const attr = alternative || (barName ? this.data[barName].attribute : null);
		if ( !attr || !this.actor ) return null;
		let data = foundry.utils.getProperty(this.actor.data.data, attr);
		if ( (data === null) || (data === undefined) ) return null;
		const model = game.system.model.Actor[this.actor.type];

		// Single values
		if ( Number.isFinite(data) ) {
			return {
				type: "value",
				attribute: attr,
				value: data,
				editable: foundry.utils.hasProperty(model, attr)
			}
		}

		// Attribute objects
		else if ( ("value" in data) && ("max" in data) ) {
			return {
				type: "bar",
				attribute: attr,
				value: parseInt(data.value || 0),
				max: parseInt(data.max || 0),
				editable: foundry.utils.hasProperty(model, `${attr}.value`)
			}
		}

		// Otherwise null
		return null;
	}

	/* -------------------------------------------- */
	/*  Actor Data Operations                       */
	/* -------------------------------------------- */

	/**
	 * Redirect updates to a synthetic Token Actor to instead update the tokenData override object.
	 * Once an attribute in the Token has been overridden, it must always remain overridden.
	 *
	 * @param {object} update       The provided differential update data which should update the Token Actor
	 * @param {object} options      Provided options which modify the update request
	 * @returns {Promise<Actor[]>}  The updated un-linked Actor instance
	 */
	async modifyActorDocument(update, options) {
		delete update._id;
		const delta = foundry.utils.diffObject(this.actor.toJSON(), foundry.utils.expandObject(update));
		await this.update({actorData: delta}, options);
		return [this.actor];
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getEmbeddedCollection(embeddedName) {
		if ( this.isLinked ) return super.getEmbeddedCollection(embeddedName);
		switch ( embeddedName ) {
			case "Item":
				return this.actor.items;
			case "ActiveEffect":
				return this.actor.effects;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Redirect creation of Documents within a synthetic Token Actor to instead update the tokenData override object.
	 * @param {string} embeddedName   The named embedded Document type being modified
	 * @param {object[]} data         The provided initial data with which to create the embedded Documents
	 * @param {object} options        Provided options which modify the creation request
	 * @returns {Promise<Document[]>} The created Embedded Document instances
	 */
	async createActorEmbeddedDocuments(embeddedName, data, options) {
		const cls = Actor.metadata.embedded[embeddedName];
		const collection = this.actor.getEmbeddedCollection(embeddedName);
		const ids = [];
		const toCreate = data.map(d => {
			d = foundry.utils.expandObject(d);
			d._id = foundry.utils.randomID(16);
			const doc = new cls(d, {parent: this.actor});
			ids.push(doc.id);
			return doc.toJSON();
		})
		options.embedded = [embeddedName, ids];
		options.action = "create";
		await this.update({
			actorData: {
				[cls.metadata.collection]: collection.toJSON().concat(toCreate)
			}
		}, options);
		return ids.map(id => this.actor.getEmbeddedDocument(embeddedName, id));
	}

	/* -------------------------------------------- */

	/**
	 * Redirect updating of Documents within a synthetic Token Actor to instead update the tokenData override object.
	 * @param {string} embeddedName   The named embedded Document type being modified
	 * @param {object[]} updates      The provided differential data with which to update the embedded Documents
	 * @param {object} options        Provided options which modify the update request
	 * @returns {Promise<Document[]>} The updated Embedded Document instances
	 */
	async updateActorEmbeddedDocuments(embeddedName, updates, options) {
		const cls = Actor.metadata.embedded[embeddedName];
		const collection = this.actor.getEmbeddedCollection(embeddedName);
		const ids = [];
		for ( let u of updates ) {
			const doc = collection.get(u._id);
			if ( !doc ) continue;
			ids.push(doc.id);
			doc.data.update(u);
		}
		options.embedded = [embeddedName, ids];
		options.action = "update";
		await this.update({
			actorData: {
				[cls.metadata.collection]: collection.toJSON()
			}
		}, options);
		return ids.map(id => this.actor.getEmbeddedDocument(embeddedName, id));
	}

	/* -------------------------------------------- */

	/**
	 * Redirect deletion of Documents within a synthetic Token Actor to instead update the tokenData override object.
	 * @param {string} embeddedName   The named embedded Document type being modified
	 * @param {string[]} ids          The provided differential data with which to update the embedded Documents
	 * @param {object} options        Provided options which modify the update request
	 * @returns {Promise<Document[]>} The updated Embedded Document instances
	 */
	async deleteActorEmbeddedDocuments(embeddedName, ids, options) {
		const cls = Actor.metadata.embedded[embeddedName];
		const collection = this.actor.getEmbeddedCollection(embeddedName);
		const deleted = [];
		const data = collection.toJSON();
		ids = ids.filter(id => {
			if ( !collection.has(id) ) return false;
			deleted.push(collection.get(id));
			data.findSplice(d => d._id === id);
			return true;
		})
		options.embedded = [embeddedName, ids];
		options.action = "delete";
		await this.update({
			actorData: {
				[cls.metadata.collection]: data
			}
		}, options);
		return deleted;
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async _preUpdate(data, options, user) {
		await super._preUpdate(data, options, user);
		if ( ("actorData" in data) && !this.isLinked ) {
			await this._preUpdateTokenActor(data.actorData, options, user);
		}
	}

	/* -------------------------------------------- */

	/**
	 * When the Actor data overrides change for an un-linked Token Actor, simulate the pre-update process.
	 * @returns {Promise<void>}
	 * @private
	 */
	async _preUpdateTokenActor(data, options, user) {
		const embeddedKeys = new Set(["_id"]);

		// Simulate modification of embedded documents
		if ( options.embedded ) {
			const [embeddedName, modifiedIds] = options.embedded;
			const cls = getDocumentClass(embeddedName);
			const documents = data[cls.metadata.collection];
			embeddedKeys.add(cls.metadata.collection);
			const result = [];

			// Handle different embedded operations
			switch (options.action) {
				case "create":
					for (let d of documents) {
						if (!modifiedIds.includes(d._id)) continue;
						result.push(d);
						const doc = new cls(d, {parent: this.actor});
						await doc._preCreate(d, options, user);
						Hooks.callAll(`preCreate${embeddedName}`, doc, d, options, user.id);
					}
					this.actor._preCreateEmbeddedDocuments(embeddedName, result, options, user.id);
					break;

				case "update":
					for ( let d of documents ) {
						if (!modifiedIds.includes(d._id)) continue;
						result.push(d);
						const doc = this.actor.getEmbeddedDocument(embeddedName, d._id);
						await doc._preUpdate(d, options, user);
						Hooks.callAll(`preUpdate${embeddedName}`, doc, d, options, user.id);
					}
					this.actor._preUpdateEmbeddedDocuments(embeddedName, result, options, user.id);
					break;

				case "delete":
					for ( let id of modifiedIds ) {
						const doc = this.actor.getEmbeddedDocument(embeddedName, id);
						await doc._preDelete(options, user);
						Hooks.callAll(`preDelete${embeddedName}`, doc, options, user.id);
					}
					this.actor._preDeleteEmbeddedDocuments(embeddedName, modifiedIds, options, user.id);
					break;
			}
		}

		// Simulate updates to the Actor itself
		if ( Object.keys(data).some(k => !embeddedKeys.has(k)) ) {
			await this.actor._preUpdate(data, options, user);
			Hooks.callAll("preUpdateActor", this.actor, data, options, user.id);
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onUpdate(data, options, userId) {

		// If the Actor association has changed, replace the cached Token actor
		if (("actorId" in data) || ("actorLink" in data)) {
			this._actor = this.getActor();
		}

		// If the Actor data override changed, simulate updating the synthetic Actor
		if (("actorData" in data) && !this.isLinked ) {
			this._onUpdateTokenActor(data.actorData, options, userId);
		}

		// Post-update the Token itself
		return super._onUpdate(data, options, userId);
	}

	/* -------------------------------------------- */

	/**
	 * When the base Actor for a TokenDocument changes, we may need to update its Actor instance
	 * @private
	 */
	_onUpdateBaseActor(update={}) {

		// Update synthetic Actor data
		if ( !this.isLinked ) {
			update = foundry.utils.mergeObject(update, this.data.actorData, {
				insertKeys: false,
				insertValues: false,
				inplace: false
			});
			this.actor.data.update(update);
			this.actor.prepareData();
			this.actor.sheet.render(false);
		}

		// Update tracked Combat resource
		const c = this.combatant;
		if ( c && foundry.utils.hasProperty(update.data || {}, game.combat.settings.resource) ) {
			c.updateResource();
			ui.combat.render();
		}

		// Re-draw Token resource bars
		if ( this.parent.isView ) this.object.drawBars();
	}

	/* -------------------------------------------- */

	/**
	 * When the Actor data overrides change for an un-linked Token Actor, simulate the post-update process.
	 * @private
	 */
	_onUpdateTokenActor(data, options, userId) {
		const embeddedKeys = new Set(["_id"]);

		// Obtain references to any embedded documents which will be deleted
		let deletedDocuments = [];
		if ( options.embedded && (options.action === "delete") ) {
			const [embeddedName, modifiedIds] = options.embedded;
			const collection = this.actor.getEmbeddedCollection(embeddedName);
			deletedDocuments = modifiedIds.map(id => collection.get(id));
		}

		// Update the Token Actor data
		this.actor.data.update(data, {recursive: !options.embedded});
		this.actor.prepareData();

		// Simulate modification of embedded documents
		if ( options.embedded ) {
			const [embeddedName, modifiedIds] = options.embedded;
			const ids = new Set(modifiedIds);
			const cls = Actor.metadata.embedded[embeddedName];
			const changes = data[cls.metadata.collection];
			const collection = this.actor.getEmbeddedCollection(embeddedName);
			embeddedKeys.add(cls.metadata.collection);
			const result = [];

			switch (options.action) {
				case "create":
					const created = [];
					for ( let d of changes ) {
						if ( !ids.has(d._id) ) continue;
						result.push(d);
						const doc = collection.get(d._id);
						created.push(doc);
						doc._onCreate(d, options, userId);
						Hooks.callAll(`create${embeddedName}`, doc, options, userId);
					}
					this.actor._onCreateEmbeddedDocuments(embeddedName, created, result, options, userId);
					break;

				case "update":
					for ( let d of changes ) {
						if ( !ids.has(d._id) ) continue;
						result.push(d);
						const doc = collection.get(d._id);
						doc._onUpdate(d, options, userId);
						Hooks.callAll(`update${embeddedName}`, doc, d, options, userId);
					}
					this.actor._onUpdateEmbeddedDocuments(embeddedName, result, options, userId);
					break;

				case "delete":
					for ( let doc of deletedDocuments ) {
						doc._onDelete(options, userId);
						Hooks.callAll(`delete${embeddedName}`, doc, options, userId);
					}
					this.actor._onDeleteEmbeddedDocuments(embeddedName, deletedDocuments, modifiedIds, options, userId);
					break;
			}
		}

		// Update tracked Combat resource
		const c = this.combatant;
		if ( c && foundry.utils.hasProperty(data.data || {}, game.combat.settings.resource) ) {
			c.updateResource();
			ui.combat.render();
		}

		// Simulate updates to the Actor itself
		if ( Object.keys(data).some(k => !embeddedKeys.has(k)) ) {
			this.actor._onUpdate(data, options, userId);
			Hooks.callAll("updateActor", this.actor, data, options, userId);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Get an Array of attribute choices which could be tracked for Actors in the Combat Tracker
	 * @return {object}
	 */
	static getTrackedAttributes(data, _path=[]) {
		if ( !data ) {
			data = {};
			for ( let model of Object.values(game.system.model.Actor) ) {
				foundry.utils.mergeObject(data, model);
			}
		}

		// Track the path and record found attributes
		const attributes = {
			"bar": [],
			"value": []
		};

		// Recursively explore the object
		for ( let [k, v] of Object.entries(data) ) {
			let p  = _path.concat([k]);

			// Check objects for both a "value" and a "max"
			if ( v instanceof Object ) {
				const isBar = ("value" in v) && ("max" in v);
				if ( isBar ) attributes.bar.push(p);
				else {
					const inner = this.getTrackedAttributes(data[k], p);
					attributes.bar.push(...inner.bar);
					attributes.value.push(...inner.value);
				}
			}

			// Otherwise identify values which are numeric or null
			else if ( Number.isNumeric(v) || (v === null) ) {
				attributes.value.push(p);
			}
		}
		return attributes;
	}

	/* -------------------------------------------- */

	/**
	 * Inspect the Actor data model and identify the set of attributes which could be used for a Token Bar
	 * @return {object}
	 */
	static getTrackedAttributeChoices(attributes) {
		attributes = attributes || this.getTrackedAttributes();
		attributes.bar = attributes.bar.map(v => v.join("."));
		attributes.bar.sort((a, b) => a.localeCompare(b));
		attributes.value = attributes.value.map(v => v.join("."));
		attributes.value.sort((a, b) => a.localeCompare(b));
		return {
			[game.i18n.localize("TOKEN.BarAttributes")]: attributes.bar,
			[game.i18n.localize("TOKEN.BarValues")]: attributes.value
		}
	}
}


/**
 * An extended Document definition used specifically
 * This ensures that the PrototypeTokenData schema is used instead of the standard TokenData.
 * This exists specifically for prototype Token configuration in the TokenConfig app and should not be used otherwise.
 * @extends {TokenDocument}
 * @private
 */
class PrototypeTokenDocument extends TokenDocument {
	static get schema() {
		return foundry.data.PrototypeTokenData;
	}
}

/**
 * The client-side User document which extends the common BaseUser abstraction.
 * Each User document contains UserData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.Document
 * @extends abstract.BaseUser
 * @extends ClientDocumentMixin
 *
 * @see {@link data.UserData}               The User data schema
 * @see {@link documents.Users}             The world-level collection of User documents
 * @see {@link applications.UserConfig}     The User configuration application
 *
 * @param {data.UserData} [data={}]         Initial data provided to construct the User document
 */
class User extends ClientDocumentMixin(foundry.documents.BaseUser) {
	constructor(data, context) {
		super(data, context);

		/**
		 * Track whether the user is currently active in the game
		 * @type {boolean}
		 */
		this.active = false;

		/**
		 * Track references to the current set of Tokens which are targeted by the User
		 * @type {Set.<Token>}
		 */
		this.targets = new UserTargets(this);

		/**
		 * Track the ID of the Scene that is currently being viewed by the User
		 * @type {string|null}
		 */
		this.viewedScene = data.viewedScene || null;
	}

	/* ---------------------------------------- */
	/*  User Properties                         */
	/* ---------------------------------------- */

	/**
	 * Return the User avatar icon or the controlled actor's image
	 * @type {string}
	 */
	get avatar() {
		return this.data.avatar || this.character?.img || CONST.DEFAULT_TOKEN;
	}

	/**
	 * Return the Actor instance of the user's impersonated character (or undefined)
	 * @type {Actor}
	 */
	get character() {
		return game.actors.get(this.data.character);
	}

	/**
	 * A convenience shortcut for the permissions object of the current User
	 * @type {object}
	 */
	get permissions() {
		return this.data.permissions;
	}

	/**
	 * A flag for whether the current User is a Trusted Player
	 * @type {boolean}
	 */
	get isTrusted() {
		return this.hasRole("TRUSTED");
	}

	/**
	 * A flag for whether this User is the connected client
	 * @type {boolean}
	 */
	get isSelf() {
		return game.userId === this.id;
	}

	/* ---------------------------------------- */
	/*  User Methods                            */
	/* ---------------------------------------- */

	/**
	 * Assign a Macro to a numbered hotbar slot between 1 and 50
	 * @param {Macro|null} macro      The Macro entity to assign
	 * @param {number|string} [slot]  A specific numbered hotbar slot to fill
	 * @param {number} [fromSlot]     An optional origin slot from which the Macro is being shifted
	 * @return {Promise<User>}        A Promise which resolves once the User update is complete
	 */
	async assignHotbarMacro(macro, slot, {fromSlot}={}) {
		if ( !(macro instanceof Macro) && (macro !== null) ) throw new Error("Invalid Macro provided");
		const hotbar = this.data.hotbar;

		// If a slot was not provided, get the first available slot
		if (Number.isNumeric(slot)) slot = Number(slot);
		else {
			for ( let i=1; i<=50; i++ ) {
				if ( !(i in hotbar ) ) {
					slot = i;
					break;
				}
			}
		}
		if ( !slot ) throw new Error("No available Hotbar slot exists");
		if ( slot < 1 || slot > 50 ) throw new Error("Invalid Hotbar slot requested");
		if ( macro && (hotbar[slot] === macro.id) ) return this;

		// Update the hotbar data
		const update = foundry.utils.duplicate(hotbar);
		if ( macro ) update[slot] = macro.id;
		else delete update[slot];
		if ( Number.isNumeric(fromSlot) && (fromSlot in hotbar) ) delete update[fromSlot];
		return this.update({hotbar: update}, {diff: false, recursive: false, noHook: true});
	}

	/* -------------------------------------------- */

	/**
	 * Assign a specific boolean permission to this user.
	 * Modifies the user permissions to grant or restrict access to a feature.
	 *
	 * @param {string} permission    The permission name from USER_PERMISSIONS
	 * @param {boolean} allowed      Whether to allow or restrict the permission
	 */
	assignPermission(permission, allowed) {
		if ( !game.user.isGM ) throw new Error(`You are not allowed to modify the permissions of User ${this.id}`);
		const permissions = {[permission]: allowed};
		return this.update({permissions});
	}

	/* -------------------------------------------- */

	/**
	 * Submit User activity data to the server for broadcast to other players.
	 * This type of data is transient, persisting only for the duration of the session and not saved to any database.
	 *
	 * @param {Object} activityData             An object of User activity data to submit to the server for broadcast.
	 * @param {Object} activityData.cursor      The coordinates of the user's cursor
	 * @param {boolean} activityData.focus      Is the user pulling focus to the cursor coordinates?
	 * @param {boolean} activityData.ping       Is the user emitting a ping at the cursor coordinates?
	 * @param {string} activityData.ruler       Serialized Ruler coordinate data in JSON format
	 * @param {string} activityData.sceneId     The id of the Scene currently being viewed by the User
	 * @param {string[]} activityData.targets   An id of Token ids which are targeted by the User
	 */
	broadcastActivity(activityData={}) {
		if ( !this.active ) {
			this.active = true;
			ui.players.render();
		}
		activityData.sceneId = canvas.ready ? canvas.scene.id : null;
		if ( this.viewedScene !== activityData.sceneId ) {
			this.viewedScene = activityData.sceneId;
			ui.nav.render();
		}
		game.socket.emit('userActivity', this.id, activityData);
	}

	/* -------------------------------------------- */

	/**
	 * Get an Array of Macro Entities on this User's Hotbar by page
	 * @param {number} page     The hotbar page number
	 * @return {Array.<Object>}
	 */
	getHotbarMacros(page=1) {
		const macros = Array.fromRange(50).map(() => "");
		for ( let [k, v] of Object.entries(this.data.hotbar) ) {
			macros[parseInt(k)-1] = v
		}
		const start = (page-1) * 10;
		return macros.slice(start, start+10).map((m, i) => {
			return {
				slot: start + i + 1,
				macro: m ? game.macros.get(m) : null
			};
		});
	}

	/* -------------------------------------------- */

	/**
	 * Update the set of Token targets for the user given an array of provided Token ids.
	 * @param {string[]} targetIds      An array of Token ids which represents the new target set
	 */
	updateTokenTargets(targetIds=[]) {

		// Clear targets outside of the viewed scene
		if ( this.viewedScene !== canvas.scene.id ) {
			for ( let t of this.targets ) {
				t.setTarget(false, {user: this, releaseOthers: false, groupSelection: true});
			}
			return;
		}

		// Update within the viewed Scene
		const targets = new Set(targetIds);
		if ( this.targets.equals(targets) ) return;

		// Remove old targets
		for ( let t of this.targets ) {
			if ( !targets.has(t.id) ) t.setTarget(false, {user: this, releaseOthers: false, groupSelection: true});
		}

		// Add new targets
		for ( let id of targets ) {
			const token = canvas.tokens.get(id);
			if ( !token || this.targets.has(token) ) continue;
			token.setTarget(true, {user: this, releaseOthers: false, groupSelection: true});
		}
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @inheritdoc  */
	_onUpdate(data, options, userId) {
		super._onUpdate(data, options, userId);

		// If the user role changed, we need to re-build the immutable User object
		if ( this.data.role !== this.role ) {
			const user = new User(this.data);
			game.users.remove(user.id);
			game.users.insert(user);
			return user._onUpdate(data, options, userId);
		}

		// Get the changed attributes
		let changed = Object.keys(data).filter(k => k !== "_id");

		// If your own password or role changed - you must re-authenticate
		const isSelf = data._id === game.userId;
		if ( isSelf && changed.some(p => ["password", "role"].includes(p) ) ) return game.logOut();
		if ( !game.ready ) return;

		// Redraw Navigation
		if ( changed.some(p => ["active", "color", "role"].includes(p)) ) ui.nav?.render();

		// Redraw Players UI
		if ( changed.some(p => ["active", "character", "color", "role"].includes(p)) ) ui.players?.render();

		// Redraw Hotbar
		if ( isSelf && changed.includes("hotbar") ) ui.hotbar?.render();

		// Reconnect to A/V if certain user features changed
		const webrtcChanges = ["avatar", "character", "permissions", "role"];
		if (webrtcChanges.some(k => changed.includes(k))) game.webrtc?.connect();

		// Update Canvas
		if ( canvas.ready ) {

			// Redraw Cursor
			if ( changed.includes("color") ) {
				canvas.controls.drawCursor(this);
				const ruler = canvas.controls.getRulerForUser(this.id);
				if ( ruler ) ruler.color = foundry.utils.colorStringToHex(data.color);
			}
			if ( changed.includes("active") ) canvas.controls.updateCursor(this, null);

			// Modify impersonated character
			if ( isSelf && changed.includes("character") ) {
				canvas.perception.initialize();
				canvas.tokens.cycleTokens(1, true);
			}
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc  */
	_onDelete(options, userId) {
		super._onDelete(options, userId);
		if ( this.id === game.user.id ) return game.logOut();
	}

	/* ---------------------------------------- */
	/*  Deprecations                            */
	/* ---------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	isRole(role) {
		console.warn("You are using the User#isRole method which is deprecated in favor of the more generalized User#hasRole method with the exact parameter set to true");
		return this.hasRole(role, {exact: true});
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	setPermission(...args) {
		console.warn("The User#setPermission method has been renamed to User#assignPermission. Support for the old method name will be removed in 0.9.0");
		return this.assignPermission(...args);
	}
}

/**
 * The client-side Wall embedded document which extends the common BaseWall abstraction.
 * Each Wall document contains WallData which defines its data schema.
 *
 * @extends abstract.Document
 * @extends abstract.BaseWall
 * @extends ClientDocumentMixin
 *
 * @see {@link data.WallData}                 The Wall data schema
 * @see {@link documents.Scene}               The Scene document type which contains Wall embedded documents
 * @see {@link applications.WallConfig}       The Wall configuration application
 *
 * @param {data.WallData} [data={}]           Initial data provided to construct the Wall document
 * @param {Scene} parent            The parent Scene document to which this Wall belongs
 */
class WallDocument extends CanvasDocumentMixin(foundry.documents.BaseWall) {}

/**
 * The virtual tabletop environment is implemented using a WebGL powered HTML 5 canvas using the powerful PIXI.js
 * library. The canvas is comprised of an ordered sequence of layers which define rendering groups and collections of
 * objects that are drawn on the canvas itself.
 *
 * @see {@link CanvasLayer} An abstract class for all Canvas layers.
 * @see {@link PlaceablesLayer} An abstract class for Canvas Layers which contain Placeable Objects.
 * @see {@link PlaceableObject} An abstract class for objects which are placed into the Scene and drawn on the canvas.
 *
 * @property {BackgroundLayer} background
 * @property {DrawingsLayer} drawings
 * @property {GridLayer} grid
 * @property {WallsLayer} walls
 * @property {TemplateLayer} templates
 * @property {NotesLayer} notes
 * @property {TokenLayer} tokens
 * @property {LightingLayer} lighting
 * @property {ForegroundLayer} foreground
 * @property {SoundsLayer} sounds
 * @property {SightLayer} sight
 * @property {EffectsLayer} effects
 * @property {ControlsLayer} controls
 *
 * @example <caption>Example Canvas commands</caption>
 * canvas.ready; // Is the canvas ready for use?
 * canvas.scene; // The currently viewed Scene entity.
 * canvas.dimensions; // The dimensions of the current Scene.
 * canvas.draw(); // Completely re-draw the game canvas (this is usually unnecessary).
 * canvas.pan(x, y, zoom); // Pan the canvas to new coordinates and scale.
 * canvas.recenter(); // Re-center the canvas on the currently controlled Token.
 */
class Canvas {
	constructor() {

		/**
		 * A reference to the currently displayed Scene document, or null if the Canvas is currently blank.
		 * @type {Scene|null}
		 */
		this.scene = null;

		/**
		 * The current pixel dimensions of the displayed Scene, or null if the Canvas is blank.
		 * @type {null|object}
		 */
		this.dimensions = null;

		/**
		 * A reference to the HeadsUpDisplay container which overlays HTML rendering on top of this Canvas.
		 * @type {HeadsUpDisplay|null}
		 */
		this.hud = null;

		/**
		 * An Array of pending canvas operations which should trigger on the next re-paint
		 * @type {object[]}
		 */
		this.pendingOperations = [];

		/**
		 * A perception manager interface for batching lighting, sight, and sound updates
		 * @type {PerceptionManager}
		 */
		this.perception = new PerceptionManager();

		/**
		 * A flag for whether the game Canvas is ready to be used. False if the canvas is not yet drawn, true otherwise.
		 * @type {boolean}
		 */
		this.ready = false;

		/**
		 * A flag for whether the game Canvas is initialized and ready for drawing.
		 * @type {boolean}
		 */
		this.initialized = false;

		/**
		 * Track the timestamp of the last stage zoom operation
		 * @type {number}
		 * @private
		 */
		this._zoomTime = 0;

		/**
		 * Track the last automatic pan time to throttle
		 * @type {number}
		 * @private
		 */
		this._panTime = 0;

		/**
		 * An object of data which is temporarily cached to be reloaded after the canvas is drawn
		 * @type {Object}
		 * @private
		 */
		this._reload = {};

		/**
		 * A Set of unique pending operation names to ensure operations are only performed once
		 * @type {Set.<string>}
		 */
		this._pendingOperationNames = new Set();
	}

	/**
	 * The pixel radius of blur distance that should be applied for the current zoom level
	 * @type {number}
	 */
	blurDistance = 0;

	/**
	 * An array of blur filter instances which are modified by the zoom level and the "soft shadows" setting
	 * @type {PIXI.filters.BlurFilter[]}
	 */
	blurFilters = [];

	/**
	 * The singleton interaction manager instance which handles mouse interaction on the Canvas.
	 * @type {MouseInteractionManager}
	 */
	mouseInteractionManager;

	/**
	 * A reference to the MouseInteractionManager that is currently controlling pointer-based interaction, or null.
	 * @type {MouseInteractionManager|null}
	 */
	currentMouseManager = null;

	/* -------------------------------------------- */

	/**
	 * Initialize the Canvas by creating the HTML element and PIXI application.
	 * This step should only ever be performed once per client session.
	 * Subsequent requests to reset the canvas should go through Canvas#draw
	 */
	initialize() {

		// Verify that WebGL is available
		if ( !PIXI.utils.isWebGLSupported() ) {
			const err = new Error(game.i18n.localize("ERROR.NoWebGL"));
			ui.notifications.error(err.message, {permanent: true});
			throw err;
		}

		// Create the canvas element and attach it to the DOM
		const canvas = document.createElement("canvas");
		canvas.id = "board";
		$("#board").replaceWith(canvas);

		// Create PIXI Application
		const resolution = game.settings.get("core", "disableResolutionScaling") ? 1 : window.devicePixelRatio;
		this.app = new PIXI.Application({
			view: canvas,
			width: window.innerWidth,
			height: window.innerHeight,
			antialias: true,
			transparent: false,
			resolution: resolution,
			backgroundColor: null,
			powerPreference: "high-performance" // Prefer high performance GPU for devices with dual graphics cards
		});
		this.app.renderer.plugins.interaction.moveWhenInside = true;

		// Define the Stage
		this.stage = this.app.stage;
		Object.defineProperty(this.stage.constructor, 'name', {value: `CanvasStage`, writable: false});

		// Register custom blend modes
		for ( let [k,v] of Object.entries(BLEND_MODES) ) {
			PIXI.BLEND_MODES[k] = this.app.renderer.state.blendModes.push(v) - 1;
		}

		// Activate drop handling
		this._dragDrop = new DragDrop({ callbacks: { drop: this._onDrop.bind(this) } }).bind(canvas);

		// Create Canvas layers and the HUD
		this.hud = new HeadsUpDisplay();
		this._createLayers(this.stage);
		this.msk = this.stage.addChild(new PIXI.Graphics());

		// Update state flags
		this.scene = null;
		this.initialized = true;
		this.ready = false;
	}

	/* -------------------------------------------- */
	/*  Properties and Attributes
	/* -------------------------------------------- */

	/**
	 * The id of the currently displayed Scene.
	 * @type {string|null}
	 */
	get id() {
		return this.scene?.id || null;
	}

	/* -------------------------------------------- */

	/**
	 * A mapping of named CanvasLayer classes which defines the layers which comprise the Scene.
	 * @type {Object<string, CanvasLayer>}
	 */
	static get layers() {
		return CONFIG.Canvas.layers;
	}

	/* -------------------------------------------- */

	/**
	 * An Array of all CanvasLayer instances which are active on the Canvas board
	 * @type {CanvasLayer[]}
	 */
	get layers() {
		return Object.keys(this.constructor.layers).map(k => this[k]);
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the active Canvas Layer
	 * @type {CanvasLayer}
	 */
	get activeLayer() {
		for ( let name of Object.keys(this.constructor.layers) ) {
			const layer = this[name];
			if ( layer?._active ) return layer;
		}
		return null;
	}

	/* -------------------------------------------- */
	/*  Rendering
	/* -------------------------------------------- */

	/**
	 * Create the layers of the game Canvas.
	 * @param {PIXI.Container} stage    The primary canvas stage
	 * @private
	 */
	_createLayers(stage) {
		for ( let [k, v] of Object.entries(this.constructor.layers) ) {
			const layer = new v();
			this[k] = this.stage.addChild(layer);
		}
	}

	/* -------------------------------------------- */

	/**
	 * When re-drawing the canvas, first tear down or discontinue some existing processes
	 * @return {Promise<void>}
	 */
	async tearDown() {
		this.stage.visible = false;

		// Track current data which should be restored on draw
		this._reload = {
			scene: this.scene.id,
			layer: this.activeLayer?.options.name,
			controlledTokens: Object.keys(this.tokens._controlled),
			targetedTokens: Array.from(game.user.targets).map(t => t.id)
		};

		// Cancel perception refresh
		this.perception.cancel();

		// Deactivate every layer before teardown
		for ( let l of this.layers.reverse() ) {
			l.deactivate();
		}

		// Tear down every layer
		for ( let l of this.layers.reverse() ) {
			await l.tearDown();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Draw the game canvas.
	 * @param {Scene} [scene]         A specific Scene document to render on the Canvas
	 * @return {Promise<Canvas>}      A Promise which resolves once the Canvas is fully drawn
	 */
	async draw(scene) {
		scene = scene ?? game.scenes.current ?? null;
		const wasReady = this.ready;
		this.ready = false;

		// Tear down any existing scene
		if ( wasReady ) await this.tearDown();

		// Confirm there is an active scene
		this.scene = scene;
		if ( this.scene === null ) {
			console.log(`${vtt} | Skipping game canvas - no active scene.`);
			canvas.app.view.style.display = "none";
			ui.controls.render();
			return this;
		}
		else if ( !(scene instanceof Scene) ) {
			throw new Error("You must provide a Scene entity to draw the VTT canvas.")
		}

		// Configure Scene variables
		this.dimensions = this.constructor.getDimensions(scene.data);
		canvas.app.view.style.display = "block";
		document.documentElement.style.setProperty("--gridSize", this.dimensions.size+"px");
		this.blurDistance = game.settings.get("core", "softShadows") ? CONFIG.Canvas.blurStrength : 0;

		// Configure rendering settings
		PIXI.settings.MIPMAP_TEXTURES = PIXI.MIPMAP_MODES[game.settings.get("core", "mipmap") ? "ON" : "OFF"];
		const maxFPS = game.settings.get("core", "maxFPS");
		this.app.ticker.maxFPS = maxFPS.between(0, 60) ? maxFPS : 0;

		// Call initialization hooks
		console.log(`${vtt} | Drawing game canvas for scene ${this.scene.name}`);
		Hooks.callAll('canvasInit', this);

		// Configure primary canvas stage
		this.stage.visible = false;
		this.stage.position.set(window.innerWidth/2, window.innerHeight/2);
		this.stage.hitArea = new PIXI.Rectangle(0, 0, this.dimensions.width, this.dimensions.height);
		this.stage.interactive = true;
		this.stage.sortableChildren = true;

		// Scene background color
		this.backgroundColor = scene.data.backgroundColor ? colorStringToHex(scene.data.backgroundColor) : 0x666666;
		this.app.renderer.backgroundColor = this.backgroundColor;

		// Temporary workaround until "Scene Levels" are developed
		this.background.bgPath = this.scene.data.img;
		this.foreground.bgPath = this.scene.data.foreground;

		// Load required textures
		await TextureLoader.loadSceneTextures(this.scene);

		// Draw layers
		for ( let l of this.layers ) {
			try {
				await l.draw();
			} catch(err) {
				ui.notifications.error(`Canvas drawing failed for the ${l.name}, see the console for more details.`);
				console.error(err);
			}
		}

		// Draw masking rectangle
		this.msk.clear().beginFill(0xFFFFFF, 1.0).drawShape(this.dimensions.rect).endFill();
		this.stage.mask = this.msk;

		// Initialize starting conditions
		this.stage.visible = this.ready = true;
		await this._initialize();
		this._addListeners();

		// Mark the canvas as ready and call hooks
		Hooks.call("canvasReady", this);
		this._reload = {};

		// Perform a final resize to ensure the rendered dimensions are correct
		this._onResize();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Get the canvas active dimensions based on the size of the scene's map.
	 * We expand the image size by a factor of 1.5 and round to the nearest 2x grid size.
	 * The rounding accomplishes that the padding buffer around the map always contains whole grid spaces.
	 * @see {@link documents.BaseScene.getDimensions}
	 * @param {object} dimensions     The scene dimensions data being established
	 */
	static getDimensions(dimensions) {
		dimensions.size = dimensions.grid;
		const d = Scene.getDimensions(dimensions);
		d.rect = new PIXI.Rectangle(0, 0, d.width, d.height);
		d.sceneRect = new PIXI.Rectangle(d.paddingX-d.shiftX, d.paddingY-d.shiftY, d.sceneWidth, d.sceneHeight);
		d.maxR = Math.hypot(d.sceneWidth, d.sceneHeight);
		return d;
	}

	/* -------------------------------------------- */

	/**
	 * Once the canvas is drawn, initialize control, visibility, and audio states
	 * @return {Promise<void>}
	 */
	async _initialize() {

		// Clear the set of targeted Tokens for the current user
		game.user.targets.clear();

		// Render the HUD layer
		this.hud.render(true);

		// Initialize starting layer conditions
		await this.sight.initialize();  // Sight layer starting conditions
		canvas.walls.initialize();      // Wall endpoints and interior walls
		this.perception.initialize();   // Vision, lighting, sound, overhead tiles

		// Initialize canvas conditions
		this._initializeCanvasPosition();
		this._initializeCanvasLayer();
		this._initializeTokenControl();

		// If the player has no vision tokens in a visibility-restricted scene, display a warning on a slight delay
		if ( this.sight.tokenVision && !game.user.isGM && !this.sight.sources.size ) {
			ui.notifications.warn("TOKEN.WarningNoVision", {localize: true});
		}

		// Broadcast user presence in the Scene
		game.user.broadcastActivity({sceneId: this.scene.id});
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the starting view of the canvas stage
	 * If we are re-drawing a scene which was previously rendered, restore the prior view position
	 * Otherwise set the view to the top-left corner of the scene at standard scale
	 * @private
	 */
	_initializeCanvasPosition() {

		// If we are re-drawing a Scene that was already visited, use it's cached view position
		let position = this.scene._viewPosition;

		// Use a saved position, or determine the default view based on the scene size
		if ( foundry.utils.isObjectEmpty(position) ) {
			const initial = this.scene.data.initial;
			position = initial ?? {
				x: this.dimensions.paddingX + this.stage.position.x,
				y: this.dimensions.paddingY + this.stage.position.y,
				scale: 1
			}
		}

		// Set initial blur strength
		this.updateBlur(position.scale);

		// Pan to the initial view
		this.pan(position);
	}

	/* -------------------------------------------- */

	/**
	 * Initialize a CanvasLayer in the activation state
	 * @private
	 */
	_initializeCanvasLayer() {
		const layer = this[this._reload.layer] ?? this.tokens;
		layer.activate();
	}

	/* -------------------------------------------- */

	/**
	 * Initialize a token or set of tokens which should be controlled.
	 * Restore controlled and targeted tokens from before the re-draw.
	 * @private
	 */
	_initializeTokenControl() {
		let isReload = this._reload.scene === this.scene.id;
		let panToken = null;

		// Initial tokens based on reload data
		let controlledTokens = isReload ? this._reload.controlledTokens.map(id => canvas.tokens.get(id)) : [];
		if ( !isReload && !game.user.isGM ) {

			// Initial tokens based on primary character
			controlledTokens = game.user.character?.getActiveTokens() || [];

			// Based on owned actors
			if (!controlledTokens.length) {
				controlledTokens = canvas.tokens.placeables.filter(t => t.actor?.testUserPermission(game.user, "OWNER"));
			}

			// Based on observed actors
			if (!controlledTokens.length) {
				const observed = canvas.tokens.placeables.filter(t => t.actor?.testUserPermission(game.user, "OBSERVER"));
				panToken = observed.shift() || null;
			}
		}

		// Initialize Token Control
		for ( let token of controlledTokens ) {
			if ( !panToken ) panToken = token;
			token.control({releaseOthers: false});
		}

		// Initialize Token targets
		const targetedTokens = isReload ? this._reload.targetedTokens : [];
		for ( let id of targetedTokens ) {
			const token = canvas.tokens.get(id);
			token.setTarget(true, {releaseOthers: false, groupSelection: true});
		}

		// Pan camera to controlled token
		if ( panToken && !isReload ) this.pan({x: panToken.center.x, y: panToken.center.y, duration: 250});
	}

	/* -------------------------------------------- */

	/**
	 * Get a reference to the a specific CanvasLayer by it's name
	 * @param {string} layerName    The name of the canvas layer to get
	 * @return {CanvasLayer}
	 */
	getLayer(layerName) {
		return this.stage.getChildByName(layerName);
	}

	/* -------------------------------------------- */

	/**
	 * Given an embedded object name, get the canvas layer for that object
	 * @param {string} embeddedName
	 * @returns {PlaceablesLayer|null}
	 */
	getLayerByEmbeddedName(embeddedName) {
		return {
			AmbientLight: this.lighting,
			AmbientSound: this.sounds,
			Drawing: this.drawings,
			Note: this.notes,
			MeasuredTemplate: this.templates,
			Tile: this.background, // Tiles may also appear in the foreground, but background is default
			Token: this.tokens,
			Wall: this.walls
		}[embeddedName] || null;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Activate a specific CanvasLayer by its canonical name
	 * @param {string} layerName      The named layer to activate
	 */
	activateLayer(layerName) {
		this[layerName].activate();
	}

	/* -------------------------------------------- */

	/**
	 * Pan the canvas to a certain {x,y} coordinate and a certain zoom level
	 * @param {number|null} x      The x-coordinate of the pan destination
	 * @param {number|null} y      The y-coordinate of the pan destination
	 * @param {number|null} scale  The zoom level (max of CONFIG.Canvas.maxZoom) of the action
	 */
	pan({x=null, y=null, scale=null}={}) {

		// Constrain the resulting canvas view
		const constrained = this._constrainView({x, y, scale});
		const scaleChange = constrained.scale !== this.stage.scale.x;

		// Set the pivot point
		this.stage.pivot.set(constrained.x, constrained.y);

		// Set the zoom level
		if ( scaleChange ) {
			this.stage.scale.set(constrained.scale, constrained.scale);
			this.updateBlur(constrained.scale);
		}

		// Update the scene tracked position
		canvas.scene._viewPosition = constrained;

		// Call canvasPan Hook
		Hooks.callAll("canvasPan", this, constrained);

		// Align the HUD
		this.hud.align();
	}

	/* -------------------------------------------- */

	/**
	 * Animate panning the canvas to a certain destination coordinate and zoom scale
	 * Customize the animation speed with additional options
	 * Returns a Promise which is resolved once the animation has completed
	 *
	 * @param {object} view         The desired view parameters
	 * @param {number} [view.x]            The destination x-coordinate
	 * @param {number} [view.y]            The destination y-coordinate
	 * @param {number} [view.scale]        The destination zoom scale
	 * @param {number} [view.duration=250] The total duration of the animation in milliseconds; used if speed is not set
	 * @param {number} [view.speed]        The speed of animation in pixels per second; overrides duration if set
	 * @returns {Promise}           A Promise which resolves once the animation has been completed
	 */
	async animatePan({x, y, scale, duration=250, speed}={}) {

		// Determine the animation duration to reach the target
		if ( speed ) {
			let ray = new Ray(this.stage.pivot, {x, y});
			duration = Math.round(ray.distance * 1000 / speed);
		}

		// Constrain the resulting dimensions and construct animation attributes
		const constrained = this._constrainView({x, y, scale});
		const attributes = [
			{ parent: this.stage.pivot, attribute: 'x', to: constrained.x },
			{ parent: this.stage.pivot, attribute: 'y', to: constrained.y },
			{ parent: this.stage.scale, attribute: 'x', to: constrained.scale },
			{ parent: this.stage.scale, attribute: 'y', to: constrained.scale },
		].filter(a => a.to !== undefined);

		// Trigger the animation function
		const animation = await CanvasAnimation.animateLinear(attributes, {
			name: "canvas.animatePan",
			duration: duration,
			ontick: () => {
				this.hud.align();
				const stage = this.stage;
				Hooks.callAll("canvasPan", this, {x: stage.pivot.x, y: stage.pivot.y, scale: stage.scale.x});
			}
		});

		// Record final values
		this.updateBlur(constrained.scale);
		canvas.scene._viewPosition = constrained;
		return animation;
	}

	/* -------------------------------------------- */

	/**
	 * Recenter the canvas
	 * Otherwise, pan the stage to put the top-left corner of the map in the top-left corner of the window
	 * @returns {Promise<void>}     A Promise which resolves once the animation has been completed
	 */
	async recenter(coordinates) {
		if ( coordinates ) this.pan(coordinates);
		return this.animatePan({
			x: this.dimensions.paddingX + (window.innerWidth / 2),
			y: this.dimensions.paddingY + (window.innerHeight / 2),
			duration: 250
		});
	}

	/* -------------------------------------------- */

	/**
	 * Get the constrained zoom scale parameter which is allowed by the maxZoom parameter
	 * @param {number} x              The requested x-coordinate
	 * @param {number} y              The requested y-coordinate
	 * @param {number} scale          The requested scale
	 * @return {{x, y, scale}}        The allowed scale
	 * @private
	 */
	_constrainView({x, y, scale}) {
		const d = canvas.dimensions;

		// Constrain the maximum zoom level
		if ( Number.isNumeric(scale) && (scale !== this.stage.scale.x) ) {
			const max = CONFIG.Canvas.maxZoom;
			const ratio = Math.max(d.width / window.innerWidth, d.height / window.innerHeight, max);
			scale = Math.round(Math.clamped(scale, 1 / ratio, max) * 100) / 100;
		} else {
			scale = this.stage.scale.x;
		}

		// Constrain the pivot point using the new scale
		if ( Number.isNumeric(x) && x !== this.stage.pivot.x ) {
			const padw = 0.4 * (window.innerWidth / scale);
			x = Math.clamped(x, -padw, d.width + padw);
		}
		else x = this.stage.pivot.x;
		if ( Number.isNumeric(y) && y !== this.stage.pivot.y ) {
			const padh = 0.4 * (window.innerHeight / scale);
			y = Math.clamped(y, -padh, d.height + padh);
		}
		else y = this.stage.pivot.y;

		// Return the constrained view dimensions
		return {x, y, scale};
	}

	/* -------------------------------------------- */

	/**
	 * Create a BlurFilter instance and register it to the array for updates when the zoom level changes.
	 * @returns {PIXI.filters.BlurFilter}
	 */
	createBlurFilter() {
		const f = new PIXI.filters.BlurFilter(this.blurDistance);
		this.blurFilters.push(f);
		return f;
	}

	/* -------------------------------------------- */


	/**
	 * Update the blur strength depending on the scale of the canvas stage.
	 * This number is zero if "soft shadows" are disabled
	 * @param {number} [scale]
	 * @private
	 */
	updateBlur(scale) {
		scale = scale || this.stage.scale.x;
		if ( this.blurDistance === 0 ) return; // Soft shadows already disabled
		this.blurDistance = Math.ceil(Math.clamped(scale * CONFIG.Canvas.blurStrength, 0, CONFIG.Canvas.blurStrength));
		for ( let f of this.blurFilters ) {
			f.blur = this.blurDistance;
		}
	}

	/* -------------------------------------------- */
	/* Event Handlers
	/* -------------------------------------------- */

	/**
	 * Attach event listeners to the game canvas to handle click and interaction events
	 * @private
	 */
	_addListeners() {

		// Remove all existing listeners
		this.stage.removeAllListeners();

		// Define callback functions for mouse interaction events
		const callbacks = {
			clickLeft: this._onClickLeft.bind(this),
			clickLeft2: this._onClickLeft2.bind(this),
			clickRight: this._onClickRight.bind(this),
			clickRight2: null,
			dragLeftStart: this._onDragLeftStart.bind(this),
			dragLeftMove: this._onDragLeftMove.bind(this),
			dragLeftDrop: this._onDragLeftDrop.bind(this),
			dragLeftCancel: this._onDragLeftCancel.bind(this),
			dragRightStart: null,
			dragRightMove: this._onDragRightMove.bind(this),
			dragRightDrop: this._onDragRightDrop.bind(this),
			dragRightCancel: null
		};

		// Create and activate the interaction manager
		const permissions = { clickRight2: false };
		const mgr = new MouseInteractionManager(this.stage, this.stage, permissions, callbacks);
		this.mouseInteractionManager = mgr.activate();

		// Add a listener for cursor movement
		this.stage.on("mousemove", this._onMouseMove.bind(this));
	}

	/* -------------------------------------------- */

	/**
	 * Handle normal mouse movement.
	 * Throttle cursor position updates to 100ms intervals
	 * @param {PIXI.InteractionEvent} event
	 * @private
	 */
	_onMouseMove(event) {
		const now = Date.now();
		if ( (now - event.data["_cursorTime"]) < 100 ) return;
		event.data["_cursorTime"] = now;
		canvas.controls._onMouseMove(event)
		canvas.sounds._onMouseMove(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle left mouse-click events occurring on the Canvas stage or its active Layer.
	 * @see {MouseInteractionManager#_handleClickLeft}
	 * @param {PIXI.InteractionEvent} event
	 * @private
	 */
	_onClickLeft(event) {

		// Extract event data
		const layer = this.activeLayer;
		const tool = game.activeTool;

		// Place Ruler waypoints
		const isRuler = tool === "ruler";
		const isCtrlRuler = game.keyboard.isCtrl(event) && (layer.name === "TokenLayer");
		if ( isRuler || isCtrlRuler ) return this.controls.ruler._onClickLeft(event);

		// Begin select events
		const isSelect = ["select", "target"].includes(tool);
		const release = game.settings.get("core", "leftClickRelease");
		if ( isSelect && !release ) return;

		// Dispatch the event to the active layer
		if ( layer instanceof PlaceablesLayer ) layer._onClickLeft(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle double left-click events occurring on the Canvas stage.
	 * @see {MouseInteractionManager#_handleClickLeft2}
	 * @param {PIXI.InteractionEvent} event
	 */
	_onClickLeft2(event) {
		const layer = this.activeLayer;
		if ( layer instanceof PlaceablesLayer ) layer._onClickLeft2(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle the beginning of a left-mouse drag workflow on the Canvas stage or its active Layer.
	 * @see {MouseInteractionManager#_handleDragStart}
	 * @param {PIXI.InteractionEvent} event
	 * @private
	 */
	_onDragLeftStart(event) {

		// Extract event data
		const layer = this.activeLayer;
		const isRuler = game.activeTool === "ruler";
		const isCtrlRuler = game.keyboard.isCtrl(event) && (layer.name === "TokenLayer");

		// Begin ruler measurement
		if ( isRuler || isCtrlRuler ) return this.controls.ruler._onDragStart(event);

		// Activate select rectangle
		const isSelect = ["select", "target"].includes(game.activeTool);
		if ( isSelect ) {
			canvas.controls.select.active = true;
			return;
		}

		// Dispatch the event to the active layer
		if ( layer instanceof PlaceablesLayer ) layer._onDragLeftStart(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse movement events occurring on the Canvas stage or it's active layer
	 * @see {MouseInteractionManager#_handleDragMove}
	 * @param {PIXI.InteractionEvent} event
	 * @private
	 */
	_onDragLeftMove(event) {
		const layer = this.activeLayer;

		// Pan the canvas if the drag event approaches the edge
		this._onDragCanvasPan(event.data.originalEvent);

		// Continue a Ruler measurement
		const ruler = this.controls.ruler;
		if ( ruler._state > 0 ) return ruler._onMouseMove(event);

		// Continue a select event
		const isSelect = ["select", "target"].includes(game.activeTool);
		if ( isSelect && canvas.controls.select.active ) return this._onDragSelect(event);

		// Dispatch the event to the active layer
		if ( layer instanceof PlaceablesLayer ) layer._onDragLeftMove(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle the conclusion of a left-mouse drag workflow when the mouse button is released.
	 * @see {MouseInteractionManager#_handleDragDrop}
	 * @param {PIXI.InteractionEvent} event
	 * @private
	 */
	_onDragLeftDrop(event) {

		// Extract event data
		const {coords, originalEvent} = event.data;
		const tool = game.activeTool;
		const layer = canvas.activeLayer;
		const isCtrl = game.keyboard.isCtrl(event);

		// Conclude a measurement event if we aren't holding the CTRL key
		const ruler = canvas.controls.ruler;
		if ( ruler.active ) {
			if ( isCtrl ) originalEvent.preventDefault();
			return ruler._onMouseUp(event);
		}

		// Conclude a select event
		const isSelect = ["select", "target"].includes(tool);
		if ( isSelect && canvas.controls.select.active ) {
			canvas.controls.select.clear();
			canvas.controls.select.active = false;
			if ( tool === "select" ) return layer.selectObjects(coords);
			if ( tool === "target" ) return layer.targetObjects(coords, {releaseOthers: !originalEvent.shiftKey});
		}

		// Dispatch the event to the active layer
		if ( layer instanceof PlaceablesLayer ) layer._onDragLeftDrop(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle the cancellation of a left-mouse drag workflow
	 * @see {MouseInteractionManager#_handleDragCancel}
	 * @param {PointerEvent} event
	 * @private
	 */
	_onDragLeftCancel(event) {
		const layer = canvas.activeLayer;
		const tool = game.activeTool;

		// Don't cancel ruler measurement
		const ruler = canvas.controls.ruler;
		if ( ruler.active ) return event.preventDefault();

		// Clear selection
		const isSelect = ["select", "target"].includes(tool);
		if ( isSelect ) return canvas.controls.select.clear();

		// Dispatch the event to the active layer
		if ( layer instanceof PlaceablesLayer ) layer._onDragLeftCancel(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle right mouse-click events occurring on the Canvas stage or it's active layer
	 * @see {MouseInteractionManager#_handleClickRight}
	 * @param {PIXI.InteractionEvent} event
	 * @private
	 */
	_onClickRight(event) {
		const ruler = canvas.controls.ruler;
		if ( ruler.active ) return ruler._onClickRight(event);

		// Dispatch to the active layer
		const layer = this.activeLayer;
		if ( layer instanceof PlaceablesLayer ) layer._onClickRight(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle right-mouse drag events occuring on the Canvas stage or an active Layer
	 * @see {MouseInteractionManager#_handleDragMove}
	 * @param {PIXI.InteractionEvent} event
	 * @private
	 */
	_onDragRightMove(event) {

		// Extract event data
		const DRAG_SPEED_MODIFIER = 0.8;
		const {cursorTime, origin, destination} = event.data;
		const dx = destination.x - origin.x;
		const dy = destination.y - origin.y;

		// Update the client's cursor position every 100ms
		const now = Date.now();
		if ( (now - (cursorTime || 0)) > 100 ) {
			if ( this.controls ) this.controls._onMouseMove(event, destination);
			event.data.cursorTime = now;
		}

		// Pan the canvas
		this.pan({
			x: canvas.stage.pivot.x - (dx * DRAG_SPEED_MODIFIER),
			y: canvas.stage.pivot.y - (dy * DRAG_SPEED_MODIFIER)
		});

		// Reset Token tab cycling
		this.tokens._tabIndex = null;
	}


	/* -------------------------------------------- */

	/**
	 * Handle the conclusion of a right-mouse drag workflow the Canvas stage.
	 * @see {MouseInteractionManager#_handleDragDrop}
	 * @param {PIXI.InteractionEvent} event
	 * @private
	 */
	_onDragRightDrop(event) {}

	/* -------------------------------------------- */

	/**
	 * Determine selection coordinate rectangle during a mouse-drag workflow
	 * @param {PIXI.InteractionEvent} event
	 * @private
	 */
	_onDragSelect(event) {

		// Extract event data
		const {origin, destination} = event.data;

		// Determine rectangle coordinates
		let coords = {
			x: Math.min(origin.x, destination.x),
			y: Math.min(origin.y, destination.y),
			width: Math.abs(destination.x - origin.x),
			height: Math.abs(destination.y - origin.y)
		};

		// Draw the select rectangle
		canvas.controls.drawSelect(coords);
		event.data.coords = coords;
	}

	/* -------------------------------------------- */

	/**
	 * Pan the canvas view when the cursor position gets close to the edge of the frame
	 * @param {MouseEvent} event    The originating mouse movement event
	 */
	_onDragCanvasPan(event) {

		// Throttle panning by 200ms
		const now = Date.now();
		if ( now - (this._panTime || 0) <= 200 ) return;
		this._panTime = now;

		// Shift by 3 grid spaces at a time
		const {x, y} = event;
		const pad = 50;
		const shift = (this.dimensions.size * 3) / this.stage.scale.x;

		// Shift horizontally
		let dx = 0;
		if ( x < pad ) dx = -shift;
		else if ( x > window.innerWidth - pad ) dx = shift;

		// Shift vertically
		let dy = 0;
		if ( y < pad ) dy = -shift;
		else if ( y > window.innerHeight - pad ) dy = shift;

		// Enact panning
		if ( dx || dy ) return this.animatePan({x: this.stage.pivot.x + dx, y: this.stage.pivot.y + dy, duration: 200});
	}

	/* -------------------------------------------- */
	/*  Other Event Handlers                        */
	/* -------------------------------------------- */

	/**
	 * Handle window resizing with the dimensions of the window viewport change
	 * @param {Event} event     The Window resize event
	 * @private
	 */
	_onResize(event=null) {
		if ( !this.ready ) return false;

		// Record the original width
		const w = window.innerWidth;
		const h = window.innerHeight;

		// Resize the renderer
		this.app.renderer.view.style.width = w + "px";
		this.app.renderer.view.style.height = h + "px";
		this.app.renderer.resize(w, h);

		// Adjust the stage position and pivot
		this.stage.position.set(w/2, h/2);
		const dx = (window.innerWidth - w) / 2;
		const dy = (window.innerHeight - h) / 2;
		this.pan({x: this.stage.pivot.x + dx, y: this.stage.pivot.y + dy});
	}

	/* -------------------------------------------- */

	/**
	 * Handle mousewheel events which adjust the scale of the canvas
	 * @param {WheelEvent} event    The mousewheel event that zooms the canvas
	 * @private
	 */
	_onMouseWheel(event) {
		let dz = ( event.deltaY < 0 ) ? 1.05 : 0.95;
		this.pan({scale: dz * canvas.stage.scale.x});
	}

	/* -------------------------------------------- */

	/**
	 * Event handler for the drop portion of a drag-and-drop event.
	 * @private
	 */
	_onDrop(event) {
		event.preventDefault();

		// Try to extract the data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData('text/plain'));
		}
		catch (err) {
			return false;
		}

		// Acquire the cursor position transformed to Canvas coordinates
		const [x, y] = [event.clientX, event.clientY];
		const t = this.stage.worldTransform;
		data.x = (x - t.tx) / canvas.stage.scale.x;
		data.y = (y - t.ty) / canvas.stage.scale.y;

		// Handle the drop with a Hooked function
		const allowed = Hooks.call("dropCanvasData", this, data);
		if ( allowed === false ) return;

		// Handle different data types
		switch ( data.type ) {
			case "Actor":
				return canvas.tokens._onDropActorData(event, data);
			case "JournalEntry":
				return canvas.notes._onDropData(event, data);
			case "Macro":
				return game.user.assignHotbarMacro(null, Number(data.slot));
			case "Tile":
				if ( canvas.activeLayer instanceof MapLayer ) {
					return canvas.activeLayer._onDropData(event, data);
				}
		}
	}

	/* -------------------------------------------- */
	/*  Pending Operations                          */
	/* -------------------------------------------- */

	/**
	 * Add a pending canvas operation that should fire once the socket handling workflow concludes.
	 * This registers operations by a unique string name into a queue - avoiding repeating the same work multiple times.
	 * This is especially helpful for multi-object updates to avoid costly and redundant refresh operations.
	 * @param {string} name     A unique name for the pending operation, conventionally Class.method
	 * @param {Function} fn     The unbound function to execute later
	 * @param {*} scope         The scope to which the method should be bound when called
	 * @param {...*} args       Arbitrary arguments to pass to the method when called
	 */
	addPendingOperation(name, fn, scope, args) {
		if ( this._pendingOperationNames.has(name) ) return;
		this._pendingOperationNames.add(name);
		this.pendingOperations.push([fn, scope, args]);
	}

	/* -------------------------------------------- */

	/**
	 * Fire all pending functions that are registered in the pending operations queue and empty it.
	 */
	triggerPendingOperations() {
		for ( let [fn, scope, args] of this.pendingOperations ) {
			if ( !fn ) continue;
			args = args || [];
			fn = fn.call(scope, ...args);
		}
		this.pendingOperations = [];
		this._pendingOperationNames.clear();
	}

	/* -------------------------------------------- */
	/*  Deprecations                                */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.2
	 * @ignore
	 */
	initializeSources() {
		console.warn("Canvas#initializeSources has been deprecated in favor of Canvas#perception#initialize");
		this.perception.initialize();
	}
}

/**
 * An abstract pattern for primary layers of the game canvas to implement
 * @type {PIXI.Container}
 * @abstract
 * @interface
 */
class CanvasLayer extends PIXI.Container {
	constructor() {
		super();
		this.interactive = false;
		this.interactiveChildren = false;
	}

	/**
	 * Track whether the canvas layer is currently active for interaction
	 * @type {boolean}
	 */
	_active = false;

	/* -------------------------------------------- */
	/*  Layer Attributes                            */
	/* -------------------------------------------- */

	/**
	 * Customize behaviors of this CanvasLayer by modifying some behaviors at a class level.
	 * @type {Object}
	 * @property {string} name              The layer name by which the instance is referenced within the Canvas
	 * @property {number} zIndex            The zIndex sorting of this layer relative to other layers
	 * @property {boolean} sortActiveTop    Should this layer be sorted to the top when it is active?
	 */
	static get layerOptions() {
		return {
			name: "",
			zIndex: 0,
			sortActiveTop: false
		}
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the active instance of this canvas layer
	 * @type {CanvasLayer}
	 */
	static get instance() {
		return canvas[this.layerOptions.name];
	}

	/* -------------------------------------------- */

	/**
	 * The canonical name of the CanvasLayer
	 * @type {string}
	 */
	get name() {
		return this.constructor.name;
	}

	/* -------------------------------------------- */
	/*  Rendering
	/* -------------------------------------------- */

	/**
	 * Draw the canvas layer, rendering its internal components and returning a Promise
	 * The Promise resolves to the drawn layer once its contents are successfully rendered.
	 * @return {Promise<CanvasLayer>}
	 */
	async draw() {
		this.removeChildren();
		const d = canvas.dimensions;
		this.width = d.width;
		this.height = d.height;
		this.hitArea = d.rect;
		this.zIndex = this.getZIndex();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Deconstruct data used in the current layer in preparation to re-draw the canvas
	 * @return {Promise<CanvasLayer>}
	 */
	async tearDown() {
		this.renderable = false;
		this.removeChildren().forEach(c => c.destroy({children: true}));
		this.renderable = true;
		return this;
	}

	/* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */

	/**
	 * Activate the CanvasLayer, deactivating other layers and marking this layer's children as interactive.
	 * @return {CanvasLayer}    The layer instance, now activated
	 */
	activate() {

		// Set this layer as active
		const wasActive = this._active;
		this._active = true;

		// Deactivate other layers
		for (let name of Object.keys(Canvas.layers) ) {
			const layer = canvas[name];
			if ( layer !== this ) layer.deactivate();
		}
		if ( wasActive ) return this;

		// Assign interactivity for the active layer
		this.zIndex = this.getZIndex();
		this.interactive = false;
		this.interactiveChildren = true;

		// Re-render Scene controls
		if ( ui.controls ) ui.controls.initialize({layer: this.constructor.layerOptions.name});
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Deactivate the CanvasLayer, removing interactivity from its children.
	 * @return {CanvasLayer}    The layer instance, now inactive
	 */
	deactivate() {
		this._active = false;
		this.interactive = false;
		this.interactiveChildren = false;
		this.zIndex = this.getZIndex();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Get the zIndex that should be used for ordering this layer vertically relative to others in the same Container.
	 * @returns {number}
	 */
	getZIndex() {
		const options = this.constructor.layerOptions;
		if ( this._active && options.sortActiveTop ) {
			return canvas.layers.reduce((max, l) => {
				if ( l.zIndex > max ) max = l.zIndex;
				return max;
			}, 0);
		}
		return options.zIndex;
	}
}
/**
 * An Abstract Base Class which defines a Placeable Object which represents an Entity placed on the Canvas
 * @extends {PIXI.Container}
 * @abstract
 * @interface
 *
 * @param {abstract.Document} document      The Document instance which is represented by this object
 */
class PlaceableObject extends PIXI.Container {
	constructor(document) {
		super();
		if ( !(document instanceof foundry.abstract.Document) || !document.isEmbedded ) {
			throw new Error("You must provide an embedded Document instance as the input for a PlaceableObject");
		}

		/**
		 * Retain a reference to the Scene within which this Placeable Object resides
		 * @type {Scene}
		 */
		this.scene = document.parent;

		/**
		 * A reference to the Scene embedded Document instance which this object represents
		 * @type {abstract.Document}
		 */
		this.document = document;

		/**
		 * The underlying data object which provides the basis for this placeable object
		 * @type {abstract.DocumentData}
		 */
		this.data = document.data;

		/**
		 * Track the field of vision for the placeable object.
		 * This is necessary to determine whether a player has line-of-sight towards a placeable object or vice-versa
		 * @type {{fov: PIXI.Polygon, los: PIXI.Polygon}}
		 */
		this.vision = {fov: undefined, los: undefined};

		/**
		 * A control icon for interacting with the object
		 * @type {ControlIcon}
		 */
		this.controlIcon = null;

		/**
		 * A mouse interaction manager instance which handles mouse workflows related to this object.
		 * @type {MouseInteractionManager}
		 */
		this.mouseInteractionManager = null;

		/**
		 * An indicator for whether the object is currently controlled
		 * @type {boolean}
		 */
		this._controlled = false;

		/**
		 * An indicator for whether the object is currently a hover target
		 * @type {boolean}
		 */
		this._hover = false;
	}

	/**
	 * Identify the official EmbeddedEntity name for this PlaceableObject class
	 * @type {string}
	 */
	static embeddedName;

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * The bounding box for this PlaceableObject.
	 * This is required if the layer uses a Quadtree, otherwise it is optional
	 * @return {Rectangle}
	 */
	get bounds() {
		return this.getLocalBounds(undefined, true);
	}

	/* -------------------------------------------- */

	/**
	 * The central coordinate pair of the placeable object based on it's own width and height
	 * @type {PIXI.Point}
	 */
	get center() {
		if ( "width" in this.data && "height" in this.data ) {
			return new PIXI.Point(this.data.x + (this.data.width / 2), this.data.y + (this.data.height / 2));
		}
		return new PIXI.Point(this.data.x, this.data.y);
	}

	/* -------------------------------------------- */

	/**
	 * The id of the corresponding Document which this PlaceableObject represents.
	 * @type {string}
	 */
	get id() {
		return this.document.id;
	}

	/* -------------------------------------------- */

	/**
	 * The field-of-vision polygon for the object, if it has been computed
	 * @type {PIXI.Polygon}
	 */
	get fov() {
		return this.vision.fov;
	}

	/* -------------------------------------------- */

	/**
	 * Provide a reference to the CanvasLayer which contains this PlaceableObject.
	 * @type {PIXI.Container}
	 */
	get layer() {
		return this.document.layer;
	}

	/* -------------------------------------------- */

	/**
	 * The line-of-sight polygon for the object, if it has been computed
	 * @type {PIXI.Polygon|null}
	 */
	get los() {
		return this.vision.los;
	}

	/* -------------------------------------------- */

	/**
	 * A Form Application which is used to configure the properties of this Placeable Object or the EmbeddedEntity
	 * it represents.
	 * @type {FormApplication}
	 */
	get sheet() {
		return this.document.sheet;
	}

	/* -------------------------------------------- */
	/*  Permission Controls                         */
	/* -------------------------------------------- */

	/**
	 * Test whether a user can perform a certain interaction with regards to a Placeable Object
	 * @param {User} user       The User performing the action
	 * @param {string} action   The named action being attempted
	 * @return {boolean}        Does the User have rights to perform the action?
	 */
	can(user, action) {
		const fn = this[`_can${action.titleCase()}`];
		return fn ? fn.call(this, user) : false;
	}

	/**
	 * Can the User access the HUD for this Placeable Object?
	 * @protected
	 */
	_canHUD(user, event) {
		return this._controlled;
	}

	/**
	 * Does the User have permission to configure the Placeable Object?
	 * @protected
	 */
	_canConfigure(user, event) {
		return this.document.canUserModify(game.user, "update");
	}

	/**
	 * Does the User have permission to control the Placeable Object?
	 * @protected
	 */
	_canControl(user, event) {
		if ( !this.layer._active ) return false;
		return this.document.canUserModify(game.user, "update");
	}

	/**
	 * Does the User have permission to view details of the Placeable Object?
	 * @protected
	 */
	_canView(user, event) {
		return this.document.testUserPermission(game.user, "LIMITED");
	}

	/**
	 * Does the User have permission to create the underlying Embedded Entity?
	 * @protected
	 */
	_canCreate(user, event) {
		return user.isGM;
	}

	/**
	 * Does the User have permission to drag this Placeable Object?
	 * @protected
	 */
	_canDrag(user, event) {
		return this._canControl(user);
	}

	/**
	 * Does the User have permission to hover on this Placeable Object?
	 * @protected
	 */
	_canHover(user, event) {
		return this._canControl(user);
	}

	/**
	 * Does the User have permission to update the underlying Embedded Entity?
	 * @protected
	 */
	_canUpdate(user, event) {
		return this._canControl(user);
	}

	/**
	 * Does the User have permission to delete the underlying Embedded Entity?
	 * @protected
	 */
	_canDelete(user, event) {
		return this._canControl(user);
	}

	/* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */

	/**
	 * Clear the display of the existing object
	 * @return {PlaceableObject}    The cleared object
	 */
	clear() {
		this.removeChildren().forEach(c => c.destroy({children: true}));
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Clone the placeable object, returning a new object with identical attributes
	 * The returned object is non-interactive, and has no assigned ID
	 * If you plan to use it permanently you should call the create method
	 *
	 * @return {PlaceableObject}  A new object with identical data
	 */
	clone() {
		const cloneDoc = this.document.clone();
		const clone = new this.constructor(cloneDoc);
		clone.interactive = false;
		clone._original = this;
		clone._controlled = this._controlled;
		return clone;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	destroy(options) {
		this.document._object = null;
		return super.destroy(options);
	}

	/* -------------------------------------------- */

	/**
	 * Draw the placeable object into its parent container
	 * @returns {Promise<PlaceableObject>}  The drawn object
	 */
	async draw() {
		throw new Error("A PlaceableObject subclass must define initial drawing procedure.");
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the current display state of the Placeable Object
	 * @return {PlaceableObject}    The refreshed object
	 */
	refresh() {
		throw new Error("A PlaceableObject subclass must define an refresh drawing procedure.");
	}

	/* -------------------------------------------- */

	/**
	 * Register pending canvas operations which should occur after a new PlaceableObject of this type is created
	 * @protected
	 */
	_onCreate(data, options, userId) {
		this.draw();
	}

	/* -------------------------------------------- */

	/**
	 * Define additional steps taken when an existing placeable object of this type is updated with new data
	 * @protected
	 */
	_onUpdate(changed, options, userId) {
		const layer = this.layer;

		// Z-index sorting
		if ( "z" in changed ) {
			this.zIndex = parseInt(changed.z) || 0;
		}

		// Quadtree location update
		if ( layer.quadtree ) {
			layer.quadtree.remove(this).insert({r: this.bounds, t: this});
		}

		// Refresh display
		this.refresh();
	}

	/* -------------------------------------------- */

	/**
	 * Define additional steps taken when an existing placeable object of this type is deleted
	 * @protected
	 */
	_onDelete(options, userId) {
		this.release({trigger: false});
		const layer = this.layer;
		if ( layer._hover === this ) layer._hover = null;
		if ( layer.quadtree ) layer.quadtree.remove(this);
		this.destroy({children: true});
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Assume control over a PlaceableObject, flagging it as controlled and enabling downstream behaviors
	 * @param {Object} options                  Additional options which modify the control request
	 * @param {boolean} options.releaseOthers   Release any other controlled objects first
	 * @return {boolean}                        A flag denoting whether or not control was successful
	 */
	control(options={}) {
		if ( !this.layer.options.controllableObjects ) return false;

		// Release other controlled objects
		const wasControlled = this._controlled;
		this._controlled = false;
		if ( options.releaseOthers !== false ) {
			for ( let o of Object.values(this.layer._controlled) ) {
				if ( o !== this ) o.release();
			}
		}
		this._controlled = wasControlled;

		// Bail out if this object is already controlled, or not controllable
		if (this._controlled) return true;
		if (!this.can(game.user, "control")) return false;

		// Toggle control status
		this._controlled = true;
		this.layer._controlled[this.id] = this;

		// Trigger follow-up events and fire an on-control Hook
		this._onControl(options);
		Hooks.callAll("control"+this.constructor.embeddedName, this, this._controlled);
		canvas.triggerPendingOperations();
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Additional events which trigger once control of the object is established
	 * @param {Object} options    Optional parameters which apply for specific implementations
	 * @protected
	 */
	_onControl(options) {
		this.refresh();
	}

	/* -------------------------------------------- */

	/**
	 * Release control over a PlaceableObject, removing it from the controlled set
	 * @param {Object} options          Options which modify the releasing workflow
	 * @return {boolean}                A Boolean flag confirming the object was released.
	 */
	release(options={}) {
		delete this.layer._controlled[this.id];
		if (!this._controlled) return true;
		this._controlled = false;

		// Trigger follow-up events
		this._onRelease(options);

		// Fire an on-release Hook
		Hooks.callAll("control"+this.constructor.embeddedName, this, this._controlled);
		if ( options.trigger !== false ) canvas.triggerPendingOperations();
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Additional events which trigger once control of the object is released
	 * @param {Object} options          Options which modify the releasing workflow
	 * @protected
	 */
	_onRelease(options) {
		const layer = this.layer;
		if ( layer.hud && (layer.hud.object === this) ) layer.hud.clear();
		this.refresh();
	}

	/* -------------------------------------------- */

	/**
	 * Rotate the PlaceableObject to a certain angle of facing
	 * @param {number} angle        The desired angle of rotation
	 * @param {number} snap         Snap the angle of rotation to a certain target degree increment
	 * @return {Promise<PlaceableObject>} The rotated object
	 */
	async rotate(angle, snap) {
		if ( this.data.rotation === undefined ) return this;
		const rotation = this._updateRotation({angle, snap});
		this.layer.hud?.clear();
		await this.document.update({rotation});
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Determine a new angle of rotation for a PlaceableObject either from an explicit angle or from a delta offset.
	 * @param {object} options    An object which defines the rotation update parameters
	 * @param {number} [options.angle]    An explicit angle, either this or delta must be provided
	 * @param {number} [options.delta=0]  A relative angle delta, either this or the angle must be provided
	 * @param {number} [options.snap=0]   A precision (in degrees) to which the resulting angle should snap. Default is 0.
	 * @return {number}           The new rotation angle for the object
	 */
	_updateRotation({angle, delta=0, snap=0}={}) {
		let degrees = Number.isNumeric(angle) ? angle : this.data.rotation + delta;
		if ( snap > 0 ) degrees = degrees.toNearest(snap);
		let isHexRow = [CONST.GRID_TYPES.HEXODDR, CONST.GRID_TYPES.HEXEVENR].includes(canvas.grid.type);
		const offset = isHexRow && (snap > 30) ? 30 : 0;
		return Math.normalizeDegrees(degrees - offset);
	}

	/* -------------------------------------------- */

	/**
	 * Obtain a shifted position for the Placeable Object
	 * @param {number} dx         The number of grid units to shift along the X-axis
	 * @param {number} dy         The number of grid units to shift along the Y-axis
	 * @return {{x:number, y:number}} The shifted target coordinates
	 */
	_getShiftedPosition(dx, dy) {
		let [x, y] = canvas.grid.grid.shiftPosition(this.data.x, this.data.y, dx, dy);
		return {x, y};
	}

	/* -------------------------------------------- */
	/*  Interactivity                               */
	/* -------------------------------------------- */

	/**
	 * Activate interactivity for the Placeable Object
	 */
	activateListeners() {
		const mgr = this._createInteractionManager();
		this.mouseInteractionManager = mgr.activate();
	}

	/* -------------------------------------------- */

	/**
	 * Create a standard MouseInteractionManager for the PlaceableObject
	 * @protected
	 */
	_createInteractionManager() {

		// Handle permissions to perform various actions
		const permissions = {
			hoverIn: this._canHover,
			hoverOut: this._canHover,
			clickLeft: this._canControl,
			clickLeft2: this._canView,
			clickRight: this._canHUD,
			clickRight2: this._canConfigure,
			dragStart: this._canDrag
		};

		// Define callback functions for each workflow step
		const callbacks = {
			hoverIn: this._onHoverIn,
			hoverOut: this._onHoverOut,
			clickLeft: this._onClickLeft,
			clickLeft2: this._onClickLeft2,
			clickRight: this._onClickRight,
			clickRight2: this._onClickRight2,
			dragLeftStart: this._onDragLeftStart,
			dragLeftMove: this._onDragLeftMove,
			dragLeftDrop: this._onDragLeftDrop,
			dragLeftCancel: this._onDragLeftCancel,
			dragRightStart: null,
			dragRightMove: null,
			dragRightDrop: null,
			dragRightCancel: null
		};

		// Define options
		const options = { target: this.controlIcon ? "controlIcon" : null };

		// Create the interaction manager
		return new MouseInteractionManager(this, canvas.stage, permissions, callbacks, options);
	}

	/* -------------------------------------------- */

	/**
	 * Actions that should be taken for this Placeable Object when a mouseover event occurs
	 * @see MouseInteractionManager#_handleMouseOver
	 * @param {PIXI.InteractionEvent} event   The triggering canvas interaction event
	 * @param {object} options                Options which customize event handling
	 * @param {boolean} [options.hoverOutOthers=true] Trigger hover-out behavior on sibling objects
	 */
	_onHoverIn(event, {hoverOutOthers=true}={}) {
		if ( this._hover === true ) return false;
		if ( this.data.locked ) return false;
		const layer = this.layer;

		// Update the hover state of all objects in the layer
		if ( hoverOutOthers ) {
			layer.placeables.forEach(o => {
				if ( o !== this ) o._onHoverOut(event);
			});
		}
		this._hover = true;
		layer._hover = this;

		// Refresh the object display
		this.refresh();
		Hooks.callAll("hover"+this.constructor.embeddedName, this, this._hover);
	}

	/* -------------------------------------------- */

	/**
	 * Actions that should be taken for this Placeable Object when a mouseout event occurs
	 * @see MouseInteractionManager#_handleMouseOut
	 * @param {PIXI.InteractionEvent} event  The triggering canvas interaction event
	 */
	_onHoverOut(event) {
		if ( this._hover !== true ) return false;
		if ( this.data.locked ) return false;
		const layer = this.layer;
		this._hover = false;
		layer._hover = null;
		this.refresh();
		Hooks.callAll("hover"+this.constructor.embeddedName, this, this._hover);
	}

	/* -------------------------------------------- */

	/**
	 * Callback actions which occur on a single left-click event to assume control of the object
	 * @see MouseInteractionManager#_handleClickLeft
	 * @param {PIXI.InteractionEvent} event  The triggering canvas interaction event
	 */
	_onClickLeft(event) {
		const hud = this.layer.hud;
		if ( hud ) hud.clear();

		// Add or remove the Placeable Object from the currently controlled set
		const oe = event.data.originalEvent;
		if ( this._controlled ) {
			if ( oe.shiftKey ) return this.release();
		} else {
			return this.control({releaseOthers: !oe.shiftKey});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Callback actions which occur on a double left-click event to activate
	 * @see MouseInteractionManager#_handleClickLeft2
	 * @param {PIXI.InteractionEvent} event  The triggering canvas interaction event
	 */
	_onClickLeft2(event) {
		const sheet = this.sheet;
		if ( sheet ) sheet.render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Callback actions which occur on a single right-click event to configure properties of the object
	 * @see MouseInteractionManager#_handleClickRight
	 * @param {PIXI.InteractionEvent} event  The triggering canvas interaction event
	 */
	_onClickRight(event) {
		const hud = this.layer.hud;
		if ( hud ) {
			const releaseOthers = !this._controlled && !event.data.originalEvent.shiftKey;
			this.control({releaseOthers});
			if ( hud.object === this) hud.clear();
			else hud.bind(this);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Callback actions which occur on a double right-click event to configure properties of the object
	 * @see MouseInteractionManager#_handleClickRight2
	 * @param {PIXI.InteractionEvent} event  The triggering canvas interaction event
	 */
	_onClickRight2(event) {
		const sheet = this.sheet;
		if ( sheet ) sheet.render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Callback actions which occur when a mouse-drag action is first begun.
	 * @see MouseInteractionManager#_handleDragStart
	 * @param {PIXI.InteractionEvent} event  The triggering canvas interaction event
	 */
	_onDragLeftStart(event) {
		const targets = this.layer.options.controllableObjects ? this.layer.controlled : [this];
		const clones = [];
		for ( let o of targets ) {
			if ( o.data.locked ) continue;
			o.data.locked = true;

			// Clone the object
			const c = o.clone();
			clones.push(c);

			// Draw the clone
			c.draw().then(c => {
				o.alpha = 0.4;
				c.alpha = 0.8;
				c.visible = true;
				this.layer.preview.addChild(c);
			});
		}
		event.data.clones = clones;
	}

	/* -------------------------------------------- */

	/**
	 * Callback actions which occur on a mouse-move operation.
	 * @see MouseInteractionManager#_handleDragMove
	 * @param {PIXI.InteractionEvent} event  The triggering canvas interaction event
	 */
	_onDragLeftMove(event) {
		const {clones, destination, origin, originalEvent} = event.data;
		canvas._onDragCanvasPan(originalEvent);
		const dx = destination.x - origin.x;
		const dy = destination.y - origin.y;
		for ( let c of clones || [] ) {
			c.data.x = c._original.data.x + dx;
			c.data.y = c._original.data.y + dy;
			c.refresh();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Callback actions which occur on a mouse-move operation.
	 * @see MouseInteractionManager#_handleDragDrop
	 * @param {PIXI.InteractionEvent} event  The triggering canvas interaction event
	 * @returns {Promise<*>}
	 */
	async _onDragLeftDrop(event) {
		const {clones, destination, originalEvent} = event.data;
		if ( !clones || !canvas.grid.hitArea.contains(destination.x, destination.y) ) return false;
		const updates = clones.map(c => {
			let dest = {x: c.data.x, y: c.data.y};
			if ( !originalEvent.shiftKey ) {
				dest = canvas.grid.getSnappedPosition(c.data.x, c.data.y, this.layer.gridPrecision);
			}
			return {_id: c._original.id, x: dest.x, y: dest.y, rotation: c.data.rotation};
		});
		return canvas.scene.updateEmbeddedDocuments(this.document.documentName, updates);
	}

	/* -------------------------------------------- */

	/**
	 * Callback actions which occur on a mouse-move operation.
	 * @see MouseInteractionManager#_handleDragCancel
	 * @param {MouseEvent} event  The triggering mouse click event
	 */
	_onDragLeftCancel(event) {
		for ( let c of this.layer.preview.children ) {
			c.visible = false;
			const o = c._original;
			if ( o ) {
				o.data.locked = false;
				o.alpha = 1.0;
			}
		}
		this.layer.preview.removeChildren();
	}

	/* -------------------------------------------- */
	/*  Deprecations                                */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	static async create(data, options={}) {
		console.warn("You are calling PlaceableObject.create which has been deprecated in favor of Document.create or Scene#createEmbeddedDocuments. Support will be removed in 0.9.0");
		options.parent = canvas.scene;
		data = data instanceof Array ? data : [data];
		return canvas.scene.createEmbeddedDocuments(this.embeddedName, data, options);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	async update(data, options) {
		console.warn("You are calling PlaceableObject#update which has been deprecated in favor of Document#update or Scene#updateEmbeddedDocuments. Support will be removed in 0.9.0");
		return this.document.update(data, options);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	async delete(options) {
		console.warn("You are calling PlaceableObject#delete which has been deprecated in favor of Document#delete or Scene#deleteEmbeddedDocuments. Support will be removed in 0.9.0");
		return this.document.delete(options);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	getFlag(scope, key) {
		console.warn("You are calling PlaceableObject#getFlag which has been deprecated in favor of Document#getFlag. Support will be removed in 0.9.0");
		return this.document.getFlag(scope, key);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	async setFlag(scope, key, value) {
		console.warn("You are calling PlaceableObject#setFlag which has been deprecated in favor of Document#setFlag. Support will be removed in 0.9.0");
		return this.document.setFlag(scope, key, value);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	async unsetFlag(scope, key) {
		console.warn("You are calling PlaceableObject#unsetFlag which has been deprecated in favor of Document#unsetFlag. Support will be removed in 0.9.0");
		return this.document.unsetFlag(scope, key);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	get uuid() {
		console.warn("You are calling PlaceableObject#uuid which has been deprecated in favor of Document#uuid. Support will be removed in 0.9.0");
		return this.document.uuid;
	}

	/**
	 * @deprecated since 0.8.2
	 * @ignore
	 */
	static get layer() {
		console.warn("The PlaceableObject.layer static attribute is deprecated in 0.8.2");
		return canvas.getLayerByEmbeddedName(this.embeddedName);
	}
}

/**
 * @typedef {Object} CanvasHistory
 * @property {string} type    The type of operation stored as history (create, update, delete)
 * @property {Object[]} data  The data corresponding to the action which may later be un-done
 */

/**
 * The base PlaceablesLayer subclass of CanvasLayer
 * @extends {CanvasLayer}
 * @abstract
 * @interface
 */
class PlaceablesLayer extends CanvasLayer {
	constructor() {
		super();

		/**
		 * Placeable Layer Objects
		 * @type {PIXI.Container}
		 */
		this.objects = null;

		/**
		 * Preview Object Placement
		 */
		this.preview = null;

		/**
		 * Keep track of history so that CTRL+Z can undo changes
		 * @type {CanvasHistory[]}
		 */
		this.history = [];

		/**
		 * Track the PlaceableObject on this layer which is currently being hovered upon
		 * @type {PlaceableObject}
		 */
		this._hover = null;

		/**
		 * Track the set of PlaceableObjects on this layer which are currently controlled by their id
		 * @type {Object}
		 */
		this._controlled = {};

		/**
		 * Keep track of an object copied with CTRL+C which can be pasted later
		 * @type {PlaceableObject[]}
		 */
		this._copy = [];

		/**
		 * PlaceableObject layer options
		 * @type {Object}
		 */
		this.options = this.constructor.layerOptions;

		/**
		 * A Quadtree which partitions and organizes Walls into quadrants for efficient target identification.
		 * @type {Quadtree|null}
		 */
		this.quadtree = null;
	}

	/* -------------------------------------------- */
	/*  Attributes                                  */
	/* -------------------------------------------- */

	/**
	 * @inheritdoc
	 * @property {boolean} canDragCreate        Does this layer support a mouse-drag workflow to create new objects?
	 * @property {boolean} canDelete            Can objects be deleted from this layer?
	 * @property {boolean} controllableObjects  Can placeable objects in this layer be controlled?
	 * @property {boolean} rotatableObjects     Can placeable objects in this layer be rotated?
	 * @property {boolean} snapToGrid           Do objects in this layer snap to the grid
	 * @property {PlaceableObject} objectClass  The class used to represent an object on this layer.
	 * @property {boolean} quadtree             Does this layer use a quadtree to track object positions?
	 * @property {FormApplication} sheetClass   The FormApplication class used to configure objects on this layer.
	 */
	static get layerOptions() {
		return foundry.utils.mergeObject(super.layerOptions, {
			canDragCreate: game.user.isGM,
			controllableObjects: false,
			rotatableObjects: false,
			snapToGrid: true,
			objectClass: getDocumentClass(this.documentName),
			quadtree: false,
			sheetClass: CONFIG[this.documentName].sheetClass
		});
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the named Document type which is contained within this Canvas Layer.
	 * @type {string}
	 */
	static documentName;

	/* -------------------------------------------- */

	/**
	 * Obtain a reference to the Collection of embedded Document instances within the currently viewed Scene
	 * @type {Collection|null}
	 */
	get documentCollection() {
		return canvas.scene?.getEmbeddedCollection(this.constructor.documentName) || null;
	}

	/* -------------------------------------------- */

	/**
	 * Obtain a reference to the PlaceableObject class definition which represents the Document type in this layer.
	 * @type {Function}
	 */
	static get placeableClass() {
		return CONFIG[this.documentName].objectClass;
	}

	/* -------------------------------------------- */

	/**
	 * Return the precision relative to the Scene grid with which Placeable objects should be snapped
	 * @return {number}
	 */
	get gridPrecision() {
		if ( canvas.grid.type === CONST.GRID_TYPES.GRIDLESS ) return 0;   // No snapping for gridless
		if ( canvas.grid.type > CONST.GRID_TYPES.SQUARE ) {               // Hexagonal grids
			return this.options.controllableObjects ? 2 : 5                 // Snap to corners or vertices
		}
		return 2;                                                         // Default handling, corners and centers
	}

	/* -------------------------------------------- */

	/**
	 * If objects on this PlaceableLayer have a HUD UI, provide a reference to its instance
	 * @type {BasePlaceableHUD|null}
	 */
	get hud() {
		return null;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience method for accessing the placeable object instances contained in this layer
	 * @type {PlaceableObject[]}
	 */
	get placeables() {
		if ( !this.objects ) return [];
		return this.objects.children;
	}

	/* -------------------------------------------- */

	/**
	 * An Array of placeable objects in this layer which have the _controlled attribute
	 * @return {PlaceableObject[]}
	 */
	get controlled() {
		return Object.values(this._controlled);
	}

	/* -------------------------------------------- */
	/*  Rendering
	/* -------------------------------------------- */

	/**
	 * Obtain an iterable of objects which should be added to this PlaceableLayer
	 * @return {Document[]}
	 */
	getDocuments() {
		return this.documentCollection || [];
	}

	/* -------------------------------------------- */

	/** @override */
	async draw() {
		await super.draw();

		// Create objects container which can be sorted
		this.objects = this.addChild(new PIXI.Container());
		this.objects.sortableChildren = true;
		this.objects.visible = false;

		// Create a Quadtree container if the layer uses it
		if ( this.options.quadtree ) {
			const d = canvas.dimensions;
			this.quadtree = new Quadtree({x: 0, y: 0, width: d.width, height: d.height});
		} else this.quadtree = null;

		// Create preview container which is always above objects
		this.preview = this.addChild(new PIXI.Container());

		// Create and draw objects
		const documents = this.getDocuments();
		const promises = documents.map(doc => {
			return doc.object.draw();
		})

		// Wait for all objects to draw
		this.visible = true;
		await Promise.all(promises);
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw a single placeable object
	 * @return {PlaceableObject}
	 */
	createObject(data) {
		const obj = new this.constructor.placeableClass(data, canvas.scene);
		this.objects.addChild(obj);
		if ( this.quadtree ) this.quadtree.insert({r: obj.bounds, t: obj});
		return obj;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async tearDown() {

		// Reset layer history
		this.history = [];

		// Release all controlled objects
		if ( this.options.controllableObjects ) {
			this._controlled = {};
		}

		// Clear the HUD
		if ( this.hud ) this.hud.clear();

		// Destroy the layer children
		return super.tearDown();
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/** @inheritdoc */
	activate() {
		super.activate();
		this.objects.visible = true;
		this.placeables.forEach(l => l.refresh());
		return this;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	deactivate() {
		super.deactivate();
		this.objects.visible = false;
		this.releaseAll();
		this.placeables.forEach(l => l.refresh());
		if ( this.preview ) this.preview.removeChildren();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Get a PlaceableObject contained in this layer by it's ID
	 * @param {string} objectId   The ID of the contained object to retrieve
	 * @return {PlaceableObject}  The object instance, or undefined
	 */
	get(objectId) {
		return this.documentCollection.get(objectId)?.object;
	}

	/* -------------------------------------------- */

	/**
	 * Acquire control over all PlaceableObject instances which are visible and controllable within the layer.
	 * @param {object} options      Options passed to the control method of each object
	 * @return {PlaceableObject[]}  An array of objects that were controlled
	 */
	controlAll(options={}) {
		if ( !this.options.controllableObjects ) return [];
		options.releaseOthers = false;
		const controllable = this.placeables.filter(o => o.visible && o.can(game.user, "control"));
		for ( let o of controllable ) {
			o.control(options);
		}
		return this.controlled;
	}

	/* -------------------------------------------- */

	/**
	 * Release all controlled PlaceableObject instance from this layer.
	 * @param {object} options   Options passed to the release method of each object
	 * @returns {number}         The number of PlaceableObject instances which were released
	 */
	releaseAll(options={}) {
		let released = 0;
		for ( let o of this.placeables ) {
			if ( !o._controlled ) continue;
			o.release(options);
			released++;
		}
		return released;
	}

	/* -------------------------------------------- */

	/**
	 * Simultaneously rotate multiple PlaceableObjects using a provided angle or incremental.
	 * This executes a single database operation using Scene.update.
	 * If rotating only a single object, it is better to use the PlaceableObject.rotate instance method.
	 *
	 * @param {object} options    Options which configure how multiple objects are rotated
	 * @param {number} [options.angle]      A target angle of rotation (in degrees) where zero faces "south"
	 * @param {number} [options.delta]      An incremental angle of rotation (in degrees)
	 * @param {number} [options.snap]       Snap the resulting angle to a multiple of some increment (in degrees)
	 * @param {Array} [options.ids]         An Array of object IDs to target for rotation

	 * @return {Promise<PlaceableObject[]>} An array of objects which were rotated
	 */
	async rotateMany({angle, delta, snap, ids}={}) {
		if ((!this.constructor.layerOptions.rotatableObjects ) || (game.paused && !game.user.isGM)) return [];
		if ( (angle ?? delta ?? null) === null ) {
			throw new Error("Either a target angle or incremental delta must be provided.");
		}

		// Determine the set of rotatable objects
		const rotatable = this.controlled.filter(o => {
			if ( ids && !ids.includes(o.id) ) return false;
			return !o.data.locked;
		});
		if ( !rotatable.length ) return [];

		// Conceal any active HUD
		const hud = this.hud;
		if ( hud ) hud.clear();

		// Update the objects with a single operation
		const updateData = rotatable.map(o => {
			return {_id: o.id, rotation: o._updateRotation({angle, delta, snap})}
		});
		await canvas.scene.updateEmbeddedDocuments(this.constructor.documentName, updateData);
		return rotatable;
	}

	/* -------------------------------------------- */

	/**
	 * Simultaneously move multiple PlaceableObjects via keyboard movement offsets.
	 * This executes a single database operation using Scene.update.
	 * If moving only a single object, this will delegate to PlaceableObject.update for performance reasons.
	 *
	 * @param {object} options    Options which configure how multiple objects are moved
	 * @param {number} [options.dx=0]       The number of incremental grid units in the horizontal direction
	 * @param {number} [options.dy=0]       The number of incremental grid units in the vertical direction
	 * @param {boolean} [options.rotate=false] Rotate the token to the keyboard direction instead of moving
	 * @param {Array} [options.ids]         An Array of object IDs to target for movement
	 *
	 * @return {Promise<PlaceableObject[]>} An array of objects which were moved during the operation
	 */
	async moveMany({dx=0, dy=0, rotate=false, ids}={}) {
		if ( !dx && !dy ) return [];
		if ( game.paused && !game.user.isGM ) {
			return ui.notifications.warn("GAME.PausedWarning", {localize: true});
		}

		// Determine the set of movable object IDs unless some were explicitly provided
		ids = ids instanceof Array ? ids : this.controlled.filter(o => !o.data.locked).map(o => o.id);
		if ( !ids.length ) return [];

		// Define rotation angles
		const rotationAngles = {
			square: [45, 135, 225, 315],
			hexR: [30, 150, 210, 330],
			hexQ: [60, 120, 240, 300]
		};

		// Determine the rotation angle
		let offsets = [dx, dy];
		let angle = 0;
		if ( rotate ) {
			let angles = rotationAngles.square;
			if ( canvas.grid.type >= CONST.GRID_TYPES.HEXODDQ ) angles = rotationAngles.hexQ;
			else if ( canvas.grid.type >= CONST.GRID_TYPES.HEXODDR ) angles = rotationAngles.hexR;
			if (offsets.equals([0, 1])) angle = 0;
			else if (offsets.equals([-1, 1])) angle = angles[0];
			else if (offsets.equals([-1, 0])) angle = 90;
			else if (offsets.equals([-1, -1])) angle = angles[1];
			else if (offsets.equals([0, -1])) angle = 180;
			else if (offsets.equals([1, -1])) angle = angles[2];
			else if (offsets.equals([1, 0])) angle = 270;
			else if (offsets.equals([1, 1])) angle = angles[3];
		}

		// Conceal any active HUD
		const hud = this.hud;
		if ( hud ) hud.clear();

		// Construct the update Array
		const moved = [];
		const updateData = ids.map(id => {
			let obj = this.get(id);
			let update = {_id: id};
			if ( rotate ) update.rotation = angle;
			else foundry.utils.mergeObject(update, obj._getShiftedPosition(...offsets));
			moved.push(obj);
			return update;
		});
		await canvas.scene.updateEmbeddedDocuments(this.constructor.documentName, updateData);
		return moved;
	}

	/* -------------------------------------------- */

	/**
	 * Undo a change to the objects in this layer
	 * This method is typically activated using CTRL+Z while the layer is active
	 * @returns {Promise<Document[]>}     An array of documents which were modified by the undo operation
	 */
	async undoHistory() {
		if ( !this.history.length ) return Promise.reject("No more tracked history to undo!");
		let event = this.history.pop();
		const type = this.constructor.documentName;

		// Undo creation with deletion
		if ( event.type === "create" ) {
			const ids = event.data.map(d => d._id);
			return canvas.scene.deleteEmbeddedDocuments(type, ids, {isUndo: true});
		}

		// Undo updates with update
		else if ( event.type === "update" ) {
			return canvas.scene.updateEmbeddedDocuments(type, event.data, {isUndo: true});
		}

		// Undo deletion with creation
		else if ( event.type === "delete" ) {
			return canvas.scene.createEmbeddedDocuments(type, event.data, {isUndo: true})
		}
	}

	/* -------------------------------------------- */

	/**
	 * A helper method to prompt for deletion of all PlaceableObject instances within the Scene
	 * Renders a confirmation dialogue to confirm with the requester that all objects will be deleted
	 * @returns {Promise<Document[]>}    An array of Document objects which were deleted by the operation
	 */
	async deleteAll() {
		const type = this.constructor.documentName;
		if ( !game.user.isGM ) {
			throw new Error(`You do not have permission to delete ${type} objects from the Scene.`);
		}
		return Dialog.confirm({
			title: game.i18n.localize("CONTROLS.ClearAll"),
			content: `<p>${game.i18n.format("CONTROLS.ClearAllHint", {type})}</p>`,
			yes: () => canvas.scene.deleteEmbeddedDocuments(type, [], {deleteAll: true})
		});
	}

	/* -------------------------------------------- */

	/**
	 * Record a new CRUD event in the history log so that it can be undone later
	 * @param {string} type   The event type (create, update, delete)
	 * @param {Object[]} data   The object data
	 */
	storeHistory(type, data) {
		if ( this.history.length >= 10 ) this.history.shift();
		this.history.push({type, data});
	}

	/* -------------------------------------------- */

	/**
	 * Copy currently controlled PlaceableObjects to a temporary Array, ready to paste back into the scene later
	 * @returns {PlaceableObject[]}             The Array of copied PlaceableObject instances
	 */
	copyObjects() {
		if ( this.options.controllableObjects ) this._copy = [...this.controlled];
		else if ( this._hover) this._copy = [this._hover];
		else this._copy = [];
		ui.notifications.info(`Copied data for ${this._copy.length} ${this.constructor.documentName} objects`);
		return this._copy;
	}

	/* -------------------------------------------- */

	/**
	 * Paste currently copied PlaceableObjects back to the layer by creating new copies
	 * @param {Point} position      The destination position for the copied data.
	 * @param {boolean} [hidden]    Paste data in a hidden state, if applicable. Default is false.
	 * @param {boolean} [snap]      Snap the resulting objects to the grid. Default is true.
	 * @return {Promise<Document[]>} An Array of created Document instances
	 */
	async pasteObjects(position, {hidden=false, snap=true}={}) {
		if ( !this._copy.length ) return [];
		const cls = this.constructor.placeableClass;
		const d = canvas.dimensions;

		// Adjust the pasted position for half a grid space
		if ( snap ) {
			position.x -= canvas.dimensions.size / 2;
			position.y -= canvas.dimensions.size / 2;
		}

		// Get the left-most object in the set
		this._copy.sort((a, b) => a.data.x - b.data.x);
		let {x, y} = this._copy[0].data;

		// Iterate over objects
		const toCreate = [];
		for ( let c of this._copy ) {
			let data = c.document.toObject();
			delete data._id;

			// Constrain the destination position
			let dest = {x: position.x + (data.x - x), y: position.y + (data.y - y)};
			dest.x = Math.clamped(dest.x, 0, d.width-1);
			dest.y = Math.clamped(dest.y, 0, d.height-1)
			if ( snap ) dest = canvas.grid.getSnappedPosition(dest.x, dest.y);

			// Stage the creation
			toCreate.push(foundry.utils.mergeObject(data, {
				x: dest.x,
				y: dest.y,
				hidden: data.hidden || hidden
			}));
		}

		// Call paste hooks
		Hooks.call(`paste${cls.name}`, this._copy, toCreate);

		// Create all objects
		let created = await canvas.scene.createEmbeddedDocuments(this.constructor.documentName, toCreate);
		ui.notifications.info(`Pasted data for ${toCreate.length} ${this.constructor.documentName} objects.`);
		return created;
	}

	/* -------------------------------------------- */

	/**
	 * Select all PlaceableObject instances which fall within a coordinate rectangle.
	 *
	 * @param {number} x      The top-left x-coordinate of the selection rectangle
	 * @param {number} y      The top-left y-coordinate of the selection rectangle
	 * @param {number} width  The width of the selection rectangle
	 * @param {number} height The height of the selection rectangle
	 * @param {Object} releaseOptions   Optional arguments provided to any called release() method
	 * @param {Object} controlOptions   Optional arguments provided to any called control() method
	 * @return {boolean}       A boolean for whether the controlled set was changed in the operation
	 */
	selectObjects({x, y, width, height, releaseOptions={}, controlOptions={}}={}) {
		if ( !this.options.controllableObjects ) return false;
		const oldSet = Object.values(this._controlled);

		// Identify controllable objects
		const controllable = this.placeables.filter(obj => obj.visible && (obj.control instanceof Function));
		const newSet = controllable.filter(obj => {
			let c = obj.center;
			return Number.between(c.x, x, x+width) && Number.between(c.y, y, y+height);
		});

		// Release objects no longer controlled
		const toRelease = oldSet.filter(obj => !newSet.includes(obj));
		toRelease.forEach(obj => obj.release(releaseOptions));

		// Control new objects
		if ( foundry.utils.isObjectEmpty(controlOptions) ) controlOptions.releaseOthers = false;
		const toControl = newSet.filter(obj => !oldSet.includes(obj));
		toControl.forEach(obj => obj.control(controlOptions));

		// Return a boolean for whether the control set was changed
		return (toRelease.length > 0) || (toControl.length > 0);
	}

	/* -------------------------------------------- */

	/**
	 * Update all objects in this layer with a provided transformation.
	 * Conditionally filter to only apply to objects which match a certain condition.
	 * @param {Function|object} transformation    An object of data or function to apply to all matched objects
	 * @param {Function|null}  condition          A function which tests whether to target each object
	 * @param {object} [options]                  Additional options passed to Entity.update
	 * @return {Promise<Document[]>}              An array of updated data once the operation is complete
	 */
	async updateAll(transformation, condition=null, options={}) {
		const hasTransformer = transformation instanceof Function;
		if ( !hasTransformer && (foundry.utils.getType(transformation) !== "Object") ) {
			throw new Error("You must provide a data object or transformation function");
		}
		const hasCondition = condition instanceof Function;
		const updates = this.placeables.reduce((arr, obj) => {
			if ( hasCondition && !condition(obj) ) return arr;
			const update = hasTransformer ? transformation(obj) : foundry.utils.deepClone(transformation);
			update._id = obj.id;
			arr.push(update);
			return arr;
		},[]);
		return canvas.scene.updateEmbeddedDocuments(this.constructor.documentName, updates, options);
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Handle left mouse-click events which originate from the Canvas stage and are dispatched to this Layer.
	 * @see {Canvas#_onClickLeft}
	 */
	_onClickLeft(event) {
		if ( this.hud ) this.hud.clear();
		switch ( ui.controls.activeTool ) {
			case "select":
				return this.releaseAll();
			case "target":
				return game.user.updateTokenTargets([]);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle double left-click events which originate from the Canvas stage and are dispatched to this Layer.
	 * @see {Canvas#_onClickLeft2}
	 */
	_onClickLeft2(event) {}

	/* -------------------------------------------- */

	/**
	 * Start a left-click drag workflow originating from the Canvas stage.
	 * @see {Canvas#_onDragLeftStart}
	 * @returns {Promise<void>}
	 */
	async _onDragLeftStart(event) {
		if ( !this.options.canDragCreate ) {
			delete event.data.createState;
			return;
		}
		event.data.createState = 0;

		// Clear any existing preview
		if ( this.preview ) this.preview.removeChildren();
		event.data.preview = null;

		// Snap the origin to the grid
		const {origin, originalEvent} = event.data;
		if ( this.options.snapToGrid && !originalEvent.isShift ) {
			event.data.origin = canvas.grid.getSnappedPosition(origin.x, origin.y, this.gridPrecision);
		}

		// Register the ongoing creation
		event.data.createState = 1;
	}

	/* -------------------------------------------- */

	/**
	 * Continue a left-click drag workflow originating from the Canvas stage.
	 * @see {Canvas#_onDragLeftMove}
	 */
	_onDragLeftMove(event) {
		const preview = event.data.preview;
		if ( !preview ) return;
		if ( preview.parent === null ) { // In theory this should never happen, but rarely does
			this.preview.addChild(preview);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Conclude a left-click drag workflow originating from the Canvas stage.
	 * @see {Canvas#_onDragLeftDrop}
	 * @returns {Promise}
	 */
	async _onDragLeftDrop(event) {
		const object = event.data.preview;
		if ( object ) {
			const cls = getDocumentClass(this.constructor.documentName);
			return cls.create(object.data.toObject(false), {parent: canvas.scene});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Cancel a left-click drag workflow originating from the Canvas stage.
	 * @see {Canvas#_onDragLeftDrop}
	 */
	_onDragLeftCancel(event) {
		if ( this.preview ) {
			for ( let c of this.preview.children ) {
				if ( c._original ) {
					if ( "locked" in c._original.data ) c._original.data.locked = false;
					c._original.alpha = 1.0;
				}
			}
			this.preview.removeChildren();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle right mouse-click events which originate from the Canvas stage and are dispatched to this Layer.
	 * @see {Canvas#_onClickRight}
	 */
	_onClickRight(event) {
		if ( this.hud ) this.hud.clear();
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-wheel events at the PlaceableObjects layer level to rotate multiple objects at once.
	 * This handler will rotate all controlled objects by some incremental angle.
	 * @param {MouseWheelEvent} event   The mousewheel event which originated the request
	 */
	_onMouseWheel(event) {

		// Prevent wheel rotation for non-GM users if the game is paused
		if ( game.paused && !game.user.isGM ) return;

		// Determine the incremental angle of rotation from event data
		const dBig = canvas.grid.type > CONST.GRID_TYPES.SQUARE ? 60 : 45;
		let snap = event.shiftKey ? dBig : 15;
		let delta = snap * Math.sign(event.deltaY);

		// Case 1 - rotate preview objects
		if ( this.preview.children.length ) {
			for ( let p of this.preview.children ) {
				p.data.rotation = p._updateRotation({delta, snap});
				p.refresh();
			}
		}

		// Case 2 - Update multiple objects
		else return this.rotateMany({delta, snap});
	}

	/* -------------------------------------------- */

	/**
	 * Handle a DELETE keypress while a placeable object is hovered
	 * @param {Event} event    The delete key press event which triggered the request
	 * @private
	 */
	async _onDeleteKey(event) {

		// Identify objects which are candidates for deletion
		const objects = this.options.controllableObjects ? this.controlled : (this._hover ? [this._hover] : []);
		if ( !objects.length ) return;

		// Restrict to objects which can be deleted
		const ids = objects.reduce((ids, o) => {
			if ( o.data.locked  || !o.document.canUserModify(game.user, "delete") ) return ids;
			ids.push(o.id);
			return ids;
		}, []);
		if ( ids.length ) return canvas.scene.deleteEmbeddedDocuments(this.constructor.documentName, ids);
	}

	/* -------------------------------------------- */
	/*  Deprecations                                */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	static get dataArray() {
		console.warn("You are calling PlaceablesLayer.dataArray which is deprecated in favor of PlaceablesLayer.documentClass.metadata.collection");
		return this.documentClass.metadata.collection;
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	async createMany(data, options) {
		console.warn("You are calling PlaceablesLayer#createMany which has been deprecated in favor Scene#createEmbeddedDocuments. Support will be removed in 0.9.0");
		return canvas.scene.createEmbeddedDocuments(this.constructor.documentName, data, options);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	async updateMany(data, options) {
		console.warn("You are calling PlaceablesLayer#updateMany which has been deprecated in favor Scene#updateEmbeddedDocuments. Support will be removed in 0.9.0");
		return canvas.scene.updateEmbeddedDocuments(this.constructor.documentName, data, options);
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	async deleteMany(ids, options) {
		console.warn("You are calling PlaceablesLayer#deleteMany which has been deprecated in favor Scene#deleteEmbeddedDocuments. Support will be removed in 0.9.0");
		return canvas.scene.deleteEmbeddedDocuments(this.constructor.documentName, ids, options);
	}
}

/**
 * Display a right-click activated Context Menu which provides a dropdown menu of options
 * A ContextMenu is constructed by designating a parent HTML container and a target selector
 * An Array of menuItems defines the entries of the menu which is displayed
 * 
 * @param {HTMLElement|jQuery} element    The containing HTML element within which the menu is positioned
 * @param {string} selector               A CSS selector which activates the context menu.
 * @param {object[]} menuItems            An Array of entries to display in the menu
 * @param {string} eventName              Optionally override the triggering event which can spawn the menu
 *
 * @param {Object} menuItem               Menu items in the array can have the following properties
 * @param {string} menuItem.name          The displayed item name
 * @param {string} menuItem.icon          An icon glyph HTML string
 * @param {Function} menuItem.condition   A function which returns a Boolean for whether or not to display the item
 * @param {Function} menuItem.callback    A callback function to trigger when the entry of the menu is clicked
 */
class ContextMenu {
	constructor(element, selector, menuItems, {eventName="contextmenu"}={}) {

		/**
		 * The target HTMLElement being selected
		 * @type {HTMLElement}
		 */
		this.element = element;

		/**
		 * The target CSS selector which activates the menu
		 * @type {string}
		 */
		this.selector = selector || element.attr("id");

		/**
		 * An interaction event name which activates the menu
		 * @type {string}
		 */
		this.eventName = eventName;

		/**
		 * The array of menu items being rendered
		 * @type {object[]}
		 */
		this.menuItems = menuItems;

		/**
		 * Track which direction the menu is expanded in
		 * @type {boolean}
		 */
		this._expandUp = false;

		// Bind to the current element
		this.bind();
	}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor to the context menu HTML object
	 * @return {*|jQuery.fn.init|jQuery|HTMLElement}
	 */
	get menu() {
		return $("#context-menu");
	}

	/* -------------------------------------------- */

	/**
	 * Attach a ContextMenu instance to an HTML selector
	 */
	bind() {
		this.element.on(this.eventName, this.selector, event => {
			event.preventDefault();
			const parent = $(event.currentTarget);
			const menu = this.menu;

			// Remove existing context UI
			$('.context').removeClass("context");
			if ($.contains(parent[0], menu[0])) return this.close();

			// Render a new context menu
			event.stopPropagation();
			ui.context = this;
			return this.render(parent);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Animate closing the menu by sliding up and removing from the DOM
	 */
	async close() {
		let menu = this.menu;
		await this._animateClose(menu);
		menu.remove();
		$('.context').removeClass("context");
		delete ui.context;
	}

	/* -------------------------------------------- */

	async _animateOpen(menu) {
		menu.hide();
		return new Promise(resolve => menu.slideDown(200, resolve));
	}

	/* -------------------------------------------- */

	async _animateClose(menu) {
		return new Promise(resolve => menu.slideUp(200, resolve));
	}

	/* -------------------------------------------- */

	/**
	 * Render the Context Menu by iterating over the menuItems it contains.
	 * Check the visibility of each menu item, and only render ones which are allowed by the item's logical condition.
	 * Attach a click handler to each item which is rendered.
	 * @param {jQuery} target     The target element to which the context menu is attached
	 */
	render(target) {
		let html = $("#context-menu").length ? $("#context-menu") : $('<nav id="context-menu"></nav>');
		let ol = $('<ol class="context-items"></ol>');
		html.html(ol);

		// Build menu items
		for (let item of this.menuItems) {

			// Determine menu item visibility (display unless false)
			let display = true;
			if ( item.condition !== undefined ) {
				display = ( item.condition instanceof Function ) ? item.condition(target) : item.condition;
			}
			if ( !display ) continue;

			// Construct and add the menu item
			let name = game.i18n.localize(item.name);
			let li = $(`<li class="context-item">${item.icon}${name}</li>`);
			li.children("i").addClass("fa-fw");
			li.click(e => {
				e.preventDefault();
				e.stopPropagation();
				item.callback(target);
				this.close();
			});
			ol.append(li);
		}

		// Bail out if there are no children
		if ( ol.children().length === 0 ) return;

		// Append to target
		this._setPosition(html, target);

		// Animate open the menu
		return this._animateOpen(html);
	}

	/* -------------------------------------------- */

	/**
	 * Set the position of the context menu, taking into consideration whether the menu should expand upward or downward
	 * @private
	 */
	_setPosition(html, target) {
		const container = target[0].parentElement;

		// Append to target and get the context bounds
		target.css('position', 'relative');
		html.css("visibility", "hidden");
		target.append(html);
		const contextRect = html[0].getBoundingClientRect();
		const parentRect = target[0].getBoundingClientRect();
		const containerRect = container.getBoundingClientRect();

		// Determine whether to expand upwards
		const contextTop = parentRect.top - contextRect.height;
		const contextBottom = parentRect.bottom + contextRect.height;
		const canOverflowUp = (contextTop > containerRect.top) || (getComputedStyle(container).overflowY === "visible");

		// If it overflows the container bottom, but not the container top
		const containerUp = ( contextBottom > containerRect.bottom ) && ( contextTop >= containerRect.top );
		const windowUp = ( contextBottom > window.innerHeight ) && ( contextTop > 0 ) && canOverflowUp;
		this._expandUp = containerUp || windowUp;

		// Display the menu
		html.addClass(this._expandUp ? "expand-up" : "expand-down");
		html.css("visibility", "");
		target.addClass("context");
	}

	/* -------------------------------------------- */

	static eventListeners() {
		document.addEventListener("click", ev => {
			if ( ui.context ) ui.context.close();
		});
	};
}

/* -------------------------------------------- */

/**
 * @typedef {Object} DialogButton
 * @property {string} icon            A Font Awesome icon for the button
 * @property {string} label           The label for the button
 * @property {Function} [callback]    A callback function that fires when the button is clicked
 */

/**
 * Create a dialog window displaying a title, a message, and a set of buttons which trigger callback functions.
 * @implements {Application}
 *
 * @param {Object} data               An object of dialog data which configures how the modal window is rendered
 * @param {string} data.title         The window title displayed in the dialog header
 * @param {string} data.content       HTML content for the dialog form
 * @param {Object<string, DialogButton>} data.buttons The buttons which are displayed as action choices for the dialog
 * @param {string} [data.default]     The name of the default button which should be triggered on Enter keypress
 * @param {Function} [data.render]    A callback function invoked when the dialog is rendered
 * @param {Function} [data.close]     Common callback operations to perform when the dialog is closed
 *
 * @param {Object} options            Dialog rendering options, see :class:`Application`
 * @param {boolean} [options.jQuery]  Whether to provide jQuery objects to callback functions (if true) or plain
 *                                    HTMLElement instances (if false). This is currently true by default but in the
 *                                    future will become false by default.
 *
 * @example <caption>Constructing a custom dialog instance</caption>
 * let d = new Dialog({
 *  title: "Test Dialog",
 *  content: "<p>You must choose either Option 1, or Option 2</p>",
 *  buttons: {
 *   one: {
 *    icon: '<i class="fas fa-check"></i>',
 *    label: "Option One",
 *    callback: () => console.log("Chose One")
 *   },
 *   two: {
 *    icon: '<i class="fas fa-times"></i>',
 *    label: "Option Two",
 *    callback: () => console.log("Chose Two")
 *   }
 *  },
 *  default: "two",
 *  render: html => console.log("Register interactivity in the rendered dialog"),
 *  close: html => console.log("This always is logged no matter which option is chosen")
 * });
 * d.render(true);
 */
class Dialog extends Application {
	constructor(data, options) {
		super(options);
		this.data = data;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			template: "templates/hud/dialog.html",
			classes: ["dialog"],
			width: 400,
			jQuery: true
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get title() {
		return this.data.title || "Dialog";
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		let buttons = Object.keys(this.data.buttons).reduce((obj, key) => {
			let b = this.data.buttons[key];
			b.cssClass = [key, this.data.default === key ? "default" : ""].filterJoin(" ");
			if ( b.condition !== false ) obj[key] = b;
			return obj;
		}, {});
		return {
			content: this.data.content,
			buttons: buttons
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		html.find(".dialog-button").click(this._onClickButton.bind(this));
		$(document).on('keydown.chooseDefault', this._onKeyDown.bind(this));
		if ( this.data.render instanceof Function ) this.data.render(this.options.jQuery ? html : html[0]);
	}

	/* -------------------------------------------- */

	/**
	 * Handle a left-mouse click on one of the dialog choice buttons
	 * @param {MouseEvent} event    The left-mouse click event
	 * @private
	 */
	_onClickButton(event) {
		const id = event.currentTarget.dataset.button;
		const button = this.data.buttons[id];
		this.submit(button);
	}

	/* -------------------------------------------- */

	/**
	 * Handle a keydown event while the dialog is active
	 * @param {KeyboardEvent} event   The keydown event
	 * @private
	 */
	_onKeyDown(event) {

		// Close dialog
		if ( event.key === "Escape" ) {
			event.preventDefault();
			event.stopPropagation();
			return this.close();
		}

		// Confirm default choice
		if ( (event.key === "Enter") && this.data.default ) {
			event.preventDefault();
			event.stopPropagation();
			const defaultChoice = this.data.buttons[this.data.default];
			return this.submit(defaultChoice);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Submit the Dialog by selecting one of its buttons
	 * @param {Object} button     The configuration of the chosen button
	 * @private
	 */
	submit(button) {
		try {
			if (button.callback) button.callback(this.options.jQuery ? this.element : this.element[0]);
			this.close();
		} catch(err) {
			ui.notifications.error(err);
			throw new Error(err);
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async close(options) {
		if ( this.data.close ) this.data.close(this.options.jQuery ? this.element : this.element[0]);
		$(document).off('keydown.chooseDefault');
		return super.close(options);
	}

	/* -------------------------------------------- */
	/*  Factory Methods                             */
	/* -------------------------------------------- */

	/**
	 * A helper factory method to create simple confirmation dialog windows which consist of simple yes/no prompts.
	 * If you require more flexibility, a custom Dialog instance is preferred.
	 *
	 * @param {object} config             Confirmation dialog configuration
	 * @param {string} config.title          The confirmation window title
	 * @param {string} config.content        The confirmation message
	 * @param {Function} [config.yes]        Callback function upon yes
	 * @param {Function} [config.no]         Callback function upon no
	 * @param {Function} [config.render]     A function to call when the dialog is rendered
	 * @param {boolean} [config.defaultYes=true]  Make "yes" the default choice?
	 * @param {boolean} [config.rejectClose=false] Reject the Promise if the Dialog is closed without making a choice.
	 * @param {Object} [config.options={}]   Additional rendering options passed to the Dialog
	 *
	 * @return {Promise<*>}               A promise which resolves once the user makes a choice or closes the window
	 *
	 * @example
	 * let d = Dialog.confirm({
	 *  title: "A Yes or No Question",
	 *  content: "<p>Choose wisely.</p>",
	 *  yes: () => console.log("You chose ... wisely"),
	 *  no: () => console.log("You chose ... poorly"),
	 *  defaultYes: false
	 * });
	 */
	static async confirm({title, content, yes, no, render, defaultYes=true, rejectClose=false, options={}}={}) {
		return new Promise((resolve, reject) => {
			const dialog = new this({
				title: title,
				content: content,
				buttons: {
					yes: {
						icon: '<i class="fas fa-check"></i>',
						label: game.i18n.localize("Yes"),
						callback: html => {
							const result = yes ? yes(html) : true;
							resolve(result);
						}
					},
					no: {
						icon: '<i class="fas fa-times"></i>',
						label: game.i18n.localize("No"),
						callback: html => {
							const result = no ? no(html) : false;
							resolve(result);
						}
					}
				},
				default: defaultYes ? "yes" : "no",
				render: render,
				close: () => {
					if ( rejectClose ) reject("The confirmation Dialog was closed without a choice being made");
					else resolve(null);
				},
			}, options);
			dialog.render(true);
		});
	}

	/* -------------------------------------------- */

	/**
	 * A helper factory method to display a basic "prompt" style Dialog with a single button
	 * @param {object} config        Dialog configuration options
	 * @param {string} [config.title]          The confirmation window title
	 * @param {string} [config.content]        The confirmation message
	 * @param {string} [config.label]          The confirmation button text
	 * @param {Function} [config.callback]     A callback function to fire when the button is clicked
	 * @param {Function} [config.render]       A function that fires after the dialog is rendered
	 * @param {boolean} [config.rejectClose=true] Reject the promise if the dialog is closed without confirming the
	 *                                         choice, otherwise resolve as null
	 * @param {object} [config.options]        Additional rendering options
	 * @return {Promise<*>}           The returned value from the provided callback function, if any
	 */
	static async prompt({title, content, label, callback, render, rejectClose=true, options={}}={}) {
		return new Promise((resolve, reject) => {
			const dialog = new this({
				title: title,
				content: content,
				buttons: {
					ok: {
						icon: '<i class="fas fa-check"></i>',
						label: label,
						callback: html => {
							const result = callback(html);
							resolve(result);
						}
					},
				},
				default: "ok",
				render: render,
				close: () => {
					if ( rejectClose ) {
						reject(new Error("The Dialog prompt was closed without being accepted."));
					}
					else resolve(null);
				},
			}, options);
			dialog.render(true);
		});
	}
}

/**
 * A UI utility to make an element draggable.
 */
class Draggable {
	constructor(app, element, handle, resizable) {

		// Setup element data
		this.app = app;
		this.element = element[0];
		this.handle = handle || this.element;
		this.resizable = resizable || false;

		/**
		 * Duplicate the application's starting position to track differences
		 * @type {Object}
		 */
		this.position = null;

		/**
		 * Remember event handlers associated with this Draggable class so they may be later unregistered
		 * @type {Object}
		 */
		this.handlers = {};

		/**
		 * Throttle mousemove event handling to 60fps
		 * @type {number}
		 */
		this._moveTime = 0;

		// Activate interactivity
		this.activateListeners();
	}

	/* ----------------------------------------- */

	/**
	 * Activate event handling for a Draggable application
	 * Attach handlers for floating, dragging, and resizing
	 */
	activateListeners() {

		// Float to top
		this.handlers["click"] = ["mousedown", ev => this.app.bringToTop(), {capture: true, passive: true}];
		this.element.addEventListener(...this.handlers.click);

		// Drag handlers
		this.handlers["dragDown"] = ["mousedown", e => this._onDragMouseDown(e), false];
		this.handlers["dragMove"] = ["mousemove", e => this._onDragMouseMove(e), false];
		this.handlers["dragUp"] = ["mouseup", e => this._onDragMouseUp(e), false];
		this.handle.addEventListener(...this.handlers.dragDown);
		this.handle.classList.add("draggable");

		// Resize handlers
		if ( !this.resizable ) return;
		let handle = $('<div class="window-resizable-handle"><i class="fas fa-arrows-alt-h"></i></div>')[0];
		this.element.appendChild(handle);

		// Register handlers
		this.handlers["resizeDown"] = ["mousedown", e => this._onResizeMouseDown(e), false];
		this.handlers["resizeMove"] = ["mousemove", e => this._onResizeMouseMove(e), false];
		this.handlers["resizeUp"] = ["mouseup", e => this._onResizeMouseUp(e), false];

		// Attach the click handler and CSS class
		handle.addEventListener(...this.handlers.resizeDown);
		this.handle.classList.add("resizable");
	}

	/* ----------------------------------------- */

	/**
	 * Handle the initial mouse click which activates dragging behavior for the application
	 * @private
	 */
	_onDragMouseDown(event) {
		event.preventDefault();

		// Record initial position
		this.position = duplicate(this.app.position);
		this._initial = {x: event.clientX, y: event.clientY};

		// Add temporary handlers
		window.addEventListener(...this.handlers.dragMove);
		window.addEventListener(...this.handlers.dragUp);
	}

	/* ----------------------------------------- */

	/**
	 * Move the window with the mouse, bounding the movement to ensure the window stays within bounds of the viewport
	 * @private
	 */
	_onDragMouseMove(event) {
		event.preventDefault();

		// Limit dragging to 60 updates per second
		const now = Date.now();
		if ( (now - this._moveTime) < (1000/60) ) return;
		this._moveTime = now;

		// Update application position
		this.app.setPosition({
			left: this.position.left + (event.clientX - this._initial.x),
			top: this.position.top + (event.clientY - this._initial.y)
		});
	}

	/* ----------------------------------------- */

	/**
	 * Conclude the dragging behavior when the mouse is release, setting the final position and removing listeners
	 * @private
	 */
	_onDragMouseUp(event) {
		event.preventDefault();
		window.removeEventListener(...this.handlers.dragMove);
		window.removeEventListener(...this.handlers.dragUp);
	}

	/* ----------------------------------------- */

	/**
	 * Handle the initial mouse click which activates dragging behavior for the application
	 * @private
	 */
	_onResizeMouseDown(event) {
		event.preventDefault();

		// Limit dragging to 60 updates per second
		const now = Date.now();
		if ( (now - this._moveTime) < (1000/60) ) return;
		this._moveTime = now;

		// Record initial position
		this.position = duplicate(this.app.position);
		if ( this.position.height === "auto" ) this.position.height = this.element.clientHeight;
		if ( this.position.width === "auto" ) this.position.width = this.element.clientWidth;
		this._initial = {x: event.clientX, y: event.clientY};

		// Add temporary handlers
		window.addEventListener(...this.handlers.resizeMove);
		window.addEventListener(...this.handlers.resizeUp);
	}

	/* ----------------------------------------- */

	/**
	 * Move the window with the mouse, bounding the movement to ensure the window stays within bounds of the viewport
	 * @private
	 */
	_onResizeMouseMove(event) {
		event.preventDefault();
		this.app.setPosition({
			width: this.position.width + (event.clientX - this._initial.x),
			height: this.position.height + (event.clientY - this._initial.y)
		});
	}

	/* ----------------------------------------- */

	/**
	 * Conclude the dragging behavior when the mouse is release, setting the final position and removing listeners
	 * @private
	 */
	_onResizeMouseUp(event) {
		event.preventDefault();
		window.removeEventListener(...this.handlers.resizeMove);
		window.removeEventListener(...this.handlers.resizeUp);
		this.app._onResize(event);
	}
}
/**
 * A controller class for managing drag and drop workflows within an Application instance.
 * The controller manages the following actions: dragstart, dragover, drop
 * @see {@link Application}
 *
 * @param {string} dragSelector     The CSS selector used to target draggable elements.
 * @param {string} dropSelector     The CSS selector used to target viable drop targets.
 * @param {Object<string,Function>} permissions    An object of permission test functions for each action
 * @param {Object<string,Function>} callbacks      An object of callback functions for each action
 *
 * @example
 * const dragDrop = new DragDrop({
 *   dragSelector: ".item",
 *   dropSelector: ".items",
 *   permissions: { dragstart: this._canDragStart.bind(this), drop: this._canDragDrop.bind(this) },
 *   callbacks: { dragstart: this._onDragStart.bind(this), drop: this._onDragDrop.bind(this) }
 * });
 * dragDrop.bind(html);
 */
class DragDrop {
	constructor({dragSelector, dropSelector, permissions={}, callbacks={}} = {}) {

		/**
		 * The HTML selector which identifies draggable elements
		 * @type {string}
		 */
		this.dragSelector = dragSelector;

		/**
		 * The HTML selector which identifies drop targets
		 * @type {string}
		 */
		this.dropSelector = dropSelector;

		/**
		 * A set of permission checking functions for each action of the Drag and Drop workflow
		 * @type {Object}
		 */
		this.permissions = permissions;

		/**
		 * A set of callback functions for each action of the Drag and Drop workflow
		 * @type {Object}
		 */
		this.callbacks = callbacks;
	}

	/* -------------------------------------------- */

	/**
	 * Bind the DragDrop controller to an HTML application
	 * @param {HTMLElement} html    The HTML element to which the handler is bound
	 */
	bind(html) {

		// Identify and activate draggable targets
		if ( this.can("dragstart", this.dragSelector) ) {
			const draggables = html.querySelectorAll(this.dragSelector);
			for (let el of draggables) {
				el.setAttribute("draggable", true);
				el.ondragstart = this._handleDragStart.bind(this);
			}
		}

		// Identify and activate drop targets
		if ( this.can("dragdrop", this.dropSelector) ) {
			const droppables = this.dropSelector ? html.querySelectorAll(this.dropSelector) : [html];
			for ( let el of droppables ) {
				el.ondragover = this._handleDragOver.bind(this);
				el.ondrop = this._handleDrop.bind(this);
			}
		}
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Execute a callback function associated with a certain action in the workflow
	 * @param {DragEvent} event   The drag event being handled
	 * @param {string} action     The action being attempted
	 */
	callback(event, action) {
		const fn = this.callbacks[action];
		if ( fn instanceof Function ) return fn(event);
	}

	/* -------------------------------------------- */

	/**
	 * Test whether the current user has permission to perform a step of the workflow
	 * @param {string} action     The action being attempted
	 * @param {string} selector   The selector being targeted
	 * @return {boolean}          Can the action be performed?
	 */
	can(action, selector) {
		const fn = this.permissions[action];
		if ( fn instanceof Function ) return fn(selector);
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Handle the start of a drag workflow
	 * @param {DragEvent} event   The drag event being handled
	 * @private
	 */
	_handleDragStart(event) {
		this.callback(event, "dragstart");
		if ( event.dataTransfer.items.length ) event.stopPropagation();
	}

	/* -------------------------------------------- */

	/**
	 * Handle a dragged element over a droppable target
	 * @param {DragEvent} event   The drag event being handled
	 * @private
	 */
	_handleDragOver(event) {
		event.preventDefault();
		this.callback(event, "dragover");
		return false;
	}

	/* -------------------------------------------- */

	/**
	 * Handle a dragged element dropped on a droppable target
	 * @param {DragEvent} event   The drag event being handled
	 * @private
	 */
	_handleDrop(event) {
		event.preventDefault();
		return this.callback(event, "drop");
	}

	/* -------------------------------------------- */

	static createDragImage(img, width, height) {
		let div = document.getElementById("drag-preview");

		// Create the drag preview div
		if ( !div ) {
			div = document.createElement("div");
			div.setAttribute("id", "drag-preview");
			const img = document.createElement("img");
			img.classList.add("noborder");
			div.appendChild(img);
			document.body.appendChild(div);
		}

		// Add the preview image
		const i = div.children[0];
		i.src = img.src;
		i.width = width;
		i.height = height;
		return div;
	}
}
/**
 * A collection of helper functions and utility methods related to the rich text editor
 */
class TextEditor {

	/**
	 * Create a Rich Text Editor. The current implementation uses TinyMCE
	 * @param {Object} options          Configuration options provided to the Editor init
	 * @param {string} content          Initial HTML or text content to populate the editor with
	 * @return {tinyMCE.Editor}         The editor instance.
	 */
	static async create(options={}, content="") {
		const mceConfig = foundry.utils.mergeObject(CONFIG.TinyMCE, options, {inplace: false});
		mceConfig.target = options.target;

		mceConfig.file_picker_callback = function (pickerCallback, value, meta) {
			let filePicker = new FilePicker({
				type: "image",
				callback: path => {
					pickerCallback(path);
					// Reset our z-index for next open
					$(".tox-tinymce-aux").css({zIndex: ''});
				},
			});
			filePicker.render();
			// Set the TinyMCE dialog to be below the FilePicker
			$(".tox-tinymce-aux").css({zIndex: Math.min(++_maxZ, 9999)});
		};
		if ( mceConfig.content_css instanceof Array ) {
			mceConfig.content_css = mceConfig.content_css.map(c => foundry.utils.getRoute(c)).join(",");
		}
		mceConfig.init_instance_callback = editor => {
			const window = editor.getWin();
			editor.focus();
			if ( content ) editor.resetContent(content);
			editor.selection.setCursorLocation(editor.getBody(), editor.getBody().childElementCount);
			window.addEventListener("wheel", event => {
				if ( event.ctrlKey ) event.preventDefault();
			}, {passive: false});
			window.addEventListener("drop", ev => this._onDropEditorData(ev, editor))
		};
		const editors = await tinyMCE.init(mceConfig);
		return editors[0];
	}

	/* -------------------------------------------- */
	/*  HTML Manipulation Helpers
	/* -------------------------------------------- */

	/**
	 * Safely decode an HTML string, removing invalid tags and converting entities back to unicode characters.
	 * @param {string} html     The original encoded HTML string
	 * @return {string}         The decoded unicode string
	 */
	static decodeHTML(html) {
		const txt = this._decoder;
		txt.innerHTML = html;
		return txt.value;
	}

	/* -------------------------------------------- */

	/**
	 * Enrich HTML content by replacing or augmenting components of it
	 * @param {string} content        The original HTML content (as a string)
	 * @param {object} [options={}]   Additional options which configure how HTML is enriched
	 * @param {boolean} [options.secrets=false]      Include secret tags in the final HTML? If false secret blocks will be removed.
	 * @param {boolean} [options.entities=true]      Replace dynamic entity links?
	 * @param {boolean} [options.links=true]         Replace hyperlink content?
	 * @param {boolean} [options.rolls=true]         Replace inline dice rolls?
	 * @param {Object|Function} [options.rollData]   The data object providing context for inline rolls
	 * @return {string}               The enriched HTML content
	 */
	static enrichHTML(content, {secrets=false, entities=true, links=true, rolls=true, rollData}={}) {

		// Create the HTML element
		const html = document.createElement("div");
		html.innerHTML = String(content);

		// Remove secret blocks
		if ( !secrets ) {
			let elements = html.querySelectorAll("section.secret");
			elements.forEach(e => e.parentNode.removeChild(e));
		}

		// Plan text content replacements
		let updateTextArray = true;
		let text = [];

		// Replace entity links
		if ( entities ) {
			if ( updateTextArray ) text = this._getTextNodes(html);
			const entityTypes = CONST.ENTITY_LINK_TYPES.concat("Compendium");
			const rgx = new RegExp(`@(${entityTypes.join("|")})\\[([^\\]]+)\\](?:{([^}]+)})?`, 'g');
			updateTextArray = this._replaceTextContent(text, rgx, this._createContentLink);
		}

		// Replace hyperlinks
		if ( links ) {
			if ( updateTextArray ) text = this._getTextNodes(html);
			const rgx = /(https?:\/\/)(www\.)?([^\s<]+)/gi;
			updateTextArray = this._replaceTextContent(text, rgx, this._createHyperlink);
		}

		// Replace inline rolls
		if ( rolls ) {
			rollData = rollData instanceof Function ? rollData() : (rollData || {});
			if (updateTextArray) text = this._getTextNodes(html);
			const rgx = /\[\[(\/[a-zA-Z]+\s)?(.*?)([\]]{2,3})(?:{([^}]+)})?/gi;
			updateTextArray = this._replaceTextContent(text, rgx, (...args) => this._createInlineRoll(...args, rollData));
		}

		// Return the enriched HTML
		return html.innerHTML;
	};

	/* -------------------------------------------- */

	/**
	 * Preview an HTML fragment by constructing a substring of a given length from its inner text.
	 * @param {string} content    The raw HTML to preview
	 * @param {number} length     The desired length
	 * @return {string}           The previewed HTML
	 */
	static previewHTML(content, length=250) {
		const div = document.createElement("div");
		div.innerHTML = content;
		div.innerText = this.truncateText(div.innerText, {maxLength: length});
		return div.innerHTML;
	}

	/* -------------------------------------------- */

	/**
	 * Truncate a fragment of text to a maximum number of characters.
	 * @param {string} text           The original text fragment that should be truncated to a maximum length
	 * @param {number} [maxLength]    The maximum allowed length of the truncated string.
	 * @param {boolean} [splitWords]  Whether to truncate by splitting on white space (if true) or breaking words.
	 * @param {string|null} [suffix]  A suffix string to append to denote that the text was truncated.
	 * @return {*}
	 */
	static truncateText(text, {maxLength=50, splitWords=true, suffix="…"}={}) {
		if ( text.length <= maxLength ) return text;

		// Split the string (on words if desired)
		let short = "";
		if ( splitWords ) {
			short = text.slice(0, maxLength + 10);
			while ( short.length > maxLength ) {
				if ( /\s/.test(short) ) short = short.replace(/[\s]+([\S]+)?$/, "");
				else short = short.slice(0, maxLength);
			}
		} else {
			short = text.slice(0, maxLength);
		}

		// Add a suffix and return
		suffix = suffix ?? "";
		return short + suffix;
	}

	/* -------------------------------------------- */
	/*  Text Node Manipulation
	/* -------------------------------------------- */

	/**
	 * Recursively identify the text nodes within a parent HTML node for potential content replacement.
	 * @param {HTMLElement} parent    The parent HTML Element
	 * @return {Text[]}               An array of contained Text nodes
	 * @private
	 */
	static _getTextNodes(parent) {
		const text = [];
		const walk = document.createTreeWalker(parent, NodeFilter.SHOW_TEXT);
		while( walk.nextNode() ) text.push(walk.currentNode);
		return text;
	}

	/* -------------------------------------------- */

	/**
	 * Facilitate the replacement of text node content using a matching regex rule and a provided replacement function.
	 * @private
	 */
	static _replaceTextContent(text, rgx, func) {
		let replaced = false;
		for ( let t of text ) {
			const matches = t.textContent.matchAll(rgx);
			for ( let match of Array.from(matches).reverse() ) {
				const replacement = func(...match);
				if ( replacement ) {
					this._replaceTextNode(t, match, replacement);
					replaced = true;
				}
			}
		}
		return replaced;
	}

	/* -------------------------------------------- */

	/**
	 * Replace a matched portion of a Text node with a replacement Node
	 * @param {Text} text
	 * @param {RegExpMatchArray} match
	 * @param {Node} replacement
	 * @private
	 */
	static _replaceTextNode(text, match, replacement) {
		let target = text;
		if ( match.index > 0 ) {
			target = text.splitText(match.index);
		}
		if ( match[0].length < target.length ) {
			target.splitText(match[0].length);
		}
		target.replaceWith(replacement);
	}

	/* -------------------------------------------- */
	/*  Text Replacement Functions
	/* -------------------------------------------- */

	/**
	 * Create a dynamic entity link from a regular expression match
	 * @param {string} match          The full matched string
	 * @param {string} type           The matched entity type or "Compendium"
	 * @param {string} target         The requested match target (_id or name)
	 * @param {string} name           A customized or over-ridden display name for the link
	 * @return {HTMLAnchorElement}    An HTML element for the entity link
	 * @private
	 */
	static _createContentLink(match, type, target, name) {

		// Prepare replacement data
		const data = {
			cls: ["entity-link"],
			icon: null,
			dataset: {},
			name: name
		};
		let broken = false;

		// Get a matched World document
		if (CONST.ENTITY_TYPES.includes(type)) {

			// Get the linked Document
			const config = CONFIG[type];
			const collection = game.collections.get(type);
			const document = /^[a-zA-Z0-9]{16}$/.test(target) ? collection.get(target) : collection.getName(target);
			if (!document) broken = true;

			// Update link data
			data.name = data.name || (broken ? target : document.name);
			data.icon = config.sidebarIcon;
			data.dataset = {entity: type, id: broken ? null : document.id};
		}

		// Get a matched Compendium entity
		else if (type === "Compendium") {

			// Get the linked Entity
			let [scope, packName, id] = target.split(".");
			const pack = game.packs.get(`${scope}.${packName}`);
			if ( pack ) {
				data.dataset = {pack: pack.collection};
				data.icon = CONFIG[pack.metadata.entity].sidebarIcon;

				// If the pack is indexed, retrieve the data
				if (pack.index.size) {
					const index = pack.index.find(i => (i._id === id) || (i.name === id));
					if ( index ) {
						if ( !data.name ) data.name = index.name;
						data.dataset.id = index._id;
					}
					else broken = true;
				}

				// Otherwise assume the link may be valid, since the pack has not been indexed yet
				if ( !data.name ) data.name = data.dataset.lookup = id;
			}
			else broken = true;
		}

		// Flag a link as broken
		if (broken) {
			data.icon = "fas fa-unlink";
			data.cls.push("broken");
		}

		// Construct the formed link
		const a = document.createElement('a');
		a.classList.add(...data.cls);
		a.draggable = true;
		for (let [k, v] of Object.entries(data.dataset)) {
			a.dataset[k] = v;
		}
		a.innerHTML = `<i class="${data.icon}"></i> ${data.name}`;
		return a;
	}

	/* -------------------------------------------- */

	/**
	 * Replace a hyperlink-like string with an actual HTML <a> tag
	 * @param {string} match          The full matched string
	 * @return {HTMLAnchorElement}    An HTML element for the entity link
	 * @private
	 */
	static _createHyperlink(match) {
		const a = document.createElement('a');
		a.classList.add("hyperlink");
		a.href = match;
		a.target = "_blank";
		a.rel = "nofollow noopener";
		a.textContent = match;
		return a;
	}

	/* -------------------------------------------- */

	/**
	 * Replace an inline roll formula with a rollable <a> element or an eagerly evaluated roll result
	 * @param {string} match      The matched string
	 * @param {string} command    An optional command
	 * @param {string} formula    The matched formula
	 * @param {string} closing    The closing brackets for the inline roll
	 * @param {string} [label]    An optional label which configures the button text
	 * @return {string}           The replaced match
	 */
	static _createInlineRoll(match, command, formula, closing, label, ...args) {
		const isDeferred = !!command;
		const rollData = args.pop();
		let roll;

		// Define default inline data
		const data = {
			cls: ["inline-roll"],
			dataset: {}
		};

		// Handle the possibility of closing brackets
		if ( closing.length === 3 ) formula += "]";

		// Extract roll data as a parsed chat command
		if ( isDeferred ) {
			const chatCommand = `${command}${formula}`;
			let parsedCommand = null;
			try {
				parsedCommand = ChatLog.parse(chatCommand);
			}
			catch(err) { return null; }
			formula = parsedCommand[1][2].trim();
			const flavor = parsedCommand[1][3];

			// Set roll data
			data.cls.push(parsedCommand[0]);
			data.dataset.mode = parsedCommand[0];
			data.dataset.flavor = flavor ? flavor.trim() : (label || "");
			data.dataset.formula = formula;
			data.label = label ?? formula;
			data.title = data.dataset.flavor || data.dataset.formula;
		}

		// Perform the roll immediately
		else {
			try {
				roll = Roll.create(formula, rollData).roll();
				data.cls.push("inline-result");
				data.label = label ? `${label}: ${roll.total}` : roll.total;
				data.title = formula;
				data.dataset.roll = escape(JSON.stringify(roll));
			}
			catch(err) { return null; }
		}

		// Construct and return the formed link element
		const a = document.createElement('a');
		a.classList.add(...data.cls);
		a.title = data.title;
		for (let [k, v] of Object.entries(data.dataset)) {
			a.dataset[k] = v;
		}
		a.innerHTML = `<i class="fas fa-dice-d20"></i> ${data.label}`;
		return a;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	static activateListeners() {
		const body = $("body");
		body.on("click", "a.entity-link", this._onClickContentLink);
		body.on('dragstart', "a.entity-link", this._onDragEntityLink);
		body.on("click", "a.inline-roll", this._onClickInlineRoll);
	}

	/* -------------------------------------------- */

	/**
	 * Handle click events on Entity Links
	 * @param {Event} event
	 * @private
	 */
	static async _onClickContentLink(event) {
		event.preventDefault();
		const  a = event.currentTarget;
		let document = null;
		let id = a.dataset.id;

		// Target 1 - Compendium Link
		if ( a.dataset.pack ) {
			const pack = game.packs.get(a.dataset.pack);
			if ( a.dataset.lookup ) {
				if ( !pack.index.length ) await pack.getIndex();
				const entry = pack.index.find(i => (i._id === a.dataset.lookup) || (i.name === a.dataset.lookup));
				if ( entry ) {
					a.dataset.id = id = entry._id;
					delete a.dataset.lookup;
				}
			}
			document = id ? await pack.getDocument(id) : null;
		}

		// Target 2 - World Entity Link
		else {
			const collection = game.collections.get(a.dataset.entity);
			document = collection.get(id);
			if ( (document.documentName === "Scene") && document.journal ) document = document.journal;
			if ( !document.testUserPermission(game.user, "LIMITED") ) {
				return ui.notifications.warn(`You do not have permission to view this ${document.documentName} sheet.`);
			}
		}
		if ( !document ) return;

		// Action 1 - Execute an Action
		if ( document.documentName === "Macro" ) {
			if ( !document.testUserPermission(game.user, "LIMITED") ) {
				return ui.notifications.warn(`You do not have permission to use this ${document.documentName}.`);
			}
			return document.execute();
		}

		// Action 2 - Render the Entity sheet
		return document.sheet.render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle left-mouse clicks on an inline roll, dispatching the formula or displaying the tooltip
	 * @param {MouseEvent} event    The initiating click event
	 * @private
	 */
	static async _onClickInlineRoll(event) {
		event.preventDefault();
		const a = event.currentTarget;

		// For inline results expand or collapse the roll details
		if ( a.classList.contains("inline-result") ) {
			if ( a.classList.contains("expanded") ) {
				return Roll.collapseInlineResult(a);
			} else {
				return Roll.expandInlineResult(a);
			}
		}

		// Get the current speaker
		const cls = ChatMessage.implementation;
		const speaker = cls.getSpeaker();
		let actor = cls.getSpeakerActor(speaker);
		let rollData = actor ? actor.getRollData() : {};

		// Obtain roll data from the contained sheet, if the inline roll is within an Actor or Item sheet
		const sheet = a.closest(".sheet");
		if ( sheet ) {
			const app = ui.windows[sheet.dataset.appid];
			if ( ["Actor", "Item"].includes(app?.object?.entity) ) rollData = app.object.getRollData();
		}

		// Execute a deferred roll
		const roll = Roll.create(a.dataset.formula, rollData).roll();
		return roll.toMessage({flavor: a.dataset.flavor, speaker}, {rollMode: a.dataset.mode});
	}

	/* -------------------------------------------- */

	/**
	 * Begin a Drag+Drop workflow for a dynamic content link
	 * @param {Event} event   The originating drag event
	 * @private
	 */
	static _onDragEntityLink(event) {
		event.stopPropagation();
		const a = event.currentTarget;
		let dragData = null;

		// Case 1 - Compendium Link
		if ( a.dataset.pack ) {
			const pack = game.packs.get(a.dataset.pack);
			let id = a.dataset.id;
			if ( a.dataset.lookup && pack.index.length ) {
				const entry = pack.index.find(i => (i._id === a.dataset.lookup) || (i.name === a.dataset.lookup));
				if ( entry ) id = entry._id;
			}
			if ( !id ) return false;
			dragData = { type: pack.entity, pack: pack.collection, id: id };
		}

		// Case 2 - World Entity Link
		else dragData = { type: a.dataset.entity, id: a.dataset.id };
		event.originalEvent.dataTransfer.setData("text/plain", JSON.stringify(dragData));
	}

	/* -------------------------------------------- */

	/**
	 * Begin a a data transfer drag event with default handling
	 * @private
	 */
	_onDragStart(event) {
		event.stopPropagation();
		let li = event.currentTarget.closest("li.directory-item");
		const dragData = li.classList.contains("folder") ?
			{ type: "Folder", id: li.dataset.folderId, entity: this.constructor.entity } :
			{ type: this.constructor.entity, id: li.dataset.entityId };
		event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
		this._dragType = dragData.type;
	}

	/* -------------------------------------------- */

	/**
	 * Handle dropping of transferred data onto the active rich text editor
	 * @param {Event} event     The originating drop event which triggered the data transfer
	 * @param {TinyMCE} editor  The TinyMCE editor instance being dropped on
	 * @private
	 */
	static async _onDropEditorData(event, editor) {
		event.preventDefault();
		const data = JSON.parse(event.dataTransfer.getData('text/plain'));
		if ( !data?.id ) return;

		// Case 1 - Document from Compendium Pack
		if ( data.pack ) {
			const pack = game.packs.get(data.pack);
			if (!pack) return;
			const entity = await pack.getDocument(data.id);
			const link = `@Compendium[${data.pack}.${data.id}]{${entity.name}}`;
			editor.insertContent(link);
		}

		// Case 2 - Document from World
		else if ( data.type ) {
			const config = CONFIG[data.type];
			if ( !config ) return false;
			const entity = config.collection.instance.get(data.id);
			if ( !entity ) return false;
			const link = `@${data.type}[${entity._id}]{${entity.name}}`;
			editor.insertContent(link);
		}
	}
}

// Singleton decoder area
TextEditor._decoder = document.createElement('textarea');

// Global Export
window.TextEditor = TextEditor;

/**
 * The FilePicker application renders contents of the server-side public directory
 * This app allows for navigating and uploading files to the public path
 * @extends {Application}
 *
 * @param {object} [options={}]           Options that configure the behavior of the FilePicker
 * @param {string} [options.type]           A type of file to target, in "audio", "image", "video", "imagevideo" or "folder"
 * @param {string} [options.current]        The current file path being modified, if any
 * @param {string} [options.activeSource=data] A current file source in "data", "public", or "s3"
 * @param {Function} [options.callback]     A callback function to trigger once a file has been selected
 * @param {boolean} [options.allowUpload=true] A flag which permits explicitly disallowing upload, true by default
 * @param {HTMLElement} [options.field]     An HTML form field that the result of this selection is applied to
 * @param {HTMLButtonElement} [options.button]  An HTML button element which triggers the display of this picker
 * @param {string} [options.displayMode]    The picker display mode in FilePicker.DISPLAY_MODES
 */
class FilePicker extends Application {
	constructor(options={}) {
		super(options);

		/**
		 * The full requested path given by the user
		 * @type {string}
		 */
		this.request = options.current;

		/**
		 * The file sources which are available for browsing
		 * @type {Object}
		 */
		this.sources = Object.entries({
			data: {
				target: "",
				label: game.i18n.localize("FILES.SourceUser"),
				icon: "fas fa-database"
			},
			public: {
				target: "",
				label: game.i18n.localize("FILES.SourceCore"),
				icon: "fas fa-server"
			},
			s3: {
				buckets: [],
				bucket: "",
				target: "",
				label: game.i18n.localize("FILES.SourceS3"),
				icon: "fas fa-cloud"
			}
		}).reduce((obj, s) => {
			if ( game.data.files.storages.includes(s[0]) ) obj[s[0]] = s[1];
			return obj;
		}, {});

		/**
		 * Track the active source tab which is being browsed
		 * @type {string}
		 */
		this.activeSource = options.activeSource || "data";

		/**
		 * A callback function to trigger once a file has been selected
		 * @type {Function}
		 */
		this.callback = options.callback;

		/**
		 * The latest set of results browsed from the server
		 * @type {Object}
		 */
		this.results = {};

		/**
		 * The general file type which controls the set of extensions which will be accepted
		 * @type {string}
		 */
		this.type = options.type;

		/**
		 * The target HTML element this file picker is bound to
		 * @type {HTMLElement}
		 */
		this.field = options.field;

		/**
		 * A button which controls the display of the picker UI
		 * @type {HTMLElement}
		 */
		this.button = options.button;

		/**
		 * The display mode of the FilePicker UI
		 * @type {string}
		 */
		this.displayMode = options.displayMode || FilePicker.LAST_DISPLAY_MODE;

		/**
		 * The current set of file extensions which are being filtered upon
		 * @type {string[]}
		 */
		this.extensions = this._getExtensions(this.type);

		// Infer the source
		const [source, target] = this._inferCurrentDirectory(this.request);
		this.activeSource = source;
		this.sources[source].target = target;

		// Track whether we have loaded files
		this._loaded = false;
	}

	/**
	 * Record the last-browsed directory path so that re-opening a different FilePicker instance uses the same target
	 * @type {string}
	 */
	static LAST_BROWSED_DIRECTORY = "";

	/**
	 * Record the last-configured tile size which can automatically be applied to new FilePicker instances
	 * @type {number|null}
	 */
	static LAST_TILE_SIZE = null;

	/**
	 * Record the last-configured display mode so that re-opening a different FilePicker instance uses the same mode.
	 * @type {string}
	 */
	static LAST_DISPLAY_MODE = "list";

	/**
	 * Enumerate the allowed FilePicker display modes
	 * @type {string[]}
	 */
	static DISPLAY_MODES = ["list", "thumbs", "tiles", "images"];

	/**
	 * Cache the names of S3 buckets which can be used
	 * @type {Array|null}
	 */
	static S3_BUCKETS = null;

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			template: "templates/apps/filepicker.html",
			classes: ["filepicker"],
			width: 520,
			tabs: [{navSelector: ".tabs"}],
			dragDrop: [{dragSelector: ".file", dropSelector: ".filepicker-body"}],
			tileSize: false,
			filters: [{inputSelector: 'input[name="filter"]', contentSelector: ".filepicker-body"}]
		});
	}

	/* -------------------------------------------- */

	/**
	 * Given a current file path, determine the directory it belongs to
	 * @param {string} target   The currently requested target path
	 * @return {string[]}       An array of the inferred source and target directory path
	 */
	_inferCurrentDirectory(target) {

		// Determine target
		const ignored = [CONST.DEFAULT_TOKEN];
		if ( !target || ignored.includes(target) ) target = this.constructor.LAST_BROWSED_DIRECTORY;
		let source = "data";

		// Check for s3 matches
		const s3Match = this.constructor.matchS3URL(target);
		if ( s3Match ) {
			this.sources.s3.bucket = s3Match.groups.bucket;
			source = "s3";
			target = s3Match.groups.key;
		}

		// Non-s3 URL matches
		else if ( ["http://", "https://"].some(c => target.startsWith(c)) ) {
			target = "";
		}

		// Local file matches
		else {
			const p0 = target.split("/").shift();
			const publicDirs = ["css", "fonts", "icons", "lang", "scripts", "sounds", "ui"];
			if ( publicDirs.includes(p0) ) source = "public";
		}

		// Split off the file name and retrieve just the directory path
		let parts = target.split("/");
		if ( parts[parts.length - 1].indexOf(".") !== -1 ) parts.pop();
		const dir = parts.join("/");
		return [source, dir];
	}

	/* -------------------------------------------- */

	/**
	 * Get the valid file extensions for a given named file picker type
	 * @param {string} type
	 * @return {string[]}
	 * @private
	 */
	_getExtensions(type) {

		// Identify allowed extensions
		let types = [];
		if ( type === "image" ) types = CONST.IMAGE_FILE_EXTENSIONS;
		else if ( type === "audio" ) types = CONST.AUDIO_FILE_EXTENSIONS;
		else if ( type === "video" ) types = CONST.VIDEO_FILE_EXTENSIONS;
		else if ( type === "imagevideo") types = CONST.IMAGE_FILE_EXTENSIONS.concat(CONST.VIDEO_FILE_EXTENSIONS);
		if ( types.length === 0 ) return undefined;

		// Return the allowed types
		else return types.reduce((arr, t) => {
			arr.push(`.${t}`);
			arr.push(`.${t.toUpperCase()}`);
			return arr;
		}, []);
	}

	/* -------------------------------------------- */

	/**
	 * Test a URL to see if it matches a well known s3 key pattern
	 * @param {string} url          An input URL to test
	 * @return {RegExpMatchArray|null}   A regular expression match
	 */
	static matchS3URL(url) {
		const endpoint = game.data.files.s3?.endpoint;
		if ( !endpoint ) return null;

		// Match new style S3 urls
		const s3New = new RegExp(`^${endpoint.protocol}//(?<bucket>.*).${endpoint.host}/(?<key>.*)`);
		const matchNew = url.match(s3New);
		if ( matchNew ) return matchNew;

		// Match old style S3 urls
		const s3Old = new RegExp(`^${endpoint.protocol}//${endpoint.host}/(?<bucket>[^/]+)/(?<key>.*)`);
		return url.match(s3Old);
	}

	/* -------------------------------------------- */

	/**
	 * Parse a s3 key to learn the bucket and the key prefix used for the request
	 * @param {string} key    A fully qualified key name or prefix path
	 * @return {{bucket: string|null, keyPrefix: string}}
	 */
	static parseS3URL(key) {
		try {
			const url = new URL(key);
			return {
				bucket: url.host.split(".").shift(),
				keyPrefix: url.pathname.slice(1)
			};
		} catch(err) {
			return {
				bucket: null,
				keyPrefix: ""
			}
		}
	}

	/* -------------------------------------------- */
	/*  FilePicker Properties                       */
	/* -------------------------------------------- */

	/** @override */
	get title() {
		let type = this.type || "file";
		return game.i18n.localize(type === "imagevideo" ? "FILES.TitleImageVideo" : `FILES.Title${type.capitalize()}`);
	}

	/* -------------------------------------------- */

	/**
	 * Return the source object for the currently active source
	 * @return {Object}
	 */
	get source() {
		return this.sources[this.activeSource];
	}

	/* -------------------------------------------- */

	/**
	 * Return the target directory for the currently active source
	 * @return {string}
	 */
	get target() {
		return this.source.target;
	}

	/* -------------------------------------------- */

	/**
	 * Return a flag for whether the current user is able to upload file content
	 * @return {boolean}
	 */
	get canUpload() {
		if ( this.options.allowUpload === false ) return false;
		if ( !["data", "s3"].includes(this.activeSource) ) return false;
		return game.isAdmin || (game.user && game.user.can("FILES_UPLOAD"));
	}

	/* -------------------------------------------- */

	/**
	 * Return the upload URL to which the FilePicker should post uploaded files
	 * @return {string}
	 */
	static get uploadURL() {
		return foundry.utils.getRoute("upload");
	}

	/* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */

	/** @override */
	async getData(options) {
		const result = this.result;
		const source = this.source;
		let target = decodeURIComponent(source.target);
		const isS3 = this.activeSource === "s3";

		// Sort directories alphabetically and store their paths
		let dirs = result.dirs.map(d => { return {
			name: decodeURIComponent(d.split("/").pop()),
			path: d,
			private: result.private || result.privateDirs.includes(d)
		}});
		dirs = dirs.sort((a, b) => a.name.localeCompare(b.name));

		// Sort files alphabetically and store their client URLs
		let files = result.files.map(f => {
			let img = f;
			if ( VideoHelper.hasVideoExtension(f) ) img = "icons/svg/video.svg";
			else if ( AudioHelper.hasAudioExtension(f) ) img = "icons/svg/sound.svg";
			return {
				name: decodeURIComponent(f.split("/").pop()),
				url: f,
				img: img
			}
		});
		files = files.sort((a, b) => a.name.localeCompare(b.name));

		// Return rendering data
		return {
			bucket: isS3 ? source.bucket : null,
			canGoBack: this.activeSource !== "",
			canUpload: this.canUpload,
			canSelect: !this.options["tileSize"],
			cssClass: [this.displayMode, result.private ? "private": "public"].join(" "),
			dirs: dirs,
			displayMode: this.displayMode,
			extensions: this.extensions,
			files: files,
			isS3: isS3,
			noResults: dirs.length + files.length === 0,
			selected: this.type === "folder" ? target : this.request,
			source: source,
			sources: this.sources,
			target: target,
			tileSize: this.options["tileSize"] ? (FilePicker.LAST_TILE_SIZE || canvas.dimensions.size) : null,
			user: game.user,
			submitText: this.type === "folder" ? "FILES.SelectFolder" : "FILES.SelectFile"
		}
	}

	/* -------------------------------------------- */

	/**
	 * Browse to a specific location for this FilePicker instance
	 * @param {string} [target]   The target within the currently active source location.
	 * @param {Object} [options]  Browsing options
	 */
	async browse(target, options={}) {

		// If the user does not have permission to browse, do not proceed
		if ( game.world && !game.user.can("FILES_BROWSE") ) return;

		// Configure browsing parameters
		target = typeof target === "string" ? target : this.target;
		const source = this.activeSource;
		options = foundry.utils.mergeObject({
			extensions: this.extensions,
			wildcard: false
		}, options);

		// Determine the S3 buckets which may be used
		if ( source === "s3" ) {
			if ( this.constructor.S3_BUCKETS === null ) {
				const buckets = await this.constructor.browse("s3", "");
				this.constructor.S3_BUCKETS = buckets.dirs;
			}
			this.sources.s3.buckets = this.constructor.S3_BUCKETS;
			if ( !this.source.bucket ) this.source.bucket = this.constructor.S3_BUCKETS[0];
			options.bucket = this.source.bucket;
		}

		// Avoid browsing certain paths
		if ( target.startsWith("/") ) target = target.slice(1);
		if ( target === CONST.DEFAULT_TOKEN ) target = this.constructor.LAST_BROWSED_DIRECTORY;

		// Request files from the server
		const result = await this.constructor.browse(source, target, options).catch(error => {
			ui.notifications.warn(error);
			return this.constructor.browse(source, "", options);
		});

		// Populate browser content
		this.result = result;
		this.source.target = result.target;
		if ( source === "s3" ) this.source.bucket = result.bucket;
		this.constructor.LAST_BROWSED_DIRECTORY = result.target;
		this._loaded = true;

		// Render the application
		this.render(true);
		return result;
	}

	/* -------------------------------------------- */

	/**
	 * Browse files for a certain directory location
	 * @param {string} source     The source location in which to browse. See FilePicker#sources for details
	 * @param {string} target     The target within the source location
	 * @param {object} options                Optional arguments
	 * @param {string} [options.bucket]       A bucket within which to search if using the S3 source
	 * @param {string[]} [options.extensions] An Array of file extensions to filter on
	 * @param {boolean} [options.wildcard]    The requested dir represents a wildcard path
	 *
	 * @return {Promise}          A Promise which resolves to the directories and files contained in the location
	 */
	static async browse(source, target, options={}) {
		const data = {action: "browseFiles", storage: source, target: target};
		return this._manageFiles(data, options);
	}

	/* -------------------------------------------- */

	/**
	 * Configure metadata settings regarding a certain file system path
	 * @param {string} source     The source location in which to browse. See FilePicker#sources for details
	 * @param {string} target     The target within the source location
	 * @param {Object} options    Optional arguments which modify the request
	 * @return {Promise<Object>}
	 */
	static async configurePath(source, target, options={}) {
		const data = {action: "configurePath", storage: source, target: target};
		return this._manageFiles(data, options);
	}

	/* -------------------------------------------- */

	/**
	 * Create a subdirectory within a given source. The requested subdirectory path must not already exist.
	 * @param {string} source     The source location in which to browse. See FilePicker#sources for details
	 * @param {string} target     The target within the source location
	 * @param {Object} options    Optional arguments which modify the request
	 * @return {Promise<Object>}
	 */
	static async createDirectory(source, target, options={}) {
		const data = {action: "createDirectory", storage: source, target: target};
		return this._manageFiles(data, options);
	}

	/* -------------------------------------------- */

	/**
	 * General dispatcher method to submit file management commands to the server
	 * @returns {Promise<object>}
	 * @private
	 */
	static async _manageFiles(data, options) {
		return new Promise((resolve, reject) => {
			game.socket.emit("manageFiles", data, options, result => {
				if (result.error) return reject(result.error);
				resolve(result);
			});
		});
	}

	/* -------------------------------------------- */

	/**
	 * Dispatch a POST request to the server containing a directory path and a file to upload
	 * @param {string} source   The data source to which the file should be uploaded
	 * @param {string} path     The destination path
	 * @param {File} file       The File object to upload
	 * @param {object} [options={}]  Additional file upload options passed as form data
	 * @return {Promise<Object>}  The response object
	 */
	static async upload(source, path, file, options={}) {

		// Create the form data to post
		const fd = new FormData();
		fd.set("source", source);
		fd.set("target", path);
		fd.set("upload", file);
		Object.entries(options).forEach(o => fd.set(...o));

		// Dispatch the request
		const request = await fetch(this.uploadURL, {method: "POST", body: fd});
		if ( request.status === 413 ) {
			return ui.notifications.error("FILES.ErrorTooLarge", {localize: true});
		}

		// Attempt to obtain the response
		const response = await request.json().catch(() => { return {} });
		if (response.error) {
			ui.notifications.error(response.error);
			return false;
		}
		else if ( !response.path ) {
			return ui.notifications.error("FILES.ErrorSomethingWrong", {localize: true});
		}

		// Display additional response messages
		if (response.message) {
			if ( /^(modules|systems)/.test(response.path) ) {
				ui.notifications.warn("FILES.WarnUploadModules", {localize: true})
			}
			ui.notifications.info(response.message);
		}
		return response;
	}

	/* -------------------------------------------- */

	/**
	 * Additional actions performed when the file-picker UI is rendered
	 */
	render(force, options) {
		if ( game.world && !game.user.can("FILES_BROWSE") ) return;
		this.position.height = null;
		this.element.css({height: ""});
		this._tabs[0].active = this.activeSource;
		if ( !this._loaded ) return this.browse();
		else super.render(force, options);
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		super.activateListeners(html);
		const header = html.find("header.filepicker-header");
		const form = html[0];

		// Change the directory
		const target = header.find('input[name="target"]');
		target.on("keydown", this._onRequestTarget.bind(this));
		target[0].focus();

		// Header Control Buttons
		html.find(".current-dir button").click(this._onClickDirectoryControl.bind(this));

		// Change the S3 bucket
		html.find('select[name="bucket"]').change(this._onChangeBucket.bind(this));

		// Activate display mode controls
		const modes = html.find(".display-modes");
		modes.on("click", ".display-mode", this._onChangeDisplayMode.bind(this));
		for ( let li of modes[0].children ) {
			li.classList.toggle("active", li.dataset.mode === this.displayMode);
		}

		// Upload new file
		if ( this.canUpload ) form.upload.onchange = ev => this._onUpload(ev);

		// Directory-level actions
		html.find(".directory").on("click", "li", this._onPick.bind(this));

		// Flag the current pick
		let li = form.querySelector(`.file[data-path="${this.request}"]`);
		if ( li ) li.classList.add("picked");

		// Form submission
		form.onsubmit = ev => this._onSubmit(ev);

		// Intersection Observer to lazy-load images
		const files = html.find(".files-list");
		const observer = new IntersectionObserver(this._onLazyLoadImages.bind(this), {root: files[0]});
		files.find("li.file").each((i, li) => observer.observe(li));
	}

	/* -------------------------------------------- */

	/**
	 * Handle a click event to change the display mode of the File Picker
	 * @param {MouseEvent} event    The triggering click event
	 * @private
	 */
	_onChangeDisplayMode(event) {
		event.preventDefault();
		const a = event.currentTarget;
		if ( !FilePicker.DISPLAY_MODES.includes(a.dataset.mode) ) {
			throw new Error("Invalid display mode requested");
		}
		if ( a.dataset.mode === this.displayMode ) return;
		FilePicker.LAST_DISPLAY_MODE = this.displayMode = a.dataset.mode;
		this.render();
	}

	/* -------------------------------------------- */

	/** @override */
	_onChangeTab(event, tabs, active) {
		this.activeSource = active;
		this.browse(this.source.target);
	}

	/* -------------------------------------------- */

	/** @override */
	_canDragStart(selector) {
		return game.user?.isGM && (canvas.activeLayer instanceof MapLayer);
	}

	/* -------------------------------------------- */

	/** @override */
	_canDragDrop(selector) {
		return this.canUpload;
	}

	/* -------------------------------------------- */

	/** @override */
	_onDragStart(event) {
		const li = event.currentTarget;

		// Get the tile size ratio
		const tileSize = parseInt(li.closest("form").tileSize.value) || canvas.dimensions.size;
		FilePicker.LAST_TILE_SIZE = tileSize;
		const ratio = canvas.dimensions.size / tileSize;

		// Set drag data
		const dragData = {
			type: "Tile",
			img: li.dataset.path,
			tileSize: tileSize
		};
		event.dataTransfer.setData("text/plain", JSON.stringify(dragData));

		// Create the drag preview for the image
		const img = li.querySelector("img");
		const w = img.naturalWidth * ratio * canvas.stage.scale.x;
		const h = img.naturalHeight * ratio * canvas.stage.scale.y;
		const preview = DragDrop.createDragImage(img, w, h);
		event.dataTransfer.setDragImage(preview, w/2, h/2);
	}

	/* -------------------------------------------- */

	/** @override */
	async _onDrop(event) {
		if ( !this.canUpload ) return;
		const form = event.currentTarget.closest("form");
		form.disabled = true;
		const target = form.target.value;

		// Process the data transfer
		const data = event.dataTransfer;
		const files = data.files;
		if ( !files || !files.length ) return;

		// Iterate over dropped files
		for ( let upload of files ) {
			if ( !this.extensions.some(ext => upload.name.endsWith(ext)) ) {
				ui.notifications.error(`Incorrect ${this.type} file extension. Supports ${this.extensions.join(" ")}.`);
				continue;
			}
			const response = await this.constructor.upload(this.activeSource, target, upload, {
				bucket: form.bucket ? form.bucket.value : null
			});
			if ( response ) this.request = response.path;
		}

		// Re-enable the form
		form.disabled = false;
		return this.browse(target);
	}

	/* -------------------------------------------- */

	/**
	 * Handle user submission of the address bar to request an explicit target
	 * @param {KeyboardEvent} event     The originating keydown event
	 * @private
	 */
	_onRequestTarget(event) {
		if ( event.key === "Enter" ) {
			event.preventDefault();
			return this.browse(event.target.value);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle requests from the IntersectionObserver to lazily load an image file
	 * @private
	 */
	_onLazyLoadImages(...args) {
		return SidebarTab.prototype._onLazyLoadImage.call(this, ...args);
	}

	/* -------------------------------------------- */

	/**
	 * Handle file or folder selection within the file picker
	 * @param {Event} event     The originating click event
	 * @private
	 */
	_onPick(event) {
		const li = event.currentTarget;
		const form = li.closest("form");
		if ( li.classList.contains("dir") ) return this.browse(li.dataset.path);
		for ( let l of li.parentElement.children ) {
			l.classList.toggle("picked", l === li);
		}
		if ( form.file ) form.file.value = li.dataset.path;
	}

	/* -------------------------------------------- */

	/**
	 * Handle backwards navigation of the fol6der structure
	 * @private
	 */
	_onClickDirectoryControl(event) {
		event.preventDefault();
		const button = event.currentTarget;
		const action = button.dataset.action;
		switch(action) {
			case "back":
				let target = this.target.split("/");
				target.pop();
				return this.browse(target.join("/"));
			case "mkdir":
				return this._createDirectoryDialog(this.source);
			case "toggle-privacy":
				let isPrivate = !this.result.private;
				const data = {private: isPrivate, bucket: this.result.bucket};
				return this.constructor.configurePath(this.activeSource, this.target, data).then(r => {
					this.result.private = r.private;
					this.render();
				})
		}
	}

	/* -------------------------------------------- */

	/**
	 * Present the user with a dialog to create a subdirectory within their currently browsed file storate location.
	 * @private
	 */
	_createDirectoryDialog(source) {
		const form = `<form><div class="form-group">
		<label>Directory Name</label>
		<input type="text" name="dirname" placeholder="directory-name" required/>
		</div></form>`;
		return Dialog.confirm({
			title: "Create Subfolder",
			content: form,
			yes: async html => {
				const dirname = html.querySelector("input").value;
				const path = [source.target, dirname].filterJoin("/");
				await this.constructor.createDirectory(this.activeSource, path, {bucket: source.bucket});
				return this.browse(this.target);
			},
			options: {jQuery: false}
		})
	}

	/* -------------------------------------------- */

	/**
	 * Handle changes to the bucket selector
	 * @private
	 */
	_onChangeBucket(event) {
		event.preventDefault();
		const select = event.currentTarget;
		this.sources.s3.bucket = select.value;
		return this.browse("/");
	}

	/* -------------------------------------------- */

	/** @override */
	_onSearchFilter(event, query, rgx, html) {
		for ( let ol of html.querySelectorAll(".directory") ) {
			let matched = false;
			for ( let li of ol.children ) {
				const f = li.dataset.path.split("/").pop();
				let match = rgx.test(SearchFilter.cleanQuery(f));
				if ( match ) matched = true;
				li.style.display = !match ? "none" : "";
			}
			ol.style.display = matched ? "grid" : "none";
		}
		this.setPosition({height: "auto"});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onSubmit(ev) {
		ev.preventDefault();
		let path = ev.target.file.value;
		if ( !path ) return ui.notifications.error("You must select a file to proceed.");

		// Update the target field
		if ( this.field ) {
			this.field.value = path;
			this.field.dispatchEvent(new Event("change"));
		}

		// Trigger a callback and close
		if ( this.callback ) this.callback(path, this);
		return this.close();
	}

	/* -------------------------------------------- */

	/**
	 * Handle file upload
	 * @param {Event} ev      The file upload event
	 * @private
	 */
	async _onUpload(ev) {
		const form = ev.target["form"];
		const upload = form.upload.files[0];

		// Validate file extension
		if ( !this.extensions.some(ext => upload.name.endsWith(ext)) ) {
			ui.notifications.error(`Incorrect ${this.type} file extension. Supports ${this.extensions.join(" ")}.`);
			return false;
		}

		// Dispatch the request
		const target = form.target.value;
		const options = { bucket: form.bucket ? form.bucket.value : null };
		const response = await this.constructor.upload(this.activeSource, target, upload, options);

		// Handle errors
		if ( response.error ) {
			console.error(response.error);
			return ui.notifications.error(response.error);
		}

		// Flag the uploaded file as the new request
		this.request = response.path;
		return this.browse(target);
	}

	/* -------------------------------------------- */
	/*  Factory Methods
	/* -------------------------------------------- */

	/**
	 * Bind the file picker to a new target field.
	 * Assumes the user will provide a <button> HTMLElement which has the data-target and data-type attributes
	 * The data-target attribute should provide the name of the input field which should receive the selected file
	 * The data-type attribute is a string in ["image", "audio"] which sets the file extensions which will be accepted
	 *
	 * @param {HTMLElement} button     The button element
	 */
	static fromButton(button) {
		if ( !(button instanceof HTMLElement ) ) throw "You must pass an HTML button";
		let type = button.getAttribute("data-type");
		const form = button["form"];
		const field = form[button.dataset.target] || null;
		const current = field?.value || "";
		return new FilePicker({field, type, current, button});
	}
}

/**
 * A controller class for managing a text input widget that filters the contents of some other UI element
 * @see {@link Application}
 *
 * @param {object} options          Options which customize the behavior of the filter
 * @param {string} options.inputSelector    The CSS selector used to target the text input element.
 * @param {string} options.contentSelector  The CSS selector used to target the content container for these tabs.
 * @param {Function} options.callback       A callback function which executes when the filter changes.
 * @param {string} [options.initial]        The initial value of the search query.
 * @param {number} [options.delay=100]      The number of milliseconds to wait for text input before processing.
 */
class SearchFilter {
	constructor({inputSelector, contentSelector, initial="", callback, delay=100}={}) {

		/**
		 * The value of the current query string
		 * @type {string}
		 */
		this.query = initial;

		/**
		 * A callback function to trigger when the tab is changed
		 * @type {Function|null}
		 */
		this.callback = callback;

		/**
		 * The regular expression corresponding to the query that should be matched against
		 * @type {RegExp}
		 */
		this.rgx = undefined;

		/**
		 * The CSS selector used to target the tab navigation element
		 * @type {string}
		 */
		this._inputSelector = inputSelector;

		/**
		 * A reference to the HTML navigation element the tab controller is bound to
		 * @type {HTMLElement|null}
		 */
		this._input = null;

		/**
		 * The CSS selector used to target the tab content element
		 * @type {string}
		 */
		this._contentSelector = contentSelector;

		/**
		 * A reference to the HTML container element of the tab content
		 * @type {HTMLElement|null}
		 */
		this._content = null;

		/**
		 * A debounced function which applies the search filtering
		 * @type {Function}
		 */
		this._filter = foundry.utils.debounce(this.callback, delay);
	}

	/* -------------------------------------------- */

	/**
	 * Bind the SearchFilter controller to an HTML application
	 * @param {HTMLElement} html
	 */
	bind(html) {

		// Identify navigation element
		this._input = html.querySelector(this._inputSelector);
		if ( !this._input ) return;
		this._input.value = this.query;

		// Identify content container
		if ( !this._contentSelector ) this._content = null;
		else if ( html.matches(this._contentSelector) ) this._content = html;
		else this._content = html.querySelector(this._contentSelector);

		// Register the handler for input changes
		this._input.addEventListener("keyup", event => {
			event.preventDefault();
			this.filter(event, event.currentTarget.value);
		});
		this._input.addEventListener("keydown", event => {
			if ( event.key === "Enter" ) event.preventDefault();
		});

		// Apply the initial filtering conditions
		const event = new KeyboardEvent("keyup", {"key": "Enter", "code": "Enter"});
		this.filter(event, this.query);
	}

	/* -------------------------------------------- */

	/**
	 * Perform a filtering of the content by invoking the callback function
	 * @param {KeyboardEvent} event   The triggering keyboard event
	 * @param {string} query          The input search string
	 */
	filter(event, query) {
		this.query = SearchFilter.cleanQuery(query);
		this.rgx = new RegExp(RegExp.escape(this.query), "i");
		this._filter(event, this.query, this.rgx, this._content);
	}

	/* -------------------------------------------- */

	/**
	 * Clean a query term to standardize it for matching.
	 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize
	 * @param {string} query    An input string which may contain leading/trailing spaces or diacritics
	 * @returns {string}        A cleaned string of ASCII characters for comparison
	 */
	static cleanQuery(query) {
		return query.trim().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
	}
}
/**
 * An extension of the native FormData implementation.
 *
 * This class functions the same way that the default FormData does, but it is more opinionated about how
 * input fields of certain types should be evaluated and handled.
 *
 * It also adds support for certain Foundry VTT specific concepts including:
 *  Support for defined data types and type conversion
 *  Support for TinyMCE editors
 *  Support for editable HTML elements
 *
 * @extends {FormData}
 *
 * @param {HTMLFormElement} form        The form being processed
 * @param {object[]} [editors]          An array of TinyMCE editor instances which are present in this form
 * @param {{string, string}} [dtypes]   A mapping of data types for form fields
 */
class FormDataExtended extends FormData {
	constructor(form, {editors=[], dtypes={}}={}) {
		super();

		/**
		 * A mapping of data types requested for each form field
		 * @type {{string, string}}
		 */
		this.dtypes = dtypes;

		/**
		 * A record of TinyMCE editors which are linked to this form
		 * @type {object[]}
		 */
		this.editors = editors;

		// Process the provided form
		this.process(form);
	}

	/* -------------------------------------------- */

	/**
	 * Process the HTML form element to populate the FormData instance.
	 * @param {HTMLFormElement} form      The HTML form
	 */
	process(form) {

		// Process standard form elements
		for ( let el of form.elements ) {
			if ( !el.name || el.disabled || (el.tagName === "BUTTON") ) continue;
			if ( this.has(el.name) ) continue;
			const field = form.elements[el.name];
			this.dtypes[el.name] = el.dataset.dtype ?? "String";

			// Radio Checkboxes
			if ( el.type === "radio" ) {
				const chosen = Array.from(field).find(r => r.checked);
				this.set(el.name, chosen ? chosen.value : null);
				continue;
			}

			// Multi-Select
			if ( el.type === "select-multiple" ) {
				const chosen = [];
				for ( let opt of el.options ) {
					if ( opt.selected ) chosen.push(opt.value);
				}
				this.dtypes[el.name] = "JSON";
				this.set(el.name, JSON.stringify(chosen));
				continue;
			}

			// Duplicate Fields
			if ( field instanceof RadioNodeList ) {
				const values = [];
				for ( let f of field ) {
					if ( f.disabled ) values.push(null);
					else if ( f.type === "checkbox" ) values.push(f.checked);
					else values.push(f.value)
				}
				this.set(el.name, JSON.stringify(values));
				this.dtypes[el.name] = "JSON";
				continue;
			}

			// Boolean Checkboxes
			if ( el.type === "checkbox" ) {
				this.set(el.name, el.checked || "");
				this.dtypes[el.name] = "Boolean";
				continue;
			}

			// Other Inputs
			if ( ["number", "range"].includes(el.type) ) {
				this.dtypes[el.name] = "Number";
			}
			this.set(el.name, el.value.trim());
		}

		// Process MCE editors
		for ( let [name, editor] of Object.entries(this.editors) ) {
			if ( editor.mce ) {
				this.set(name, editor.mce.getContent());
				this.delete(editor.mce.id); // Delete hidden MCE inputs
			}
		}

		// Process editable HTML fields
		const editableFields = form.querySelectorAll('[data-edit]');
		for ( let el of editableFields ) {
			const name = el.dataset.edit;
			if ( this.has(name) || el.getAttribute("disabled") || (name in this.editors) ) continue;
			if (el.tagName === "IMG") this.set(name, el.getAttribute("src"));
			else this.set(name, el.innerHTML.trim());
			this.dtypes[name] = el.dataset.dtype ?? "String";
		}
	}

	/* -------------------------------------------- */

	/**
	 * Export the FormData as an object
	 * @return {object}
	 */
	toObject() {
		const data = {};
		for ( let [k, v] of this.entries() ) {
			const dtype = this.dtypes[k];
			if ( dtype === "Boolean" ) v = v === "true";
			else if ( dtype === "JSON" ) v = JSON.parse(v);
			else if ( (dtype === "String") && !v ) v = "";
			else {
				if ( v === "" ) v = null;
				if ( (v !== null) && ( window[dtype] instanceof Function ) ) {
					try {
						v = window[dtype](v);
					} catch(err) {
						console.warn(`The form field ${k} was not able to be cast to the requested data type ${dtype}`);
					}
				}
			}
			data[k] = v;
		}
		return data;
	}
}

/**
 * A common framework for displaying notifications to the client.
 * Submitted notifications are added to a queue, and up to 3 notifications are displayed at once.
 * Each notification is displayed for 5 seconds at which point further notifications are pulled from the queue.
 *
 * @extends {Application}
 *
 * @example
 * ui.notifications.info("This is an info message");
 * ui.notifications.warn("This is a warning message");
 * ui.notifications.error("This is an error message");
 * ui.notifications.info("This is a 4th message which will not be shown until the first info message is done");
 */
class Notifications extends Application {
	constructor(options) {
		super(options);

		/**
		 * Submitted notifications which are queued for display
		 * @type {object[]}
		 */
		this.queue = [];

		/**
		 * Notifications which are currently displayed
		 * @type {object[]}
		 */
		this.active = [];

		// Initialize any pending messages
		this.initialize();
	}

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			popOut: false,
			id: "notifications",
			template: "templates/hud/notifications.html"
		});
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the Notifications system by displaying any system-generated messages which were passed from the server.
	 */
	initialize() {
		if ( !MESSAGES ) return;
		for ( let m of MESSAGES ) {
			this.notify(game.i18n.localize(m.message), m.type, m.options);
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_renderInner(...args) {
		return $('<ol id="notifications"></ol>');
	}

	/* -------------------------------------------- */

	/** @override */
	async _render(...args) {
		await super._render(...args);
		while ( this.queue.length ) this.fetch();
	}

	/* -------------------------------------------- */

	/**
	 * Push a new notification into the queue
	 * @param {string} message      The content of the notification message
	 * @param {string} type         The type of notification, currently "info", "warning", and "error" are supported
	 * @param {object} [options={}] Additional options which affect the notification
	 * @param {boolean} [options.permanent=false]   Whether the notification should be permanently displayed unless otherwise dismissed
	 * @param {boolean} [options.localize=false]    Whether to localize the message content before displaying it
	 */
	notify(message, type="info", {localize=false, permanent=false}={}) {
		if ( localize ) message = game.i18n.localize(message);

		// Construct notification data
		let n = {
			message: message,
			type: ["info", "warning", "error"].includes(type) ? type : "info",
			timestamp: new Date().getTime(),
			permanent: permanent
		};
		this.queue.push(n);

		// Call the fetch method
		if ( this.rendered ) this.fetch();
	}

	/* -------------------------------------------- */

	/**
	 * Display a notification with the "info" type
	 * @param {string} message    The content of the notification message
	 * @param {Object} options    Notification options passed to the notify function
	 * @returns {void}
	 */
	info(message, options) {
		this.notify(message, "info", options);
	}

	/* -------------------------------------------- */

	/**
	 * Display a notification with the "warning" type
	 * @param {string} message    The content of the notification message
	 * @param {Object} options    Notification options passed to the notify function
	 * @returns {void}
	 */
	warn(message, options) {
		this.notify(message, "warning", options);
	}

	/* -------------------------------------------- */

	/**
	 * Display a notification with the "error" type
	 * @param {string} message    The content of the notification message
	 * @param {Object} options    Notification options passed to the notify function
	 * @returns {void}
	 */
	error(message, options) {
		this.notify(message, "error", options);
	}

	/* -------------------------------------------- */

	/**
	 * Retrieve a pending notification from the queue and display it
	 * @private
	 * @returns {void}
	 */
	fetch() {
		if ( this.queue.length === 0 || this.active.length >= 3 ) return;
		const next = this.queue.pop();
		const now = Date.now();
		let cleared = false;

		// Define the function to remove the notification
		const _remove = li => {
			if ( cleared ) return;
			li.fadeOut(66, () => li.remove());
			this.active.pop();
			return this.fetch();
		};

		// Construct a new notification
		const cls = ["notification", next.type, next.permanent ? "permanent": null].filterJoin(" ");
		const li = $(`<li class="${cls}">${next.message}<i class="close fas fa-times-circle"></i></li>`);
``
		// Add click listener to dismiss
		li.click(ev => { if ( Date.now() - now > 250 ) _remove(li) });
		this.element.prepend(li);
		li.hide().slideDown(132);
		this.active.push(li);

		// Schedule clearing the notification 5 seconds later
		if ( !next.permanent ) window.setTimeout(() => _remove(li), 5000);
	}
}

/**
 * @typedef {Object} TabsConfiguration
 * @param {string} navSelector        The CSS selector used to target the navigation element for these tabs
 * @param {string} contentSelector    The CSS selector used to target the content container for these tabs
 * @param {string} initial            The tab name of the initially active tab
 * @param {Function|null} [callback]  An optional callback function that executes when the active tab is changed
 */

/**
 * A controller class for managing tabbed navigation within an Application instance.
 * @see {@link Application}
 * @param {TabsConfiguration} config    The Tabs Configuration to use for this tabbed container
 *
 * @example
 * <!-- Example HTML -->
 * <nav class="tabs" data-group="primary-tabs">
 *   <a class="item" data-tab="tab1">Tab 1</li>
 *   <a class="item" data-tab="tab2">Tab 2</li>
 * </nav>
 *
 * <section class="content">
 *   <div class="tab" data-tab="tab1" data-group="primary-tabs">Content 1</div>
 *   <div class="tab" data-tab="tab2" data-group="primary-tabs">Content 2</div>
 * </section>
 *
 * @example
 * // JavaScript
 * const tabs = new Tabs({navSelector: ".tabs", contentSelector: ".content", initial: "tab1"});
 * tabs.bind(html);
 */
class Tabs {
	constructor({navSelector, contentSelector, initial, callback}={}) {

		/**
		 * The value of the active tab
		 * @type {string}
		 */
		this.active = initial;

		/**
		 * A callback function to trigger when the tab is changed
		 * @type {Function|null}
		 */
		this.callback = callback;

		/**
		 * The CSS selector used to target the tab navigation element
		 * @type {string}
		 */
		this._navSelector = navSelector;

		/**
		 * A reference to the HTML navigation element the tab controller is bound to
		 * @type {HTMLElement|null}
		 */
		this._nav = null;

		/**
		 * The CSS selector used to target the tab content element
		 * @type {string}
		 */
		this._contentSelector = contentSelector;

		/**
		 * A reference to the HTML container element of the tab content
		 * @type {HTMLElement|null}
		 */
		this._content = null;
	}

	/* -------------------------------------------- */

	/**
	 * Bind the Tabs controller to an HTML application
	 * @param {HTMLElement} html
	 */
	bind(html) {

		// Identify navigation element
		this._nav = html.querySelector(this._navSelector);
		if ( !this._nav ) return;

		// Identify content container
		if ( !this._contentSelector ) this._content = null;
		else if ( html.matches(this._contentSelector )) this._content = html;
		else this._content = html.querySelector(this._contentSelector);

		// Initialize the active tab
		this.activate(this.active);

		// Register listeners
		this._nav.addEventListener("click", this._onClickNav.bind(this))
	}

	/* -------------------------------------------- */

	/**
	 * Activate a new tab by name
	 * @param {string} tabName
	 * @param {boolean} triggerCallback
	 */
	activate(tabName, {triggerCallback=false}={}) {

		// Validate the requested tab name
		const group = this._nav.dataset.group;
		const items = this._nav.querySelectorAll("[data-tab]");
		if ( !items.length ) return;
		const valid = Array.from(items).some(i => i.dataset.tab === tabName);
		if ( !valid ) tabName = items[0].dataset.tab;

		// Change active tab
		for ( let i of items ) {
			i.classList.toggle("active", i.dataset.tab === tabName);
		}

		// Change active content
		if ( this._content ) {
			const tabs = this._content.querySelectorAll("[data-tab]");
			for ( let t of tabs ) {
				if ( t.dataset.group && (t.dataset.group !== group) ) continue;
				t.classList.toggle("active", t.dataset.tab === tabName);
			}
		}

		// Store the active tab
		this.active = tabName;

		// Optionally trigger the callback function
		if ( triggerCallback ) this.callback(null, this, tabName);
	}

	/* -------------------------------------------- */

	/**
	 * Handle click events on the tab navigation entries
	 * @param {MouseEvent} event    A left click event
	 * @private
	 */
	_onClickNav(event) {
		const tab = event.target.closest("[data-tab]");
		if ( !tab ) return;
		event.preventDefault();
		const tabName = tab.dataset.tab;
		if ( tabName !== this.active) this.activate(tabName, {triggerCallback: true});
	}
}

const TabsV2 = Tabs;
/**
 * Render the Sidebar container, and after rendering insert Sidebar tabs.
 * @extends {Application}
 */
class Sidebar extends Application {

	/**
	 * Singleton application instances for each sidebar tab
	 * @type {Object<SidebarTab>}
	 */
	tabs = {};

	/**
	 * Track whether the sidebar container is currently collapsed
	 * @type {boolean}
	 */
	_collapsed = false;

	/* -------------------------------------------- */

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "sidebar",
			template: "templates/sidebar/sidebar.html",
			popOut: false,
			width: 300,
			tabs: [{navSelector: ".tabs", contentSelector: "#sidebar", initial: "chat"}]
		});
	}

	/* -------------------------------------------- */

	/**
	 * Return the name of the active Sidebar tab
	 * @type {string}
	 */
	get activeTab() {
		return this._tabs[0].active;
	}

	/* -------------------------------------------- */

	/**
	 * Singleton application instances for each popout tab
	 * @type {Object<SidebarTab>}
	 */
	get popouts() {
		const popouts = {};
		for ( let [name, app] of Object.entries(this.tabs) ) {
			if ( app._popout ) popouts[name] = app._popout;
		}
		return popouts;
	}

	/* -------------------------------------------- */
	/*  Rendering
	/* -------------------------------------------- */

	/** @override */
	getData(options) {
		return {
			coreUpdate: game.user.isGM && game.data.coreUpdate ? game.i18n.format("SETUP.UpdateAvailable", {
				type: game.i18n.localize("Software"),
				channel: game.data.coreUpdate.channel,
				version: game.data.coreUpdate.version
			}) : false,
			systemUpdate: game.user.isGM && game.data.systemUpdate ? game.i18n.format("SETUP.UpdateAvailable", {
				type: game.i18n.localize("System"),
				channel: game.data.system.data.title,
				version: game.data.systemUpdate.version
			}) : false,
			user: game.user
		};
	}

 	/* -------------------------------------------- */

	/** @inheritdoc */
	async _render(force, options) {

		// Render the Sidebar container only once
		if ( !this.rendered ) await super._render(force, options);

		// Define the sidebar tab names to render
		const tabs = ["chat", "combat", "actors", "items", "journal", "tables", "playlists", "compendium", "settings"];
		if ( game.user.isGM ) tabs.push("scenes");

		// Render sidebar Applications
		for ( let [name, app] of Object.entries(this.tabs) ) {
			app._render(true).catch(err => {
				err.message = `Failed to render Sidebar tab ${name}: ${err.message}`;
				console.error(err);
			});
		}
	}

	/* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */

	/**
	 * Activate a Sidebar tab by it's name
	 * @param {string} tabName      The tab name corresponding to it's "data-tab" attribute
	 */
	activateTab(tabName) {
		this._tabs[0].activate(tabName, {triggerCallback: true});
	}

	/* -------------------------------------------- */

	/**
	 * Expand the Sidebar container from a collapsed state.
	 * Take no action if the sidebar is already expanded.
	 */
	expand() {
		if ( !this._collapsed ) return;
		const sidebar = this.element;
		const tab = sidebar.find(".sidebar-tab.active");
		const icon = sidebar.find("#sidebar-tabs a.collapse i");

		// Animate the sidebar expansion
		tab.hide();
		sidebar.animate({width: this.options.width, height: this.position.height}, 150, () => {
			sidebar.css({width: "", height: ""});
			icon.removeClass("fa-caret-left").addClass("fa-caret-right");
			tab.fadeIn(250, () => tab.css("display", ""));
			this._collapsed = false;
			sidebar.removeClass("collapsed");
			Hooks.callAll("collapseSidebar", this, this._collapsed);
		})
	}

	/* -------------------------------------------- */

	/**
	 * Collapse the sidebar to a minimized state.
	 * Take no action if the sidebar is already collapsed.
	 */
	collapse() {
		if ( this._collapsed ) return;
		const sidebar = this.element;
		const tab = sidebar.find(".sidebar-tab.active");
		const icon = sidebar.find("#sidebar-tabs a.collapse i");

		// Animate the sidebar collapse
		tab.fadeOut(250, () => {
			sidebar.animate({width: 30, height: 370}, 150, () => {
				icon.removeClass("fa-caret-right").addClass("fa-caret-left");
				this._collapsed = true;
				sidebar.addClass("collapsed");
				tab.css("display", "");
				Hooks.callAll("collapseSidebar", this, this._collapsed);
			})
		})
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		super.activateListeners(html);

		// Right click pop-out
		const nav = this._tabs[0]._nav;
		nav.addEventListener('contextmenu', this._onRightClickTab.bind(this));

		// Toggle Collapse
		const collapse = nav.querySelector(".collapse");
		collapse.addEventListener("click", this._onToggleCollapse.bind(this));
	}

	/* -------------------------------------------- */

	/** @override */
	_onChangeTab(event, tabs, active) {
		const app = ui[active];
		if ( (active === "chat") && app ) app.scrollBottom();
		if ( this._collapsed ) app.renderPopout(app);

		/**
		 * A hook event that fires when the Sidebar tab is changed.
		 * @function changeSidebarTab
		 * @memberof hookEvents
		 * @param {SidebarTab} app    The SidebarTab application which is now active
		 */
		Hooks.callAll("changeSidebarTab", app);
	}

	/* -------------------------------------------- */

	/**
	 * Handle right-click events on tab controls to trigger pop-out containers for each tab
	 * @param {Event} event     The originating contextmenu event
	 * @private
	 */
	_onRightClickTab(event) {
		const li = event.target.closest(".item");
		if ( !li ) return;
		event.preventDefault();
		const tabApp = ui[li.dataset.tab];
		tabApp.renderPopout(tabApp);
	}

	/* -------------------------------------------- */

	/**
	 * Handle toggling of the Sidebar container's collapsed or expanded state
	 * @param {Event} event
	 * @private
	 */
	_onToggleCollapse(event) {
		event.preventDefault();
		if ( this._collapsed ) this.expand();
		else this.collapse();
	}
}

/**
 * An abstract pattern followed by the different tabs of the sidebar
 * @type {Application}
 * @abstract
 * @interface
 */
class SidebarTab extends Application {
	constructor(...args) {
		super(...args);

		/**
		 * The base name of this sidebar tab
		 * @type {string}
		 */
		this.tabName = this.constructor.defaultOptions.id;

		/**
		 * A reference to the pop-out variant of this SidebarTab, if one exists
		 * @type {SidebarTab}
		 * @protected
		 */
		this._popout = null;

		/**
		 * Denote whether or not this is the original version of the sidebar tab, or a pop-out variant
		 * @type {SidebarTab}
		 */
		this._original = null;

		// Register the tab as the sidebar singleton
		if ( !this.popOut && ui.sidebar ) ui.sidebar.tabs[this.tabName] = this;
	}

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			popOut: false,
			width: 300,
			height: "auto",
			baseApplication: "SidebarTab"
		});
	}

	/* -------------------------------------------- */
		/*  Rendering                                   */
	/* -------------------------------------------- */

		/** @override */
		async _renderInner(data) {
			let html = await super._renderInner(data);
			if ( ui.sidebar?.activeTab === this.options.id ) html.addClass('active');
			if ( this.popOut ) html.removeClass("tab");
			return html;
		}

	/* -------------------------------------------- */

		/** @override */
		async _render(force=false, options={}) {
				await super._render(force, options);
				if ( this._popout ) await this._popout._render(force, options);
		}

		/* -------------------------------------------- */

		/** @override */
		async render(force=false, options={}) {
				await super.render(force, options);
				if ( this._popout ) await this._popout.render(force, options);
		}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Activate this SidebarTab, switching focus to it
	 */
	activate() {
		ui.sidebar.activateTab(this.tabName);
	}

	/* -------------------------------------------- */

	/** @override */
	async close(options) {
		if ( this.popOut ) {
			const base = this._original;
			base._popout = null;
			return super.close(options);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Create a second instance of this SidebarTab class which represents a singleton popped-out container
	 * @return {SidebarTab}   The popped out sidebar tab instance
	 */
	createPopout() {
		if ( this._popout ) return this._popout;
		const pop = new this.constructor({
			id: `${this.options.id}-popout`,
			classes: this.options.classes.concat([["sidebar-popout"]]),
			popOut: true
		});
		this._popout = pop;
		pop._original = this;
		return pop;
	}

	/* -------------------------------------------- */

	/**
	 * Render the SidebarTab as a pop-out container
	 */
	renderPopout() {
		const pop = this.createPopout();
		pop.render(true);
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/**
	 * Handle lazy loading for sidebar images to only load them once they become observed
	 * @param {HTMLElement[]} entries               The entries which are now observed
	 * @param {IntersectionObserver} observer       The intersection observer instance
	 */
	_onLazyLoadImage(entries, observer) {
		for ( let e of entries ) {
			if ( !e.isIntersecting ) continue;
			const li = e.target;

			// Background Image
			if ( li.dataset.backgroundImage ) {
				li.style["background-image"] = `url("${li.dataset.backgroundImage}")`;
				delete li.dataset.backgroundImage;
			}

			// Avatar image
			const img = li.querySelector("img");
			if ( img && img.dataset.src ) {
				img.src = img.dataset.src;
				delete img.dataset.src;
			}

			// No longer observe the target
			observer.unobserve(e.target);
		}
	}
}

/**
 * A shared pattern for the sidebar directory which Actors, Items, and Scenes all use
 * @extends {SidebarTab}
 * @abstract
 * @interface
 */
class SidebarDirectory extends SidebarTab {
	constructor(options) {
		super(options);

		/**
		 * References to the set of Documents which are displayed in the Sidebar
		 * @type {Document[]}
		 */
		this.documents = null;

		/**
		 * Reference the set of Folders which exist in this Sidebar
		 * @type {Folder[]}
		 */
		this.folders = null;

		// Initialize sidebar content
		this.initialize();

		// Record the directory as an application of the collection if it is not a popout
		if ( !this.options.popOut ) this.constructor.collection.apps.push(this);
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the named Document type that this Sidebar Directory instance displays
	 * @type {string}
	 */
	static documentName = "Document";

	/* -------------------------------------------- */

	/** @inheritdoc */
	static get defaultOptions() {
		const cls = getDocumentClass(this.documentName);
		const collection = cls.metadata.collection;
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: collection,
			template: `templates/sidebar/${collection}-directory.html`,
			title: `${game.i18n.localize(cls.metadata.label)} Directory`,
			renderUpdateKeys: ["name", "img", "thumb", "permission", "sort", "sorting", "folder"],
			height: "auto",
			scrollY: ["ol.directory-list"],
			dragDrop: [{ dragSelector: ".directory-item",  dropSelector: ".directory-list"}],
			filters: [{inputSelector: 'input[name="search"]', contentSelector: ".directory-list"}]
		});
	}

	/* -------------------------------------------- */

	/**
	 * The WorldCollection instance which this Sidebar Directory displays.
	 * @type {WorldCollection}
	 */
	static get collection() {
		return game.collections.get(this.documentName);
	}

	/* -------------------------------------------- */
	/*  Initialization Helpers
	/* -------------------------------------------- */

	/**
	 * Initialize the content of the directory by categorizing folders and entities into a hierarchical tree structure.
	 */
	initialize() {

		// Assign Folders
		this.folders = game.folders.filter(f => f.type === this.constructor.documentName);

		// Assign Entities
		this.documents = this.constructor.collection.filter(e => e.visible);

		// Build Tree
		this.tree = this.constructor.setupFolders(this.folders, this.documents);
	}

	/* -------------------------------------------- */

	/**
	 * Given a Document type and a list of Document instances, set up the Folder tree
	 * @param {Folder[]} folders        The Array of Folder objects to organize
	 * @param {Document[]} documents    The Array of Document objects to organize
	 * @return {Object}                 A tree structure containing the folders and documents
	 */
	static setupFolders(folders, documents) {
		documents = documents.filter(d => d.visible);
		const depths = [];
		const handled = new Set();

		// Iterate parent levels
		const root = {id: null};
		let batch = [root];
		for ( let i = 0; i < CONST.FOLDER_MAX_DEPTH; i++ ) {
			depths[i] = [];
			for ( let folder of batch ) {
				if ( handled.has(folder.id) ) continue;

				// Classify content for this folder
				try {
					[folders, documents] = this._populate(folder, folders, documents);
				} catch(err) {
					console.error(err);
					continue;
				}

				// Add child folders to the correct depth level
				depths[i] = depths[i].concat(folder.children);
				folder.depth = i;
				handled.add(folder.id);
			}
			batch = depths[i];
		}

		// Populate content to any remaining folders and assign them to the root level
		const remaining = depths[CONST.FOLDER_MAX_DEPTH-1].concat(folders);
		for ( let f of remaining ) {
			[folders, documents] = this._populate(f, folders, documents, {allowChildren: false});
		}
		depths[0] = depths[0].concat(folders);

		// Filter folder visibility
		for ( let i = CONST.FOLDER_MAX_DEPTH - 1; i >= 0; i-- ) {
			depths[i] = depths[i].reduce((arr, f) => {
				f.children = f.children.filter(c => c.displayed);
				if ( !f.displayed ) return arr;
				f.depth = i+1;
				arr.push(f);
				return arr;
			}, []);
		}

		// Return the root level contents of folders and documents
		return {
			root: true,
			content: root.content.concat(documents),
			children: depths[0]
		};
	}

	/* -------------------------------------------- */

	/**
	 * Populate a single folder with child folders and content
	 * This method is called recursively when building the folder tree
	 * @private
	 */
	static _populate(folder, folders, documents, {allowChildren=true}={}) {
		const id = folder.id;

		// Define sorting function for this folder
		const alpha = folder.data?.sorting === "a";
		const s = alpha ? (a, b) => a.name.localeCompare(b.name) : (a, b) => a.data.sort - b.data.sort;

		// Partition folders into children and unassigned folders
		let [u, children] = folders.partition(f => allowChildren && (f.data.parent === id));
		folder.children = children.sort(s);
		folders = u;

		// Partition documents into contents and unassigned documents
		const [docs, content] = documents.partition(e => e.data.folder === id);
		folder.content = content.sort(s);
		documents = docs;

		// Return the remainder
		return [folders, documents];
	}

	/* -------------------------------------------- */
	/*  Application Rendering
	/* -------------------------------------------- */

	/** @inheritdoc */
	render(force, context={}) {

		// Only re-render the sidebar directory for certain types of updates
		const {action, data, entityType} = context;
		if ( action && !["create", "update", "delete"].includes(action) ) return;
		if ( (entityType !== "Folder") && (action === "update") && !data.some(d => {
			return this.options.renderUpdateKeys.some(k => k in d);
		}) ) return;

		// Re-build the tree and render
		this.initialize();
		super.render(force, context);
		return this;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const cfg = CONFIG[this.constructor.documentName];
		return {
			user: game.user,
			tree: this.tree,
			canCreate: cfg.documentClass.canUserCreate(game.user),
			sidebarIcon: cfg.sidebarIcon
		};
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onSearchFilter(event, query, rgx, html) {
		const isSearch = !!query;
		let entityIds = new Set();
		let folderIds = new Set();

		// Match documents and folders
		if ( isSearch ) {

			// Match document names
			for ( let d of this.documents ) {
				if ( rgx.test(SearchFilter.cleanQuery(d.name)) ) {
					entityIds.add(d.id);
					if ( d.data.folder ) folderIds.add(d.data.folder);
				}
			}

			// Match folder tree
			const includeFolders = fids => {
				const folders = this.folders.filter(f => fids.has(f.id));
				const pids = new Set(folders.filter(f => f.data.parent).map(f => f.data.parent));
				if ( pids.size ) {
					pids.forEach(p => folderIds.add(p));
					includeFolders(pids);
				}
			};
			includeFolders(folderIds);
		}

		// Toggle each directory item
		for ( let el of html.querySelectorAll(".directory-item") ) {

			// Entities
			if (el.classList.contains("entity")) {
				el.style.display = (!isSearch || entityIds.has(el.dataset.entityId)) ? "flex" : "none";
			}

			// Folders
			if (el.classList.contains("folder")) {
				let match = isSearch && folderIds.has(el.dataset.folderId);
				el.style.display = (!isSearch || match) ? "flex" : "none";
				if (isSearch && match) el.classList.remove("collapsed");
				else el.classList.toggle("collapsed", !game.folders._expanded[el.dataset.folderId]);
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Collapse all subfolders in this directory
	 */
	collapseAll() {
		this.element.find('li.folder').addClass("collapsed");
		for ( let f of this.folders ) {
			game.folders._expanded[f.id] = false;
		}
		if ( this.popOut ) this.setPosition();
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Activate event listeners triggered within the Actor Directory HTML
	 */
	activateListeners(html) {
		super.activateListeners(html);
		const directory = html.find(".directory-list");
		const entries = directory.find(".directory-item");

		// Directory-level events
		html.find('.create-entity').click(ev => this._onCreateDocument(ev));
		html.find('.collapse-all').click(this.collapseAll.bind(this));
		html.find(".folder .folder .folder .create-folder").remove(); // Prevent excessive folder nesting
		if ( game.user.isGM ) html.find('.create-folder').click(ev => this._onCreateFolder(ev));

		// Entry-level events
		directory.on("click", ".entity-name", this._onClickEntityName.bind(this));
		directory.on("click", ".folder-header", this._toggleFolder.bind(this));
		const dh = this._onDragHighlight.bind(this);
		html.find(".folder").on("dragenter", dh).on("dragleave", dh);
		this._contextMenu(html);

		// Intersection Observer
		const observer = new IntersectionObserver(this._onLazyLoadImage.bind(this), { root: directory[0] });
		entries.each((i, li) => observer.observe(li));
	}

	/* -------------------------------------------- */

	/**
	 * Handle clicking on an Entity name in the Sidebar directory
	 * @param {Event} event   The originating click event
	 * @protected
	 */
	_onClickEntityName(event) {
		event.preventDefault();
		const element = event.currentTarget;
		const entityId = element.parentElement.dataset.entityId;
		const entity = this.constructor.collection.get(entityId);
		const sheet = entity.sheet;

		// If the sheet is already rendered:
		if ( sheet.rendered ) {
			sheet.bringToTop();
			return sheet.maximize();
		}

		// Otherwise render the sheet
		else sheet.render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle new Document creation request
	 * @param {MouseEvent} event    The originating button click event
	 * @protected
	 */
	async _onCreateDocument(event) {
		event.preventDefault();
		event.stopPropagation();
		const button = event.currentTarget;
		const data = {folder: button.dataset.folder};
		const options = {width: 320, left: window.innerWidth - 630, top: button.offsetTop };
		const cls = getDocumentClass(this.constructor.documentName);
		return cls.createDialog(data, options);
	}

	/* -------------------------------------------- */

	/**
	 * Create a new Folder in this SidebarDirectory
	 * @param {MouseEvent} event    The originating button click event
	 * @protected
	 */
	_onCreateFolder(event) {
		event.preventDefault();
		event.stopPropagation();
		const button = event.currentTarget;
		const parent = button.dataset.parentFolder;
		const data = {parent: parent ? parent : null, type: this.constructor.documentName};
		const options = {top: button.offsetTop, left: window.innerWidth - 310 - FolderConfig.defaultOptions.width};
		Folder.createDialog(data, options);
	}

	/* -------------------------------------------- */

	/**
	 * Handle toggling the collapsed or expanded state of a folder within the directory tab
	 * @param {MouseEvent} event    The originating click event
	 * @protected
	 */
	_toggleFolder(event) {
		let folder = $(event.currentTarget.parentElement);
		let collapsed = folder.hasClass("collapsed");
		game.folders._expanded[folder.attr("data-folder-id")] = collapsed;

		// Expand
		if ( collapsed ) folder.removeClass("collapsed");

		// Collapse
		else {
			folder.addClass("collapsed");
			const subs = folder.find('.folder').addClass("collapsed");
			subs.each((i, f) => game.folders._expanded[f.dataset.folderId] = false);
		}

		// Resize container
		if ( this.popOut ) this.setPosition();
	}

	/* -------------------------------------------- */

	/** @override */
	_onDragStart(event) {
		let li = event.currentTarget.closest(".directory-item");
		const isFolder = li.classList.contains("folder");
		const dragData = isFolder ?
			{ type: "Folder", id: li.dataset.folderId, documentName: this.constructor.documentName } :
			{ type: this.constructor.documentName, id: li.dataset.entityId };
		event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
		this._dragType = dragData.type;
	}

	/* -------------------------------------------- */

	/** @override */
	_canDragStart(selector) {
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Highlight folders as drop targets when a drag event enters or exits their area
	 * @param {DragEvent} event     The DragEvent which is in progress
	 */
	_onDragHighlight(event) {
		const li = event.currentTarget;
		if ( !li.classList.contains("folder") ) return;
		event.stopPropagation();  // Don't bubble to parent folders

		// Remove existing drop targets
		if ( event.type === "dragenter" ) {
			for ( let t of li.closest(".directory-list").querySelectorAll(".droptarget") ) {
				t.classList.remove("droptarget");
			}
		}

		// Remove current drop target
		if ( event.type === "dragleave" ) {
			const el = document.elementFromPoint(event.clientX, event.clientY);
			const parent = el.closest(".folder");
			if ( parent === li ) return;
		}

		// Add new drop target
		li.classList.toggle("droptarget", event.type === "dragenter");
	}

	/* -------------------------------------------- */

	/** @override */
	_onDrop(event) {
		const cls = this.constructor.documentName;

		// Try to extract the data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData('text/plain'));
		}
		catch (err) {
			return false;
		}

		// Identify the drop target
		const selector = this._dragDrop[0].dropSelector;
		const target = event.target.closest(".directory-item") || null;

		// Call the drop handler
		switch ( data.type ) {
			case "Folder":
				return this._handleDroppedFolder(target, data);
			case cls:
				return this._handleDroppedDocument(target, data);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle Document data being dropped into the directory.
	 * @param {HTMLElement} target    The target element
	 * @param {Object} data           The data being dropped
	 * @protected
	 */
	async _handleDroppedDocument(target, data) {

		// Determine the closest folder ID
		const closestFolder = target ? target.closest(".folder") : null;
		if ( closestFolder ) closestFolder.classList.remove("droptarget");
		const closestFolderId = closestFolder ? closestFolder.dataset.folderId : null;

		// Obtain the dropped document
		const cls = getDocumentClass(this.constructor.documentName);
		const collection = this.constructor.collection;
		const isSort = collection.has(data.id);
		const document = await cls.fromDropData(data, {importWorld: true});
		if ( !document ) return;

		// Sort relative to another Document
		const sortData = {sortKey: "sort", sortBefore: true};
		const isRelative = target && target.dataset.entityId;
		if ( isRelative ) {
			if ( document.id === target.dataset.entityId ) return; // Don't drop on yourself
			const targetDocument = collection.get(target.dataset.entityId);
			sortData.target = targetDocument;
			sortData.folderId = targetDocument.data.folder;
		}

		// Sort relative to the closest Folder
		else {
			sortData.target = null;
			sortData.folderId = closestFolderId;
		}

		// Determine siblings and perform sort
		sortData.siblings = collection.filter(doc => {
			return (doc.data.folder === sortData.folderId) && (doc.id !== data.id);
		});
		sortData.updateData = { folder: sortData.folderId };
		return document.sortRelative(sortData);
	}

	/* -------------------------------------------- */

	/**
	 * Handle Folder data being dropped into the directory.
	 * @param {HTMLElement} target    The target element
	 * @param {Object} data           The data being dropped
	 * @protected
	 */
	async _handleDroppedFolder(target, data) {
		if ( data.documentName !== this.constructor.documentName ) return;
		const folder = await Folder.implementation.fromDropData(data);

		// Determine the closest folder ID
		const closestFolder = target ? target.closest(".folder") : null;
		if ( closestFolder ) closestFolder.classList.remove("droptarget");
		const closestFolderId = closestFolder ? closestFolder.dataset.folderId : null;

		// Sort into another Folder
		const sortData = {sortKey: "sort", sortBefore: true};
		const isFolder = target && target.dataset.folderId;
		if ( isFolder ) {
			const targetFolder = game.folders.get(target.dataset.folderId);
			if ( folder.id === targetFolder.id ) return; // Don't drop on yourself

			// Sort relative to a collapsed Folder
			if ( target.classList.contains("collapsed") ) {
				sortData.target = targetFolder;
				sortData.parentId = targetFolder.data.parent;
			}

			// Drop into an expanded Folder
			else {
				if (Number(target.dataset.folderDepth) >= CONST.FOLDER_MAX_DEPTH) return; // Prevent going beyond max depth
				sortData.target = null;
				sortData.parentId = targetFolder.id;
			}
		}

		// Sort relative to existing Folder contents
		else {
			sortData.parentId = closestFolderId;
			sortData.target = closestFolder && closestFolder.classList.contains("collapsed") ? closestFolder : null;
		}

		// Determine siblings and perform sort
		sortData.siblings = game.folders.filter(f => {
			return (f.data.parent === sortData.parentId) && (f.data.type === folder.data.type) && (f !== folder);
		});
		sortData.updateData = { parent: sortData.parentId };
		return folder.sortRelative(sortData);
	}

	/* -------------------------------------------- */

	/**
	 * Default folder context actions
	 * @param {jQuery} html     The context menu HTML being rendered for the directory
	 * @protected
	 */
	_contextMenu(html) {

		// Folder Context
		const folderOptions = this._getFolderContextOptions();

		// Entity Context
		const entryOptions = this._getEntryContextOptions();

		// Dispatch Hooks down the chain
		for ( let cls of this.constructor._getInheritanceChain() ) {
			Hooks.call(`get${cls.name}FolderContext`, html, folderOptions);
			Hooks.call(`get${cls.name}EntryContext`, html, entryOptions);
		}

		// Create ContextMenus
		if (folderOptions) new ContextMenu(html, ".folder .folder-header", folderOptions);
		if (entryOptions) new ContextMenu(html, ".entity", entryOptions);
	}

	/* -------------------------------------------- */

	/**
	 * Get the set of ContextMenu options which should be used for Folders in a SidebarDirectory
	 * @return {object[]}   The Array of context options passed to the ContextMenu instance
	 * @protected
	 */
	_getFolderContextOptions() {
		return [
			{
				name: "FOLDER.Edit",
				icon: '<i class="fas fa-edit"></i>',
				condition: game.user.isGM,
				callback: header => {
					const li = header.parent()[0];
					const folder = game.folders.get(li.dataset.folderId);
					const options = {top: li.offsetTop, left: window.innerWidth - 310 - FolderConfig.defaultOptions.width};
					new FolderConfig(folder, options).render(true);
				}
			},
			{
				name: "PERMISSION.Configure",
				icon: '<i class="fas fa-lock"></i>',
				condition: () => game.user.isGM,
				callback: header => {
					const li = header.parent()[0];
					const folder = game.folders.get(li.dataset.folderId);
					new PermissionControl(folder, {
						top: Math.min(li.offsetTop, window.innerHeight - 350),
						left: window.innerWidth - 720
					}).render(true);
				}
			},
			{
				name: "FOLDER.Export",
				icon: `<i class="fas fa-atlas"></i>`,
				condition: header => {
					const folder = game.folders.get(header.parent().data("folderId"));
					return CONST.COMPENDIUM_ENTITY_TYPES.includes(folder.type);
				},
				callback: header => {
					const li = header.parent();
					const folder = game.folders.get(li.data("folderId"));
					return folder.exportDialog(null, {
							top: Math.min(li[0].offsetTop, window.innerHeight - 350),
							left: window.innerWidth - 720,
							width: 400
					});
				}
			},
			{
				name: "FOLDER.CreateTable",
				icon: `<i class="${CONFIG.RollTable.sidebarIcon}"></i>`,
				condition: header => {
					const folder = game.folders.get(header.parent().data("folderId"));
					return CONST.COMPENDIUM_ENTITY_TYPES.includes(folder.type);
				},
				callback: header => {
					const li = header.parent()[0];
					const folder = game.folders.get(li.dataset.folderId);
					return Dialog.confirm({
						title: `${game.i18n.localize("FOLDER.CreateTable")}: ${folder.name}`,
						content: game.i18n.localize("FOLDER.CreateTableConfirm"),
						yes: () => RollTable.fromFolder(folder),
						options: {
							top: Math.min(li.offsetTop, window.innerHeight - 350),
							left: window.innerWidth - 680,
							width: 360
						}
					});
				}
			},
			{
				name: "FOLDER.Remove",
				icon: '<i class="fas fa-trash"></i>',
				condition: game.user.isGM,
				callback: header => {
					const li = header.parent();
					const folder = game.folders.get(li.data("folderId"));
					return Dialog.confirm({
						title: `${game.i18n.localize("FOLDER.Remove")} ${folder.name}`,
						content: `<h4>${game.i18n.localize("AreYouSure")}</h4><p>${game.i18n.localize("FOLDER.RemoveWarning")}</p>`,
						yes: () => folder.delete({deleteSubfolders: false, deleteContents: false}),
						options: {
							top: Math.min(li[0].offsetTop, window.innerHeight - 350),
							left: window.innerWidth - 720,
							width: 400
						}
					});
				}
			},
			{
				name: "FOLDER.Delete",
				icon: '<i class="fas fa-dumpster"></i>',
				condition: game.user.isGM,
				callback: header => {
					const li = header.parent();
					const folder = game.folders.get(li.data("folderId"));
					return Dialog.confirm({
						title: `${game.i18n.localize("FOLDER.Delete")} ${folder.name}`,
						content: `<h4>${game.i18n.localize("AreYouSure")}</h4><p>${game.i18n.localize("FOLDER.DeleteWarning")}</p>`,
						yes: () => folder.delete({deleteSubfolders: true, deleteContents: true}),
						options: {
							top: Math.min(li[0].offsetTop, window.innerHeight - 350),
							left: window.innerWidth - 720,
							width: 400
						}
					});
				}
			}
		];
	}

	/* -------------------------------------------- */

	/**
	 * Get the set of ContextMenu options which should be used for Documents in a SidebarDirectory
	 * @return {object[]}   The Array of context options passed to the ContextMenu instance
	 * @protected
	 */
	_getEntryContextOptions() {
		return [
			{
				name: "FOLDER.Clear",
				icon: '<i class="fas fa-folder"></i>',
				condition: li => {
					const document = this.constructor.collection.get(li.data("entityId"));
					return game.user.isGM && !!document.data.folder;
				},
				callback: li => {
					const document = this.constructor.collection.get(li.data("entityId"));
					document.update({folder: null});
				}
			},
			{
				name: "SIDEBAR.Delete",
				icon: '<i class="fas fa-trash"></i>',
				condition: () => game.user.isGM,
				callback: li => {
					const document = this.constructor.collection.get(li.data("entityId"));
					if ( !document ) return;
					return document.deleteDialog({
						top: Math.min(li[0].offsetTop, window.innerHeight - 350),
						left: window.innerWidth - 720
					});
				}
			},
			{
				name: "SIDEBAR.Duplicate",
				icon: '<i class="far fa-copy"></i>',
				condition: () => game.user.isGM,
				callback: li => {
					const original = this.constructor.collection.get(li.data("entityId"));
					return original.clone({name: `${original.name} (Copy)`}, {save: true});
				}
			},
			{
				name: "PERMISSION.Configure",
				icon: '<i class="fas fa-lock"></i>',
				condition: () => game.user.isGM,
				callback: li => {
					const document = this.constructor.collection.get(li.data("entityId"));
					new PermissionControl(document, {
						top: Math.min(li[0].offsetTop, window.innerHeight - 350),
						left: window.innerWidth - 720
					}).render(true);
				}
			},
			{
				name: "SIDEBAR.Export",
				icon: '<i class="fas fa-file-export"></i>',
				condition: li => {
					const document = this.constructor.collection.get(li.data("entityId"));
					return document.isOwner;
				},
				callback: li => {
					const document = this.constructor.collection.get(li.data("entityId"));
					return document.exportToJSON();
				}
			},
			{
				name: "SIDEBAR.Import",
				icon: '<i class="fas fa-file-import"></i>',
				condition: li => {
					const document = this.constructor.collection.get(li.data("entityId"));
					return document.isOwner;
				},
				callback: li => {
					const document = this.constructor.collection.get(li.data("entityId"));
					return document.importFromJSONDialog();
				}
			}
		];
	}

	/* -------------------------------------------- */
	/*  DEPRECATED                                  */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	get entities() {
		return this.documents;
	}

}

/**
 * The Actor configuration sheet.
 * This Application is responsible for rendering an actor's attributes and allowing the actor to be edited.
 * System modifications may elect to override this class to better suit their own game system by re-defining the value
 * CONFIG.Actor.sheetClass.

 * @extends {DocumentSheet}
 *
 * @param {Actor} actor                   The Actor instance being displayed within the sheet.
 * @param {ApplicationOptions} options    Additional application configuration options.
 */
class ActorSheet extends DocumentSheet {

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			height: 720,
			width: 800,
			template: "templates/sheets/actor-sheet.html",
			closeOnSubmit: false,
			submitOnClose: true,
			submitOnChange: true,
			resizable: true,
			baseApplication: "ActorSheet",
			dragDrop: [{dragSelector: ".item-list .item", dropSelector: null}],
			token: null
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get id() {
		const actor = this.actor;
		let id = `actor-${actor.id}`;
		if (actor.isToken) id += `-${actor.token.id}`;
		return id;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get title() {
		return (this.token && !this.token.data.actorLink) ? `[Token] ${this.actor.name}` : this.actor.name;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience reference to the Actor entity
	 * @type {Actor}
	 */
	get actor() {
		return this.object;
	}

	/* -------------------------------------------- */

	/**
	 * If this Actor Sheet represents a synthetic Token actor, reference the active Token
	 * @type {Token|null}
	 */
	get token() {
		return this.object.token || this.options["token"] || null;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async close(options) {
		this.options.token = null;
		return super.close(options);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const context = super.getData(options);
		context.actor = this.object;
		context.items = context.data.items;
		context.items.sort((a, b) => (a.sort || 0) - (b.sort || 0));
		context.effects = context.data.effects;
		return context;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_getHeaderButtons() {
		let buttons = super._getHeaderButtons();

		// Token Configuration
		const canConfigure = game.user.isGM || (this.actor.isOwner && game.user.can("TOKEN_CONFIGURE"));
		if (this.options.editable && canConfigure) {
			buttons = [
				{
					label: "Sheet",
					class: "configure-sheet",
					icon: "fas fa-cog",
					onclick: ev => this._onConfigureSheet(ev)
				},
				{
					label: this.token ? "Token" : "Prototype Token",
					class: "configure-token",
					icon: "fas fa-user-circle",
					onclick: ev => this._onConfigureToken(ev)
				}
			].concat(buttons);
		}
		return buttons
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_getSubmitData(updateData = {}) {
		const data = super._getSubmitData(updateData);
		// Prevent submitting overridden values
		const overrides = foundry.utils.flattenObject(this.actor.overrides);
		for ( let k of Object.keys(overrides) ) {
			delete data[k];
		}
		return data;
	}

	/* -------------------------------------------- */
	/*  Event Listeners                             */
	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		super.activateListeners(html);
		if ( this.isEditable ) html.find('img[data-edit]').click(ev => this._onEditImage(ev));
	}

	/* -------------------------------------------- */

	/**
	 * Handle requests to configure the Token for the Actor
	 * @private
	 */
	_onConfigureToken(event) {
		event.preventDefault();
		new TokenConfig(this.token ?? this.actor, {
			left: Math.max(this.position.left - 560 - 10, 10),
			top: this.position.top
		}).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle requests to configure the default sheet used by this Actor
	 * @private
	 */
	_onConfigureSheet(event) {
		event.preventDefault();
		new EntitySheetConfig(this.actor, {
			top: this.position.top + 40,
			left: this.position.left + ((this.position.width - 400) / 2)
		}).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle changing the actor profile image by opening a FilePicker
	 * @private
	 */
	_onEditImage(event) {
		const attr = event.currentTarget.dataset.edit;
		const current = getProperty(this.actor.data, attr);
		const fp = new FilePicker({
			type: "image",
			current: current,
			callback: path => {
				event.currentTarget.src = path;
				this._onSubmit(event);
			},
			top: this.position.top + 40,
			left: this.position.left + 10
		});
		return fp.browse();
	}

	/* -------------------------------------------- */
	/*  Drag and Drop                               */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_canDragStart(selector) {
		return this.isEditable;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_canDragDrop(selector) {
		return this.isEditable;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragStart(event) {
		const li = event.currentTarget;
		if ( event.target.classList.contains("entity-link") ) return;

		// Create drag data
		const dragData = {
			actorId: this.actor.id,
			sceneId: this.actor.isToken ? canvas.scene?.id : null,
			tokenId: this.actor.isToken ? this.actor.token.id : null
		};

		// Owned Items
		if ( li.dataset.itemId ) {
			const item = this.actor.items.get(li.dataset.itemId);
			dragData.type = "Item";
			dragData.data = item.data;
		}

		// Active Effect
		if ( li.dataset.effectId ) {
			const effect = this.actor.effects.get(li.dataset.effectId);
			dragData.type = "ActiveEffect";
			dragData.data = effect.data;
		}

		// Set data transfer
		event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _onDrop(event) {

		// Try to extract the data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData('text/plain'));
		} catch (err) {
			return false;
		}
		const actor = this.actor;

		// Handle the drop with a Hooked function
		const allowed = Hooks.call("dropActorSheetData", actor, this, data);
		if ( allowed === false ) return;

		// Handle different data types
		switch ( data.type ) {
			case "ActiveEffect":
				return this._onDropActiveEffect(event, data);
			case "Actor":
				return this._onDropActor(event, data);
			case "Item":
				return this._onDropItem(event, data);
			case "Folder":
				return this._onDropFolder(event, data);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle the dropping of ActiveEffect data onto an Actor Sheet
	 * @param {DragEvent} event     The concluding DragEvent which contains drop data
	 * @param {Object} data         The data transfer extracted from the event
	 * @return {Promise<Object>}    A data object which describes the result of the drop
	 * @private
	 */
	async _onDropActiveEffect(event, data) {
		const actor = this.actor;
		if ( !actor.isOwner || !data.data ) return;
		let sameActor = (data.actorId === actor.id) || (actor.isToken && (data.tokenId === actor.token.id));
		if ( sameActor ) return;
		return ActiveEffect.create(data.data, {parent: actor})
	}

	/* -------------------------------------------- */

	/**
	 * Handle dropping of an Actor data onto another Actor sheet
	 * @param {DragEvent} event     The concluding DragEvent which contains drop data
	 * @param {Object} data         The data transfer extracted from the event
	 * @return {Promise<Object>}    A data object which describes the result of the drop
	 * @private
	 */
	async _onDropActor(event, data) {
		if ( !this.actor.isOwner ) return false;
	}

	/* -------------------------------------------- */

	/**
	 * Handle dropping of an item reference or item data onto an Actor Sheet
	 * @param {DragEvent} event     The concluding DragEvent which contains drop data
	 * @param {Object} data         The data transfer extracted from the event
	 * @return {Promise<Object>}    A data object which describes the result of the drop
	 * @private
	 */
	async _onDropItem(event, data) {
		if ( !this.actor.isOwner ) return false;
		const item = await Item.implementation.fromDropData(data);
		const itemData = item.toJSON();

		// Handle item sorting within the same Actor
		const actor = this.actor;
		let sameActor = (data.actorId === actor.id) || (actor.isToken && (data.tokenId === actor.token.id));
		if (sameActor) return this._onSortItem(event, itemData);

		// Create the owned item
		return this._onDropItemCreate(itemData);
	}

	/* -------------------------------------------- */

	/**
	 * Handle dropping of a Folder on an Actor Sheet.
	 * Currently supports dropping a Folder of Items to create all items as owned items.
	 * @param {DragEvent} event     The concluding DragEvent which contains drop data
	 * @param {Object} data         The data transfer extracted from the event
	 * @return {Promise<Object>}    A data object which describes the result of the drop
	 * @private
	 */
	async _onDropFolder(event, data) {
		if ( !this.actor.isOwner ) return false;
		if ( data.entity !== "Item" ) return;
		const folder = game.folders.get(data.id);
		if ( !folder ) return;
		return this._onDropItemCreate(folder.entities.map(e => e.data));
	}

	/* -------------------------------------------- */

	/**
	 * Handle the final creation of dropped Item data on the Actor.
	 * This method is factored out to allow downstream classes the opportunity to override item creation behavior.
	 * @param {object} itemData     The item data requested for creation
	 * @return {Promise<Actor>}
	 * @private
	 */
	async _onDropItemCreate(itemData) {
		return this.actor.createEmbeddedDocuments("Item", [itemData]);
	}

	/* -------------------------------------------- */

	/**
	 * Handle a drop event for an existing embedded Item to sort that Item relative to its siblings
	 * @param {Event} event
	 * @param {Object} itemData
	 * @private
	 */
	_onSortItem(event, itemData) {

		// Get the drag source and its siblings
		const source = this.actor.items.get(itemData._id);
		const siblings = this.actor.items.filter(i => {
			return (i.data.type === source.data.type) && (i.data._id !== source.data._id);
		});

		// Get the drop target
		const dropTarget = event.target.closest("[data-item-id]");
		const targetId = dropTarget ? dropTarget.dataset.itemId : null;
		const target = siblings.find(s => s.data._id === targetId);

		// Ensure we are only sorting like-types
		if (target && (source.data.type !== target.data.type)) return;

		// Perform the sort
		const sortUpdates = SortingHelpers.performIntegerSort(source, {target: target, siblings});
		const updateData = sortUpdates.map(u => {
			const update = u.update;
			update._id = u.target.data._id;
			return update;
		});

		// Perform the update
		return this.actor.updateEmbeddedDocuments("Item", updateData);
	}
}
/**
 * Configure the Combat tracker to display additional information as appropriate
 * @extends {FormApplication}
 */
class CombatTrackerConfig extends FormApplication {
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "combat-config",
			title: game.i18n.localize("COMBAT.Settings"),
			classes: ["sheet", "combat-sheet"],
			template: "templates/sheets/combat-config.html",
			width: 420
		});
	}

	/* -------------------------------------------- */

	/** @override */
	async getData(options) {
		const attributes = TokenDocument.getTrackedAttributes();
		attributes.bar.forEach(a => a.push("value"));
		return {
			settings: game.settings.get("core", Combat.CONFIG_SETTING),
			attributeChoices: TokenDocument.getTrackedAttributeChoices(attributes)
		};
	};

	/* -------------------------------------------- */

	/** @override */
	async _updateObject(event, formData) {
		return game.settings.set("core", Combat.CONFIG_SETTING, {
			resource: formData.resource,
			skipDefeated: formData.skipDefeated
		});
	}
}

/**
 * Configure or create a single Combatant within a Combat entity.
 * @extends {FormApplication}
 */
class CombatantConfig extends DocumentSheet {
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "combatant-config",
			title: game.i18n.localize("COMBAT.CombatantConfig"),
			classes: ["sheet", "combat-sheet"],
			template: "templates/sheets/combatant-config.html",
			width: 420
		});
	}

	/* -------------------------------------------- */

	/** @override */
	get title() {
		return game.i18n.localize(this.object.id ? "COMBAT.CombatantUpdate" : "COMBAT.CombatantCreate");
	}

	/* -------------------------------------------- */

	/** @override */
	async _updateObject(event, formData) {
		if ( this.object.id ) return this.object.update(formData);
		else {
			const cls = getDocumentClass("Combatant");
			return cls.create(formData, {parent: game.combat});
		}
	}
}

/**
 * A form designed for creating and editing an Active Effect on an Actor or Item entity.
 * @extends {DocumentSheet}
 *
 * @param {ActiveEffect} object     The target active effect being configured
 * @param {object} [options]        Additional options which modify this application instance
 */
class ActiveEffectConfig extends DocumentSheet {

	/** @override */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["sheet", "active-effect-sheet"],
			template: "templates/sheets/active-effect-config.html",
			width: 560,
			height: "auto",
			tabs: [{navSelector: ".tabs", contentSelector: "form", initial: "details"}]
		});
	}

	/* ----------------------------------------- */

	/** @override */
	get title() {
		return `${game.i18n.localize("EFFECT.ConfigTitle")}: ${this.object.data.label}`;
	}

	/* ----------------------------------------- */

	/** @override */
	getData(options) {
		const effect = foundry.utils.deepClone(this.object.data);
		return {
			effect: effect, // Backwards compatibility
			data: foundry.utils.deepClone(this.object.data),
			isActorEffect: this.object.parent.entity === "Actor",
			isItemEffect: this.object.parent.entity === "Item",
			submitText: "EFFECT.Submit",
			modes: Object.entries(CONST.ACTIVE_EFFECT_MODES).reduce((obj, e) => {
				obj[e[1]] = game.i18n.localize("EFFECT.MODE_"+e[0]);
				return obj;
			}, {})
		};
	}

	/* ----------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find(".effect-control").click(this._onEffectControl.bind(this));
	}

	/* ----------------------------------------- */

	/**
	 * Provide centralized handling of mouse clicks on control buttons.
	 * Delegate responsibility out to action-specific handlers depending on the button action.
	 * @param {MouseEvent} event      The originating click event
	 * @private
	 */
	_onEffectControl(event) {
		event.preventDefault();
		const button = event.currentTarget;
		switch ( button.dataset.action ) {
			case "add":
				return this._addEffectChange();
			case "delete":
				button.closest(".effect-change").remove();
				return this.submit({preventClose: true}).then(() => this.render());
		}
	}

	/* ----------------------------------------- */

	/**
	 * Handle adding a new change to the changes array.
	 * @private
	 */
	async _addEffectChange() {
		const idx = this.document.data.changes.length;
		return this.submit({preventClose: true, updateData: {
			[`changes.${idx}`]: {key: "", mode: CONST.ACTIVE_EFFECT_MODES.ADD, value: ""}
		}});
	}

	/* ----------------------------------------- */

	/** @inheritdoc */
	_getSubmitData(updateData={}) {
		const fd = new FormDataExtended(this.form, {editors: this.editors});
		let data = foundry.utils.expandObject(fd.toObject());
		if ( updateData ) foundry.utils.mergeObject(data, updateData);
		data.changes = Array.from(Object.values(data.changes || {}));
		return data;
	}
}

/**
 * Edit a folder, configuring its name and appearance
 * @extends {FormApplication}
 */
class FolderConfig extends DocumentSheet {

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["sheet", "folder-edit"],
			template: "templates/sidebar/folder-edit.html",
			width: 360
		});
	}

	/* -------------------------------------------- */

	/** @override */
	get id() {
		return this.object.id ? `folder-edit-${this.object.id}` : "folder-create";
	}

	/* -------------------------------------------- */

	/** @override */
	get title() {
		if ( this.object.id ) return `${game.i18n.localize("FOLDER.Update")}: ${this.object.name}`;
		return game.i18n.localize("FOLDER.Create");
	}

	/* -------------------------------------------- */

	/** @override */
	async getData(options) {
		return {
			name: this.object.id ? this.object.name : "",
			newName: game.i18n.format("ENTITY.New", {entity: game.i18n.localize(Folder.metadata.label)}),
			folder: this.object.data,
			safeColor: this.object.data.color ?? "#000000",
			sortingModes: {"a": "FOLDER.SortAlphabetical", "m": "FOLDER.SortManual"},
			submitText: game.i18n.localize(this.object.id ? "FOLDER.Update" : "FOLDER.Create")
		}
	}

	/* -------------------------------------------- */

	/** @override */
	async _updateObject(event, formData) {
		if ( !formData.parent ) formData.parent = null;
		if ( !this.object.id ) {
			this.object.data.update(formData);
			return Folder.create(this.object.data);
		}
		return this.object.update(formData);
	}
}

/**
 * A tool for fine tuning the grid in a Scene
 * @extends {FormApplication}
 */
class GridConfig extends FormApplication {
	constructor(scene, sheet, ...args) {
		super(scene, ...args);

		/**
		 * Track the Scene Configuration sheet reference
		 * @type {SceneConfig}
		 */
		this.sheet = sheet;

		/**
		 * The counter-factual dimensions being evaluated
		 * @type {Object}
		 */
		this._dimensions = {};

		/**
		 * A reference to the bound key handler function so it can be removed
		 * @type {Function|null}
		 * @private
		 */
		this._keyHandler = null;

		/**
		 * A reference to the bound mousewheel handler function so it can be removed
		 * @type {Function|null}
		 * @private
		 */
		this._wheelHandler = null;
	}

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "grid-config",
			template: "templates/scene/grid-config.html",
			title: game.i18n.localize("SCENES.GridConfigTool"),
			width: 480,
			height: "auto",
			closeOnSubmit: true,
			submitOnChange: true
		});
	}

	/* -------------------------------------------- */

	/** @override */
	getData(options) {
		return {
			gridTypes: SceneConfig._getGridTypes(),
			scale: canvas.background.bg ? this.object.data.width / canvas.background.bgSource.width : 1,
			scene: this.object.data
		};
	}

	/* -------------------------------------------- */

	/** @override */
	async _render(...args) {
		await super._render(...args);
		if ( !this.object.data.img ) {
			ui.notifications.warn("WARNING.GridConfigNoBG", {localize: true});
		}
		for ( let l of canvas.layers ) {
			if ( !["BackgroundLayer", "ForegroundLayer", "GridLayer"].includes(l.name) ) l.visible = false;
		}
		this._refresh({grid: true, background: true});
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);
		this._keyHandler = this._keyHandler || this._onKeyDown.bind(this);
		document.addEventListener("keydown", this._keyHandler);
		this._wheelHandler = this._wheelHandler || this._onWheel.bind(this);
		document.addEventListener("wheel", this._wheelHandler, {passive: false});
		html.find('button[name="reset"]').click(this._onReset.bind(this));
	}

	/* -------------------------------------------- */

	/** @override */
	async close(options) {
		document.removeEventListener("keydown", this._keyHandler);
		document.removeEventListener("wheel", this._wheelHandler);
		this._keyHandler = this._wheelHandler = null;
		if ( canvas.ready ) await canvas.draw();
		await this.sheet.maximize();
		return super.close(options);
	}

	/* -------------------------------------------- */

	/**
	 * Handle resetting the form and re-drawing back to the original dimensions
	 * @param {KeyboardEvent} event    The original keydown event
	 * @private
	 */
	_onKeyDown(event) {
		const key = game.keyboard.getKey(event);
		if ( !(key in game.keyboard.moveKeys) || game.keyboard.hasFocus ) return;
		event.preventDefault();

		const up = ["w", "W", "ArrowUp"];
		const down = ["s", "S", "ArrowDown"];
		const left = ["a", "A", "ArrowLeft"];
		const right = ["d", "D", "ArrowRight"];

		// Increase the Scene scale on shift + up or down
		if ( event.shiftKey ) {
			let delta = up.includes(key) ? 1 : (down.includes(key) ? -1 : 0);
			this._scaleBackgroundSize(delta);
		}

		// Resize grid size on ALT
		else if ( event.altKey ) {
			let delta = up.includes(key) ? 1 : (down.includes(key) ? -1 : 0);
			this._scaleGridSize(delta);
		}

		// Shift grid position
		else {
			if ( up.includes(key) ) this._shiftBackground({deltaY: -1});
			else if ( down.includes(key) ) this._shiftBackground({deltaY: 1});
			else if ( left.includes(key) ) this._shiftBackground({deltaX: -1});
			else if ( right.includes(key) ) this._shiftBackground({deltaX: 1});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle resetting the form and re-drawing back to the original dimensions
	 * @param {WheelEvent} event    The original wheel event
	 * @private
	 */
	_onWheel(event) {
		if ( event.deltaY === 0 ) return;

		// Increase the Scene scale on shift
		if ( event.shiftKey ) {
			event.preventDefault();
			event.stopImmediatePropagation();
			this._scaleBackgroundSize(-Math.sign(event.deltaY));
		}

		// Increase the Grid scale on alt
		if ( event.altKey ) {
			event.preventDefault();
			event.stopImmediatePropagation();
			this._scaleGridSize(-Math.sign(event.deltaY));
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle resetting the form and re-drawing back to the original dimensions
	 * @param {MouseEvent} event    The original click event
	 * @private
	 */
	_onReset(event) {
		event.preventDefault();
		this._dimensions = {};
		this.render();
	}

	/* -------------------------------------------- */
	/*  Previewing and Updating Functions           */
	/* -------------------------------------------- */

	/**
	 * Scale the background size relative to the grid size
	 * @param {number} delta          The directional change in background size
	 * @private
	 */
	_scaleBackgroundSize(delta) {
		const scale = Math.round((parseFloat(this.form.scale.value) + (0.05 * delta)) * 100) / 100;
		this.form.scale.value = Math.clamped(scale, 0.25, 10.0);
		this._refresh({background: true});
	}

	/* -------------------------------------------- */

	/**
	 * Scale the grid size relative to the background image.
	 * When scaling the grid size in this way, constrain the allowed values between 50px and 300px.
	 * @param {number} delta          The grid size in pixels
	 * @private
	 */
	_scaleGridSize(delta) {
		this.form.grid.value = Math.clamped(parseInt(this.form.grid.value) + delta, 50, 300);
		this._refresh({grid: true});
	}

	/* -------------------------------------------- */

	/**
	 * Shift the background image relative to the grid layer
	 * @param {number} deltaX         The number of pixels to shift in the x-direction
	 * @param {number} deltaY         The number of pixels to shift in the y-direction
	 * @private
	 */
	_shiftBackground({deltaX=0, deltaY=0}={}) {
		this.form.shiftX.value = parseInt(this.form.shiftX.value) + deltaX;
		this.form.shiftY.value = parseInt(this.form.shiftY.value) + deltaY;
		this._refresh({background: true});
	}

	/* -------------------------------------------- */

	/**
	 * Temporarily refresh the display of the BackgroundLayer and GridLayer for the new pending dimensions
	 * @param {boolean} background      Refresh the background display?
	 * @param {boolean} grid            Refresh the grid display?
	 * @private
	 */
	_refresh({background=false, grid=false}={}) {
		const form = this.form;
		const bg = canvas.background.bg;
		const fg = canvas.foreground.bg;
		const tex = bg ? bg.texture : {width: canvas.scene.data.width, height: canvas.scene.data.height};

		// Establish new Scene dimensions
		const scale = parseFloat(form.scale.value);
		const d = this._dimensions = Canvas.getDimensions({
			width: tex.width * scale,
			height: tex.height * scale,
			padding: this.object.data.padding,
			grid: Math.max(parseInt(form.grid.value), 50),
			gridDistance: this.object.data.gridDistance,
			shiftX: parseInt(form.shiftX.value),
			shiftY: parseInt(form.shiftY.value)
		});
		canvas.dimensions = d;

		// Update the background and foreground sizing
		if ( background && bg ) {
			bg.position.set(d.paddingX - d.shiftX, d.paddingY - d.shiftY);
			bg.width = d.sceneWidth;
			bg.height = d.sceneHeight;
			grid = true;
		}
		if ( background && fg ) {
			fg.position.set(d.paddingX - d.shiftX, d.paddingY - d.shiftY);
			fg.width = d.sceneWidth;
			fg.height = d.sceneHeight;
		}

		// Update the grid layer
		if ( grid ) {
			canvas.grid.tearDown();
			canvas.grid.draw({type: parseInt(form.gridType.value), dimensions: d, gridColor: 0xFF0000, gridAlpha: 1.0});
			canvas.stage.hitArea = new PIXI.Rectangle(0, 0, d.width, d.height);
		}
	}

	/* -------------------------------------------- */

	/** @override */
	async _onChangeInput(event) {
		event.preventDefault();
		this._refresh({background: true, grid: true});
	}

	/* -------------------------------------------- */

	/** @override */
	async _updateObject(event, formData) {
		formData.width = Math.round(this._dimensions.sceneWidth);
		formData.height = Math.round(this._dimensions.sceneHeight);
		const delta = foundry.utils.diffObject(this.object.data, formData);
		if ( ["width", "height", "padding", "shiftX", "shiftY", "size"].some(k => k in delta) ) {
			const confirm = await Dialog.confirm({
				title: game.i18n.localize("SCENES.DimensionChangeTitle"),
				content: `<p>${game.i18n.localize("SCENES.DimensionChangeWarning")}</p>`
			});
			if ( !confirm ) return;
		}
		return this.object.update(formData, {fromSheet: true});
	}
}

/**
 * An Image Popout Application which features a single image in a lightbox style frame.
 * This popout can also be used as a form, allowing the user to edit an image which is being used.
 * Furthermore, this application allows for sharing the display of an image with other connected players.
 * @extends {FormApplication}
 *
 * @example
 * // Construct the Application instance
 * const ip = new ImagePopout("path/to/image.jpg", {
 *   title: "My Featured Image",
 *   shareable: true,
 *   entity: game.actors.getName("My Hero")
 * });
 *
 * // Display the image popout
 * ip.render(true);
 *
 * // Share the image with other connected players
 * ip.share();
 */
class ImagePopout extends FormApplication {
	constructor(src, options={}) {
		super(src, options);
		this._related = null;
	}

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			template: "templates/apps/image-popout.html",
			classes: ["image-popout", "dark"],
			editable: false,
			resizable: true,
			shareable: false,
			uuid: null
		});
	}

	/* -------------------------------------------- */

	/** @override */
	get title() {
		return this.isTitleVisible() ? super.title : "";
	}

	/* -------------------------------------------- */

	/** @override */
	async getData(options) {
		return {
			image: this.object,
			options: this.options,
			title: this.title,
			showTitle: this.isTitleVisible()
		}
	}

	/* -------------------------------------------- */

	/**
	 * Test whether the title of the image popout should be visible to the user
	 * @returns {boolean}
	 */
	isTitleVisible() {
		if ( this._related && this._related["hasPerm"] ) {
			return this._related.testUserPermission(game.user, "LIMITED");
		}
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Provide a reference to the Entity referenced by this popout, if one exists
	 * @return {Promise<*>}
	 */
	async getRelatedObject() {
		if ( this.options.uuid && !this._related ) {
			this._related = await fromUuid(this.options.uuid);
		}
		return this._related;
	}

	/* -------------------------------------------- */

	/** @override */
	async _render(...args) {
		this.position = await this.constructor.getPosition(this.object);
		return super._render(...args);
	}

	/* -------------------------------------------- */

	/** @override */
	_getHeaderButtons() {
		let buttons = super._getHeaderButtons();
		if ( game.user.isGM && this.options.shareable ) {
			buttons.unshift({
				label: "JOURNAL.ActionShow",
				class: "share-image",
				icon: "fas fa-eye",
				onclick: ev => this.shareImage()
			});
		}
		return buttons
	}

	/* -------------------------------------------- */
	/*  Helper Methods
	/* -------------------------------------------- */

	/**
	 * Determine the correct position and dimensions for the displayed image
	 * @returns {Object}    The positioning object which should be used for rendering
	 * @private
	 */
	static async getPosition(img) {
		if ( !img ) return { width: 720, height: window.innerHeight * 0.8 };
		const position = {};
		let size;
		try {
			size = await this.getImageSize(img);
		} catch(err) {
			return { width: 720, height: window.innerHeight * 0.8 };
		}
		let wh = window.innerHeight,
				ww = window.innerWidth,
				wr = window.innerWidth / window.innerHeight,
				ir = size[0] / size[1];
		if (ir > wr) {
			position.width = Math.min(size[0] * 2, parseInt(0.95 * ww));
			position.height = parseInt(position.width / ir);
		} else {
			position.height = Math.min(size[1] * 2, parseInt(0.95 * wh));
			position.width = parseInt(position.height * ir);
		}
		position.top = (wh - position.height) / 2;
		position.left = (ww - position.width) / 2;
		return position;
	}

	/* -------------------------------------------- */

	/**
	 * Determine the Image dimensions given a certain path
	 * @return {Promise<Array.<Number>>}
	 */
	static getImageSize(path) {
		return new Promise((resolve, reject) => {
			let img = new Image();
			img.onload = function() {
				resolve([this.width, this.height]);
			};
			img.onerror = reject;
			img.src = path;
		});
	}

	/* -------------------------------------------- */

	/**
	 * Share the displayed image with other connected Users
	 */
	shareImage() {
		game.socket.emit("shareImage", {
			image: this.object,
			title: this.options.title,
			uuid: this.options.uuid
		});
		ui.notifications.info(game.i18n.format("JOURNAL.ActionShowSuccess", {
			mode: "image",
			title: this.options.title,
			which: "all"
		}));
	}

	/* -------------------------------------------- */

	/**
	 * Handle a received request to display an image.
	 * @param {string} image
	 * @param {string} title
	 * @param {string} uuid
	 * @return {ImagePopout}
	 * @private
	 */
	static _handleShareImage({image, title, uuid}={}) {
		return new ImagePopout(image, {
			title: title,
			uuid: uuid,
			shareable: false,
			editable: false
		}).render(true);
	}
}

/**
 * The default Item configuration sheet.
 * This Application is responsible for rendering an item's attributes and allowing the item to be edited.
 * @extends {DocumentSheet}
 *
 * @param {Item} item                     The Item instance being displayed within the sheet.
 * @param {ApplicationOptions} options    Additional application configuration options.
 */
class ItemSheet extends DocumentSheet {

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			template: "templates/sheets/item-sheet.html",
			width: 500,
			closeOnSubmit: false,
			submitOnClose: true,
			submitOnChange: true,
			resizable: true,
			baseApplication: "ItemSheet",
			id: "item"
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get id() {
		if (this.actor) return `actor-${this.actor.id}-item-${this.item.id}`;
		else return super.id;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get title() {
		return this.item.name;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience reference to the Item entity
	 * @type {Item}
	 */
	get item() {
		return this.object;
	}

	/* -------------------------------------------- */

	/**
	 * The Actor instance which owns this item. This may be null if the item is unowned.
	 * @type {Actor}
	 */
	get actor() {
		return this.item.actor;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const data = super.getData(options);
		data.item = data.document;
		return data;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_getHeaderButtons() {
		let buttons = super._getHeaderButtons();
		let canConfigure = this.isEditable && game.user.isGM;
		if (!canConfigure) return buttons;

		// Add a Sheet Configuration button
		buttons.unshift({
			label: "Sheet",
			class: "configure-sheet",
			icon: "fas fa-cog",
			onclick: ev => this._onConfigureSheet(ev)
		});
		return buttons;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		super.activateListeners(html);
		if ( this.isEditable) html.find('img[data-edit]').click(ev => this._onEditImage(ev));
	}

	/* -------------------------------------------- */

	/**
	 * Handle requests to configure the default sheet used by this Item
	 * @private
	 */
	_onConfigureSheet(event) {
		event.preventDefault();
		new EntitySheetConfig(this.item, {
			top: this.position.top + 40,
			left: this.position.left + ((this.position.width - 400) / 2)
		}).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle changing the item image
	 * @private
	 */
	_onEditImage(event) {
		const attr = event.currentTarget.dataset.edit;
		const current = getProperty(this.item.data, attr);
		const fp = new FilePicker({
			type: "image",
			current: current,
			callback: path => {
				event.currentTarget.src = path;
				if ( this.options.submitOnChange ) {
					this._onSubmit(event);
				}
			},
			top: this.position.top + 40,
			left: this.position.left + 10
		});
		return fp.browse();
	}
}

/**
 * The JournalEntry Configuration Sheet
 * @implements {DocumentSheet}
 *
 * @param {JournalEntry} entity     The JournalEntry instance which is being edited
 * @param {object} [options]        Application options
 */
class JournalSheet extends DocumentSheet {
	constructor(object, options={}) {
		super(object, options);
		this._sheetMode = this.options.sheetMode || this._inferDefaultMode();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["sheet", "journal-sheet"],
			width: 720,
			height: 800,
			resizable: true,
			closeOnSubmit: false,
			submitOnClose: true,
			viewPermission: CONST.ENTITY_PERMISSIONS.NONE
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get template() {
		if ( this._sheetMode === "image" ) return ImagePopout.defaultOptions.template;
		return "templates/journal/sheet.html";
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get title() {
		return this.object.permission ? this.object.name : "";
	}

	/* -------------------------------------------- */

	/**
	 * Guess the default view mode for the sheet based on the player's permissions to the Entry
	 * @return {string}
	 * @private
	 */
	_inferDefaultMode() {
		const hasImage = !!this.object.data.img;
		const hasText = this.object.data.content;

		// If the user only has limited permission, show an image or nothing
		if ( this.object.limited ) return hasImage ? "image" : null;

		// Otherwise prefer text if it exists
		return hasText || !hasImage ? "text" : "image";
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _render(force, options={}) {

		// Determine the sheet rendering mode
		const mode = options.sheetMode || this._sheetMode;
		if ( mode === null ) return;

		// Close the existing sheet if the mode has changed
		if ( (mode !== this._sheetMode) && this.rendered ) {
			await this.close({submit: false});
			options.sheetMode = this._sheetMode = mode;
			return this.render(true, options);
		}

		// Display image mode
		if ( mode === "image" ) {
			const img = this.object.data.img;
			const pos = await ImagePopout.getPosition(img);
			foundry.utils.mergeObject(options, pos);
			options.classes = this.constructor.defaultOptions.classes.concat(ImagePopout.defaultOptions.classes);
		}

		// Adjust for text mode
		else if ( mode === "text" ) {
			options.classes = this.constructor.defaultOptions.classes
		}

		this._sheetMode = mode;
		// Normal rendering
		await super._render(force, options);


		// If the sheet was first created, activate the editor
		if ( options.action === "create" ) this.activateEditor("content")
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_getHeaderButtons() {
		const buttons = super._getHeaderButtons();
		const isOwner = this.object.isOwner;
		const atLeastLimited = !!this.object.compendium || this.object.testUserPermission(game.user, "LIMITED");
		const atLeastObserver = !!this.object.compendium || this.object.testUserPermission(game.user, "OBSERVER");
		const hasMultipleModes = !!this.object.data.img && !!this.object.data.content;

		// Image Mode
		if ( isOwner || (atLeastLimited && hasMultipleModes) ) {
			buttons.unshift({
				label: "JOURNAL.ModeImage",
				class: "entry-image",
				icon: "fas fa-image",
				onclick: ev => this._onSwapMode(ev, "image")
			})
		}

		// Text Mode
		if ( isOwner || (atLeastObserver && hasMultipleModes) ) {
			buttons.unshift({
				label: "JOURNAL.ModeText",
				class: "entry-text",
				icon: "fas fa-file-alt",
				onclick: ev => this._onSwapMode(ev, "text")
			})
		}

		// Share Entry
		if ( game.user.isGM ) {
			buttons.unshift({
				label: "JOURNAL.ActionShow",
				class: "share-image",
				icon: "fas fa-eye",
				onclick: ev => this._onShowPlayers(ev)
			});
		}
		return buttons;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const data = super.getData(options);
		data.title = this.title; // Needed for image mode
		data.image = this.object.data.img;
		data.folders = game.folders.filter(f => (f.data.type === "JournalEntry") && f.displayed);
		return data
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _updateObject(event, formData) {
		if ( this._sheetMode === "image" ) {
			formData.name = formData.title;
			delete formData["title"];
			formData.img = formData.image;
			delete formData["image"];
		}
		return super._updateObject(event, formData);
	}

	/* -------------------------------------------- */

	/**
	 * Handle requests to switch the rendered mode of the Journal Entry sheet
	 * Save the form before triggering the show request, in case content has changed
	 * @param {Event} event   The triggering click event
	 * @param {string} mode   The journal mode to display
	 */
	async _onSwapMode(event, mode) {
		event.preventDefault();
		await this.submit();
		this.render(true, {sheetMode: mode});
	}

	/* -------------------------------------------- */

	/**
	 * Handle requests to show the referenced Journal Entry to other Users
	 * Save the form before triggering the show request, in case content has changed
	 * @param {Event} event   The triggering click event
	 */
	async _onShowPlayers(event) {
		event.preventDefault();
		await this.submit();
		return this.object.show(this._sheetMode, true);
	}
}

/**
 * A Macro configuration sheet
 * @extends {DocumentSheet}
 *
 * @see {@link Macro} The Macro Entity which is being configured
 */
class MacroConfig extends DocumentSheet {

	/** @override */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["sheet", "macro-sheet"],
			template: "templates/sheets/macro-config.html",
			width: 560,
			height: 480,
			resizable: true
		});
	}

	/* -------------------------------------------- */

	/** @override */
	get id() {
		return `macro-config-${this.object.id}`;
	}

	/* -------------------------------------------- */

	/** @override */
	getData(options) {
		const data = super.getData();
		data.macroTypes = foundry.utils.deepClone(game.system.entityTypes.Macro);
		if ( !game.user.can("MACRO_SCRIPT") ) data.macroTypes.findSplice(t => t === "script");
		data.macroScopes = CONST.MACRO_SCOPES;
		return data;
	}

	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find('img[data-edit="img"]').click(ev => this._onEditImage(ev));
		html.find("button.execute").click(this._onExecute.bind(this));
	}

	/* -------------------------------------------- */

	/**
	 * Handle changing the actor profile image by opening a FilePicker
	 * @private
	 */
	_onEditImage(event) {
		const fp = new FilePicker({
			type: "image",
			current: this.object.data.img,
			callback: path => {
				event.currentTarget.src = path;
				this._onSubmit(event, {preventClose: true});
			},
			top: this.position.top + 40,
			left: this.position.left + 10
		});
		return fp.browse();
	}

	/* -------------------------------------------- */

	/**
	 * Save and execute the macro using the button on the configuration sheet
	 * @param {MouseEvent} event      The originating click event
	 * @return {Promise<void>}
	 * @private
	 */
	async _onExecute(event) {
		event.preventDefault();
		await this._onSubmit(event, {preventClose: true}); // Submit pending changes
		this.object.execute(); // Execute the macro
	}


	/* -------------------------------------------- */

	/** @override */
	async _updateObject(event, formData) {
		if ( !this.object.id ) {
			return Macro.create(formData);
		} else {
			return super._updateObject(event, formData);
		}
	}
}

/**
 * A configuration Form Application for modifying the properties of a MeasuredTemplate object.
 * @extends {FormApplication}
 * @see {@link MeasuredTemplate}
 */
class MeasuredTemplateConfig extends FormApplication {

	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "template-config",
			classes: ["sheet", "template-sheet"],
			title: "Measurement Template Configuration",
			template: "templates/scene/template-config.html",
			width: 400
		});
	}

	/* -------------------------------------------- */

	/** @override */
	getData() {
		return {
			object: duplicate(this.object.data),
			options: this.options,
			templateTypes: CONFIG.MeasuredTemplate.types,
			gridUnits: canvas.scene.data.gridUnits,
			submitText: this.options.preview ? "Create" : "Update"
		}
	}

	/* -------------------------------------------- */

	/** @override */
	async _updateObject(event, formData) {
		if ( this.object.id ) {
			formData["id"] = this.object.id;
			return this.object.update(formData);
		}
		return this.object.constructor.create(formData);
	}
}

/**
 * A generic application for configuring permissions for various Entity types
 * @extends {DocumentSheet}
 */
class PermissionControl extends DocumentSheet {

	/** @override */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "permission",
			template: "templates/apps/permission.html",
			width: 400
		});
	}

	/* -------------------------------------------- */

	/** @override */
	get title() {
		return `${game.i18n.localize("PERMISSION.Title")}: ${this.document.name}`;
	}

	/* -------------------------------------------- */

	/** @override */
	getData(options) {
		const e = this.document;
		const isFolder = e instanceof Folder;

		// User permission levels
		const playerLevels = {};
		if ( isFolder ) {
			playerLevels["-2"] = game.i18n.localize("PERMISSION.DEFAULT");
			playerLevels["-1"] = game.i18n.localize("PERMISSION.NOCHANGE");
		} else {
			playerLevels["-1"] = game.i18n.localize("PERMISSION.DEFAULT");
		}
		for ( let [n, l] of Object.entries(CONST.ENTITY_PERMISSIONS) ) {
			playerLevels[l] = game.i18n.localize(`PERMISSION.${n}`);
		}

		// Default permission levels
		const defaultLevels = foundry.utils.deepClone(playerLevels);
		if ( isFolder ) delete defaultLevels["-2"];
		else delete defaultLevels["-1"];

		// Player users
		const users = game.users.map(u => {
			return {
				user: u,
				level: e.data.permission?.[u.id] ?? "-1"
			};
		});

		// Construct and return the data object
		return {
			entity: e,
			currentDefault: e.data.permission?.default ?? "-1",
			instructions: game.i18n.localize(isFolder ? "PERMISSION.HintFolder" : "PERMISSION.HintEntity"),
			defaultLevels,
			playerLevels,
			isFolder,
			users
		};
	}

	/* -------------------------------------------- */

	/** @override */
 async _updateObject(event, formData) {
		event.preventDefault();
		if (!game.user.isGM) throw new Error("You do not have the ability to configure permissions.");

		// Collect user permissions
		const perms = {};
		for ( let [user, level] of Object.entries(formData) ) {
			if ( (name !== "default") && (level === -1) ) {
				delete perms[user];
				continue;
			}
			perms[user] = level;
		}

		// Update all entities in a Folder
		if ( this.document instanceof Folder ) {
			const cls = getDocumentClass(this.document.type);
			const updates = this.document.content.map(e => {
				const p = foundry.utils.deepClone(e.data.permission);
				for ( let [k, v] of Object.entries(perms) ) {
					if ( v === -2 ) delete p[k];
					else p[k] = v;
				}
				return {_id: e.id, permission: p}
			});
			return cls.updateDocuments(updates, {diff: false, recursive: false, noHook: true});
		}

		// Update a single Entity
		return this.document.update({permission: perms}, {diff: false, recursive: false, noHook: true});
	}
}

/**
 * Playlist Configuration Sheet
 * @extends {DocumentSheet}
 */
class PlaylistConfig extends DocumentSheet {

	/** @inheritdoc */
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = "playlist-config";
		options.template = "templates/playlist/playlist-config.html";
		options.width = 360;
		return options;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get title() {
		return `${game.i18n.localize("PLAYLIST.Edit")}: ${this.object.name}`;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const data = super.getData(options);
		data.modes = Object.entries(CONST.PLAYLIST_MODES).reduce((obj, e) => {
			const [name, value] = e;
			obj[value] = game.i18n.localize(`PLAYLIST.Mode${name.titleCase()}`);
			return obj;
		}, {});
		return data;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_getFilePickerOptions(event) {
		const options = super._getFilePickerOptions(event);
		options.allowUpload = false;
		return options;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onSelectFile(selection, filePicker) {
		if ( filePicker.button.dataset.target !== "importPath" ) return;
		const playlist = this.object;
		const currentSources = new Set(playlist.sounds.map(s => s.data.path));
		const toCreate = filePicker.result.files.reduce((arr, src) => {
			if ( !AudioHelper.hasAudioExtension(src) || currentSources.has(src) ) return arr;
			const soundData = { name: AudioHelper.getDefaultSoundName(src), path: src };
			arr.push(soundData);
			return arr;
		}, []);
		if ( toCreate.length ) {
			ui.playlists._expanded.add(playlist.id);
			return playlist.createEmbeddedDocuments("PlaylistSound", toCreate);
		} else {
			const warning = game.i18n.format("PLAYLIST.BulkImportWarning", {path: filePicker.target});
			return ui.notifications.warn(warning);
		}
	}
}

/**
 * Playlist Sound Configuration Sheet
 * @extends {DocumentSheet}
 *
 * @param {PlaylistSound} sound   The PlaylistSound document being configured
 * @param {object} options        Additional application rendering options
 */
class PlaylistSoundConfig extends DocumentSheet {

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "track-config",
			template: "templates/playlist/sound-config.html",
			width: 360
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get title() {
		if ( !this.object.id ) return `${game.i18n.localize("PLAYLIST.SoundCreate")}: ${this.object.parent.name}`;
		return `${game.i18n.localize("PLAYLIST.SoundEdit")}: ${this.object.name}`;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const data = super.getData(options);
		if ( !this.object.id ) data.data.name = "";
		data.lvolume = AudioHelper.volumeToInput(data.data.volume);
		return data;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		super.activateListeners(html);
		html.find('input[name="path"]').change(this._onSourceChange.bind(this));
		return html;
	}

	/* -------------------------------------------- */

	/**
	 * Auto-populate the track name using the provided filename, if a name is not already set
	 * @param {Event} event
	 * @private
	 */
	_onSourceChange(event) {
		event.preventDefault();
		const field = event.target;
		const form = field.form;
		if ( !form.name.value ) {
			let fileParts = field.value.split("/").pop().split(".");
			fileParts.pop();
			form.name.value = decodeURIComponent(fileParts.join("."));
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _updateObject(event, formData) {
		formData["volume"] = AudioHelper.inputToVolume(formData["lvolume"]);
		if (this.object.id)  return this.object.update(formData);
		return this.object.constructor.create(formData, {parent: this.object.parent});
	}
}

/**
 * The RollTable configuration sheet
 * @extends {DocumentSheet}
 * @param {RollTable} table               The RollTable document being configured
 * @param {ApplicationOptions} options    Additional application configuration options
 */
class RollTableConfig extends DocumentSheet {
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["sheet", "roll-table-config"],
			template: "templates/sheets/roll-table-config.html",
			width: 720,
			height: "auto",
			closeOnSubmit: false,
			viewPermission: CONST.ENTITY_PERMISSIONS.OBSERVER,
			scrollY: ["ol.table-results"],
			dragDrop: [{dragSelector: null, dropSelector: null}]
		})
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get title() {
		return `${game.i18n.localize("TABLE.SheetTitle")}: ${this.document.name}`;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const results = this.document.results.map(result => {
			result = result.data.toObject(false);
			result.isText = result.type === CONST.TABLE_RESULT_TYPES.TEXT;
			result.isEntity = result.type === CONST.TABLE_RESULT_TYPES.ENTITY;
			result.isCompendium = result.type === CONST.TABLE_RESULT_TYPES.COMPENDIUM;
			result.img = result.img || CONFIG.RollTable.resultIcon;
			result.text = TextEditor.decodeHTML(result.text);
			return result;
		});
		results.sort((a, b) => a.range[0] - b.range[0]);

		// Merge data and return;
		return foundry.utils.mergeObject(super.getData(options), {
			results: results,
			resultTypes: Object.entries(CONST.TABLE_RESULT_TYPES).reduce((obj, v) => {
				obj[v[1]] = v[0].titleCase();
				return obj;
			}, {}),
			entityTypes: CONST.COMPENDIUM_ENTITY_TYPES,
			compendiumPacks: Array.from(game.packs.keys())
		});
	}

	/* -------------------------------------------- */
	/* 	Event Listeners and Handlers								*/
	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		super.activateListeners(html);

		// Roll the Table
		const button = html.find("button.roll");
		button.click(this._onRollTable.bind(this));
		button[0].disabled = false;

		// The below options require an editable sheet
		if (!this.isEditable) return;

		// Reset the Table
		html.find("button.reset").click(this._onResetTable.bind(this));

		// Save the sheet on checkbox change
		html.find('input[type="checkbox"]').change(this._onSubmit.bind(this));

		// Create a new Result
		html.find("a.create-result").click(this._onCreateResult.bind(this));

		// Delete a Result
		html.find("a.delete-result").click(this._onDeleteResult.bind(this));

		// Support Image updates
		html.find('img[data-edit]').click(this._onEditImage.bind(this));

		// Lock or Unlock a Result
		html.find("a.lock-result").click(this._onLockResult.bind(this));

		// Modify Result Type
		html.find(".result-type select").change(this._onChangeResultType.bind(this));

		// Re-normalize Table Entries
		html.find(".normalize-results").click(this._onNormalizeResults.bind(this));
	}

	/* -------------------------------------------- */

	/**
	 * Handle creating a TableResult in the RollTable entity
	 * @param {MouseEvent} event        The originating mouse event
	 * @param {object} [resultData]     An optional object of result data to use
	 * @return {Promise}
	 * @private
	 */
	async _onCreateResult(event, resultData={}) {
		event.preventDefault();

		// Save any pending changes
		await this._onSubmit(event);

		// Get existing results
		const results = Array.from(this.document.results.values());
		let last = results[results.length - 1];

		// Get weight and range data
		let weight = last ? (last.data.weight || 1) : 1;
		let totalWeight = results.reduce((t, r) => t + r.data.weight, 0) || 1;
		let minRoll = results.length ? Math.min(...results.map(r => r.data.range[0])) : 0;
		let maxRoll = results.length ? Math.max(...results.map(r => r.data.range[1])) : 0;

		// Determine new starting range
		const spread = maxRoll - minRoll + 1;
		const perW = Math.round(spread / totalWeight);
		const range = [maxRoll + 1, maxRoll + (weight * perW)];

		// Create the new Result
		resultData = foundry.utils.mergeObject({
			type: last ? last.type : CONST.TABLE_RESULT_TYPES.TEXT,
			collection: last ? last.collection : null,
			weight: weight,
			range: range,
			drawn: false
		}, resultData);
		return this.document.createEmbeddedDocuments("TableResult", [resultData]);
	}

	/* -------------------------------------------- */

	/**
	 * Submit the entire form when a table result type is changed, in case there are other active changes
	 * @param {Event} event
	 * @private
	 */
	_onChangeResultType(event) {
		event.preventDefault();
		const rt = CONST.TABLE_RESULT_TYPES;
		const select = event.target;
		const value = parseInt(select.value);
		const key = select.name.replace(".type", ".collection.js");
		let collection = "";
		if ( value === rt.ENTITY ) collection = "Actor";
		else if ( value === rt.COMPENDIUM ) collection = game.packs.keys().next().value;
		const updateData = {[key]: collection, resultId: ""};
		return this._onSubmit(event, {updateData});
	}

	/* -------------------------------------------- */

	/**
	 * Handle deleting a TableResult from the RollTable entity
	 * @param {MouseEvent} event        The originating click event
	 * @return {Promise<TableResult>}   The deleted TableResult document
	 * @private
	 */
	async _onDeleteResult(event) {
		event.preventDefault();
		await this._onSubmit(event);
		const li = event.currentTarget.closest(".table-result");
		const result = this.object.results.get(li.dataset.resultId);
		return result.delete();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _onDrop(event) {

		// Try to extract the data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData('text/plain'));
		} catch (err) {
			return false;
		}

		// Handle the drop with a Hooked function
		const allowed = Hooks.call("dropRollTableSheetData", this.document, this, data);
		if (allowed === false) return;

		// Get the dropped entity
		if (!CONST.ENTITY_TYPES.includes(data.type)) return;
		const cls = getDocumentClass(data.type);
		const entity = await cls.fromDropData(data);
		if ( !entity ) return;

		// Delegate to the onCreate handler
		const isCompendium = !!entity.compendium;
		return this._onCreateResult(event, {
			type: isCompendium ? CONST.TABLE_RESULT_TYPES.COMPENDIUM : CONST.TABLE_RESULT_TYPES.ENTITY,
			collection: isCompendium ? data.pack : entity.entity,
			text: entity.name,
			resultId: entity.id,
			img: entity.data.img || null
		});
	}

	/* -------------------------------------------- */

	/**
	 * Handle changing the actor profile image by opening a FilePicker
	 * @param {Event} event
	 * @private
	 */
	_onEditImage(event) {
		const img = event.currentTarget;
		const isHeader = img.dataset["edit"] === "img";
		let current = this.document.data.img;
		if ( !isHeader ) {
			const li = img.closest(".table-result");
			const result = this.document.results.get(li.dataset.resultId);
			if (result.data.type !== CONST.TABLE_RESULT_TYPES.TEXT) return;
			current = result.data.img;
		}
		const fp = new FilePicker({
			type: "image",
			current: current,
			callback: path => {
				img.src = path;
				return this._onSubmit(event);
			},
			top: this.position.top + 40,
			left: this.position.left + 10
		});
		return fp.browse();
	}

	/* -------------------------------------------- */

	/**
	 * Handle a button click to re-normalize dice result ranges across all RollTable results
	 * @param {Event} event
	 * @private
	 */
	async _onNormalizeResults(event) {
		event.preventDefault();
		if ( !this.rendered || this._submitting) return false;

		// Save any pending changes
		await this._onSubmit(event);

		// Normalize the RollTable
		return this.document.normalize();
	}

	/* -------------------------------------------- */

	/**
	 * Handle toggling the drawn status of the result in the table
	 * @param {Event} event
	 * @private
	 */
	_onLockResult(event) {
		event.preventDefault();
		const li = event.currentTarget.closest("li.table-result");
		const result = this.document.results.get(li.dataset.resultId);
		return result.update({drawn: !result.data.drawn});
	}

	/* -------------------------------------------- */

	/**
	 * Reset the Table to it's original composition with all options unlocked
	 * @param {Event} event
	 * @private
	 */
	_onResetTable(event) {
		event.preventDefault();
		return this.document.reset();
	}

	/* -------------------------------------------- */

	/**
	 * Handle drawing a result from the RollTable
	 * @param {Event} event
	 * @private
	 */
	async _onRollTable(event) {
		event.preventDefault();
		await this.submit({preventClose: true, preventRender: true});
		event.currentTarget.disabled = true;
		let tableRoll = await this.document.roll();
		const draws = this.document.getResultsForRoll(tableRoll.roll.total);
		if ( draws.length ) {
			if (game.settings.get("core", "animateRollTable")) await this._animateRoll(draws);
			await this.document.draw(tableRoll);
		}
		event.currentTarget.disabled = false;
	}

	/* -------------------------------------------- */

	/**
	 * Configure the update object workflow for the Roll Table configuration sheet
	 * Additional logic is needed here to reconstruct the results array from the editable fields on the sheet
	 * @param {Event} event            The form submission event
	 * @param {Object} formData        The validated FormData translated into an Object for submission
	 * @return {Promise}
	 * @private
	 */
	async _updateObject(event, formData) {

		// Expand the data to update the results array
		const expanded = foundry.utils.expandObject(formData);
		expanded.results = expanded.hasOwnProperty("results") ? Object.values(expanded.results) : [];
		for (let r of expanded.results) {
			r.range = [r["rangeL"], r["rangeH"]];
			switch (r.type) {

				// Document results
				case CONST.TABLE_RESULT_TYPES.ENTITY:
					const collection = game.collections.get(r.collection);
					if (!collection) continue;

					// Get the original entity, if the name still matches - take no action
					const original = r.resultId ? collection.get(r.resultId) : null;
					if (original && (original.name === r.text)) continue;

					// Otherwise find the entity by ID or name (id preferred)
					const ent = collection.find(e => (e.id === r.text) || (e.name === r.text)) || null;
					r.resultId = ent?.id ?? null;
					r.text = ent?.name ?? null;
					r.img = ent?.img ?? null;
					r.img = ent?.data.thumb || ent?.data.img || null;
					break;

				// Compendium results
				case CONST.TABLE_RESULT_TYPES.COMPENDIUM:
					const pack = game.packs.get(r.collection);
					if (pack) {
						const index = await pack.getIndex();

						// Get the original entry, if the name still matches - take no action
						const original = r.resultId ? index.find(i => i._id === r.resultId) : null;
						if (original && (original.name === r.text)) continue;

						// Otherwise find the entity by ID or name (id preferred)
						const ent = index.find(i => (i._id === r.text) || (i.name === r.text)) || null;
						r.resultId = ent ? ent._id : null;
						r.text = ent ? ent.name : null;
						r.img = ent ? ent.img : null;
					}
					break;

				// Plain text results
				default:
					r.type = 0;
					r.collection = null;
					r.resultId = null;
			}
		}

		// Update the object
		return this.document.update(expanded, {recursive: false});
	}

	/* -------------------------------------------- */

	/**
	 * Display a roulette style animation when a Roll Table result is drawn from the sheet
	 * @param {TableResult[]} results     An Array of drawn table results to highlight
	 * @return {Promise}                  A Promise which resolves once the animation is complete
	 * @protected
	 */
	async _animateRoll(results) {

		// Get the list of results and their indices
		const ol = this.element.find(".table-results")[0];
		const drawnIds = new Set(results.map(r => r.id));
		const drawnItems = Array.from(ol.children).filter(item => drawnIds.has(item.dataset.resultId));

		// Set the animation timing
		const nResults = this.object.results.size;
		const maxTime = 2000;
		let animTime = 50;
		let animOffset = Math.round(ol.offsetHeight / (ol.children[1].offsetHeight * 2));
		const nLoops = Math.min(Math.ceil(maxTime/(animTime * nResults)), 4);
		if ( nLoops === 1 ) animTime = maxTime / nResults;

		// Animate the roulette
		await this._animateRoulette(ol, drawnIds, nLoops, animTime, animOffset);

		// Flash the results
		const flashes = drawnItems.map(li => this._flashResult(li));
		return Promise.all(flashes);
	}

	/* -------------------------------------------- */

	/**
	 * Animate a "roulette" through the table until arriving at the final loop and a drawn result
	 * @return {Promise}          A Promise that resolves once the animation is complete
	 * @protected
	 */
	async _animateRoulette(ol, drawnIds, nLoops, animTime, animOffset) {
		let loop = 0;
		let idx = 1;
		let item = null;
		return new Promise(resolve => {
			let animId = setInterval(() => {
				if (idx === 1) loop++;
				if (item) item.classList.remove("roulette");

				// Scroll to the next item
				item = ol.children[idx];
				ol.scrollTop = (idx - animOffset) * item.offsetHeight;

				// If we are on the final loop
				if ( (loop === nLoops) && drawnIds.has(item.dataset.resultId) ) {
					clearInterval(animId);
					return resolve();
				}

				// Continue the roulette and cycle the index
				item.classList.add("roulette");
				idx = idx < ol.children.length - 1 ? idx+1 : 1;
			}, animTime);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Display a flashing animation on the selected result to emphasize the draw
	 * @param {HTMLElement} item      The HTML <li> item of the winning result
	 * @return {Promise}              A Promise that resolves once the animation is complete
	 * @protected
	 */
	async _flashResult(item) {
		return new Promise(resolve => {
			let count = 0;
			let animId = setInterval(() => {
				if (count % 2) item.classList.remove("roulette");
				else item.classList.add("roulette");
				if (count === 7) {
					clearInterval(animId);
					resolve();
				}
				count++;
			}, 50);
		})
	}
}

/**
 * A Scene configuration sheet
 * @extends {DocumentSheet}
 * @see {@link Scene} The Scene Document which is being configured
 */
class SceneConfig extends DocumentSheet {

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "scene-config",
			classes: ["sheet", "scene-sheet"],
			template: "templates/scene/config.html",
			width: 680,
			height: "auto"
		});
	}

	/* -------------------------------------------- */

	/** @override */
	get title() {
		return `${game.i18n.localize("SCENES.ConfigTitle")}: ${this.object.name}`;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	render(force, options={}) {
		if ( options.renderContext && (options.renderContext !== "updateScene" ) ) return;
		return super.render(force, options);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const data = super.getData(options);

		// Selectable types
		data.gridTypes = this.constructor._getGridTypes();
		data.weatherTypes = this._getWeatherTypes();

		// Referenced entities
		data.playlists = this._getDocuments(game.playlists);
		data.sounds = this._getDocuments(this.object.playlist?.sounds ?? []);
		data.journals = this._getDocuments(game.journal);

		// Global illumination threshold
		data.hasGlobalThreshold = data.data.globalLightThreshold !== null;
		data.data.globalLightThreshold = data.data.globalLightThreshold ?? 0;
		return data;
	}

	/* -------------------------------------------- */

	/**
	 * Get an enumeration of the available grid types which can be applied to this Scene
	 * @return {Object}
	 * @private
	 */
	static _getGridTypes() {
		const labels = {
			"GRIDLESS": "SCENES.GridGridless",
			"SQUARE": "SCENES.GridSquare",
			"HEXODDR": "SCENES.GridHexOddR",
			"HEXEVENR": "SCENES.GridHexEvenR",
			"HEXODDQ": "SCENES.GridHexOddQ",
			"HEXEVENQ": "SCENES.GridHexEvenQ"
		};
		return Object.keys(CONST.GRID_TYPES).reduce((obj, t) => {
			obj[CONST.GRID_TYPES[t]] = labels[t];
			return obj;
		}, {});
	}

	/* -------------------------------------------- */

	/**
	 * Get the available weather effect types which can be applied to this Scene
	 * @return {Object}
	 * @private
	 */
	_getWeatherTypes() {
		const types = {};
		for ( let [k, v] of Object.entries(CONFIG.weatherEffects) ) {
			types[k] = v.label;
		}
		return types;
	}

	/* -------------------------------------------- */

	/**
	 * Get the alphabetized Documents which can be chosen as a configuration for the Scene
	 * @param {WorldCollection} collection
	 * @return {object[]}
	 * @private
	 */
	_getDocuments(collection) {
		const documents = collection.map(doc => {
			return {id: doc.id, name: doc.name};
		});
		documents.sort((a, b) => a.name.localeCompare(b.name));
		return documents;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		super.activateListeners(html);
		html.find("button.capture-position").click(this._onCapturePosition.bind(this));
		html.find("button.grid-config").click(this._onGridConfig.bind(this));
		html.find("select[name='playlist']").change(this._onChangePlaylist.bind(this));
	}

	/* -------------------------------------------- */

	/**
	 * Capture the current Scene position and zoom level as the initial view in the Scene config
	 * @param {Event} event   The originating click event
	 * @private
	 */
	_onCapturePosition(event) {
		event.preventDefault();
		const btn = event.currentTarget;
		const form = btn.form;
		form["initial.x"].value = parseInt(canvas.stage.pivot.x);
		form["initial.y"].value = parseInt(canvas.stage.pivot.y);
		form["initial.scale"].value = canvas.stage.scale.x;
		ui.notifications.info("Captured canvas position as initial view in the Scene configuration form.")
	}

	/* -------------------------------------------- */

	/** @override */
	_onChangeRange(event) {
		super._onChangeRange(event);
		const rng = event.target;
		if ( (rng.name === "darkness") && this.object.isView ) {
			canvas.lighting.refresh(Number(rng.value));
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle updating the select menu of PlaylistSound options when the Playlist is changed
	 * @param {Event} event   The initiating select change event
	 * @private
	 */
	_onChangePlaylist(event) {
		event.preventDefault();
		const playlist = game.playlists.get(event.target.value);
		const sounds = this._getDocuments(playlist?.sounds || []);
		const options = ['<option value=""></option>'].concat(sounds.map(s => {
			return `<option value="${s.id}">${s.name}</option>`;
		}));
		const select = this.form.querySelector(`select[name="playlistSound"]`);
		select.innerHTML = options.join("");
	}

	/* -------------------------------------------- */

	/**
	 * Handle click events to open the grid configuration application
	 * @param {Event} event   The originating click event
	 * @private
	 */
	async _onGridConfig(event) {
		event.preventDefault();
		if ( !this.object.isView ) await this.object.view();
		new GridConfig(this.object, this).render(true);
		return this.minimize();
	}

	/* -------------------------------------------- */

	/** @override */
	async _updateObject(event, formData) {
		const scene = this.document;

		// Capture initial camera position
		const initialViewAttrs = ["initial.x", "initial.y", "initial.scale"];
		if ( initialViewAttrs.every(a => !formData[a]) ) {
			for ( let a of initialViewAttrs ) {
				delete formData[a];
			}
			formData.initial = null;
		}

		// Toggle global illumination threshold
		if ( formData.hasGlobalThreshold === false ) formData.globalLightThreshold = null;

		// Determine what type of change has occurred
		const hasDefaultDims = (scene.data.width === 4000 ) && ( scene.data.height === 3000 );
		const hasImage = formData.img || scene.data.img;
		const changedBackground = (formData.img !== undefined) && (formData.img !== scene.data.img);
		const clearedDims = (formData.width === null) || (formData.height === null);
		const needsThumb = changedBackground || !scene.data.thumb;
		const needsDims = formData.img && (clearedDims || hasDefaultDims);

		// Update thumbnail and image dimensions
		if ( hasImage && (needsThumb || needsDims) ) {
			let td = {};
			try {
				td = await scene.createThumbnail({img: formData.img ?? scene.data.img});
			} catch(err) {
				ui.notifications.error("Thumbnail generation for Scene failed: " + err.message);
			}
			if ( needsThumb ) formData.thumb = td.thumb || null;
			if ( needsDims ) {
				formData.width = td.width;
				formData.height = td.height;
			}
		}

		// Warn the user if Scene dimensions are changing
		const delta = foundry.utils.diffObject(scene.data, formData);
		if ( ["width", "height", "padding", "shiftX", "shiftY", "size"].some(k => k in delta) ) {
			const confirm = await Dialog.confirm({
				title: game.i18n.localize("SCENES.DimensionChangeTitle"),
				content: `<p>${game.i18n.localize("SCENES.DimensionChangeWarning")}</p>`
			});
			if ( !confirm ) return;
		}

		// Perform the update
		return scene.update(formData);
	}
}

/**
 * Entity Sheet Configuration Application
 * @extends {FormApplication}
 */
class EntitySheetConfig extends FormApplication {
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "sheet-config",
			template: "templates/sheets/sheet-config.html",
			width: 400
		});
	}

	/**
	 * An array of pending sheet assignments which are submitted before other elements of the framework are ready.
	 * @type {object[]}
	 * @private
	 */
	static _pending = [];

	/* -------------------------------------------- */

	/** @inheritdoc */
	get title() {
		return `${this.object.name}: Sheet Configuration`;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const config = CONFIG[this.object.documentName];
		const type = this.object.data.type || CONST.BASE_ENTITY_TYPE;
		let defaultClass = null;

		// Classes which can be chosen
		const classes = Object.values(config.sheetClasses[type]).reduce((obj, c) => {
			obj[c.id] = c.label;
			if ( c.default && !defaultClass ) defaultClass = c.id;
			return obj;
		}, {});

		// Return data
		return {
			isGM: game.user.isGM,
			object: duplicate(this.object.data),
			options: this.options,
			sheetClass: this.object.getFlag("core", "sheetClass") ?? "",
			sheetClasses: classes,
			defaultClass: defaultClass,
			blankLabel: game.i18n.localize("SHEETS.DefaultSheet")
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _updateObject(event, formData) {
		event.preventDefault();
		const original = this.getData({});

		// De-register the current sheet class
		const sheet = this.object.sheet;
		await sheet.close();
		this.object._sheet = null;
		delete this.object.apps[sheet.appId];

		// Update world settings
		if ( game.user.isGM && (formData.defaultClass !== original.defaultClass) ) {
			const setting = await game.settings.get("core", "sheetClasses") || {};
			foundry.utils.mergeObject(setting, {[`${this.object.documentName}.${this.object.data.type}`]: formData.defaultClass});
			await game.settings.set("core", "sheetClasses", setting);
		}

		// Update the Entity-specific override
		if ( formData.sheetClass !== original.sheetClass ) {
			await this.object.setFlag("core", "sheetClass", formData.sheetClass);
		}

		// Re-draw the updated sheet
		this.object.sheet.render(true);
	}

	/* -------------------------------------------- */
	/*  Configuration Methods
	/* -------------------------------------------- */

	/**
	 * Initialize the configured Sheet preferences for Entities which support dynamic Sheet assignment
	 * Create the configuration structure for supported entities
	 * Process any pending sheet registrations
	 * Update the default values from settings data
	 */
	static initializeSheets() {

		// Restrict to valid types
		const documents = [Actor, Item];
		for ( let cls of documents ) {
			const types = this._getDocumentTypes(cls);
			CONFIG[cls.documentName].sheetClasses = types.reduce((obj, type) => {
				obj[type] = {};
				return obj;
			}, {});
		}

		// Register any pending sheets
		this._pending.forEach(p => {
			if ( p.action === "register" ) this._registerSheet(p);
			else if ( p.action === "unregister" ) this._unregisterSheet(p);
		});
		this._pending = [];

		// Update default sheet preferences
		const defaults = game.settings.get("core", "sheetClasses");
		this.updateDefaultSheets(defaults)
	}

	/* -------------------------------------------- */

	static _getDocumentTypes(cls, types=[]) {
		if ( types.length ) return types;
		const systemTypes = game.system?.entityTypes[cls.documentName];
		return systemTypes?.length ? systemTypes : [CONST.BASE_ENTITY_TYPE];
	}

	/* -------------------------------------------- */

	/**
	 * Register a sheet class as a candidate which can be used to display entities of a given type
	 * @param {Function} documentClass  The Document class for which to register a new Sheet option
	 * @param {string} scope            Provide a unique namespace scope for this sheet
	 * @param {Application} sheetClass  A defined Application class used to render the sheet
	 * @param {Object} options          Additional options used for sheet registration
	 * @param {string} [options.label]          A human readable label for the sheet name, which will be localized
	 * @param {string[]} [options.types]        An array of entity types for which this sheet should be used
	 * @param {boolean} [options.makeDefault]   Whether to make this sheet the default for provided types
	 */
	static registerSheet(documentClass, scope, sheetClass, {label, types, makeDefault=false}={}) {
		const id = `${scope}.${sheetClass.name}`;
		const config = {documentClass, id, label, sheetClass, types, makeDefault};
		if ( game.ready ) this._registerSheet(config);
		else {
			config["action"] = "register";
			this._pending.push(config);
		}
	}

	/**
	 * Perform the sheet registration
	 * @private
	 */
	static _registerSheet({documentClass, id, label, sheetClass, types, makeDefault}={}) {
		types = this._getDocumentTypes(documentClass, types);
		const classes = CONFIG[documentClass.documentName]?.sheetClasses;
		if ( typeof classes !== "object" ) return;
		for ( let t of types ) {
			classes[t][id] = {
				id: id,
				cls: sheetClass,
				default: makeDefault,
				label: label ? game.i18n.localize(label) : id
			};
		}
	}

	/* -------------------------------------------- */

	/**
	 * Unregister a sheet class, removing it from the list of available Applications to use for a Document type
	 * @param {Function} documentClass  The Document class for which to register a new Sheet option
	 * @param {string} scope            Provide a unique namespace scope for this sheet
	 * @param {Application} sheetClass  A defined Application class used to render the sheet
	 * @param {object[]} types             An Array of types for which this sheet should be removed
	 */
	static unregisterSheet(documentClass, scope, sheetClass, {types}={}) {
		const id = `${scope}.${sheetClass.name}`;
		const config = {documentClass, id, types};
		if ( game.ready ) this._unregisterSheet(config);
		else {
			config["action"] = "unregister";
			this._pending.push(config);
		}
	}

	/**
	 * Perform the sheet de-registration
	 * @private
	 */
	static _unregisterSheet({documentClass, id, types}={}) {
		types = this._getDocumentTypes(documentClass, types);
		const classes = CONFIG[documentClass.documentName]?.sheetClasses;
		if ( typeof classes !== "object" ) return;
		for ( let t of types ) {
			delete classes[t][id];
		}
	}

	/* -------------------------------------------- */

	/**
	 * Update the currently default Sheets using a new core world setting
	 * @param {object} setting
	 */
	static updateDefaultSheets(setting={}) {
		if ( !Object.keys(setting).length ) return;
		const documents = ["Actor", "Item"];
		for ( let documentName of documents ) {
			const cfg = CONFIG[documentName];
			const classes = cfg.sheetClasses;
			const collection = cfg.collection.instance;
			let defaults = setting[documentName] || {};
			if ( !defaults ) continue;

			// Update default preference for registered sheets
			for ( let [type, sheetId] of Object.entries(defaults) ) {
				const sheets = Object.values(classes[type] || {});
				let requested = sheets.find(s => s.id === sheetId);
				if ( requested ) sheets.forEach(s => s.default = s.id === sheetId);
			}

			// Close and de-register any existing sheets
			for ( let document of collection ) {
				Object.values(document.apps).forEach(app => app.close());
				document.apps = {};
			}
		}
	}
}

/**
 * The User Configuration application provides a form used to allow the current client to edit preferences and
 * configurations about a User entity (typically their own).
 * @extends {FormApplication}
 * 
 * @param {User} user     The User entity being configured.
 * @param {object} [options]        Additional rendering options which modify the behavior of the form.
 */
class UserConfig extends DocumentSheet {

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["sheet", "user-config"],
			template: "templates/user/user-config.html",
			width: 400,
			height: "auto"
		})
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get title() {
		return `${game.i18n.localize("PLAYERS.ConfigTitle")}: ${this.object.name}`;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const controlled = game.users.map(e => e.data.character).filter(a => a);
		const actors = game.actors.filter(a => a.testUserPermission(this.object, "OBSERVER") && !controlled.includes(a.id));
		return {
			user: this.object,
			actors: actors,
			options: this.options
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		super.activateListeners(html);

		// When a character is clicked, record it's ID in the hidden input
		let input = html.find('[name="character"]');
		html.find('.actor').click(ev => {

			// Record the selected actor
			let li = ev.currentTarget;
			let actorId = li.getAttribute("data-actor-id");
			input.val(actorId);

			// Add context to the selection
			for ( let a of html[0].getElementsByClassName("actor") ) {
				a.classList.remove("context");
			}
			li.classList.add("context");
		});

		// Release the currently selected character
		html.find('button[name="release"]').click(ev => {
			canvas.tokens?.releaseAll();
			this.object.update({character: null}).then(() => this.render(false));
		});

		// Support Image updates
		html.find('img[data-edit="avatar"]').click(ev => this._onEditAvatar(ev));
	}

	/* -------------------------------------------- */
	
	/**
	 * Handle changing the user avatar image by opening a FilePicker
	 * @private
	 */
	_onEditAvatar(event) {
		event.preventDefault();
		const fp = new FilePicker({
			type: "image",
			current: this.object.data.avatar,
			callback: path => {
				event.currentTarget.src = path;
				return this._onSubmit(event, {preventClose: true});
			},
			top: this.position.top + 40,
			left: this.position.left + 10
		});
		return fp.browse();
	}
}

/**
 * The Chat Bubble Class
 * This application displays a temporary message sent from a particular Token in the active Scene.
 * The message is displayed on the HUD layer just above the Token.
 */
class ChatBubbles {
	constructor() {
		this.template = "templates/hud/chat-bubble.html";

		/**
		 * Track active Chat Bubbles
		 * @type {Object}
		 */
		this.bubbles = {};

		/**
		 * Track which Token was most recently panned to highlight
		 * Use this to avoid repeat panning
		 * @type {Token}
		 * @private
		 */
		this._panned = null;
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the chat bubbles HTML container in which rendered bubbles should live
	 * @return {jQuery}
	 */
	get container() {
		return $("#chat-bubbles");
	}

	/* -------------------------------------------- */

	/**
	 * Speak a message as a particular Token, displaying it as a chat bubble
	 * @param {Token} token       The speaking Token
	 * @param {string} message    The spoken message text
	 * @param {boolean} emote     Whether to style the speech bubble as an emote
	 * @returns {Promise<void>}   A Promise which resolves once the chat bubble has been created
	 */
	async say(token, message, {emote=false}={}) {
		if ( !token || !message ) return;
		let allowBubbles = game.settings.get("core", "chatBubbles");
		if ( !allowBubbles ) return;
		const panToSpeaker = game.settings.get("core", "chatBubblesPan");

		// Clear any existing bubble for the speaker
		await this._clearBubble(token);

		// Create the HTML and call the chatBubble hook
		let html = $(await this._renderHTML({token, message, emote}));
		const allowed = Hooks.call("chatBubble", token, html, message, {emote});
		if ( allowed === false ) return;

		// Set initial dimensions
		let dimensions = this._getMessageDimensions(message);
		this._setPosition(token, html, dimensions);

		// Append to DOM
		this.container.append(html);

		// Pan to the speaker
		if ( panToSpeaker && (this._panned !== token) ) {
			canvas.animatePan({x: token.x, y: token.y, scale: Math.max(1, canvas.stage.scale.x), duration: 1000});
			this._panned = token;
		}

		// Get animation duration and settings
		const duration = this._getDuration(html);
		const scroll = dimensions.unconstrained - dimensions.height;

		// Animate the bubble
		html.fadeIn(250, () => {
			if ( scroll > 0 ) {
				html.find(".bubble-content").animate({ top: -1 * scroll }, duration - 1000, 'linear');
			}
			setTimeout(() => html.fadeOut(250, () => html.remove()), duration);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Clear any existing chat bubble for a certain Token
	 * @param {Token} token
	 * @private
	 */
	async _clearBubble(token) {
		let existing = $(`.chat-bubble[data-token-id="${token.id}"]`);
		if ( !existing.length ) return;
		return new Promise(resolve => {
			existing.fadeOut(100, () => {
				existing.remove();
				resolve();
			});
		})
	}

	/* -------------------------------------------- */

	/**
	 * Render the HTML template for the chat bubble
	 * @param {Object} data         Template data
	 * @return {Promise<string>}    The rendered HTML
	 * @private
	 */
	async _renderHTML(data) {
		data.cssClasses = [
			data.emote ? "emote" : null
		].filter(c => c !== null).join(" ");
		return renderTemplate(this.template, data);
	}

	/* -------------------------------------------- */

	/**
	 * Before displaying the chat message, determine it's constrained and unconstrained dimensions
	 * @param {string} message    The message content
	 * @return {Object}           The rendered message dimensions
	 * @private
	 */
	_getMessageDimensions(message) {
		let div = $(`<div class="chat-bubble" style="visibility:hidden">${message}</div>`);
		$('body').append(div);
		let dims = {
			width: div[0].clientWidth + 8,
			height: div[0].clientHeight
		};
		div.css({maxHeight: "none"});
		dims.unconstrained = div[0].clientHeight;
		div.remove();
		return dims;
	}

	/* -------------------------------------------- */

	/**
	 * Assign styling parameters to the chat bubble, toggling either a left or right display (randomly)
	 * @private
	 */
	_setPosition(token, html, dimensions) {
		let cls = Math.random() > 0.5 ? "left" : "right";
		html.addClass(cls);
		const pos = {
			height: dimensions.height,
			width: dimensions.width,
			top: token.y - dimensions.height - 8
		};
		if ( cls === "right" ) pos.left = token.x - (dimensions.width - token.w);
		else pos.left = token.x;
		html.css(pos);
	}

	/* -------------------------------------------- */

	/**
	* Determine the length of time for which to display a chat bubble.
	* Research suggests that average reading speed is 200 words per minute.
	* Since these are short-form messages, we multiply reading speed by 1.5.
	* Clamp the result between 1 second (minimum) and 20 seconds (maximum)
	* @param {jQuery} html     The HTML message
	* @returns {number}        The number of milliseconds for which to display the message
	*/
	_getDuration(html) {
		let words = html.text().split(" ").map(w => w.trim()).length;
		let ms = (words * 60 * 1000) / 300;
		return Math.clamped(1000, ms, 20000);
	}
}








/**
 * Render the HUD container
 * @type {Application}
 */
class HeadsUpDisplay extends Application {
	constructor(...args) {
		super(...args);

		/**
		 * Token HUD
		 * @type {TokenHUD}
		 */
		this.token = new TokenHUD();

		/**
		 * Tile HUD
		 * @type {TileHUD}
		 */
		this.tile = new TileHUD();

		/**
		 * Drawing HUD
		 * @type {DrawingHUD}
		 */
		this.drawing = new DrawingHUD();

		/**
		 * Chat Bubbles
		 * @type {ChatBubbles}
		 */
		this.bubbles = new ChatBubbles();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = "hud";
		options.template = "templates/hud/hud.html";
		options.popOut = false;
		return options;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		if ( !canvas.ready ) return {};
		return {
			width: canvas.dimensions.width,
			height: canvas.dimensions.height
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _render(force, options) {
		await super._render(force, options);
		this.align();
	}

	/* -------------------------------------------- */

	/**
	 * Align the position of the HUD layer to the current position of the canvas
	 */
	align() {
		const hud = this.element[0];
		let {x, y} = canvas.background.getGlobalPosition();
		let scale = canvas.stage.scale.x;
		hud.style.left = x+"px";
		hud.style.top = y+"px";
		hud.style.transform = `scale(${scale})`;
	}
}

/**
 * @typedef {Object} SceneControlTool
 * @property {string} name
 * @property {string} label
 * @property {string} icon
 * @property {boolean} visible
 * @property {boolean} toggle
 * @property {boolean} active
 */

/**
 * @typedef {Object} SceneControl
 * @property {string} name
 * @property {string} title
 * @property {string} layer
 * @property {string} icon
 * @property {boolean} visible
 * @property {SceneControlTool[]} tools
 * @property {string} activeTool
 */

/**
 * Scene controls navigation menu
 * @extends {Application}
 */
class SceneControls extends Application {
	constructor(options) {
		super(options);

		/**
		 * The name of the active Scene Control toolset
		 * @type {string}
		 */
		this.activeControl = "token";

		/**
		 * The Array of Scene Control buttons which are currently rendered
		 * @type {SceneControl[]}
		 */
		this.controls = this._getControlButtons();
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			width: 100,
			id: "controls",
			template: "templates/hud/controls.html",
			popOut: false
		});
	}

	/* -------------------------------------------- */

	/**
	 * Return the active control set
	 * @type {SceneControl|null}
	 */
	get control() {
		if ( !this.controls ) return null;
		return this.controls.find(c => c.name === this.activeControl) || null;
	}

	/* -------------------------------------------- */

	/**
	 * Return the name of the active tool within the active control set
	 * @type {string|null}
	 */
	get activeTool() {
		const control = this.control;
		return control ? control.activeTool : null;
	}

	/* -------------------------------------------- */

	/**
	 * Return the actively controlled tool
	 * @type {SceneControlTool|null}
	 */
	get tool() {
		const control = this.control;
		if ( !control ) return null;
		const tool = control.tools.find(t => t.name === control.activeTool);
		return tool || null;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience reference for whether the currently active tool is a Ruler
	 * @type {boolean}
	 */
	get isRuler() {
		return this.activeTool === "ruler";
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Initialize the Scene Controls by obtaining the set of control buttons and rendering the HTML
	 * @param {object} options      Options which modify how the controls UI is initialized
	 * @param {string} [options.control]      An optional control set to set as active
	 * @param {string} [options.layer]        An optional layer name to target as the active control
	 * @param {string} [options.tool]         A specific named tool to set as active for the palette
	 */
	initialize({control, layer, tool}={}) {
		const tools = this.controls.reduce((obj, t) => {
			obj[t.name] = t.activeTool;
			return obj;
		}, {});

		// Set the new control
		if ( control ) this.activeControl = control;
		else if ( layer && this.controls ) {
			const control = this.controls.find(c => c.layer === layer);
			if ( control ) this.activeControl = control.name;
		}

		// Update the control buttons
		this.controls = this._getControlButtons();
		if ( tool ) tools[this.activeControl] = tool;
		for ( let c of this.controls ) {
			c.activeTool = tools[c.name];
		}
		this.render(true);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const isActive = !!canvas.scene;

		// Filter to control tool sets which can be displayed
		let controls = this.controls.filter(s => s.visible !== false).map(s => {
			s = foundry.utils.deepClone(s);

			// Add styling rules
			s.css = isActive && (this.activeControl === s.name) ? "active" : "";

			// Prepare contained tools
			s.tools = s.tools.filter(t => t.visible !== false).map(t => {
				let active = isActive && ((s.activeTool === t.name) || (t.toggle && t.active));
				t.css = [
					t.toggle ? "toggle" : null,
					active ? "active" : null
				].filter(t => !!t).join(" ");
				return t;
			});
			return s;
		});

		// Return data for rendering
		return {
			active: isActive,
			cssClass: isActive ? "" : "disabled",
			controls: controls.filter(s => s.tools.length)
		};
	}


	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		html.find('.scene-control').click(this._onClickLayer.bind(this));
		html.find('.control-tool').click(this._onClickTool.bind(this));
	}

	/* -------------------------------------------- */

	/**
	 * Handle click events on a Control set
	 * @param {Event} event   A click event on a tool control
	 * @private
	 */
	_onClickLayer(event) {
		event.preventDefault();
		if ( !canvas.ready ) return;
		const li = event.currentTarget;
		const controlName = li.dataset.control;
		if ( this.activeControl === controlName ) return;
		this.activeControl = controlName;
		const control = this.controls.find(c => c.name === controlName);
		if ( control ) canvas[control.layer].activate();
	}

	/* -------------------------------------------- */

	/**
	 * Handle click events on Tool controls
	 * @param {Event} event   A click event on a tool control
	 * @private
	 */
	_onClickTool(event) {
		event.preventDefault();
		if ( !canvas.ready ) return;
		const li = event.currentTarget;
		const control = this.control;
		const toolName = li.dataset.tool;
		const tool = control.tools.find(t => t.name === toolName);

		// Handle Toggles
		if ( tool.toggle ) {
			tool.active = !tool.active;
			if ( tool.onClick instanceof Function ) tool.onClick(tool.active);
		}

		// Handle Buttons
		else if ( tool.button ) {
			if ( tool.onClick instanceof Function ) tool.onClick();
		}

		// Handle Tools
		else {
			control.activeTool = toolName;
			if ( tool.onClick instanceof Function ) tool.onClick();
		}

		// Render the controls
		this.render();
	}

	/* -------------------------------------------- */

	/**
	 * Get the set of Control sets and tools that are rendered as the Scene Controls.
	 * These controls may be extended using the "getSceneControlButtons" Hook.
	 * @return {SceneControl[]}
	 * @private
	 */
	_getControlButtons() {
		const controls = [];
		const isGM = game.user.isGM;

		// Token Controls
		controls.push({
			name: "token",
			title: "CONTROLS.GroupToken",
			layer: "tokens",
			icon: "fas fa-user-alt",
			tools: [
				{
					name: "select",
					title: "CONTROLS.BasicSelect",
					icon: "fas fa-expand"
				},
				{
					name: "target",
					title: "CONTROLS.TargetSelect",
					icon: "fas fa-bullseye"
				},
				{
					name: "ruler",
					title: "CONTROLS.BasicMeasure",
					icon: "fas fa-ruler"
				}
			],
			activeTool: "select"
		});

		// Measurement Layer Tools
		controls.push({
			name: "measure",
			title: "CONTROLS.GroupMeasure",
			layer: "templates",
			icon: "fas fa-ruler-combined",
			visible: game.user.can("TEMPLATE_CREATE"),
			tools: [
				{
					name: "circle",
					title: "CONTROLS.MeasureCircle",
					icon: "far fa-circle"
				},
				{
					name: "cone",
					title: "CONTROLS.MeasureCone",
					icon: "fas fa-angle-left"
				},
				{
					name: "rect",
					title: "CONTROLS.MeasureRect",
					icon: "far fa-square"
				},
				{
					name: "ray",
					title: "CONTROLS.MeasureRay",
					icon: "fas fa-arrows-alt-v"
				},
				{
					name: "clear",
					title: "CONTROLS.MeasureClear",
					icon: "fas fa-trash",
					visible: isGM,
					onClick: () => canvas.templates.deleteAll(),
					button: true
				}
			],
			activeTool: "circle"
		});

		// Tiles Layer
		controls.push({
			name: "tiles",
			title: "CONTROLS.GroupTile",
			layer: "background",
			icon: "fas fa-cubes",
			visible: isGM,
			tools: [
				{
					name: "select",
					title: "CONTROLS.TileSelect",
					icon: "fas fa-expand"
				},
				{
					name: "tile",
					title: "CONTROLS.TilePlace",
					icon: "fas fa-cube"
				},
				{
					name: "browse",
					title: "CONTROLS.TileBrowser",
					icon: "fas fa-folder",
					button: true,
					onClick: () => {
						new FilePicker({
							type: "imagevideo",
							displayMode: "tiles",
							tileSize: true
						}).render(true);
					}
				},
				{
					name: "foreground",
					title: "CONTROLS.TileForeground",
					icon: "fas fa-home",
					toggle: true,
					active: canvas.foreground?._active ?? false,
					onClick: toggled => canvas[toggled ? "foreground" : "background"].activate()
				}
			],
			activeTool: "select"
		});

		// Drawing Tools
		controls.push({
			name: "drawings",
			title: "CONTROLS.GroupDrawing",
			layer: "drawings",
			icon: "fas fa-pencil-alt",
			visible: game.user.can("DRAWING_CREATE"),
			tools: [
				{
					name: "select",
					title: "CONTROLS.DrawingSelect",
					icon: "fas fa-expand"
				},
				{
					name: "rect",
					title: "CONTROLS.DrawingRect",
					icon: "fas fa-square"
				},
				{
					name: "ellipse",
					title: "CONTROLS.DrawingEllipse",
					icon: "fas fa-circle"
				},
				{
					name: "polygon",
					title: "CONTROLS.DrawingPoly",
					icon: "fas fa-draw-polygon"
				},
				{
					name: "freehand",
					title: "CONTROLS.DrawingFree",
					icon: "fas fa-signature"
				},
				{
					name: "text",
					title: "CONTROLS.DrawingText",
					icon: "fas fa-font"
				},
				{
					name: "configure",
					title: "CONTROLS.DrawingConfig",
					icon: "fas fa-cog",
					onClick: () => canvas.drawings.configureDefault(),
					button: true
				},
				{
					name: "clear",
					title: "CONTROLS.DrawingClear",
					icon: "fas fa-trash",
					visible: isGM,
					onClick: () => canvas.drawings.deleteAll(),
					button: true
				}
			],
			activeTool: "select"
		});

		// Walls Layer Tools
		controls.push({
			name: "walls",
			title: "CONTROLS.GroupWall",
			layer: "walls",
			icon: "fas fa-university",
			visible: isGM,
			tools: [
				{
					name: "select",
					title: "CONTROLS.WallSelect",
					icon: "fas fa-expand"
				},
				{
					name: "walls",
					title: "CONTROLS.WallDraw",
					icon: "fas fa-bars"
				},
				{
					name: "terrain",
					title: "CONTROLS.WallTerrain",
					icon: "fas fa-mountain"
				},
				{
					name: "invisible",
					title: "CONTROLS.WallInvisible",
					icon: "fas fa-eye-slash"
				},
				{
					name: "ethereal",
					title: "CONTROLS.WallEthereal",
					icon: "fas fa-mask"
				},
				{
					name: "doors",
					title: "CONTROLS.WallDoors",
					icon: "fas fa-door-open"
				},
				{
					name: "secret",
					title: "CONTROLS.WallSecret",
					icon: "fas fa-user-secret"
				},
				{
					name: "clone",
					title: "CONTROLS.WallClone",
					icon: "far fa-clone"
				},
				{
					name: "snap",
					title: "CONTROLS.WallSnap",
					icon: "fas fa-plus",
					toggle: true,
					active: canvas.walls?._forceSnap || false,
					onClick: toggled => canvas.walls._forceSnap = toggled
				},
				{
					name: "clear",
					title: "CONTROLS.WallClear",
					icon: "fas fa-trash",
					onClick: () => canvas.walls.deleteAll(),
					button: true
				}
			],
			activeTool: "walls"
		});

		// Lighting Layer Tools
		controls.push({
			name: "lighting",
			title: "CONTROLS.GroupLighting",
			layer: "lighting",
			icon: "far fa-lightbulb",
			visible: isGM,
			tools: [
				{
					name: "light",
					title: "CONTROLS.LightDraw",
					icon: "fas fa-lightbulb"
				},
				{
					name: "day",
					title: "CONTROLS.LightDay",
					icon: "fas fa-sun",
					onClick: () => canvas.scene.update({darkness: 0.0}, {animateDarkness: 10000}),
					button: true
				},
				{
					name: "night",
					title: "CONTROLS.LightNight",
					icon: "fas fa-moon",
					onClick: () => canvas.scene.update({darkness: 1.0}, {animateDarkness: 10000}),
					button: true
				},
				{
					name: "reset",
					title: "CONTROLS.LightReset",
					icon: "fas fa-cloud",
					onClick: () => {
						new Dialog({
							title: game.i18n.localize("CONTROLS.FOWResetTitle"),
							content: `<p>${game.i18n.localize("CONTROLS.FOWResetDesc")}</p>`,
							buttons: {
								yes: {
									icon: '<i class="fas fa-check"></i>',
									label: "Yes",
									callback: () => canvas.sight.resetFog()
								},
								no: {
									icon: '<i class="fas fa-times"></i>',
									label: "No"
								}
							}
						}).render(true);
					},
					button: true
				},
				{
					name: "clear",
					title: "CONTROLS.LightClear",
					icon: "fas fa-trash",
					onClick: () => canvas.lighting.deleteAll(),
					button: true
				}
			],
			activeTool: "light"
		});

		// Sounds Layer Tools
		controls.push({
			name: "sounds",
			title: "CONTROLS.GroupSound",
			layer: "sounds",
			icon: "fas fa-music",
			visible: isGM,
			tools: [
				{
					name: "sound",
					title: "CONTROLS.SoundDraw",
					icon: "fas fa-volume-up"
				},
				{
					name: "preview",
					title: "CONTROLS.SoundPreview",
					icon: "fas fa-headphones",
					toggle: true,
					active: canvas.sounds?.livePreview ?? false,
					onClick: toggled => {
						canvas.sounds.livePreview = toggled;
						canvas.sounds.update();
					}
				},
				{
					name: "clear",
					title: "CONTROLS.SoundClear",
					icon: "fas fa-trash",
					onClick: () => canvas.sounds.deleteAll(),
					button: true
				}
			],
			activeTool: "sound"
		});

		// Notes Layer Tools
		controls.push({
			name: "notes",
			title: "CONTROLS.GroupNotes",
			layer: "notes",
			icon: "fas fa-bookmark",
			tools: [
				{
					name: "select",
					title: "CONTROLS.NoteSelect",
					icon: "fas fa-expand"
				},
				{
					name: "toggle",
					title: "CONTROLS.NoteToggle",
					icon: "fas fa-map-pin",
					toggle: true,
					active: game.settings.get("core", NotesLayer.TOGGLE_SETTING),
					onClick: toggled => game.settings.set("core", NotesLayer.TOGGLE_SETTING, toggled)
				},
				{
					name: "clear",
					title: "CONTROLS.NoteClear",
					icon: "fas fa-trash",
					visible: isGM,
					onClick: () => canvas.notes.deleteAll(),
					button: true
				}
			],
			activeTool: 'select'
		});

		// Pass the Scene Controls to a hook function to allow overrides or changes
		Hooks.callAll(`getSceneControlButtons`, controls);
		return controls;
	}
}

/**
 * The global action bar displayed at the bottom of the game view.
 * The Hotbar is a UI element at the bottom of the screen which contains Macros as interactive buttons.
 * The Hotbar supports 5 pages of global macros which can be dragged and dropped to organize as you wish.
 *
 * Left clicking a Macro button triggers its effect.
 * Right clicking the button displays a context menu of Macro options.
 * The number keys 1 through 0 activate numbered hotbar slots.
 * Pressing the delete key while hovering over a Macro will remove it from the bar.
 *
 * @extends {Application}
 *
 * @see {@link Macros}
 * @see {@link Macro}
 */
class Hotbar extends Application {
	constructor(options) {
		super(options);
		game.macros.apps.push(this);

		/**
		 * The currently viewed macro page
		 * @type {number}
		 */
		this.page = 1;

		/**
		 * The currently displayed set of macros
		 * @type {Macro[]}
		 */
		this.macros = [];

		/**
		 * Track collapsed state
		 * @type {boolean}
		 */
		this._collapsed = false;

		/**
		 * Track which hotbar slot is the current hover target, if any
		 * @type {number|null}
		 */
		this._hover = null;
	}

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "hotbar",
			template: "templates/hud/hotbar.html",
			popOut: false,
			dragDrop: [{ dragSelector: ".macro-icon", dropSelector: "#macro-list" }]
		});
	}

	/* -------------------------------------------- */

	/** @override */
	getData(options) {
		this.macros = this._getMacrosByPage(this.page);
		return {
			page: this.page,
			macros: this.macros,
			barClass: this._collapsed ? "collapsed" : ""
		};
	}

	/* -------------------------------------------- */

	/**
	 * Get the Array of Macro (or null) values that should be displayed on a numbered page of the bar
	 * @param {number} page
	 * @returns {Macro[]}
	 * @private
	 */
	_getMacrosByPage(page) {
		const macros = game.user.getHotbarMacros(page);
		for ( let [i, m] of macros.entries() ) {
			m.key = i<9 ? i+1 : 0;
			m.cssClass = m.macro ? "active" : "inactive";
			m.icon = m.macro ? m.macro.data.img : null;
		}
		return macros;
	}

	/* -------------------------------------------- */

	/**
	 * Collapse the Hotbar, minimizing its display.
	 * @return {Promise}    A promise which resolves once the collapse animation completes
	 */
	async collapse() {
		if ( this._collapsed ) return true;
		const toggle = this.element.find("#bar-toggle");
		const icon = toggle.children("i");
		const bar = this.element.find("#action-bar");
		return new Promise(resolve => {
			bar.slideUp(200, () => {
				bar.addClass("collapsed");
				icon.removeClass("fa-caret-down").addClass("fa-caret-up");
				this._collapsed = true;
				resolve(true);
			});
		});
	}

	/* -------------------------------------------- */

	/**
	 * Expand the Hotbar, displaying it normally.
	 * @return {Promise}    A promise which resolves once the expand animation completes
	 */
	async expand() {
		if ( !this._collapsed ) return true;
		const toggle = this.element.find("#bar-toggle");
		const icon = toggle.children("i");
		const bar = this.element.find("#action-bar");
		return new Promise(resolve => {
			bar.slideDown(200, () => {
				bar.css("display", "");
				bar.removeClass("collapsed");
				icon.removeClass("fa-caret-up").addClass("fa-caret-down");
				this._collapsed = false;
				resolve(true);
			});
		});
	}

	/* -------------------------------------------- */

	/**
	 * Change to a specific numbered page from 1 to 5
	 * @param {number} page     The page number to change to.
	 */
	changePage(page) {
		this.page = Math.clamped(page ?? 1, 1, 5);
		this.render();
	}

	/* -------------------------------------------- */

	/**
	 * Change the page of the hotbar by cycling up (positive) or down (negative)
	 * @param {number} direction    The direction to cycle
	 */
	cyclePage(direction) {
		direction = Number.isNumeric(direction) ? Math.sign(direction) : 1;
		if ( direction > 0 ) {
			this.page = this.page < 5 ? this.page+1 : 1;
		} else {
			this.page = this.page > 1 ? this.page-1 : 5;
		}
		this.render();
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);

		// Macro actions
		html.find('#bar-toggle').click(this._onToggleBar.bind(this));
		html.find("#macro-directory").click(ev => ui.macros.renderPopout(true));
		html.find(".macro").click(this._onClickMacro.bind(this)).hover(this._onHoverMacro.bind(this));
		html.find(".page-control").click(this._onClickPageControl.bind(this));

		// Activate context menu
		this._contextMenu(html);
	}

	/* -------------------------------------------- */

	/**
	 * Create a Context Menu attached to each Macro button
	 * @param {jQuery} html   The HTML being rendered for the hotbar
	 * @private
	 */
	_contextMenu(html) {
		new ContextMenu(html, ".macro", [
			{
				name: "MACRO.Edit",
				icon: '<i class="fas fa-edit"></i>',
				condition: li => {
					const macro = game.macros.get(li.data("macro-id"));
					return macro ? macro.isOwner : false;
				},
				callback: li => {
					const macro = game.macros.get(li.data("macro-id"));
					macro.sheet.render(true);
				}
			},
			{
				name: "MACRO.Remove",
				icon: '<i class="fas fa-times"></i>',
				condition: li => !!li.data("macro-id"),
				callback: li => game.user.assignHotbarMacro(null, Number(li.data("slot")))
			},
			{
				name: "MACRO.Delete",
				icon: '<i class="fas fa-trash"></i>',
				condition: li => {
					const macro = game.macros.get(li.data("macro-id"));
					return macro ? macro.isOwner : false;
				},
				callback: li => {
					const macro = game.macros.get(li.data("macro-id"));
					return Dialog.confirm({
						title: `${game.i18n.localize("MACRO.Delete")} ${macro.name}`,
						content: `<h4>${game.i18n.localize("AreYouSure")}</h4><p>${game.i18n.localize("MACRO.DeleteWarning")}</p>`,
						yes: macro.delete.bind(macro)
					});
				}
			},
		]);
	}

	/* -------------------------------------------- */

	/**
	 * Handle left-click events to
	 * @param {MouseEvent} event    The originating click event
	 * @protected
	 */
	async _onClickMacro(event) {
		event.preventDefault();
		const li = event.currentTarget;

		// Case 1 - create a new Macro
		if ( li.classList.contains("inactive") ) {
			const macro = await Macro.create({name: "New Macro", type: "chat", scope: "global"});
			await game.user.assignHotbarMacro(macro, Number(li.dataset.slot));
			macro.sheet.render(true);
		}

		// Case 2 - trigger a Macro
		else {
			const macro = game.macros.get(li.dataset.macroId);
			return macro.execute();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle hover events on a macro button to track which slot is the hover target
	 * @param {Event} event   The originating mouseover or mouseleave event
	 * @private
	 */
	_onHoverMacro(event) {
		event.preventDefault();
		const li = event.currentTarget;
		const hasAction = !li.classList.contains("inactive");

		// Remove any existing tooltip
		const tooltip = li.querySelector(".tooltip");
		if ( tooltip ) li.removeChild(tooltip);

		// Handle hover-in
		if ( event.type === "mouseenter" ) {
			this._hover = li.dataset.slot;
			if ( hasAction ) {
				const macro = game.macros.get(li.dataset.macroId);
				const tooltip = document.createElement("SPAN");
				tooltip.classList.add("tooltip");
				tooltip.textContent = macro.name;
				li.appendChild(tooltip);
			}
		}

		// Handle hover-out
		else {
			this._hover = null;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle pagination controls
	 * @param {Event} event   The originating click event
	 * @private
	 */
	_onClickPageControl(event) {
		this.cyclePage(event.currentTarget.dataset.action === "page-up" ? 1 : -1);
	}

	/* -------------------------------------------- */

	/** @override */
	_canDragStart(selector) {
		return true;
	}

	/* -------------------------------------------- */

	/** @override */
	_onDragStart(event) {
		const li = event.currentTarget.closest(".macro");
		if ( !li.dataset.macroId ) return false;
		const dragData = { type: "Macro", id: li.dataset.macroId, slot: li.dataset.slot };
		event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
	}

	/* -------------------------------------------- */

	/** @override */
	_canDragDrop(selector) {
		return true;
	}

	/* -------------------------------------------- */

	/** @override */
	async _onDrop(event) {
		event.preventDefault();
		const li = event.target.closest(".macro");
		const slot = Number(li.dataset.slot);

		// Extract drop data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData('text/plain'));
		}
		catch (err) { return }

		/**
		 * A hook event that fires whenever data is dropped into a Hotbar slot.
		 * The hook provides a reference to the Hotbar application, the dropped data, and the target slot.
		 * Default handling of the drop event can be prevented by returning false within the hooked function.
		 *
		 * @function hotbarDrop
		 * @memberof hookEvents
		 * @param {Hotbar} hotbar       The Hotbar application instance
		 * @param {object} data         The dropped data object
		 * @param {number} slot         The target hotbar slot
		 */
		if ( Hooks.call("hotbarDrop", this, data, slot) === false ) return;

		// Only handle Macro drops
		let macro = await Macro.fromDropData(data);
		if ( !macro ) return;
		if ( !game.macros.has(macro.id) ) {
			macro = await Macro.create(macro.toJSON());
		}
		return game.user.assignHotbarMacro(macro, slot, {fromSlot: data.slot});
	}

	/* -------------------------------------------- */

	/**
	 * Handle click events to toggle display of the macro bar
	 * @param {Event} event
	 * @private
	 */
	_onToggleBar(event) {
		event.preventDefault();
		if ( this._collapsed ) return this.expand();
		else return this.collapse();
	}
}

/**
 * An abstract base class for displaying a heads-up-display interface bound to a Placeable Object on the canvas
 * @type {Application}
 * @abstract
 * @interface
 */
class BasePlaceableHUD extends Application {

	/**
	 * Reference a PlaceableObject this HUD is currently bound to
	 * @type {PlaceableObject}
	 */
	object = undefined;

	/* -------------------------------------------- */

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["placeable-hud"],
			popOut: false
		});
	}

	/* -------------------------------------------- */

	/**
	 * Convenience access for the canvas layer which this HUD modifies
	 * @type {PlaceablesLayer}
	 */
	get layer() {
		return this.object?.layer;
	}

	/* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */

	/**
	 * Bind the HUD to a new PlaceableObject and display it
	 * @param {PlaceableObject} object    A PlaceableObject instance to which the HUD should be bound
	 */
	bind(object) {
		const states = this.constructor.RENDER_STATES;
		if ( [states.CLOSING, states.RENDERING].includes(this._state) ) return;
		if ( this.object ) this.clear();

		// Record the new object
		if ( !(object instanceof PlaceableObject ) || (object.scene !== canvas.scene) ) {
			throw new Error("You may only bind a HUD instance to a PlaceableObject in the currently viewed Scene.")
		}
		this.object = object;

		// Render the HUD
		this.render(true);
		this.element.hide().fadeIn(200);
	}

	/* -------------------------------------------- */

	/**
	 * Clear the HUD by fading out it's active HTML and recording the new display state
	 */
	clear() {
		let states = this.constructor.RENDER_STATES;
		if ( this._state <= states.NONE ) return;
		this._state = states.CLOSING;

		// Unbind
		this.object = null;
		this.element.hide();
		this._element = null;
		this._state = states.NONE
	}

	/* -------------------------------------------- */

	/** @override */
	async _render(...args) {
		await super._render(...args);
		this.setPosition();
	}

	/* -------------------------------------------- */

	/** @override */
	getData(options) {
		const data = this.object.data.toObject();
		return foundry.utils.mergeObject(data, {
			id: this.id,
			classes: this.options.classes.join(" "),
			appId: this.appId,
			isGM: game.user.isGM,
			icons: CONFIG.controlIcons
		});
	}

	/* -------------------------------------------- */

	/** @override */
	setPosition({left, top, width, height, scale}={}) {
		const position = {
			width: width || this.object.width,
			height: height || this.object.height,
			left: left ?? this.object.x,
			top: top ?? this.object.y
		};
		this.element.css(position);
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		html.find(".control-icon").click(this._onClickControl.bind(this));
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse clicks to control a HUD control button
	 * @param {PointerEvent} event    The originating click event
	 * @protected
	 */
	_onClickControl(event) {
		const button = event.currentTarget;
		switch ( button.dataset.action ) {
			case "visibility":
				return this._onToggleVisibility(event);
			case "locked":
				return this._onToggleLocked(event);
			case "sort-up":
				return this._onSort(event, true);
			case "sort-down":
				return this._onSort(event, false);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Toggle the visible state of all controlled objects in the Layer
	 * @param {PointerEvent} event    The originating click event
	 * @private
	 */
	async _onToggleVisibility(event) {
		event.preventDefault();

		// Toggle the visible state
		const isHidden = this.object.data.hidden;
		const updates = this.layer.controlled.map(o => {
			return {_id: o.id, hidden: !isHidden};
		});

		// Update all objects
		event.currentTarget.classList.toggle("active", !isHidden);
		return canvas.scene.updateEmbeddedDocuments(this.object.document.documentName, updates);
	}

	/* -------------------------------------------- */

	/**
	 * Toggle locked state of all controlled objects in the Layer
	 * @param {PointerEvent} event    The originating click event
	 * @private
	 */
	async _onToggleLocked(event) {
		event.preventDefault();

		// Toggle the visible state
		const isLocked = this.object.data.locked;
		const updates = this.layer.controlled.map(o => {
			return {_id: o.id, locked: !isLocked};
		});

		// Update all objects
		event.currentTarget.classList.toggle("active", !isLocked);
		return canvas.scene.updateEmbeddedDocuments(this.object.document.documentName, updates);
	}

	/* -------------------------------------------- */

	/**
	 * Handle sorting the z-order of the object
	 * @param {boolean} up            Move the object upwards in the vertical stack?
	 * @param {PointerEvent} event    The originating mouse click event
	 * @return {Promise}
	 * @protected
	 */
	async _onSort(event, up) {
		event.preventDefault();
		const siblings = this.layer.placeables;
		const controlled = this.layer.controlled.filter(o => !o.data.locked);

		// Determine target sort index
		let z = 0;
		if ( up ) {
			controlled.sort((a, b) => a.data.z - b.data.z);
			z = siblings.length ? Math.max(...siblings.map(o => o.data.z)) + 1 : 1;
		}
		else {
			controlled.sort((a, b) => b.data.z - a.data.z);
			z = siblings.length ? Math.min(...siblings.map(o => o.data.z)) - 1 : -1;
		}

		// Update all controlled objects
		const updates = controlled.map((o, i) => {
			let d = up ? i : i * -1;
			return {_id: o.id, z: z + d};
		});
		return canvas.scene.updateEmbeddedDocuments(this.object.document.documentName, updates);
	}
}

/**
 * A simple main menu application
 * @type {Application}
 */
class MainMenu extends Application {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = "menu";
		options.template = "templates/hud/menu.html";
		options.popOut = false;
		return options;
	}

	/* ----------------------------------------- */

	/**
	 * The structure of menu items
	 * @return {Object}
	 */
	get items() {
		return {
			 reload: {
				label: "MENU.Reload",
				icon: '<i class="fas fa-redo"></i>',
				enabled: true,
				onClick: () => window.location.reload()
			},
			logout: {
				label: "MENU.Logout",
				icon: '<i class="fas fa-user"></i>',
				enabled: true,
				onClick: () => game.logOut()
			},
			players: {
				label: "MENU.Players",
				icon: '<i class="fas fa-users"></i>',
				enabled: game.user.isGM,
				onClick: () => window.location.href = "./players"
			},
			world: {
				label: "MENU.Setup",
				icon: '<i class="fas fa-globe"></i>',
				enabled: game.user.hasRole("GAMEMASTER"),
				onClick: () => game.shutDown()
			}
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		return {
			items: this.items
		}
	}

	/* ----------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		for ( let [k, v] of Object.entries(this.items) ) {
			html.find('.menu-'+k).click(ev => v.onClick());
		}
	}

	/* ----------------------------------------- */

	/**
	 * Toggle display of the menu (or render it in the first place)
	 */
	toggle() {
		let menu = this.element;
		if ( !menu.length ) this.render(true);
		else menu.slideToggle(150);
	}
}
/**
 * Top menu scene navigation
 * @extends {Application}
 */
class SceneNavigation extends Application {
	constructor(options) {
		super(options);
		game.scenes.apps.push(this);

		/**
		 * Navigation collapsed state
		 * @type {boolean}
		 */
		this._collapsed = false;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "navigation",
			template: "templates/hud/navigation.html",
			popOut: false,
			dragDrop: [{dragSelector: ".scene"}]
		});
	}

	/* -------------------------------------------- */

	/**
	 * Return an Array of Scenes which are displayed in the Navigation bar
	 * @return {Scene[]}
	 */
	get scenes() {
		const scenes = game.scenes.filter(s => {
			return (s.data.navigation && s.visible) || s.active || s.isView;
		});
		scenes.sort((a, b) => a.data.navOrder - b.data.navOrder);
		return scenes;
	}

	/* -------------------------------------------- */
	/*  Application Rendering
	/* -------------------------------------------- */

	/** @inheritdoc */
	render(force, context={}) {
		let { renderContext, renderData} = context;
		if ( renderContext ) {
			const events = ["createScene", "updateScene", "deleteScene"];
			if ( !events.includes(renderContext) ) return;
			const updateKeys = ["name", "permission", "permission.default", "active", "navigation", "navName", "navOrder"];
			if ( renderContext === "updateScene" && !updateKeys.some(k => renderData.hasOwnProperty(k)) ) return;
		}
		return super.render(force, context);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _render(force, options) {
		await super._render(force, options);
		const loading = document.getElementById("loading");
		const nav = this.element[0];
		loading.style.top = `${nav.offsetTop + nav.offsetHeight}px`;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {

		// Modify Scene data
		const scenes = this.scenes.map(scene => {
			let data = scene.data.toObject(false);
			let users = game.users.filter(u => u.active && (u.viewedScene === scene.id));
			data.name = TextEditor.truncateText(data.navName || data.name, {maxLength: 32});
			data.users = users.map(u => { return {letter: u.name[0], color: u.data.color} });
			data.visible = (game.user.isGM || scene.isOwner || scene.active);
			data.css = [
				scene.isView ? "view" : null,
				scene.active ? "active" : null,
				data.permission.default === 0 ? "gm" : null
			].filter(c => !!c).join(" ");
			return data;
		});

		// Return data for rendering
		return {
			collapsed: this._collapsed,
			scenes: scenes
		}
	}

	/* -------------------------------------------- */

	/**
	 * Expand the SceneNavigation menu, sliding it down if it is currently collapsed
	 */
	expand() {
		if ( !this._collapsed ) return true;
		const nav = this.element;
		const icon = nav.find("#nav-toggle i.fas");
		const ul = nav.children("#scene-list");
		return new Promise(resolve => {
			ul.slideDown(200, () => {
				nav.removeClass("collapsed");
				icon.removeClass("fa-caret-down").addClass("fa-caret-up");
				this._collapsed = false;
				Hooks.callAll("collapseSceneNavigation", this, this._collapsed);
				return resolve(true);
			});
		});
	}

	/* -------------------------------------------- */

	/**
	 * Collapse the SceneNavigation menu, sliding it up if it is currently expanded
	 * @return {Promise<boolean>}
	 */
	async collapse() {
		if ( this._collapsed ) return true;
		const nav = this.element;
		const icon = nav.find("#nav-toggle i.fas");
		const ul = nav.children("#scene-list");
		return new Promise(resolve => {
			ul.slideUp(200, () => {
				nav.addClass("collapsed");
				icon.removeClass("fa-caret-up").addClass("fa-caret-down");
				this._collapsed = true;
				Hooks.callAll("collapseSceneNavigation", this, this._collapsed);
				return resolve(true);
			});
		});
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		super.activateListeners(html);

		// Click event listener
		const scenes = html.find('.scene');
		scenes.click(this._onClickScene.bind(this));
		html.find('#nav-toggle').click(this._onToggleNav.bind(this));

		// Activate Context Menu
		const contextOptions = this._getContextMenuOptions();
		Hooks.call("getSceneNavigationContext", html, contextOptions);
		if ( contextOptions ) new ContextMenu(html, ".scene", contextOptions);
	}

	/* -------------------------------------------- */

	/**
	 * Get the set of ContextMenu options which should be applied for Scenes in the menu
	 * @return {object[]}   The Array of context options passed to the ContextMenu instance
	 * @private
	 */
	_getContextMenuOptions() {
		return [
			{
				name: "SCENES.Activate",
				icon: '<i class="fas fa-bullseye"></i>',
				condition: li => game.user.isGM && !game.scenes.get(li.data("sceneId")).data.active,
				callback: li => {
					let scene = game.scenes.get(li.data("sceneId"));
					scene.activate();
				}
			},
			{
				name: "SCENES.Configure",
				icon: '<i class="fas fa-cogs"></i>',
				condition: game.user.isGM,
				callback: li => {
					let scene = game.scenes.get(li.data("sceneId"));
					scene.sheet.render(true);
				}
			},
			{
				name: "SCENES.Notes",
				icon: '<i class="fas fa-scroll"></i>',
				condition: li => {
					if ( !game.user.isGM ) return false;
					const scene = game.scenes.get(li.data("sceneId"));
					return !!scene.journal;
				},
				callback: li => {
					const scene = game.scenes.get(li.data("sceneId"));
					const entry = scene.journal;
					if ( entry ) {
						const sheet = entry.sheet;
						sheet.options.sheetMode = "text";
						sheet.render(true);
					}
				}
			},
			{
				name: "SCENES.Preload",
				icon: '<i class="fas fa-download"></i>',
				condition: game.user.isGM,
				callback: li => {
					let sceneId = li.attr("data-scene-id");
					game.scenes.preload(sceneId, true);
				}
			},
			{
				name: "SCENES.ToggleNav",
				icon: '<i class="fas fa-compass"></i>',
				condition: li => {
					const scene = game.scenes.get(li.data("sceneId"));
					return game.user.isGM && ( !scene.data.active );
				},
				callback: li => {
					const scene = game.scenes.get(li.data("sceneId"));
					scene.update({navigation: !scene.data.navigation});
				}
			}
		];
	}

	/* -------------------------------------------- */

	/**
	 * Handle left-click events on the scenes in the navigation menu
	 * @param {Event} event
	 * @private
	 */
	_onClickScene(event) {
		event.preventDefault();
		let sceneId = event.currentTarget.dataset.sceneId;
		game.scenes.get(sceneId).view();
	}

	/* -------------------------------------------- */

	/** @override */
	_onDragStart(event) {
		const sceneId = event.currentTarget.dataset.sceneId;
		event.dataTransfer.setData("text/plain", JSON.stringify({
			type: "SceneNavigation",
			id: sceneId,
		}));
	}

	/* -------------------------------------------- */

	/** @override */
	async _onDrop(event) {

		// Process drop data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData("text/plain"));
		} catch(err) {
			return false;
		}
		if ( data.type !== "SceneNavigation" ) return false;

		// Identify the entity, the drop target, and the set of siblings
		const entity = game.scenes.get(data.id);
		const dropTarget = event.target.closest(".scene") || null;
		const sibling = dropTarget ? game.scenes.get(dropTarget.dataset.sceneId) : null;
		if ( sibling && (sibling._id === entity._id) ) return;
		const siblings = this.scenes.filter(s => s._id !== entity._id);

		// Update the navigation sorting for each Scene
		entity.sortRelative({
			target: sibling,
			siblings: siblings,
			sortKey: "navOrder",
			sortBefore: true
		});
	}

	/* -------------------------------------------- */

	/**
	 * Handle navigation menu toggle click events
	 * @param {Event} event
	 * @private
	 */
	_onToggleNav(event) {
		event.preventDefault();
		if ( this._collapsed ) this.expand();
		else this.collapse();
	}

	/* -------------------------------------------- */

	static _onLoadProgress(context, pct) {
		const loader = document.getElementById("loading");
		pct = Math.clamped(pct, 0, 100);
		loader.querySelector("#context").textContent = context;
		loader.querySelector("#loading-bar").style.width = `${pct}%`;
		loader.querySelector("#progress").textContent = `${pct}%`;
		loader.style.display = "block";
		if ( (pct === 100 ) && !loader.hidden) $(loader).fadeOut(2000);
	}
}

/**
 * Pause notification in the HUD
 * @extends {Application}
 */
class Pause extends Application {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = "pause";
		options.template = "templates/hud/pause.html";
		options.popOut = false;
		return options;
	}

	/** @override */
	getData(options) {
		return { paused: game.paused };
	}
}


/**
 * The active Player List application
 * @extends {Application}
 */
class PlayerList extends Application {
	constructor(options) {
		super(options);
		game.users.apps.push(this);

		/**
		 * An internal toggle for whether or not to show offline players or hide them
		 * @type {boolean}
		 * @private
		 */
		this._showOffline = false;
	}

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "players",
			template: "templates/user/players.html",
			popOut: false
		});
	}

	/* -------------------------------------------- */
	/*  Application Rendering
	/* -------------------------------------------- */

	/** @override */
	render(force, context={}) {
		let { renderContext, renderData} = context;
		if ( renderContext ) {
			const events = ["createUser", "updateUser", "deleteUser"];
			if ( !events.includes(renderContext) ) return;
			const updateKeys = ["name", "permission", "permission.default", "active", "navigation"];
			if ( renderContext === "updateUser" && !updateKeys.some(k => renderData.hasOwnProperty(k)) ) return;
		}
		return super.render(force, context);
	}

	/* -------------------------------------------- */

	/** @override */
	getData(options) {

		// Process user data by adding extra characteristics
		const users = game.users.filter(u => this._showOffline || u.active).map(u => {
			u.charname = u.character ? u.character.name.split(" ")[0] : "";
			const color = u.active ? u.data.color : "#333333",
					rgb = PIXI.utils.hex2rgb(color.replace("#", "0x")),
					border = u.active ? PIXI.utils.hex2string(PIXI.utils.rgb2hex(rgb.map(c => Math.min(c * 2, 1)))) : "#000000";
			u.color = color;
			u.border = border;
			return u;
		}).sort((a, b) => {
			if ( (b.role >= CONST.USER_ROLES.ASSISTANT) && (b.role > a.role) ) return 1;
			return a.name.localeCompare(b.name);
		})

		// Determine whether to hide the players list when using AV conferencing
		let hide = false;
		if ( game.webrtc && game.webrtc.settings.mode >= AVSettings.AV_MODES.VIDEO ) {
			hide = game.webrtc.settings.client.hidePlayerList;
		}

		// Return the data for rendering
		return {
			users: users,
			showOffline: this._showOffline,
			hide: hide
		};
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {

		// Toggle online/offline
		html.find("h3").click(this._onToggleOfflinePlayers.bind(this));

		// Context menu
		const contextOptions = this._getUserContextOptions();
		Hooks.call(`getUserContextOptions`, html, contextOptions);
		new ContextMenu(html, ".player", contextOptions);
	}

	/* -------------------------------------------- */

	/**
	 * Return the default context options available for the Players application
	 * @return {object[]}
	 * @private
	 */
	_getUserContextOptions() {
		return [
			{
				name: game.i18n.localize("PLAYERS.ConfigTitle"),
				icon: '<i class="fas fa-male"></i>',
				condition: li => game.user.isGM || (li[0].dataset.userId === game.user.id),
				callback: li => {
					const user = game.users.get(li[0].dataset.userId);
					new UserConfig(user).render(true)
				}
			},
			{
				name: game.i18n.localize("PLAYERS.ViewAvatar"),
				icon: '<i class="fas fa-image"></i>',
				condition: li => {
					const user = game.users.get(li[0].dataset.userId);
					return user.avatar !== CONST.DEFAULT_TOKEN;
				},
				callback: li => {
					let user = game.users.get(li.data("user-id"));
					new ImagePopout(user.avatar, {
						title: user.name,
						shareable: false,
						uuid: user.uuid
					}).render(true);
				}
			},
			{
				name: game.i18n.localize("PLAYERS.PullToScene"),
				icon: '<i class="fas fa-directions"></i>',
				condition: li => game.user.isGM && (li[0].dataset.userId !== game.user.id),
				callback: li => game.socket.emit("pullToScene", canvas.scene.id, li.data("user-id"))
			},
			{
				name: game.i18n.localize("PLAYERS.Kick"),
				icon: '<i class="fas fa-door-open"></i>',
				condition: li => {
					const user = game.users.get(li[0].dataset.userId);
					return game.user.isGM && user.active && !user.isSelf;
				},
				callback: li => {
					const user = game.users.get(li[0].dataset.userId);
					const role = user.role;
					user.update({role: CONST.USER_ROLES.NONE}).then(u => u.update({role}));
					ui.notifications.info(`${user.name} has been kicked from the world.`);
				}
			},
			{
				name: game.i18n.localize("PLAYERS.Ban"),
				icon: '<i class="fas fa-ban"></i>',
				condition: li => {
					const user = game.users.get(li[0].dataset.userId);
					return game.user.isGM && !user.isSelf && (user.role !== CONST.USER_ROLES.NONE);
				},
				callback: li => {
					const user = game.users.get(li[0].dataset.userId);
					user.update({role: CONST.USER_ROLES.NONE});
					ui.notifications.info(`${user.name} has been <strong>banned</strong> from the world.`);
				}
			},
			{
				name: game.i18n.localize("PLAYERS.UnBan"),
				icon: '<i class="fas fa-ban"></i>',
				condition: li => {
					const user = game.users.get(li[0].dataset.userId);
					return game.user.isGM && !user.isSelf && (user.role === CONST.USER_ROLES.NONE);
				},
				callback: li => {
					const user = game.users.get(li[0].dataset.userId);
					user.update({role: CONST.USER_ROLES.PLAYER});
					ui.notifications.info(`${user.name} has been restored to a Player role in the World.`);
				}
			}
		];
	}

	/* -------------------------------------------- */

	/**
	 * Toggle display of the Players hud setting for whether or not to display offline players
	 * @param {Event} event   The originating click event
	 * @private
	 */
	_onToggleOfflinePlayers(event) {
		event.preventDefault();
		this._showOffline = !this._showOffline;
		this.render();
	}
}

/**
 * Audio/Video Conferencing Configuration Sheet
 * @extends {FormApplication}
 */
class AVConfig extends FormApplication {
	constructor(object, options) {
		super(object || game.webrtc, options);
	}

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			title: game.i18n.localize("WEBRTC.Title"),
			id: "av-config",
			template: "templates/sidebar/apps/av-config.html",
			popOut: true,
			width: 480,
			height: "auto",
			tabs: [{navSelector: ".tabs", contentSelector: "form", initial: "general"}]
		});
	}

	/* -------------------------------------------- */

	/** @override */
	async getData(options) {
		const settings = this.object.settings;
		const videoSources = await this.object.client.getVideoSources();
		const audioSources = await this.object.client.getAudioSources();
		const audioSinks = await this.object.client.getAudioSinks();

		// If the currently chosen device is unavailable, display a separate option for 'unavailable device (use default)'
		const { videoSrc, audioSrc, audioSink } = settings.client;
		const videoSrcUnavailable = videoSrc && (videoSrc !== "default") && !Object.keys(videoSources).includes(videoSrc);
		const audioSrcUnavailable = audioSrc && (audioSrc !== "default") && !Object.keys(audioSources).includes(audioSrc);
		const audioSinkUnavailable = audioSink && (audioSink !== "default") && !Object.keys(audioSinks).includes(audioSink);
		const isSSL = window.location.protocol === "https:";

		// Audio/Video modes
		const modes = {
			[AVSettings.AV_MODES.DISABLED]: "WEBRTC.ModeDisabled",
			[AVSettings.AV_MODES.AUDIO]: "WEBRTC.ModeAudioOnly",
			[AVSettings.AV_MODES.VIDEO]: "WEBRTC.ModeVideoOnly",
			[AVSettings.AV_MODES.AUDIO_VIDEO]: "WEBRTC.ModeAudioVideo"
		};

		// Voice Broadcast modes
		const voiceModes = Object.values(AVSettings.VOICE_MODES).reduce((obj, m) => {
			obj[m] = game.i18n.localize("WEBRTC.VoiceMode"+m.titleCase());
			return obj;
		}, {});

		// Return data to the template
		return {
			user: game.user,
			modes,
			voiceModes,
			serverTypes: {FVTT: "WEBRTC.FVTTSignalingServer", custom: "WEBRTC.CustomSignalingServer"},
			turnTypes: {server: "WEBRTC.TURNServerProvisioned", custom: "WEBRTC.CustomTURNServer"},
			settings,
			canSelectMode: game.user.isGM && isSSL,
			noSSL: !isSSL,
			videoSources,
			audioSources,
			audioSinks: isObjectEmpty(audioSinks) ? false : audioSinks,
			videoSrcUnavailable,
			audioSrcUnavailable,
			audioSinkUnavailable
		};
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);

		// Push-to-talk key assignment
		const ptt = html.find('input[name="client.voice.pttName"]');
		ptt.keydown(this._onPTTKeyDown.bind(this)).mousedown(this._onPTTMouseDown.bind(this));

		// Options below are GM only
		if ( !game.user.isGM ) return;
		html.find('select[name="world.server.type"]').change(this._onServerTypeChanged.bind(this));
		html.find('select[name="world.turn.type"]').change(this._onTurnTypeChanged.bind(this));

		// Activate or de-activate the custom server and turn configuration sections based on current settings
		const settings = this.object.settings;
		this._setConfigSectionEnabled(".webrtc-custom-server-config", settings.world.server.type === "custom");
		this._setConfigSectionEnabled(".webrtc-custom-turn-config", settings.world.turn.type === "custom");
	}

	/* -------------------------------------------- */

	/**
	 * Set a section's input to enabled or disabled
	 * @param {string} selector    Selector for the section to enable or disable
	 * @param {boolean} enabled    Whether to enable or disable this section
	 * @private
	 */
	_setConfigSectionEnabled(selector, enabled = true) {
		let section = this.element.find(selector);
		if (section) {
			section.css("opacity", enabled ? 1.0 : 0.5);
			section.find("input").prop("disabled", !enabled);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Callback when the server type changes
	 * Will enable or disable the server section based on whether the user selected a custom server or not
	 * @param {Event} event   The event that triggered the server type change
	 * @private
	 */
	_onServerTypeChanged(event) {
		event.preventDefault();
		const choice = event.currentTarget.value;
		this._setConfigSectionEnabled(".webrtc-custom-server-config", choice === "custom")
	}

	/* -------------------------------------------- */

	/**
	 * Callback when the turn server type changes
	 * Will enable or disable the turn section based on whether the user selected a custom turn or not
	 * @param {Event} event   The event that triggered the turn server type change
	 * @private
	 */
	_onTurnTypeChanged(event) {
		event.preventDefault();
		const choice = event.currentTarget.value;
		this._setConfigSectionEnabled(".webrtc-custom-turn-config", choice === "custom")
	}

	/* -------------------------------------------- */

	/**
	 * Handle the assignment of a push-to-talk/push-to-mute key
	 * @param {Event} event
	 * @private
	 */
	_onPTTKeyDown(event) {
		event.preventDefault();
		event.target.value = event.originalEvent.key.toUpperCase();
		const form = event.target.form;
		form["client.voice.pttKey"].value = event.originalEvent.keyCode;
		form["client.voice.pttMouse"].value = false;
	}

	/* -------------------------------------------- */

	/**
	 * Handle the assignment of a push-to-talk/push-to-mute mouse key
	 * @param {Event} event
	 * @private
	 */
	_onPTTMouseDown(event) {
		if (document.activeElement !== event.target) return;
		event.preventDefault();
		const button = event.originalEvent.button;
		event.target.value = `MOUSE-${button}`;
		const form = event.target.form;
		form["client.voice.pttKey"].value = button;
		form["client.voice.pttMouse"].value = true;
	}

	/* -------------------------------------------- */

	/** @override */
	async _updateObject(event, formData) {
		const settings = game.webrtc.settings;
		settings.client.videoSrc = settings.client.videoSrc || null;
		settings.client.audioSrc = settings.client.audioSrc || null;
		const update = expandObject(formData);

		// Update world settings
		if ( game.user.isGM ) {
			const world = mergeObject(settings.world, update.world);
			game.settings.set("core", "rtcWorldSettings", world);
		}

		// Update client settings
		const client = mergeObject(settings.client, update.client);
		game.settings.set("core", "rtcClientSettings", client);
	}
}
/**
 * Abstraction of the Application interface to be used with the Draggable class as a substitute for the app
 * This class will represent one popout feed window and handle its positioning and draggability
 * @param {CameraViews} view      The CameraViews application that this popout belongs to
 * @param {string} userId         ID of the user this popout belongs to
 * @param {jQuery} element        The div element of this specific popout window
 */
class CameraPopoutAppWrapper {
	constructor(view, userId, element) {
		this.view = view;
		this.element = element;
		this.userId = userId;
		let setting = game.webrtc.settings.getUser(userId);
		this.setPosition({ left: setting.x, top: setting.y, width: setting.width });
		new Draggable(this, element.find(".camera-view"), element.find(".video-container")[0], true);
	}

	/* -------------------------------------------- */

	/**
	 * Get the current position of this popout window
	 */
	get position() {
		return mergeObject(this.element.position(), {
			width: this.element.outerWidth(),
			height: this.element.outerHeight(),
			scale: 1
		});
	}

	/* -------------------------------------------- */

	/** @override */
	setPosition({ left, top, width, height, scale } = {}) {
		const updates = {};

		// Constrain aspect ratio + 30px for nameplate
		if (width || height) {
			if (width) height = Math.floor(width * 3 / 4 + 30);
			else if (height) width = Math.floor((height - 30) * 4 / 3);
			this.element.outerWidth(width);
			this.element.outerHeight(height);
			updates.width = width;
		}

		// Position
		this.element.css({ left, top });
		if (left) updates.x = left;
		if ( top ) updates.y = top;

		// Save settings
		if ( !isObjectEmpty(updates) ) {
			const current = game.webrtc.settings.client.users[this.userId] || {};
			const update = mergeObject(current, updates);
			game.webrtc.settings.set("client", `users.${this.userId}`, update);
		}
	}

	/* -------------------------------------------- */

	_onResize(event) {}

	/* -------------------------------------------- */

	/** @override */
	bringToTop() {
		let parent = this.element.parent();
		let children = parent.children();
		let lastElement = children[children.length - 1];
		if (lastElement !== this.element[0]) {
			game.webrtc.settings.set("client", `users.${this.userId}.z`, ++this.view.maxZ);
			parent.append(this.element);
		}
	}
}

/**
 * The Camera UI View that displays all the camera feeds as individual video elements.
 * @type {Application}
 *
 * @param {WebRTC} webrtc     The WebRTC Implementation to display
 */
class CameraViews extends Application {
	constructor(webrtc, options) {
		super(options);
		game.users.apps.push(this);
	}

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: "camera-views",
			template: "templates/hud/camera-views.html",
			popOut: false
		});
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the master AV orchestrator instance
	 * @type {AVMaster}
	 */
	get webrtc() {
		return game.webrtc;
	}

	/* -------------------------------------------- */
	/* Public API                                   */
	/* -------------------------------------------- */

	/**
	 * Obtain a reference to the div.camera-view which is used to portray a given Foundry User.
	 * @param {string} userId     The ID of the User entity
	 * @return {HTMLElement|null}
	 */
	getUserCameraView(userId) {
		return this.element.find(`.camera-view[data-user=${userId}]`)[0] || null;
	}

	/* -------------------------------------------- */

	/**
	 * Obtain a reference to the video.user-camera which displays the video channel for a requested Foundry User.
	 * If the user is not broadcasting video this will return null.
	 * @param {string} userId     The ID of the User entity
	 * @return {HTMLVideoElement|null}
	 */
	getUserVideoElement(userId) {
		return this.element.find(`.camera-view[data-user=${userId}] video.user-camera`)[0] || null;
	}

	/* -------------------------------------------- */

	/**
	 * Sets whether a user is currently speaking or not
	 *
	 * @param {string} userId     The ID of the user
	 * @param {boolean} speaking  Whether the user is speaking
	 */
	setUserIsSpeaking(userId, speaking) {
		const view = this.getUserCameraView(userId);
		if ( view ) view.classList.toggle("speaking", speaking);
	}

	/* -------------------------------------------- */
	/*  Application Rendering                       */
	/* -------------------------------------------- */

	/**
	 * Extend the render logic to first check whether a render is necessary based on the context
	 * If a specific context was provided, make sure an update to the navigation is necessary before rendering
	 */
	render(force, context={}) {
		const { renderContext, renderData } = context;
		if (this.webrtc.mode === AVSettings.AV_MODES.DISABLED)
			return;
		if (renderContext) {
			if (renderContext !== "updateUser")
				return;
			const updateKeys = ["name", "permissions", "role", "active", "color", "sort", "character", "avatar"];
			if (!updateKeys.some(k => renderData.hasOwnProperty(k)))
				return;
		}
		return super.render(force, context);
	}

	/* -------------------------------------------- */

	/** @override */
	async _render(force = false, options = {}) {
		await super._render(force, options);
		this._setPlayerListVisibility();
		this.webrtc.onRender();
	}

	/* -------------------------------------------- */

	/** @override */
	getData(options) {
		const settings = this.webrtc.settings;
		const userSettings = settings.users;

		// Get the sorted array of connected users
		const connectedIds = this.webrtc.client.getConnectedUsers();
		const users = connectedIds.reduce((users, u) => {
			const data = this._getDataForUser(u, userSettings[u]);
			if ( data ) users.push(data);
			return users;
		}, []);
		users.sort(this.constructor._sortUsers);

		// Maximum Z of all user popout windows
		this.maxZ = Math.max(...users.map(u => userSettings[u.id].z));

		// Define a dynamic class for the camera dock container which affects it's rendered style
		let dockClass = `camera-size-${settings.client.dockSize} camera-position-${settings.client.dockPosition}`;
		if (!users.some(u => !u.settings.popout)) dockClass += " webrtc-dock-empty";

		// Alter the body class depending on whether the players list is hidden
		if (settings.client.hidePlayerList) document.body.classList.add("players-hidden");
		else document.body.classList.remove("players-hidden");

		// Return data for rendering
		return {
			self: game.user,
			users: users,
			dockClass: dockClass,
			muteAll: settings.muteAll
		};
	}

	/* -------------------------------------------- */

	/**
	 * Prepare rendering data for a single user
	 * @private
	 */
	_getDataForUser(userId, settings) {
		const user = game.users.get(userId);
		if ( !user || !user.active ) return null;
		const charname = user.character ? user.character.name.split(" ")[0] : "";

		// CSS classes for the frame
		const frameClass = settings.popout ? "camera-box-popout" : "camera-box-dock";
		const audioClass = this.webrtc.canUserBroadcastAudio(userId) ? null : "no-audio";
		const videoClass = this.webrtc.canUserBroadcastVideo(userId) ? null : "no-video";

		// Return structured User data
		return {
			user: user,
			id: user.id,
			local: user.isSelf,
			name: user.name,
			color: user.data.color,
			colorAlpha: hexToRGBAString(colorStringToHex(user.data.color), 0.20),
			charname: user.isGM ? game.i18n.localize("GM") : charname,
			avatar: user.avatar,
			settings: settings,
			volume: AudioHelper.volumeToInput(settings.volume),
			cameraViewClass: [frameClass, videoClass, audioClass].filterJoin(" ")
		};
	}

	/* -------------------------------------------- */

	/**
	 * A custom sorting function that orders/arranges the user display frames
	 * @return {number}
	 * @private
	 */
	static _sortUsers(a, b) {
		const as = a.settings;
		const bs = b.settings;
		if (as.popout && bs.popout) return as.z - bs.z; // Sort popouts by z-index
		if (as.popout) return -1;                       // Show popout feeds first
		if (bs.popout) return 1;
		if (a.user.isSelf) return -1;                   // Show local feed first
		if (b.user.isSelf) return 1;
		if (a.hasVideo && !b.hasVideo) return -1;       // Show remote users with a camera before those without
		if (b.hasVideo && !a.hasVideo) return 1;
		return a.user.data.sort - b.user.data.sort;     // Sort according to user order
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {

		// Display controls when hovering over the video container
		let cvh = this._onCameraViewHover.bind(this);
		html.find('.camera-view').hover(cvh, cvh);

		// Handle clicks on AV control buttons
		html.find(".av-control").click(this._onClickControl.bind(this));

		// Handle volume changes
		html.find(".webrtc-volume-slider").change(this._onVolumeChange.bind(this));

		// Hide Global permission icons depending on the A/V mode
		const mode = this.webrtc.mode;
		if (mode === AVSettings.AV_MODES.VIDEO) html.find('[data-action="toggle-audio"]').hide();
		if (mode === AVSettings.AV_MODES.AUDIO) html.find('[data-action="toggle-video"]').hide();

		// Make each popout window draggable
		for (let popout of this.element.find(".app.camera-view-popout")) {
			let box = popout.querySelector(".camera-view");
			new CameraPopoutAppWrapper(this, box.dataset.user, $(popout));
		}

		// Listen to the video's srcObjectSet event to set the display mode of the user.
		for (let video of this.element.find("video")) {
			const view = video.closest(".camera-view");
			this._refreshView(view);
			video.addEventListener('webrtcVideoSet', ev => {
				const view = video.closest(".camera-view");
				if ( view.dataset.user !== ev.detail ) return;
				this._refreshView(view);
			});
		}
	}

	/* -------------------------------------------- */

	/**
	 * On hover in a camera container, show/hide the controls.
	 * @event {Event} event   The original mouseover or mouseout hover event
	 * @private
	 */
	_onCameraViewHover(event) {
		this._toggleControlVisibility(event.currentTarget, event.type === "mouseenter", null);
	}

	/* -------------------------------------------- */

	/**
	 * On clicking on a toggle, disable/enable the audio or video stream.
	 * @event {MouseEvent} event   The originating click event
	 * @private
	 */
	async _onClickControl(event) {
		event.preventDefault();

		// Reference relevant data
		const button = event.currentTarget;
		const action = button.dataset.action;
		const view = button.closest(".camera-view");
		const user = game.users.get(view.dataset.user);
		const settings = this.webrtc.settings;
		const userSettings = settings.getUser(user.id);

		// Handle different actions
		switch ( action ) {

			// Globally block video
			case "block-video": {
				if (!game.user.isGM) break;
				await user.update({"permissions.BROADCAST_VIDEO": !userSettings.canBroadcastVideo});
				this._refreshView(view);
				break;
			}

			// Globally block audio
			case "block-audio": {
				if (!game.user.isGM) break;
				await user.update({"permissions.BROADCAST_AUDIO": !userSettings.canBroadcastAudio});
				this._refreshView(view);
				break;
			}

			// Toggle video display
			case "toggle-video": {
				if ( !user.isSelf ) break;
				if ( userSettings.hidden && !userSettings.canBroadcastVideo ) {
					return ui.notifications.warn("WEBRTC.WarningCannotEnableVideo", {localize: true});
				}
				await settings.set("client", `users.${user.id}.hidden`, !userSettings.hidden);
				this._refreshView(view);
				break;
			}

			// Toggle audio output
			case "toggle-audio":
				if ( !user.isSelf ) break;
				if ( userSettings.muted && !userSettings.canBroadcastAudio ) {
					return ui.notifications.warn("WEBRTC.WarningCannotEnableAudio", {localize: true})
				}
				await settings.set("client", `users.${user.id}.muted`, !userSettings.muted);
				this._refreshView(view);
				break;

			// Toggle mute all peers
			case "mute-peers":
				if ( !user.isSelf ) break;
				await settings.set("client", "muteAll", !settings.client.muteAll);
				this._refreshView(view);
				break;

			// Configure settings
			case "configure":
				return this.webrtc.config.render(true);

			// Toggle popout
			case "toggle-popout":
				await settings.set("client", `users.${user.id}.popout`, !userSettings.popout);
				return this.render();

			// Hide players
			case "toggle-players":
				await settings.set("client", "hidePlayerList", !settings.client.hidePlayerList);
				return this.render();

			// Cycle camera size
			case "change-size":
				const sizes = ["large", "medium", "small"];
				const size = sizes.indexOf(settings.client.dockSize);
				const next = size+1 >= sizes.length ? 0 : size+1;
				await settings.set("client", "dockSize", sizes[next]);
				return this.render();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Change volume control for a stream
	 * @param {Event} event   The originating change event from interaction with the range input
	 * @private
	 */
	_onVolumeChange(event) {
		const input = event.currentTarget;
		const box = input.closest(".camera-view");
		const userId = box.dataset.user;
		let volume = AudioHelper.inputToVolume(input.value);
		box.getElementsByTagName("video")[0].volume = volume;
		this.webrtc.settings.set("client", `users.${userId}.volume`, volume);
	}

	/* -------------------------------------------- */
	/*  Internal Helpers                            */
	/* -------------------------------------------- */

	/**
	 * Dynamically refresh the state of a single camera view
	 * @param {HTMLElement} view      The view container div
	 * @private
	 */
	_refreshView(view) {
		const userId = view.dataset.user;
		const isSelf = game.user.id === userId;
		const clientSettings = game.webrtc.settings.client;
		const userSettings = game.webrtc.settings.getUser(userId);

		// Identify permissions
		const cbv = game.webrtc.canUserBroadcastVideo(userId);
		const csv = game.webrtc.canUserShareVideo(userId);
		const cba = game.webrtc.canUserBroadcastAudio(userId);
		const csa = game.webrtc.canUserShareAudio(userId);

		// Refresh video display
		const video = view.querySelector("video.user-camera");
		const avatar = view.querySelector("img.user-avatar");
		if (video && avatar) {
			video.style.visibility = csv ? 'visible' : "hidden";
			video.style.display = csv ? "block" : "none";
			avatar.style.display = csv ? "none" : "unset";
		}

		// Hidden and muted status icons
		view.querySelector(".status-hidden").classList.toggle("hidden", csv);
		view.querySelector(".status-muted").classList.toggle("hidden", csa);

		// Volume bar and video output volume
		video.volume = userSettings.volume;
		video.muted = isSelf || clientSettings.muteAll; // Mute your own video
		const volBar = view.querySelector(".volume-bar");
		const displayBar = (userId !== game.user.id) && cba;
		volBar.style.display = displayBar ? "block" : "none";
		volBar.disabled = !displayBar;

		// Control toggle states
		const actions = {
			"block-video": {state: !cbv, display: game.user.isGM && !isSelf},
			"block-audio": {state: !cba, display: game.user.isGM && !isSelf},
			"toggle-video": {state: !csv, display: isSelf},
			"toggle-audio": {state: !csa, display: isSelf},
			"mute-peers": {state: clientSettings.muteAll, display: isSelf},
			"toggle-players": {state: !clientSettings.hidePlayerList, display: isSelf}
		};
		const toggles = view.querySelectorAll(".av-control.toggle");
		for ( let button of toggles ) {
			const action = button.dataset.action;
			if (!(action in actions) ) continue;
			const state = actions[action].state;
			const displayed = actions[action].display;
			button.style.display = displayed ? "block" : "none";
			button.enabled = displayed;
			button.children[0].classList.remove(this._getToggleIcon(action, !state));
			button.children[0].classList.add(this._getToggleIcon(action, state));
			button.setAttribute("title", this._getToggleTooltip(action, state));
		}
	}

	/* -------------------------------------------- */

	/**
	 * Render changes needed to the PlayerList ui.
	 * Show/Hide players depending on option.
	 * @private
	 */
	_setPlayerListVisibility() {
		let players = document.getElementById("players");
		if (! players ) return;
		players.classList.toggle("hidden", this.webrtc.settings.client.hidePlayerList);
	}

	/* -------------------------------------------- */

	/**
	 * Get the icon class that should be used for various action buttons with different toggled states.
	 * The returned icon should represent the visual status of the NEXT state (not the CURRENT state).
	 *
	 * @param {string} action     The named av-control button action
	 * @param {boolean} state     The CURRENT action state.
	 * @return {string}           The icon that represents the NEXT action state.
	 * @private
	 */
	_getToggleIcon(action, state) {
		const actionMapping = {
			"block-video": ["fa-video", "fa-video-slash"],            // True means "blocked"
			"block-audio": ["fa-microphone", "fa-microphone-slash"],  // True means "blocked"
			"toggle-video": ["fa-video", "fa-video-slash"],           // True means "enabled"
			"toggle-audio": ["fa-microphone", "fa-microphone-slash"], // True means "enabled"
			"mute-peers": ["fa-volume-up", "fa-volume-mute"],         // True means "muted"
			"toggle-players": ["fa-caret-square-right", "fa-caret-square-left"] // True means "displayed"
		};
		const icons = actionMapping[action];
		return icons ? icons[state ? 1: 0] : null;
	}

	/* -------------------------------------------- */

	/**
	 * Get the text title that should be used for various action buttons with different toggled states.
	 * The returned title should represent the tooltip of the NEXT state (not the CURRENT state).
	 *
	 * @param {string} action     The named av-control button action
	 * @param {boolean} state     The CURRENT action state.
	 * @return {string}           The icon that represents the NEXT action state.
	 * @private
	 */
	_getToggleTooltip(action, state) {
		const actionMapping = {
			"block-video": ["BlockUserVideo", "AllowUserVideo"],      // True means "blocked"
			"block-audio": ["BlockUserAudio", "AllowUserAudio"],      // True means "blocked"
			"toggle-video": ["DisableMyVideo", "EnableMyVideo"],      // True means "enabled"
			"toggle-audio": ["DisableMyAudio", "EnableMyAudio"],      // True means "enabled"
			"mute-peers": ["MutePeers", "UnmutePeers"],               // True means "muted"
			"toggle-players": ["ShowPlayers", "HidePlayers"]          // True means "displayed"
		};
		const labels = actionMapping[action];
		return game.i18n.localize(`WEBRTC.Tooltip${labels ? labels[state ? 1 : 0] : ""}`);
	}

	/* -------------------------------------------- */

	/**
	 * Show or hide UI control elements
	 * This replaces the use of jquery.show/hide as it simply adds a class which has display:none
	 * which allows us to have elements with display:flex which can be hidden then shown without
	 * breaking their display style.
	 * This will show/hide the toggle buttons, volume controls and overlay sidebars
	 * @param {jQuery} container    The container for which to show/hide control elements
	 * @param {boolean} show        Whether to show or hide the controls
	 * @param {string} selector     Override selector to specify which controls to show or hide
	 * @private
	 */
	_toggleControlVisibility(container, show, selector) {
		selector = selector || `.control-bar`;
		container.querySelectorAll(selector).forEach(c => c.classList.toggle("hidden", !show));
	}
}

/**
 * Configuration sheet for the Drawing object
 * @extends {FormApplication}
 *
 * @param {Drawing} drawing         The Drawing object being configured
 * @param {object} options          Additional application rendering options
 * @param {boolean} [options.configureDefault=false]  Configure the default drawing settings, instead of a specific Drawing
 * @param {boolean} [options.preview]  Configure a preview version of the Drawing which is not yet saved
 */
class DrawingConfig extends FormApplication {
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "drawing-config",
			classes: ["sheet"],
			template: "templates/scene/drawing-config.html",
			width: 480,
			height: 360,
			configureDefault: false,
			tabs: [{navSelector: ".tabs", contentSelector: "form", initial: "position"}]
		});
	}

	/* -------------------------------------------- */

	/** @override */
	get title() {
		const title = this.options.configureDefault ? "DRAWING.ConfigDefaultTitle" : "DRAWING.ConfigTitle";
		return game.i18n.localize(title);
	}

	/* -------------------------------------------- */

	/** @override */
	getData(options) {
		const author = game.users.get(this.object.data.author);

		// Submit text
		let submit;
		if ( this.options.configureDefault ) submit = "DRAWING.SubmitDefault";
		else submit = this.options.preview ? "DRAWING.SubmitCreate" : "DRAWING.SubmitUpdate";

		// Return data
		return {
			author: author ? author.name : "",
			isDefault: this.options.configureDefault,
			fillTypes: this.constructor._getFillTypes(),
			fontFamilies: CONFIG.fontFamilies.reduce((obj, f) => {
				obj[f] = f;
				return obj;
			}, {}),
			object: this.object.toJSON(),
			options: this.options,
			submitText: submit
		}
	}

	/* -------------------------------------------- */

	/**
	 * Get the names and labels of fill type choices which can be applied
	 * @return {Object}
	 * @private
	 */
	static _getFillTypes() {
		return Object.entries(CONST.DRAWING_FILL_TYPES).reduce((obj, v) => {
			obj[v[1]] = `DRAWING.FillType${v[0].titleCase()}`;
			return obj;
		}, {});
	}

	/* -------------------------------------------- */

	/** @override */
	async _updateObject(event, formData) {
		if ( !this.object.isOwner ) throw new Error("You do not have the ability to configure this Drawing object.");

		// Configure the default Drawing settings
		if ( this.options.configureDefault ) {
			formData.author = game.user.id;
			const newDefault = new DrawingDocument(formData);
			return game.settings.set("core", DrawingsLayer.DEFAULT_CONFIG_SETTING, newDefault.toJSON());
		}

		// Create or update a Drawing
		if ( this.object.id ) return this.object.update(formData);
		return this.object.constructor.create(formData);
	}

	/* -------------------------------------------- */

	/** @override */
	async close(options) {
		await super.close(options);
		if ( this.preview ) {
			this.preview.removeChildren();
			this.preview = null;
		}
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find('button[name="resetDefault"]').click(this._onResetDefaults.bind(this));
	}

	/* -------------------------------------------- */

	/**
	 * Reset the user Drawing configuration settings to their default values
	 * @param {PointerEvent} event      The originating mouse-click event
	 * @protected
	 */
	_onResetDefaults(event) {
		event.preventDefault();
		game.settings.set("core", DrawingsLayer.DEFAULT_CONFIG_SETTING, {});
		const defaultValues = new foundry.data.DrawingData(canvas.drawings._getNewDrawingData({})).toJSON();
		this.object.data.update(defaultValues);
		this.render();
	}
}

/**
 * An implementation of the PlaceableHUD base class which renders a heads-up-display interface for Drawing objects.
 * @extends {BasePlaceableHUD}
 */
class DrawingHUD extends BasePlaceableHUD {

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "drawing-hud",
			template: "templates/hud/drawing-hud.html"
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const data = super.getData(options);
		return foundry.utils.mergeObject(data, {
			lockedClass: data.locked ? "active" : "",
			visibilityClass: data.hidden ? "active" : "",
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	setPosition(options) {
		let {x, y, width, height} = this.object.drawing.hitArea;
		const c = 70;
		const p = 10;
		const position = {
			width: width + (c * 2) + (p * 2),
			height: height + (p * 2),
			left: x + this.object.data.x - c - p,
			top: y + this.object.data.y - p
		};
		this.element.css(position);
	}
}

/**
 * Light Source Configuration Sheet
 * @extends {DocumentSheet}
 * @param {AmbientLight} light            The AmbientLight object for which settings are being configured
 * @param {ApplicationOptions} options    Additional application configuration options
 */
class LightConfig extends DocumentSheet {

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			title: "LIGHT.ConfigTitle",
			template: "templates/scene/light-config.html",
			width: 480
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const data = super.getData(options);
		const animationTypes = {"": "None"};
		for ( let [k, v] of Object.entries(CONFIG.Canvas.lightAnimations) ) {
			animationTypes[k] = v.label;
		}
		const lightTypes = Object.entries(CONST.SOURCE_TYPES).reduce((obj, e) => {
			obj[e[1]] = `LIGHT.Type${e[0].titleCase()}`;
			return obj;
		}, {});
		return foundry.utils.mergeObject(data, {
			submitText: game.i18n.localize(this.options["preview"] ? "LIGHT.Create" : "LIGHT.Update"),
			lightTypes: lightTypes,
			lightAnimations: animationTypes,
			colorIntensity: Math.sqrt(this.document.data.tintAlpha).toNearest(0.05)
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async close(options) {
		this.document.data.reset();
		this._refresh();
		return super.close(options);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _onChangeInput(event) {
		await super._onChangeInput(event);
		const previewData = this._getSubmitData();
		foundry.utils.mergeObject(this.document.data, previewData, {inplace: true});
		this._refresh();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_getSubmitData(updateData) {
		const data = super._getSubmitData(updateData);
		data.tintAlpha = Math.pow(data.tintAlpha, 2).toNearest(0.01);
		return data;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _updateObject(event, formData) {
		this.object.data.reset();
		if ( this.object.id ) return this.object.update(formData);
		return this.object.constructor.create(formData, {parent: canvas.scene});
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the display of the AmbientLight object
	 * @private
	 */
	_refresh() {
		if ( !this.document.object ) return;
		this.document.object.updateSource();
		this.document.object.refresh();
	}
}

/**
 * A configuration sheet for creating or editing a Note document.
 * @extends {DocumentSheet}
 * @param {NoteDocument} note   The Note object for which settings are being configured
 * @param {object} options      Additional Application configuration options
 */
class NoteConfig extends DocumentSheet {

	/** @override */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			title: game.i18n.localize("NOTE.ConfigTitle"),
			template: "templates/scene/note-config.html",
			width: 400
		});
	}

	/* -------------------------------------------- */

	/** @override */
	getData(options) {
		const data = super.getData(options);
		return foundry.utils.mergeObject(data, {
			entry: game.journal.get(this.object.data.entryId) || {},
			entries: game.journal.contents,
			icons: CONFIG.JournalEntry.noteIcons,
			fontFamilies: CONFIG.fontFamilies.reduce((obj, f) => {
				obj[f] = f;
				return obj;
			}, {}),
			textAnchors: Object.entries(CONST.TEXT_ANCHOR_POINTS).reduce((obj, e) => {
				obj[e[1]] = game.i18n.localize(`JOURNAL.Anchor${e[0].titleCase()}`);
				return obj;
			}, {}),
			submitText: game.i18n.localize(this.id ? "NOTE.Update" : "NOTE.Create")
		});
	}

	/* -------------------------------------------- */

	/** @override */
	async _updateObject(event, formData) {
		if ( this.object.id ) return this.object.update(formData);
		else return this.object.constructor.create(formData, {parent: canvas.scene});
	}

	/* -------------------------------------------- */

	/** @override */
	async close(options) {
		if ( !this.object.id ) canvas.notes.preview.removeChildren();
		return super.close(options);
	}
}

/**
 * Ambient Sound Config Sheet
 * @extends {DocumentSheet}
 *
 * @param {AmbientSound} sound       The sound object being configured
 * @param {object} options           Additional application rendering options
 * @param {boolean} options.preview  Configure a preview version of a sound which is not yet saved
 */
class AmbientSoundConfig extends DocumentSheet {

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			title: "SOUND.ConfigTitle",
			template: "templates/scene/sound-config.html",
			width: 480
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get title() {
		if ( this.object.id ) return super.title;
		else return game.i18n.localize("SOUND.Create");
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const data = super.getData(options);
		data.submitText = game.i18n.localize(this.object.id ? "SOUND.Create" : "SOUND.Update");
		return data;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _updateObject(event, formData) {
		if ( this.object.id ) return this.object.update(formData);
		return this.object.constructor.create(formData, {parent: canvas.scene});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async close(options) {
		if ( !this.object.id ) canvas.sounds.preview.removeChildren();
		await super.close(options);
	}
}

/**
 * Tile Config Sheet
 * @extends {DocumentSheet}
 *
 * @param {Tile} tile                The Tile object being configured
 * @param {Object} options           Additional application rendering options
 * @param {boolean} options.preview  Configure a preview version of a tile which is not yet saved
 */
class TileConfig extends DocumentSheet {

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "tile-config",
			title: game.i18n.localize("TILE.ConfigTitle"),
			template: "templates/scene/tile-config.html",
			width: 420,
			height: "auto",
			submitOnChange: true,
			tabs: [{navSelector: ".tabs", contentSelector: "form", initial: "basic"}]
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async close(options) {
		await super.close(options);
		const layer = this.object.layer;
		layer.preview?.removeChildren();
		this.options.preview = false;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const data = super.getData(options);
		const label = game.i18n.localize("DOCUMENT.Tile");
		data.submitText = game.i18n.format(this.options.preview ? "DOCUMENT.Create" : "DOCUMENT.Update", {type: label});
		data.occlusionModes = Object.entries(CONST.TILE_OCCLUSION_MODES).reduce((obj, e) => {
			obj[e[1]] = game.i18n.localize(`TILE.OcclusionMode${e[0].titleCase()}`);
			return obj;
		}, {})
		return data;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _onChangeInput(event) {

		// Handle form element updates
		const el = event.target;
		if ( (el.type === "color") && el.dataset.edit ) this._onChangeColorPicker(event);
		else if ( el.type === "range" ) this._onChangeRange(event);

		// Update preview object
		const fd = new FormDataExtended(this.form);
		for ( let [k, v] of Object.entries(fd.toObject()) ) {
			this.document.data[k] = v;
		}
		this.document.object.refresh();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _updateObject(event, formData) {
		if ( this.document.id ) return this.document.update(formData);
		else return this.document.constructor.create(formData, {
			parent: this.document.parent,
			pack: this.document.pack
		});
	}
}

/**
 * An implementation of the PlaceableHUD base class which renders a heads-up-display interface for Tile objects.
 * @extends {BasePlaceableHUD}
 */
class TileHUD extends BasePlaceableHUD {

	/**
	 * @inheritdoc
	 * @type {Tile}
	 */
	object = undefined;

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "tile-hud",
			template: "templates/hud/tile-hud.html"
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const d = this.object.data;
		const isVideo = this.object.isVideo;
		const isPlaying = isVideo && !this.object.sourceElement.paused;
		return foundry.utils.mergeObject(super.getData(options), {
			isVideo: isVideo,
			lockedClass: d.locked ? "active" : "",
			visibilityClass: d.hidden ? "active" : "",
			overheadClass: d.overhead ? "active" : "",
			underfootClass: !d.overhead ? "active" : "",
			videoIcon: isPlaying ? "fas fa-pause" : "fas fa-play",
			videoTitle: game.i18n.localize(isPlaying ? "HUD.TilePause" : "HUD.TilePlay")
		})
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	setPosition(options) {
		let {x, y, width, height} = this.object.hitArea;
		const c = 70;
		const p = -10;
		const position = {
			width: width + (c * 2) + (p * 2),
			height: height + (p * 2),
			left: x + this.object.data.x - c - p,
			top: y + this.object.data.y - p
		};
		this.element.css(position);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onClickControl(event) {
		super._onClickControl(event);
		if ( event.defaultPrevented ) return;
		const button = event.currentTarget;
		switch ( button.dataset.action ) {
			case "overhead":
				return this._onToggleOverhead(event, true);
			case "underfoot":
				return this._onToggleOverhead(event, false);
			case "video":
				return this._onControlVideo(event);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle toggling the overhead state of the Tile.
	 * @private
	 */
	_onToggleOverhead(event, overhead) {
		// Grab before release
		const documentName = this.object.document.documentName;

		// Toggle the underhead/overhead state
		const updates = this.layer.controlled.map(o => {
			return {_id: o.id, overhead: overhead};
		});

		// Update all objects
		return canvas.scene.updateEmbeddedDocuments(documentName, updates);
	}

	/* -------------------------------------------- */

	/**
	 * Control video playback by toggling play or paused state for a video Tile.
	 * @private
	 */
	_onControlVideo(event) {
		const button = event.currentTarget;
		const isPaused = this.object.sourceElement.paused;

		// Update the icon
		const icon = button.children[0];
		if ( isPaused ) icon.classList.replace("fa-play", "fa-pause");
		else icon.classList.replace("fa-pause", "fa-play");

		// Trigger playback
		return this.object.document.update({"video.autoplay": false}, {diff: false, playVideo: isPaused});
	}
}

/**
 * A Token Configuration Application
 * @extends {FormApplication}
 */
class TokenConfig extends FormApplication {
	constructor(object, options) {
		super(object, options);
		this.token = this.object;
		if ( this.isPrototype ) this.token = new PrototypeTokenDocument(this.object.data.token, {actor: this.object});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			classes: ["sheet", "token-sheet"],
			template: "templates/scene/token-config.html",
			width: 480,
			height: "auto",
			tabs: [{navSelector: ".tabs", contentSelector: "form", initial: "character"}]
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get id() {
		return `token-config-${this.object.id}`;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor to test whether we are configuring the prototype Token for an Actor.
	 * @type {boolean}
	 */
	get isPrototype() {
		return this.object instanceof Actor;
	}

	/* -------------------------------------------- */

	/**
	 * Convenience access to the Actor document that this Token represents
	 * @type {Actor}
	 */
	get actor() {
		return this.isPrototype? this.object : this.token.actor;
	}

	/* -------------------------------------------- */


	/** @inheritdoc */
	get title() {
		if ( this.isPrototype ) return `[${game.i18n.localize("TOKEN.TitlePrototype")}] ${this.actor.name}`;
		return `${this.token.name}: ${game.i18n.localize("TOKEN.Title")}`;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async getData(options) {
		let hasAlternates = this.actor?.data.token.randomImg ?? false;
		const attributes = TokenDocument.getTrackedAttributes(this.actor?.data.data ?? {});
		const data = this.isPrototype ? this.actor.data.token : this.token.data;
		return {
			cssClasses: [this.isPrototype ? "prototype" : null].filter(c => !!c).join(" "),
			isPrototype: this.isPrototype,
			hasAlternates: hasAlternates,
			alternateImages: hasAlternates ? await this._getAlternateTokenImages() : [],
			object: data,
			options: this.options,
			gridUnits: canvas.ready ? canvas.scene.data.gridUnits : game.system.gridUnits,
			barAttributes: TokenDocument.getTrackedAttributeChoices(attributes),
			bar1: this.token.getBarAttribute("bar1"),
			bar2: this.token.getBarAttribute("bar2"),
			displayModes: Object.entries(CONST.TOKEN_DISPLAY_MODES).reduce((obj, e) => {
				obj[e[1]] = game.i18n.localize(`TOKEN.DISPLAY_${e[0]}`);
				return obj;
			}, {}),
			actors: game.actors.reduce((actors, a) => {
				if ( !a.isOwner ) return actors;
				actors.push({'_id': a.id, 'name': a.name});
				return actors;
			}, []).sort((a, b) => a.name.localeCompare(b.name)),
			dispositions: Object.entries(CONST.TOKEN_DISPOSITIONS).reduce((obj, e) => {
				obj[e[1]] = game.i18n.localize(`TOKEN.${e[0]}`);
				return obj;
			}, {}),
			lightAnimations: Object.entries(CONFIG.Canvas.lightAnimations).reduce((obj, e) => {
				obj[e[0]] = game.i18n.localize(e[1].label);
				return obj;
			}, {"": game.i18n.localize("None")}),
			lightAlpha: Math.sqrt(data.lightAlpha).toNearest(0.05),
			isGM: game.user.isGM
		};
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async render(force, options) {
		const canConfigure = game.user.isGM || this.actor?.isOwner;
		if ( !game.user.can("TOKEN_CONFIGURE") || !canConfigure ) {
			ui.notifications.warn("You do not have permission to configure this Token!");
			return this;
		}
		return super.render(force, options);
	}

	/* -------------------------------------------- */

	/**
	 * Get an Object of image paths and filenames to display in the Token sheet
	 * @return {Promise}
	 * @private
	 */
	async _getAlternateTokenImages() {
		const images = await this.actor.getTokenImages();
		return images.reduce((obj, i) => {
			obj[i] = i.split("/").pop();
			return obj;
		}, {});
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		super.activateListeners(html);
		html.find(".bar-attribute").change(this._onBarChange.bind(this));
		html.find(".alternate-images").change(ev => ev.target.form.img.value = ev.target.value);
		html.find('button.assign-token').click(this._onAssignToken.bind(this));
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_getSubmitData(updateData = {}) {
		const data = super._getSubmitData(updateData);
		data.lightAlpha = Math.pow(data.lightAlpha, 2).toNearest(0.01);
		return data;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _updateObject(event, formData) {

		// Configure the Prototype Token data of an Actor
		if ( this.isPrototype ) return this.actor.update({token: formData});

		// Update an embedded Token document
		else return this.token.update(formData);
	}

	/* -------------------------------------------- */

	/**
	 * Handle Token assignment requests to update the default prototype Token
	 * @param {MouseEvent} event  The left-click event on the assign token button
	 * @private
	 */
	async _onAssignToken(event) {
		event.preventDefault();

		// Get controlled Token data
		let tokens = canvas.ready ? canvas.tokens.controlled : [];
		if ( tokens.length !== 1 ) {
			ui.notifications.warn("TOKEN.AssignWarn", {localize: true});
			return;
		}
		const token = tokens.pop().data.toJSON();
		token.tokenId = token.x = token.y = null;

		// Update the prototype token for the actor using the existing Token instance
		await this.actor.update({token: token}, {diff: false, recursive: false, noHook: true});
		ui.notifications.info(game.i18n.format("TOKEN.AssignSuccess", {name: this.actor.name}));
		return this.close();
	}

	/* -------------------------------------------- */

	/**
	 * Handle changing the attribute bar in the drop-down selector to update the default current and max value
	 * @private
	 */
	async _onBarChange(ev) {
		const form = ev.target.form;
		const attr = this.token.getBarAttribute("", {alternative: ev.target.value});
		const bar = ev.target.name.split(".").shift();
		form.querySelector(`input.${bar}-value`).value = attr !== null ? attr.value : "";
		form.querySelector(`input.${bar}-max`).value = ((attr !== null) && (attr.type === "bar")) ? attr.max : "";
	}
}

/**
 * A sheet that alters the values of the default Token configuration used when new Token documents are created.
 * @extends {FormApplication}
 */
class DefaultTokenConfig extends FormApplication {
	constructor(object, options) {
		super(object, options);
		const setting = game.settings.get("core", DefaultTokenConfig.SETTING);
		this.data = new foundry.data.TokenData(setting);
		this.object = this.data.toObject();
	}

	/**
	 * The named world setting that stores the default Token configuration
	 * @type {string}
	 */
	static SETTING = "defaultToken";

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "default-token-config",
			classes: ["sheet"],
			template: "templates/scene/default-token-config.html",
			title: "Default Token Configuration",
			width: 480,
			height: "auto"
		});
	}

	/* -------------------------------------------- */

	/** @override */
	async getData(options) {
		return {
			object: this.object,
			barAttributes: TokenDocument.getTrackedAttributeChoices(),
			dispositions: Object.entries(CONST.TOKEN_DISPOSITIONS).reduce((obj, e) => {
				obj[e[1]] = game.i18n.localize(`TOKEN.${e[0]}`);
				return obj;
			}, {}),
			lightAnimations: Object.entries(CONFIG.Canvas.lightAnimations).reduce((obj, e) => {
				obj[e[0]] = game.i18n.localize(e[1].label);
				return obj;
			}, {"": game.i18n.localize("None")}),
			displayModes: Object.entries(CONST.TOKEN_DISPLAY_MODES).reduce((obj, e) => {
				obj[e[1]] = game.i18n.localize(`TOKEN.DISPLAY_${e[0]}`);
				return obj;
			}, {}),
			lightAlpha: Math.sqrt(this.object.lightAlpha).toNearest(0.05)
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_getSubmitData(updateData = {}) {
		const formData = foundry.utils.expandObject(super._getSubmitData(updateData));
		formData.lightAlpha = Math.pow(formData.lightAlpha, 2).toNearest(0.01);
		formData.lightColor = formData.lightColor || undefined;
		formData.bar1.attribute = formData.bar1.attribute || null;
		formData.bar2.attribute = formData.bar2.attribute || null;
		return formData;
	}

	/* -------------------------------------------- */

	/** @override */
	async _updateObject(event, formData) {
		try {
			this.data.update(formData);
		} catch(err) {
			ui.notifications.error(err.message);
		}
		const defaults = new foundry.data.TokenData();
		const delta = foundry.utils.diffObject(defaults, this.data);
		return game.settings.set("core", DefaultTokenConfig.SETTING, delta);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		super.activateListeners(html);
		html.find('button[data-action="reset"]').click(this.reset.bind(this));
	}

	/* -------------------------------------------- */

	/**
	 * Reset the form to default values
	 * @returns {Promise<void>}
	 */
	async reset() {
		this.data = new foundry.data.TokenData({});
		this.object = this.data.toObject();
		this.render();
	}
}
/**
 * An implementation of the PlaceableHUD base class which renders a heads-up-display interface for Token objects.
 * This interface provides controls for visibility, attribute bars, elevation, status effects, and more.
 * @type {BasePlaceableHUD}
 */
class TokenHUD extends BasePlaceableHUD {

	/**
	 * Track whether the status effects control palette is currently expanded or hidden
	 * @type {boolean}
	 * @private
	 */
	_statusEffects = false;

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "token-hud",
			template: "templates/hud/token-hud.html"
		});
	}

	/* -------------------------------------------- */

	/** @override */
	bind(object) {
		this._statusEffects = false;
		return super.bind(object);
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the currently active state of all status effect icons in the Token HUD selector.
	 */
	refreshStatusIcons() {
		const effects = this.element.find(".status-effects")[0];
		const statuses = this._getStatusEffectChoices();
		for ( let img of effects.children ) {
			const status = statuses[img.getAttribute("src")] || {};
			img.classList.toggle("overlay", !!status.isOverlay);
			img.classList.toggle("active", !!status.isActive);
		}
	}

	/* -------------------------------------------- */

	/** @override */
	setPosition(_position) {
		const td = this.object.data;
		const ratio = canvas.dimensions.size / 100;
		const position = {
			width: td.width * 100,
			height: td.height * 100,
			left: this.object.x,
			top: this.object.y,
		};
		if ( ratio !== 1 ) position.transform = `scale(${ratio})`;
		this.element.css(position);
	}

	/* -------------------------------------------- */

	/** @override */
	getData(options) {
		let data = super.getData(options);
		const bar1 = this.object.document.getBarAttribute("bar1");
		const bar2 = this.object.document.getBarAttribute("bar2");
		data = foundry.utils.mergeObject(data, {
			canConfigure: game.user.can("TOKEN_CONFIGURE"),
			canToggleCombat: ui.combat !== null,
			displayBar1: bar1 && (bar1.type !== "none"),
			bar1Data: bar1,
			displayBar2: bar2 && (bar2.type !== "none"),
			bar2Data: bar2,
			visibilityClass: data.hidden ? "active" : "",
			effectsClass: this._statusEffects ? "active" : "",
			combatClass: this.object.inCombat ? "active" : "",
			targetClass: this.object.targeted.has(game.user) ? "active" : "",
		});
		data.statusEffects =this._getStatusEffectChoices(data);
		return data;
	}

	/* -------------------------------------------- */

	/**
	 * Get an array of icon paths which represent valid status effect choices
	 * @private
	 */
	_getStatusEffectChoices() {
		const token = this.object;

		// Get statuses which are active for the token actor
		const actor = token.actor || null;
		const statuses = actor ? actor.effects.reduce((obj, e) => {
			const id = e.getFlag("core", "statusId");
			if ( id ) {
				obj[id] = {
					id: id,
					overlay: !!e.getFlag("core", "overlay")
				}
			}
			return obj;
		}, {}) : {};

		// Prepare the list of effects from the configured defaults and any additional effects present on the Token
		const tokenEffects = foundry.utils.deepClone(token.data.effects) || [];
		if ( token.data.overlayEffect ) tokenEffects.push(token.data.overlayEffect);
		return CONFIG.statusEffects.concat(tokenEffects).reduce((obj, e) => {
			const src = e.icon ?? e;
			if ( src in obj ) return obj;
			const status = statuses[e.id] || {};
			const isActive = !!status.id || token.data.effects.includes(src);
			const isOverlay = !!status.overlay || token.data.overlayEffect === src;
			obj[src] = {
				id: e.id ?? "",
				title: e.label ? game.i18n.localize(e.label) : null,
				src,
				isActive,
				isOverlay,
				cssClass: [
					isActive ? "active" : null,
					isOverlay ? "overlay" : null
				].filterJoin(" ")
			};
			return obj;
		}, {});
	}

	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);

		// Attribute Bars
		html.find(".attribute input")
			.click(this._onAttributeClick)
			.keydown(this._onAttributeKeydown.bind(this))
			.change(this._onAttributeUpdate.bind(this))

		// Status Effects Controls
		this._toggleStatusEffects(this._statusEffects);
		html.find(".status-effects")
			.on("click", ".effect-control", this._onToggleEffect.bind(this))
			.on("contextmenu", ".effect-control", event => this._onToggleEffect(event, {overlay: true}));
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onClickControl(event) {
		super._onClickControl(event);
		if ( event.defaultPrevented ) return;
		const button = event.currentTarget;
		switch ( button.dataset.action ) {
			case "config":
				return this._onTokenConfig(event);
			case "combat":
				return this._onToggleCombat(event);
			case "target":
				return this._onToggleTarget(event);
			case "effects":
				return this._onToggleStatusEffects(event);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle initial click to focus an attribute update field
	 * @private
	 */
	_onAttributeClick(event) {
		event.currentTarget.select();
	}

	/* -------------------------------------------- */

	/**
	 * Force field handling on an Enter keypress even if the value of the field did not change.
	 * This is important to suppose use cases with negative number values.
	 * @param {KeyboardEvent} event     The originating keydown event
	 * @private
	 */
	_onAttributeKeydown(event) {
		const code = game.keyboard.getKey(event);
		if ( code === "Enter" ) return this._onAttributeUpdate(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle attribute bar update
	 * @private
	 */
	_onAttributeUpdate(event) {
		event.preventDefault();
		if ( !this.object ) return;

		// Acquire string input
		const input = event.currentTarget;
		let strVal = input.value.trim();
		let isDelta = strVal.startsWith("+") || strVal.startsWith("-");
		if (strVal.startsWith("=")) strVal = strVal.slice(1);
		let value = Number(strVal);

		// For attribute bar values, update the associated Actor
		const bar = input.dataset.bar;
		const actor = this.object?.actor;
		if ( bar && actor ) {
			const attr = this.object.document.getBarAttribute(bar);
			actor.modifyTokenAttribute(attr.attribute, value, isDelta, attr.type === "bar");
		}

		// Otherwise update the Token directly
		else {
			const current = this.object.data[input.name];
			this.object.document.update({[input.name]: isDelta ? current + value : value});
		}

		// Clear the HUD
		this.clear();
	}

	/* -------------------------------------------- */

	/**
	 * Toggle Token combat state
	 * @private
	 */
	async _onToggleCombat(event) {
		event.preventDefault();
		await this.object.toggleCombat();
		event.currentTarget.classList.toggle("active", this.object.inCombat);
	}

	/* -------------------------------------------- */

	/**
	 * Handle Token configuration button click
	 * @private
	 */
	_onTokenConfig(event) {
		event.preventDefault();
		this.object.sheet.render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle left-click events to toggle the displayed state of the status effect selection palette
	 * @param {MouseEvent }event
	 * @private
	 */
	_onToggleStatusEffects(event) {
		event.preventDefault();
		this._toggleStatusEffects(!this._statusEffects);
	}

	/* -------------------------------------------- */

	/**
	 * Assign css selectors for the active state of the status effects selection palette
	 * @private
	 */
	_toggleStatusEffects(active) {
		this._statusEffects = active;
		const button = this.element.find('.control-icon[data-action="effects"]')[0];
		button.classList.toggle("active", active);
		const palette = button.querySelector(".status-effects");
		palette.classList.toggle("active", active);
	}

	/* -------------------------------------------- */

	/**
	 * Handle toggling a token status effect icon
	 * @private
	 */
	_onToggleEffect(event, {overlay=false}={}) {
		event.preventDefault();
		event.stopPropagation();
		let img = event.currentTarget;
		const effect = ( img.dataset.statusId && this.object.actor ) ?
			CONFIG.statusEffects.find(e => e.id === img.dataset.statusId) :
			img.getAttribute("src");
		return this.object.toggleEffect(effect, {overlay});
	}

	/* -------------------------------------------- */

	/**
	 * Handle toggling the target state for this Token
	 * @private
	 */
	_onToggleTarget(event) {
		event.preventDefault();
		const btn = event.currentTarget;
		const token = this.object;
		const targeted = !token.isTargeted;
		token.setTarget(targeted, {releaseOthers: false});
		btn.classList.toggle("active", targeted);
	}
}

/**
 * Wall Configuration Sheet
 * @extends {FormApplication}
 * @param {Wall} object                     The Wall object for which settings are being configured
 * @param {ApplicationOptions} options      Additional options which configure the rendering of the configuration sheet.
 */
class WallConfig extends FormApplication {

	/** @inheritdoc */
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = "wall-config";
		options.title = "Wall Configuration";
		options.template = "templates/scene/wall-config.html";
		options.width = 400;
		options.editTargets = [];
		return options;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get title() {
		let title = this.options.editTargets.length ? "WALLS.TitleMany" : "WALLS.Title";
		return game.i18n.localize(title);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		return {
			object: this.object.toJSON(),
			options: this.options,
			moveTypes: Object.keys(CONST.WALL_MOVEMENT_TYPES).reduce((obj, key) => {
				let k = CONST.WALL_MOVEMENT_TYPES[key];
				obj[k] = key.titleCase();
				return obj;
			}, {}),
			senseTypes: Object.keys(CONST.WALL_SENSE_TYPES).reduce((obj, key) => {
				let k = CONST.WALL_SENSE_TYPES[key];
				obj[k] = key.titleCase();
				return obj;
			}, {}),
			dirTypes: Object.keys(CONST.WALL_DIRECTIONS).reduce((obj, key) => {
				let k = CONST.WALL_DIRECTIONS[key];
				obj[k] = key.titleCase();
				return obj;
			}, {}),
			doorTypes: Object.keys(CONST.WALL_DOOR_TYPES).reduce((obj, key) => {
				let k = CONST.WALL_DOOR_TYPES[key];
				obj[k] = key.titleCase();
				return obj;
			}, {}),
			doorStates: Object.keys(CONST.WALL_DOOR_STATES).reduce((obj, key) => {
				let k = CONST.WALL_DOOR_STATES[key];
				obj[k] = key.titleCase();
				return obj;
			}, {}),
			isDoor: this.object.data.door > CONST.WALL_DOOR_TYPES.NONE
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _updateObject(event, formData) {

		// Update multiple walls
		const wallIds = this.options.editTargets;
		if ( wallIds.length ) {
			const updateData = canvas.scene.walls.reduce((arr, w) => {
				if ( wallIds.includes(w.id) ) {
					arr.push(foundry.utils.mergeObject(w.toJSON(), formData));
				}
				return arr;
			}, []);
			return canvas.scene.updateEmbeddedDocuments("Wall", updateData);
		}

		// Update single wall
		else return this.object.update(formData);
	}
}

/**
 * A simple application which supports popping a ChatMessage out to a separate UI window.
 * @extends {Application}
 */
class ChatPopout extends Application {
	constructor(message, options) {
		super(options);

		/**
		 * The displayed Chat Message entity
		 * @type {ChatMessage}
		 */
		this.message = message;

		// Register the application
		this.message.apps[this.appId] = this;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			width: 300,
			height: "auto",
			classes: ["chat-popout"]
		})
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get id() {
		return `chat-popout-${this.message.id}`;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get title() {
		let title = this.message.data.flavor ?? this.message.data.speaker.alias;
		return title.length > 32 ? title.substr(0, 32) + " ..." : title;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _renderInner(data, options) {
		const html = await this.message.getHTML();
		html.find(".message-delete").remove();
		return html;
	}
}

/**
 * A game settings configuration application
 * This form renders the settings defined via the game.settings.register API which have config = true
 *
 * @extends {FormApplication}
 */
class SettingsConfig extends FormApplication {

	/** @override */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			title: game.i18n.localize("SETTINGS.Title"),
			id: "client-settings",
			template: "templates/sidebar/apps/settings-config.html",
			width: 600,
			height: "auto",
			tabs: [
				{navSelector: ".tabs", contentSelector: ".content", initial: "core"}
			]
		})
	}

	/* -------------------------------------------- */

	/** @override */
	getData(options) {
		const gs = game.settings;
		const canConfigure =  game.user.can("SETTINGS_MODIFY");

		// Set-up placeholder structure for core, system, and module settings
		const data = {
			core: {version: game.data.version, menus: [], settings: []},
			system: {title: game.system.data.title, menus: [], settings: []},
			modules: {}
		};

		// Register a module the first time it is seen
		const registerModule = name => {
			const module = game.modules.get(name);
			data.modules[name] = {title: module ? module.data.title : "General Module Settings", menus: [], settings: []};
		};

		// Classify all menus
		for ( let menu of gs.menus.values() ) {
			if ( menu.restricted && !canConfigure ) continue;
			if ( menu.module === "core" ) {
				data.core.menus.push(menu);
			}
			else if ( menu.module === game.system.id ) {
				data.system.menus.push(menu);
			}
			else {
				const name = menu.module || "module";
				if ( !data.modules[name] ) registerModule(name);
				data.modules[name].menus.push(menu);
			}
		}

		// Classify all settings
		for ( let setting of gs.settings.values() ) {

			// Exclude settings the user cannot change
			if ( !setting.config || (!canConfigure && (setting.scope !== "client")) ) continue;

			// Update setting data
			const s = foundry.utils.deepClone(setting);
			s.id = `${s.module}.${s.key}`;
			s.name = game.i18n.localize(s.name);
			s.hint = game.i18n.localize(s.hint);
			s.value = game.settings.get(s.module, s.key);
			s.type = setting.type instanceof Function ? setting.type.name : "String";
			s.isCheckbox = setting.type === Boolean;
			s.isSelect = s.choices !== undefined;
			s.isRange = (setting.type === Number) && s.range;

			// Classify setting
			const name = s.module;
			if ( name === "core" ) data.core.settings.push(s);
			else if ( name === game.system.id ) data.system.settings.push(s);
			else {
				if ( !data.modules[name] ) registerModule(name);
				data.modules[name].settings.push(s);
			}
		}

		// Sort Module headings by name
		data.modules = Object.values(data.modules).sort((a, b) => a.title.localeCompare(b.title));

		// Flag categories that have nothing
		data.core.none = (data.core.menus.length + data.core.settings.length) === 0;
		data.system.none = (data.system.menus.length + data.system.settings.length) === 0;

		// Return data
		return {
			user: game.user,
			canConfigure: canConfigure,
			systemTitle: game.system.data.title,
			data: data
		};
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find('.submenu button').click(this._onClickSubmenu.bind(this));
		html.find('button[name="reset"]').click(this._onResetDefaults.bind(this));
	}

	/* -------------------------------------------- */

	/**
	 * Handle activating the button to configure User Role permissions
	 * @param {Event} event   The initial button click event
	 * @private
	 */
	_onClickSubmenu(event) {
		event.preventDefault();
		const menu = game.settings.menus.get(event.currentTarget.dataset.key);
		if ( !menu ) return ui.notifications.error("No submenu found for the provided key");
		const app = new menu.type();
		return app.render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle button click to reset default settings
	 * @param {Event} event   The initial button click event
	 * @private
	 */
	_onResetDefaults(event) {
		event.preventDefault();
		const button = event.currentTarget;
		const form = button.form;
		for ( let [k, v] of game.settings.settings.entries() ) {
			if ( v.config ) {
				let input = form[k];
				if (input.type === "checkbox") input.checked = v.default;
				else if (input) input.value = v.default;
			}
		}
	}

	/* -------------------------------------------- */

	/** @override */
	async _updateObject(event, formData) {
		for ( let [k, v] of Object.entries(foundry.utils.flattenObject(formData)) ) {
			let s = game.settings.settings.get(k);
			let current = game.settings.get(s.module, s.key);
			if ( v !== current ) {
				await game.settings.set(s.module, s.key, v);
			}
		}
	}
}

/**
 * An interface for displaying the content of a CompendiumCollection.
 * @extends {Application}
 */
class Compendium extends Application {
	constructor(collection, options) {
		super(options);

		/**
		 * The CompendiumCollection instance which is represented in this Compendium interface.
		 * @type {CompendiumCollection}
		 */
		this.collection = collection;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			template: "templates/apps/compendium.html",
			width: 350,
			height: window.innerHeight - 100,
			top: 70,
			left: 120,
			scrollY: [".directory-list"],
			dragDrop: [{ dragSelector: ".directory-item", dropSelector: ".directory-list" }],
			filters: [{inputSelector: 'input[name="search"]', contentSelector: ".directory-list"}]
		});
	}
	/* ----------------------------------------- */

	/** @inheritdoc */
	get title() {
		return [this.collection.title, this.collection.locked ? "[Locked]" : null].filterJoin(" ");
	}

	/* ----------------------------------------- */

	/**
	 * A convenience redirection back to the metadata object of the associated CompendiumCollection
	 * @returns {object}
	 */
	get metadata() {
		return this.collection.metadata;
	}

	/* ----------------------------------------- */
	/*  Rendering                                */
	/* ----------------------------------------- */

	/** @inheritdoc */
	async getData(options) {
		return {
			collection: this.collection,
			cssClass: this.collection.documentName.toLowerCase(),
			index: this.collection.index
		};
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async close(options) {
		const li = document.querySelector(`.compendium-pack[data-pack="${this.collection.collection}"]`);
		li.dataset.open = 0;
		const icon = li.querySelector("i.folder");
		icon.classList.replace("fa-folder-open", "fa-folder");
		return super.close(options);
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		super.activateListeners(html);
		const directory = html.find('.directory-list');
		const entries = directory.find('.directory-item');

		// Open sheets
		html.find('.entry-name').click(this._onClickEntry.bind(this));

		// Context menu for each entry
		this._contextMenu(html);

		// Intersection Observer for Compendium avatars
		const observer = new IntersectionObserver(SidebarTab.prototype._onLazyLoadImage.bind(this), {root: directory[0]});
		entries.each((i, li) => observer.observe(li));
	}

	/* -------------------------------------------- */

	/**
	 * Handle opening a single compendium entry by invoking the configured entity class and its sheet
	 * @param {MouseEvent} event      The originating click event
	 * @private
	 */
	async _onClickEntry(event) {
		let li = event.currentTarget.parentElement;
		const document = await this.collection.getDocument(li.dataset.documentId);
		const sheet = document.sheet;
		if ( sheet._minimized ) return sheet.maximize();
		else return sheet.render(true, {editable: game.user.isGM && !this.collection.locked});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onSearchFilter(event, query, rgx, html) {
		for (let li of html.children) {
			const name = li.querySelector(".entry-name").textContent;
			const match = rgx.test(SearchFilter.cleanQuery(name));
			li.style.display = match ? "flex" : "none";
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_canDragStart(selector) {
		return true;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_canDragDrop(selector) {
		return game.user.isGM;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragStart(event) {
		const li = event.currentTarget;
		const pack = this.collection;
		event.dataTransfer.setData("text/plain", JSON.stringify({
			type: pack.documentName,
			pack: pack.collection,
			id: li.dataset.documentId
		}));
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _onDrop(event) {
		let data;
		try { data = JSON.parse(event.dataTransfer.getData('text/plain')); }
		catch (err) { return false; }

		// Ensure an entity type was indicated
		if ( !data.type ) throw new Error("You must define the type of entity data being dropped");
		if ( data.pack === this.collection.collection ) return false; // Prevent drop on self

		// Import the dropped Document
		const cls = this.collection.documentClass;
		const document = await cls.fromDropData(data);
		return this.collection.importDocument(document);
	}

	/* -------------------------------------------- */

	/**
	 * Render the ContextMenu which applies to each compendium Document
	 * @private
	 */
	_contextMenu(html) {
		new ContextMenu(html, ".directory-item", [
			{
				name: "COMPENDIUM.ImportEntry",
				icon: '<i class="fas fa-download"></i>',
				condition: () => this.collection.documentClass.canUserCreate(game.user),
				callback: li => {
					const collection = game.collections.get(this.collection.documentName);
					const id = li.data("document-id");
					return collection.importFromCompendium(this.collection, id, {}, {renderSheet: true});
				}
			},
			{
				name: "COMPENDIUM.DeleteEntry",
				icon: '<i class="fas fa-trash"></i>',
				condition: () => game.user.isGM,
				callback: async li => {
					const id = li.data("document-id");
					const document = await this.collection.getDocument(id);
					return Dialog.confirm({
						title: `${game.i18n.localize("COMPENDIUM.DeleteEntry")} ${document.name}`,
						content: `<h4>${game.i18n.localize("AreYouSure")}</h4><p>${game.i18n.localize("COMPENDIUM.DeleteEntryWarning")}</p>`,
						yes: () => document.delete()
					});
				}
			}
		]);
	}
}
/**
 * Keyboard Controls Reference Sheet
 * @type {Application}
 */
class ControlsReference extends Application {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.title = game.i18n.localize("CONTROLS.Title");
		options.id = "controls-reference";
		options.template = "templates/sidebar/apps/controls-reference.html";
		options.width = 600;
		return options;
	}
}

/**
 * Game Invitation Links Reference
 * @extends {Application}
 */
class InvitationLinks extends Application {
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "invitation-links",
			template: "templates/sidebar/apps/invitation-links.html",
			title: game.i18n.localize("INVITATIONS.Title"),
			width: 400
		})
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		return game.data.addresses;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		super.activateListeners(html);
		html.find(".invite-link").click(ev => {
			ev.preventDefault();
			ev.target.select();
			document.execCommand('copy');
			ui.notifications.info("INVITATIONS.Copied", {localize: true});
		});
	}
}

/**
 * The Module Management Application.
 * This application provides a view of which modules are available to be used and allows for configuration of the
 * set of modules which are active within the World.
 *
 * @extends {FormApplication}
 */

class ModuleManagement extends FormApplication {
	constructor(...args) {
		super(...args);
		this._filter = "all";
		this._expanded = false;
		this._checked = {};
	}

	/**
	 * The named game setting which persists module configuration.
	 * @type {string}
	 */
	static CONFIG_SETTING = "moduleConfiguration";

	/* -------------------------------------------- */

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			title: game.i18n.localize("MODMANAGE.Title"),
			id: "module-management",
			template: "templates/sidebar/apps/module-management.html",
			popOut: true,
			width: 680,
			height: "auto",
			scrollY: [".package-list"],
			closeOnSubmit: false,
			filters: [{inputSelector: 'input[name="search"]', contentSelector: ".package-list"}]
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get isEditable() {
		return game.user.can("SETTINGS_MODIFY");
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		const settings = game.settings.get("core", this.constructor.CONFIG_SETTING);
		const editable = this.isEditable;
		const counts = {all: game.data.modules.length, active: 0, inactive: 0};

		// Prepare modules
		const modules = game.data.modules.reduce((arr, m) => {
			const isActive = settings[m.id] === true;
			if ( isActive ) counts.active++;
			else counts.inactive++;
			if ( !editable && !isActive ) return arr;

			// Apply filters
			if ( (this._filter === "active") && !isActive ) return arr;
			if ( (this._filter === "inactive") && isActive ) return arr;

			// Modify data
			if ( !this.isEditable && !isActive ) return arr;

			const mod = m.data.toObject();
			mod.active = isActive;
			mod.availability = m.availability;
			mod.data = m.data;
			mod.css = isActive ? " active" : "";
			mod.hasPacks = mod.packs.length > 0;
			mod.hasScripts = mod.scripts.length > 0;
			mod.hasStyles = mod.styles.length > 0;
			mod.systemOnly = mod.systems && (mod.systems.indexOf(game.system.id) !== -1);
			mod.systemTag = game.system.id;
			mod.dependencies = mod.dependencies ? mod.dependencies.map(d => d.name) : null;
			foundry.packages.tagPackageAvailability(mod);
			return arr.concat([mod]);
		}, []).sort((a, b) => a.title.localeCompare(b.title));

		// Filters
		const filters = ["all", "active", "inactive"].map(f => {
			return {
				id: f,
				label: game.i18n.localize(`MODMANAGE.Filter${f.titleCase()}`),
				css: this._filter === f ? " active" : "",
				count: counts[f] || 0
			}
		});

		// Return data for rendering
		return { editable, filters, modules, expanded: this._expanded };
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		super.activateListeners(html);
		html.find('button[name="deactivate"]').click(this._onDeactivateAll.bind(this));
		html.find('.filter').click(this._onFilterList.bind(this));
		html.find('button.expand').click(this._onExpandCollapse.bind(this));
		html.find('input[type="checkbox"').change(this._onChangeCheckbox.bind(this));

		this._restoreCheckboxState();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _updateObject(event, formData) {
		const settings = game.settings.get("core", this.constructor.CONFIG_SETTING);
		const setting = foundry.utils.mergeObject(settings, formData);

		// Ensure all dependencies are satisfied
		for ( let [k, v] of Object.entries(setting) ) {
			if ( v === false ) continue;
			const mod = game.modules.get(k);
			if ( !mod ) {
				delete setting[k];
				continue;
			}
			if ( !mod.data.dependencies?.length ) continue;
			const missing = mod.data.dependencies.reduce((arr, d) => {
				if ( d.type && (d.type !== "module") ) return arr;
				if ( !setting[d.name] ) arr.push(d.name);
				return arr;
			}, []);
			if ( missing.length ) {
				const warning = game.i18n.format("MODMANAGE.DepMissing", {module: k, missing: missing.join(", ")});
				this.options.closeOnSubmit = false;
				return ui.notifications.warn(warning)
			}
		}

		// Apply the setting
		return game.settings.set("core", this.constructor.CONFIG_SETTING, setting);
	}

	/* -------------------------------------------- */

	/**
	 * Restores the Form UI to the internal checked state
	 * @private
	 */
	_restoreCheckboxState() {
		for ( let [k, v] of Object.entries(this._checked) ) {
			if ( this.form[k] ) this.form[k].checked = v;
		}
	}

	/**
	 * Handle changes to a module checkbox to prompt for whether or not to enable dependencies
	 * @private
	 */
	async _onChangeCheckbox(event) {
		const input = event.target;
		this._checked[input.name] = input.checked;
		const module = game.modules.get(input.name);
		if ( !module.data.dependencies?.length ) return;
		const allModules = [...game.modules.values()];

		let dependenciesNotMatchingDesiredState = module.data.dependencies.filter(x => {
			if ( x.type === "system" ) return false;
			const pack = game.modules.get(x.name);
			if ( !pack ) {
				ui.notifications.error(game.i18n.format("MODMANAGE.DepNotInstalled", {missing: x.name}));
				return false;
			}
			if ( pack.active === input.checked ) return false;
			if ( !input.checked ) {
				// Check if other modules depend on this dependency, and if so, remove it from the to-disable list.
				return !allModules.find(a => {
					if ( !a.active ) return false;
					if ( a.data.name === input.name ) return false;
					return a.data.dependencies.find(d => d.name === x.name);
				});
			}
			return true;
		});

		if ( dependenciesNotMatchingDesiredState.length == 0 ) return;

		let html = await renderTemplate("templates/setup/impacted-dependencies.html", {
			enabling: input.checked,
			dependencies: dependenciesNotMatchingDesiredState
		});

		return Dialog.confirm({
			title: game.i18n.localize("MODMANAGE.Dependencies"),
			content: html,
			yes: () => {
				for ( let d of module.data.dependencies ) {
					const dep = input.form[d.name];
					if ( dep ) dep.checked = input.checked;
				}
			},
			no: () => {
				if ( input.checked ) {
					// We only cancel enabling, not disabling
					this._checked[input.name] = !input.checked;
					this._restoreCheckboxState();
				}
			}
		});
	}

	/* -------------------------------------------- */

	/**
	 * Handle a button-click to deactivate all modules
	 * @private
	 */
	_onDeactivateAll(event) {
		event.preventDefault();
		for ( let input of this.element[0].querySelectorAll('input[type="checkbox"]') ) {
			this._checked[input.name] = input.checked = false;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle expanding or collapsing the display of descriptive elements
	 * @private
	 */
	_onExpandCollapse(event) {
		event.preventDefault();
		this._expanded = !this._expanded;
		this.render();
	}

	/* -------------------------------------------- */

	/**
	 * Handle a button-click to deactivate all modules
	 * @private
	 */
	_onFilterList(event) {
		event.preventDefault();
		this._filter = event.target.dataset.filter;
		this.render();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onSearchFilter(event, query, rgx, html) {
		for ( let li of html.children ) {
			if ( !query ) {
				li.classList.remove("hidden");
				continue;
			}
			const name = li.dataset.moduleName;
			const title = (li.querySelector(".package-title")?.textContent || "").trim();
			const author = (li.querySelector(".author")?.textContent || "").trim();
			const match = rgx.test(SearchFilter.cleanQuery(name)) ||
				rgx.test(SearchFilter.cleanQuery(title)) ||
				rgx.test(SearchFilter.cleanQuery(author));
			li.classList.toggle("hidden", !match);
		}
	}
}

/**
 * An application for configuring the permissions which are available to each User role.
 * @extends {FormApplication}
 */
class PermissionConfig extends FormApplication {

	/** @override */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			title: game.i18n.localize("PERMISSION.Title"),
			id: "permissions-config",
			template: "templates/sidebar/apps/permission-config.html",
			width: 660,
			height: "auto",
			scrollY: [".permissions-list"],
			closeOnSubmit: true
		})
	}

	/* -------------------------------------------- */

	/** @override */
	async getData(options) {
		const current = await game.settings.get("core", "permissions");
		return {
			roles: Object.keys(CONST.USER_ROLES).reduce((obj, r) => {
				if ( r === "NONE" ) return obj;
				obj[r] = `USER.Role${r.titleCase()}`;
				return obj;
			}, {}),
			permissions: this._getPermissions(current)
		}
	}

	/* -------------------------------------------- */

	/**
	 * Prepare the permissions object used to render the configuration template
	 * @return {object[]}
	 * @private
	 */
	_getPermissions(current) {
		const rgm = CONST.USER_ROLES.GAMEMASTER;

		// Get permissions
		const perms = Object.entries(CONST.USER_PERMISSIONS).reduce((arr, e) => {
			const perm = foundry.utils.deepClone(e[1]);
			perm.id = e[0];
			perm.label = game.i18n.localize(perm.label);
			perm.hint = game.i18n.localize(perm.hint);
			arr.push(perm);
			return arr;
		}, []);
		perms.sort((a, b) => a.label.localeCompare(b.label));

		// Configure permission roles
		for ( let p of perms ) {
			const roles = current[p.id] || Array.fromRange(rgm + 1).slice(p.defaultRole);
			p.roles = Object.values(CONST.USER_ROLES).reduce((arr, role) => {
				if ( role === CONST.USER_ROLES.NONE ) return arr;
				arr.push({
					name: `${p.id}.${role}`,
					value: roles.includes(role),
					disabled: (role === rgm) && (!p.disableGM)
				});
				return arr;
			}, []);
		}
		return perms;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find('button[name="reset"]').click(this._onResetDefaults.bind(this));
	}

	/* -------------------------------------------- */

	/**
	 * Handle button click to reset default settings
	 * @param {Event} event   The initial button click event
	 * @private
	 */
	async _onResetDefaults(event) {
		event.preventDefault();
		const defaults = this._getPermissions({});
		await game.settings.set("core", "permissions", defaults);
		ui.notifications.info(`Reset User role permission configuration to default values.`);
		return this.render();
	}

	/* -------------------------------------------- */

	/** @override */
	async _onSubmit(event, options) {
		event.target.querySelectorAll("input[disabled]").forEach(i => i.disabled = false);
		return super._onSubmit(event, options);
	}

	/* -------------------------------------------- */

	/** @override */
	async _updateObject(event, formData) {
		const permissions = foundry.utils.expandObject(formData);
		for ( let [k, v] of Object.entries(permissions) ) {
			if ( !(k in CONST.USER_PERMISSIONS ) ) {
				delete permissions[k];
				continue
			}
			permissions[k] = Object.entries(v).reduce((arr, r) => {
				if ( r[1] === true ) arr.push(parseInt(r[0]));
				return arr;
			}, []);
		}
		await game.settings.set("core", "permissions", permissions);
		ui.notifications.info(`Updated User role permission configuration.`);
	}
}

/**
 * The World Management setup application
 * @extends {FormApplication}
 */
class WorldConfig extends FormApplication {
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "world-config",
			template: "templates/sidebar/apps/world-config.html",
			width: 600,
			height: "auto",
			create: false
		});
	}

	static WORLD_KB_URL = "https://foundryvtt.com/article/game-worlds/";

	/* -------------------------------------------- */

	/** @override */
	get title() {
		return this.options.create ? "Create New World" : `Edit World: ${this.object.data.title}`;
	}

	/* -------------------------------------------- */

	/** @override */
	getData(options) {
		const ac = CONST.PACKAGE_AVAILABILITY_CODES;
		const nextDate = new Date(this.object?.data?.nextSession || undefined);
		const worldConfigData = {
			world: this.object,
			isCreate: this.options.create,
			submitText: this.options.create ? "Create World" : "Update World",
			nextDate: nextDate.isValid() ? nextDate.toDateInputString() : "",
			nextTime: nextDate.isValid() ? nextDate.toTimeInputString() : "",
			worldKbUrl: WorldConfig.WORLD_KB_URL,
			inWorld: options.inWorld ?? false
		};
		worldConfigData.showEditFields = !worldConfigData.isCreate && !worldConfigData.inWorld;
		if ( game.data.systems ) {
			worldConfigData.systems = game.data.systems.filter(s => {
				if ( this.object.data && ( this.object.data.system === s.id ) ) return true;
				return ![ac.REQUIRES_DEPENDENCY, ac.REQUIRES_CORE].includes( s.availability );
			});
		}
		return worldConfigData;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	async _onSubmit(event) {
		event.preventDefault();
		const form = event.target || this.form;
		form.disabled = true;

		// Get form data
		const data = this._getSubmitData();
		if ( this.options.create ) data.action = "createWorld";
		else {
			data.action = "editWorld";
			data.name = this.object.data.name;
			if ( !data.resetKeys ) delete data.resetKeys;
			if ( !data.safeMode ) delete data.safeMode;
		}

		// Handle next session schedule fields
		if ( data.nextSession.some(t => !!t) ) {
			const now = new Date();
			const dateStr = `${data.nextSession[0] || now.toDateString()} ${data.nextSession[1] || now.toTimeString()}`;
			const date = new Date(dateStr);
			data.nextSession = isNaN(date) ? null : date.toISOString();
		}
		else data.nextSession = null;

		// Dispatch the POST request
		const response = await fetch(foundry.utils.getRoute("setup"), {
			method: "POST",
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(data)
		}).then(r => r.json());
		form.disabled = false;

		// Display error messages
		if ( response.error ) return ui.notifications.error(response.error);

		// Handle successful creation
		if ( game.data.worlds ) {
			const world = game.data.worlds.find(w => w.id === response.id);
			if ( world ) mergeObject(world.data, response.data);
			else game.data.worlds.push(response);
			if ( ui.setup ) ui.setup.render();
		}
		else {
			mergeObject(game.world.data, response.data);
		}
		return this.close();
	}
}

/**
 * A directory listing of Actor Documents in the Sidebar.
 * @extends {SidebarDirectory}
 */
class ActorDirectory extends SidebarDirectory {
	constructor(...args) {
		super(...args);
		this._dragDrop[0].permissions["dragstart"] = () => game.user.can("TOKEN_CREATE");
		this._dragDrop[0].permissions["dragdrop"] = () => game.user.can("ACTOR_CREATE");
	}

	/* -------------------------------------------- */

	/** @override */
	static documentName = "Actor";

	/* -------------------------------------------- */

	/** @override */
	_canDragStart(selector) {
		return game.user.can("TOKEN_CREATE");
	}

	/* -------------------------------------------- */

	/** @override */
	_onDragStart(event) {
		const li = event.currentTarget.closest(".directory-item");
		let actor = null;
		if ( li.dataset.entityId ) {
			actor = game.actors.get(li.dataset.entityId);
			if ( !actor || !actor.visible ) return false;
		}

		// Parent directory drag start handling
		super._onDragStart(event);

		// Create the drag preview for the Token
		if ( actor && canvas.ready ) {
			const img = li.querySelector("img");
			const td = actor.data.token;
			const w = td.width * canvas.dimensions.size * td.scale * canvas.stage.scale.x;
			const h = td.height * canvas.dimensions.size * td.scale * canvas.stage.scale.y;
			const preview = DragDrop.createDragImage(img, w, h);
			event.dataTransfer.setDragImage(preview, w / 2, h / 2);
		}
	}
	
	/* -------------------------------------------- */

	/** @override */
	_canDragDrop(selector) {
		return game.user.can("ACTOR_CREATE");
	}

	/* -------------------------------------------- */

	/** @override */
	async _onClickEntityName(event) {
		event.preventDefault();
		const actorId = event.currentTarget.closest(".actor").dataset.entityId;
		const actor = this.constructor.collection.get(actorId);
		if ( actor.sheet?.token ) await actor.sheet.close();
		super._onClickEntityName(event);
	}

	/* -------------------------------------------- */

	/** @override */
	_getEntryContextOptions() {
		const options = super._getEntryContextOptions();
		return [
			{
				name: "SIDEBAR.CharArt",
				icon: '<i class="fas fa-image"></i>',
				condition: li => {
					const actor = game.actors.get(li.data("entityId"));
					return actor.data.img !== CONST.DEFAULT_TOKEN;
				},
				callback: li => {
					const actor = game.actors.get(li.data("entityId"));
					new ImagePopout(actor.data.img, {
						title: actor.name,
						shareable: true,
						uuid: actor.uuid
					}).render(true);
				}
			},
			{
				name: "SIDEBAR.TokenArt",
				icon: '<i class="fas fa-image"></i>',
				condition: li => {
					const actor = game.actors.get(li.data("entityId"));
					if ( actor.data.token.randomImg ) return false;
					return ![null, undefined, CONST.DEFAULT_TOKEN].includes(actor.data.token.img);
				},
				callback: li => {
					const actor = game.actors.get(li.data("entityId"));
					new ImagePopout(actor.data.token.img, {
						title: actor.name,
						shareable: true,
						uuid: actor.uuid
					}).render(true);
				}
			}
		].concat(options);
	}
}

/**
 * The Chat Log application displayed in the Sidebar
 * @extends {SidebarTab}
 * @see {Sidebar}
 */
class ChatLog extends SidebarTab {
	constructor(options) {
		super(options);

		/**
		 * Track any pending text which the user has submitted in the chat log textarea
		 * @type {string}
		 * @private
		 */
		this._pendingText = "";

		/**
		 * Track the history of the past 5 sent messages which can be accessed using the arrow keys
		 * @type {object[]}
		 * @private
		 */
		this._sentMessages = [];

		/**
		 * Track which remembered message is being currently displayed to cycle properly
		 * @type {number}
		 * @private
		 */
		this._sentMessageIndex = -1;

		/**
		 * Track the time when the last message was sent to avoid flooding notifications
		 * @type {number}
		 * @private
		 */
		this._lastMessageTime = 0;

		/**
		 * Track the id of the last message displayed in the log
		 * @type {string|null}
		 * @private
		 */
		this._lastId = null;

		/**
		 * Track the last received message which included the user as a whisper recipient.
		 * @type {ChatMessage|null}
		 * @private
		 */
		this._lastWhisper = null;

		// Update timestamps every 15 seconds
		setInterval(this.updateTimestamps.bind(this), 1000 * 15);
	}

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "chat",
			template: "templates/sidebar/chat-log.html",
			title: game.i18n.localize("CHAT.Title"),
			scrollContainer: null,
			stream: false
		});
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the Messages collection that the chat log displays
	 * @type {Messages}
	 */
	get collection() {
		return game.messages;
	}

	/* -------------------------------------------- */
	/*  Application Rendering                       */
	/* -------------------------------------------- */

	/** @override */
	getData(options) {
		return {
			user: game.user,
			rollMode: game.settings.get("core", "rollMode"),
			rollModes: CONFIG.Dice.rollModes,
			isStream: !!this.options.stream
		};
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _render(force, options) {
		if (this.rendered) return; // Never re-render the Chat Log itself, only it's contents
		await super._render(force, options);
		this.scrollBottom();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _renderInner(data) {
		const html = await super._renderInner(data);
		await this._renderBatch(html, CONFIG.ChatMessage.batchSize);
		return html;
	}

	/* -------------------------------------------- */

	/**
	 * Render a batch of additional messages, prepending them to the top of the log
	 * @param {jQuery} html     The rendered jQuery HTML object
	 * @param {number} size     The batch size to include
	 * @return {Promise<void>}
	 * @private
	 */
	async _renderBatch(html, size) {
		const messages = game.messages.contents;
		const log = html.find("#chat-log");

		// Get the index of the last rendered message
		let lastIdx = messages.findIndex(m => m.id === this._lastId);
		lastIdx = lastIdx !== -1 ? lastIdx : messages.length;

		// Get the next batch to render
		let targetIdx = Math.max(lastIdx - size,  0);
		let m = null;
		if ( lastIdx !== 0 ) {
			let html = [];
			for ( let i=targetIdx; i<lastIdx; i++) {
				m = messages[i];
				if (!m.visible) continue;
				try {
					html.push(await m.getHTML());
				} catch (err) {
					err.message = `Chat message ${m.id} failed to render: ${err})`;
					console.error(err);
				}
			}

			// Prepend the HTML
			log.prepend(html);
			this._lastId = messages[targetIdx].id;
		}
	}

	/* -------------------------------------------- */
	/*  Chat Sidebar Methods                        */
	/* -------------------------------------------- */

	/**
	 * Delete a single message from the chat log
	 * @param {string} messageId    The ChatMessage entity to remove from the log
	 * @param {boolean} [deleteAll] Is this part of a flush operation to delete all messages?
	 */
	deleteMessage(messageId, {deleteAll=false}={}) {
		let li = this.element.find(`.message[data-message-id="${messageId}"]`);
		if ( !li.length ) return;

		// Update the last index
		if ( deleteAll ) {
			this._lastId = null;
		} else if ( messageId === this._lastId ) {
			const next = li[0].nextElementSibling;
			this._lastId = !!next ? next.dataset["messageId"] : null;
		}

		// Remove the deleted message
		li.slideUp(100, () => li.remove());

		// Delete from popout tab
		if ( this._popout ) this._popout.deleteMessage(messageId, {deleteAll});
		if ( this.popOut ) this.setPosition();
	}

	/* -------------------------------------------- */

	/**
	 * Trigger a notification that alerts the user visually and audibly that a new chat log message has been posted
	 */
	notify(message) {
		this._lastMessageTime = Date.now();
		if ( !this.rendered ) return;

		// Display the chat notification icon and remove it 3 seconds later
		let icon = $('#chat-notification');
		if ( icon.is(":hidden") ) icon.fadeIn(100);
		setTimeout(() => {
			if ( (Date.now() - this._lastMessageTime > 3000) && icon.is(":visible") ) icon.fadeOut(100);
		}, 3001);

		// Play a notification sound effect
		if ( message.data.sound ) AudioHelper.play({src: message.data.sound});
	}

	/* -------------------------------------------- */

	/**
	 * Parse a chat string to identify the chat command (if any) which was used
	 * @param {string} message    The message to match
	 * @return {string[]}         The identified command and regex match
	 */
	static parse(message) {

		// Dice roll regex
		let formula = '([^#]*)';                  // Capture any string not starting with '#'
		formula += '(?:(?:#\\s?)(.*))?';          // Capture any remaining flavor text
		const roll = '^(\\/r(?:oll)? )';          // Regular rolls, support /r or /roll
		const gm = '^(\\/gmr(?:oll)? )';          // GM rolls, support /gmr or /gmroll
		const br = '^(\\/b(?:lind)?r(?:oll)? )';  // Blind rolls, support /br or /blindroll
		const sr = '^(\\/s(?:elf)?r(?:oll)? )';   // Self rolls, support /sr or /sroll
		const any = '([^]*)';                     // Any character, including new lines

		// Define regex patterns
		const patterns = {
			"roll": new RegExp(roll+formula, 'i'),
			"gmroll": new RegExp(gm+formula, 'i'),
			"blindroll": new RegExp(br+formula, 'i'),
			"selfroll": new RegExp(sr+formula, 'i'),
			"ic": new RegExp('^(\/ic )'+any, 'i'),
			"ooc": new RegExp('^(\/ooc )'+any, 'i'),
			"emote": new RegExp('^(\/(?:em(?:ote)?|me) )'+any, 'i'),
			"whisper": new RegExp(/^(\/w(?:hisper)?\s)(\[(?:[^\]]+)\]|(?:[^\s]+))\s*([^]*)/, 'i'),
			"reply": new RegExp('^(\/reply )'+any, 'i'),
			"gm": new RegExp('^(\/gm )'+any, 'i'),
			'players': new RegExp('^(\/players )'+any, 'i'),
			"invalid": /^(\/[^\s]+)/, // Any other message starting with a slash command is invalid
		};

		// Iterate over patterns, finding the first match
		let c, rgx, match;
		for ( [c, rgx] of Object.entries(patterns) ) {
			match = message.match(rgx); 
			if ( match ) return [c, match];
		}
		return ["none", [message, "", message]];
	}

	/* -------------------------------------------- */

	/**
	 * Post a single chat message to the log
	 * @param {ChatMessage} message   A ChatMessage entity instance to post to the log
	 * @param {boolean} [notify]      Trigger a notification which shows the log as having a new unread message
	 * @return {Promise<void>}        A Promise which resolves once the message is posted
	 */
	async postOne(message, notify=false) {
		if ( !message.visible ) return;

		// Track internal flags
		if ( !this._lastId ) this._lastId = message.id; // Ensure that new messages don't result in batched scrolling
		if ( (message.data.whisper || []).includes(game.user.id) && !message.isRoll ) {
			this._lastWhisper = message;
		}

		// Render the message to the log
		const html = await message.getHTML();
		this.element.find("#chat-log").append(html);
		this.scrollBottom();

		// Post notification
		if ( notify ) this.notify(message);

		// Update popout tab
		if ( this._popout ) await this._popout.postOne(message, false);
		if ( this.popOut ) this.setPosition();
	}

	/* -------------------------------------------- */

	/**
	 * Scroll the chat log to the bottom
	 * @private
	 */
	scrollBottom() {
		const el = this.element;
		const log = el.length ? el[0].querySelector("#chat-log") : null;
		if ( log ) log.scrollTop = log.scrollHeight;
	}

	/* -------------------------------------------- */

	/**
	 * Update the content of a previously posted message after its data has been replaced
	 * @param {ChatMessage} message   The ChatMessage instance to update
	 * @param {boolean} notify        Trigger a notification which shows the log as having a new unread message
	 */
	async updateMessage(message, notify=false) {
		let li = this.element.find(`.message[data-message-id="${message.id}"]`);
		if ( li.length ) {
			const html = await message.getHTML();
			li.replaceWith(html);
		}
		else await this.postOne(message, false);

		// Post notification of update
		if ( notify ) this.notify(message);

		// Update popout tab
		if ( this._popout ) await this._popout.updateMessage(message, false);
		if ( this.popOut ) this.setPosition();
	}

	/* -------------------------------------------- */

	/**
	 * Update the displayed timestamps for every displayed message in the chat log.
	 * Timestamps are displayed in a humanized "timesince" format.
	 */
	updateTimestamps() {
		const messages = this.element.find("#chat-log .message");
		for ( let li of messages ) {
			const message = game.messages.get(li.dataset["messageId"]);
			if ( !message?.data.timestamp ) return;
			const stamp = li.querySelector('.message-timestamp');
			stamp.textContent = foundry.utils.timeSince(message.data.timestamp);
		}
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {

		// Load new messages on scroll
		html.find("#chat-log").scroll(this._onScrollLog.bind(this));

		// Chat message entry
		html.find("#chat-message").keydown(this._onChatKeyDown.bind(this));

		// Expand dice roll tooltips
		html.on("click", ".dice-roll", this._onDiceRollClick.bind(this));

		// Modify Roll Type
		html.find('select[name="rollMode"]').change(this._onChangeRollMode.bind(this));

		// Single Message Delete
		html.on('click', 'a.message-delete', this._onDeleteMessage.bind(this));

		// Flush log
		html.find('a.chat-flush').click(this._onFlushLog.bind(this));

		// Export log
		html.find('a.export-log').click(this._onExportLog.bind(this));

		// Chat Entry context menu
		this._contextMenu(html);
	}

	/* -------------------------------------------- */

	/**
	 * Prepare the data object of chat message data depending on the type of message being posted
	 * @param {string} message      The original string of the message content
	 * @return {Promise<Object>}    A Promise resolving to the prepared chat data object
	 */
	async processMessage(message) {
		message = message.trim();
		if ( !message ) return;
		const cls = ChatMessage.implementation;

		// Set up basic chat data
		const chatData = {
			user: game.user.id,
			speaker: cls.getSpeaker()
		};

		// Allow for handling of the entered message to be intercepted by a hook
		if ( Hooks.call("chatMessage", this, message, chatData) === false ) return;

		// Alter the message content, if needed
		message = message.replace(/\n/g, "<br>");

		// Parse the message to determine the matching handler
		let [command, match] = this.constructor.parse(message);

		// Special handlers for no command
		if ( command === "invalid" ) throw new Error(game.i18n.format("CHAT.InvalidCommand", {command: match[1]}));
		else if ( command === "none" ) command = chatData.speaker.token ? "ic" : "ooc";

		// Process message data based on the identified command type
		const createOptions = {};
		switch (command) {
			case "roll": case "gmroll": case "blindroll": case "selfroll":
				await this._processDiceCommand(command, match, chatData, createOptions);
				break;
			case "whisper": case "reply": case "gm": case "players":
				this._processWhisperCommand(command, match, chatData, createOptions);
				break;
			case "ic": case "emote": case "ooc":
				this._processChatCommand(command, match, chatData, createOptions);
				break;
		}

		// Create the message using provided data and options
		return cls.create(chatData, createOptions);
	}

	/* -------------------------------------------- */

	/**
	 * Process messages which are posted using a dice-roll command
	 * @param {string} command          The chat command type
	 * @param {RegExpMatchArray} match  The matched RegExp expressions
	 * @param {Object} chatData         The initial chat data
	 * @param {Object} createOptions    Options used to create the message
	 * @private
	 */
	async _processDiceCommand(command, match, chatData, createOptions) {

		// Convert the chat content into an evaluated Roll instance
		let [formula, flavor] = match.slice(2, 4);
		const actor = ChatMessage.getSpeakerActor(chatData.speaker) || game.user.character;
		const rollData = actor ? actor.getRollData() : {};
		const roll = Roll.create(formula, rollData);
		await roll.evaluate({async: true});

		// Roll content and flavor text
		foundry.utils.mergeObject(chatData, {
			flavor: flavor || null,
			type: CONST.CHAT_MESSAGE_TYPES.ROLL,
			roll: roll,
			content: roll.total,
			sound: CONFIG.sounds.dice
		});
		if ( ["gmroll", "blindroll"].includes(command) ) chatData.whisper = ChatMessage.getWhisperRecipients("GM");
		if ( command === "selfroll" ) chatData.whisper = [game.user.id];
		if ( command === "blindroll" ) chatData.blind = true;
	}

	/* -------------------------------------------- */

	/**
	 * Process messages which are posted using a chat whisper command
	 * @param {string} command          The chat command type
	 * @param {RegExpMatchArray} match  The matched RegExp expressions
	 * @param {Object} chatData         The initial chat data
	 * @param {Object} createOptions    Options used to create the message
	 * @private
	 */
	_processWhisperCommand(command, match, chatData, createOptions) {

		// Prepare whisper data
		chatData.type = CONST.CHAT_MESSAGE_TYPES.WHISPER;
		delete chatData.speaker;

		// Determine the recipient users
		let users = [];
		let message= "";
		switch(command) {
			case "whisper":
				message = match[3];
				const names = match[2].replace(/[\[\]]/g, "").split(",").map(n => n.trim());
				users = names.reduce((arr, n) => arr.concat(ChatMessage.getWhisperRecipients(n)), []);
				break;
			case "reply":
				message = match[2];
				const w = this._lastWhisper;
				if ( w ) {
					const group = new Set(w.data.whisper);
					group.add(w.data.user);
					group.delete(game.user.id);
					users = Array.from(group).map(id => game.users.get(id));
				}
				break;
			case "gm":
				message = match[2];
				users = ChatMessage.getWhisperRecipients("gm");
				break;
			case "players":
				message = match[2];
				users = ChatMessage.getWhisperRecipients("players");
				break;
		}

		// Ensure we have valid whisper targets
		if ( !users.length ) throw new Error(game.i18n.localize("ERROR.NoTargetUsersForWhisper"));
		if ( users.some(u => !u.isGM) && !game.user.can("MESSAGE_WHISPER") ) {
			throw new Error(game.i18n.localize("ERROR.CantWhisper"));
		}

		// Update chat data
		chatData.whisper = users.map(u => u.id);
		chatData.content = message;
		chatData.sound = CONFIG.sounds.notification;
	}

	/* -------------------------------------------- */

	/**
	 * Process messages which are posted using a chat whisper command
	 * @param {string} command          The chat command type
	 * @param {RegExpMatchArray} match  The matched RegExp expressions
	 * @param {Object} chatData         The initial chat data
	 * @param {Object} createOptions    Options used to create the message
	 * @private
	 */
	_processChatCommand(command, match, chatData, createOptions) {
		if ( ["ic", "emote"].includes(command) && !(chatData.speaker.actor || chatData.speaker.token) ) {
			throw new Error("You cannot chat in-character without an identified speaker");
		}
		chatData.content = match[2];

		// Augment chat data
		if ( command === "ic" ) {
			chatData.type = CONST.CHAT_MESSAGE_TYPES.IC;
			createOptions.chatBubble = true;
		} else if ( command === "emote" ) {
			chatData.type = CONST.CHAT_MESSAGE_TYPES.EMOTE;
			chatData.content = `${chatData.speaker.alias} ${chatData.content}`;
			createOptions.chatBubble = true;
		}
		else {
			chatData.type = CONST.CHAT_MESSAGE_TYPES.OOC;
			delete chatData.speaker;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Add a sent message to an array of remembered messages to be re-sent if the user pages up with the up arrow key
	 * @param {string} message    The message text being remembered
	 * @private
	 */
	_remember(message) {
		if ( this._sentMessages.length === 5 ) this._sentMessages.splice(4, 1);
		this._sentMessages.unshift(message);
		this._sentMessageIndex = -1;
	}

	/* -------------------------------------------- */

	/**
	 * Recall a previously sent message by incrementing up (1) or down (-1) through the sent messages array
	 * @param {number} direction    The direction to recall, positive for older, negative for more recent
	 * @return {string}             The recalled message, or an empty string
	 * @private
	 */
	_recall(direction) {
		if ( this._sentMessages.length > 0 ) {
			let idx = this._sentMessageIndex + direction;
			this._sentMessageIndex = Math.clamped(idx, -1, this._sentMessages.length-1);
		}
		return this._sentMessages[this._sentMessageIndex] || "";
	}

	/* -------------------------------------------- */

	/**
	 * Attach context menu options to messages in the chat log.
	 * @param {jQuery} html     The HTML element to which context options are attached
	 * @protected
	 */
	_contextMenu(html) {

		// Entry Context
		const entryOptions = this._getEntryContextOptions();

		// Dispatch Hooks down the chain
		for ( let cls of this.constructor._getInheritanceChain() ) {
			Hooks.call(`get${cls.name}EntryContext`, html, entryOptions);
		}
		if (entryOptions) new ContextMenu(html, ".message", entryOptions);
	}

	/* -------------------------------------------- */

	/**
	 * Get the ChatLog entry context options
	 * @return {object[]}   The sidebar entry context options
	 * @private
	 */
	_getEntryContextOptions() {
		return [
			{
				name: "CHAT.PopoutMessage",
				icon: '<i class="fas fa-external-link-alt fa-rotate-180"></i>',
				condition: li => {
					const message = game.messages.get(li.data("messageId"));
					return message.getFlag("core", "canPopout") === true;
				},
				callback: li => {
					const message = game.messages.get(li.data("messageId"));
					new ChatPopout(message).render(true);
				}
			},
			{
				name: "CHAT.RevealMessage",
				icon: '<i class="fas fa-eye"></i>',
				condition: li => {
					const message = game.messages.get(li.data("messageId"));
					const isLimited = message.data.whisper.length || message.data.blind;
					return isLimited && (game.user.isGM || message.isAuthor) && message.isContentVisible;
				},
				callback: li => {
					const message = game.messages.get(li.data("messageId"));
					return message.update({whisper: [], blind: false});
				}
			},
			{
				name: "CHAT.ConcealMessage",
				icon: '<i class="fas fa-eye-slash"></i>',
				condition: li => {
					const message = game.messages.get(li.data("messageId"));
					const isLimited = message.data.whisper.length || message.data.blind;
					return !isLimited && (game.user.isGM || message.isAuthor) && message.isContentVisible;
				},
				callback: li => {
					const message = game.messages.get(li.data("messageId"));
					return message.update({whisper: ChatMessage.getWhisperRecipients("gm").map(u => u.id), blind: false});
				}
			}
		]
	}

	/* -------------------------------------------- */

	/**
	 * Handle keydown events in the chat entry textarea
	 * @param {Event} event
	 * @private
	 */
	_onChatKeyDown(event) {
		const code = game.keyboard.getKey(event);
		const textarea = event.currentTarget;

		// UP/DOWN ARROW -> Recall Previous Messages
		const isArrow = ["ArrowUp", "ArrowDown"].includes(code);
		if ( isArrow ) {
			if ( this._pendingText ) return;
			event.preventDefault();
			textarea.value = this._recall(code === "ArrowUp" ? 1 : -1);
			return;
		}

		// ENTER -> Send Message
		const isEnter = (code === "Enter") && !event.shiftKey;
		if ( isEnter ) {
			event.preventDefault();
			const message = textarea.value;
			if (!message) return;
			this._pendingText = "";

			// Prepare chat message data and handle result
			return this.processMessage(message).then(() => {
				textarea.value = "";
				this._remember(message);
			}).catch(error => {
				ui.notifications.error(error);
				throw error;
			});
		}

		// BACKSPACE -> Remove pending text
		if ( event.key === "Backspace" ) {
			this._pendingText = this._pendingText.slice(0, -1);
			return
		}

		// Otherwise, record that there is pending text
		this._pendingText = textarea.value + (event.key.length === 1 ? event.key : "");
	}

	/* -------------------------------------------- */

	/**
	 * Handle setting the preferred roll mode
	 * @param {Event} event
	 * @private
	 */
	_onChangeRollMode(event) {
		event.preventDefault();
		game.settings.set("core", "rollMode", event.target.value);
	}

	/* -------------------------------------------- */

	/**
	 * Handle single message deletion workflow
	 * @param {Event} event
	 * @private
	 */
	_onDeleteMessage(event) {
		event.preventDefault();
		const li = event.currentTarget.closest(".message");
		const message = game.messages.get(li.dataset.messageId);
		return message.delete();
	}

	/* -------------------------------------------- */

	/**
	 * Handle clicking of dice tooltip buttons
	 * @param {Event} event
	 * @private
	 */
	_onDiceRollClick(event) {
		event.preventDefault();
		let roll = $(event.currentTarget),
				tip = roll.find(".dice-tooltip");
		if ( !tip.is(":visible") ) tip.slideDown(200);
		else tip.slideUp(200);
	}

	/* -------------------------------------------- */

	/**
	 * Handle click events to export the chat log
	 * @param {Event} event
	 * @private
	 */
	_onExportLog(event) {
		event.preventDefault();
		game.messages.export();
	}

	/* -------------------------------------------- */

	/**
	 * Handle click events to flush the chat log
	 * @param {Event} event
	 * @private
	 */
	_onFlushLog(event) {
		event.preventDefault();
		game.messages.flush();
	}

	/* -------------------------------------------- */

	/**
	 * Handle scroll events within the chat log container
	 * @param {UIEvent} event   The initial scroll event
	 * @private
	 */
	_onScrollLog(event) {
		if ( !this.rendered ) return;
		const log = event.target;
		const pct = log.scrollTop / log.scrollHeight;
		if ( pct < 0.01 ) {
			return this._renderBatch(this.element, CONFIG.ChatMessage.batchSize);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Update roll mode select dropdowns when the setting is changed
	 * @param {string} mode     The new roll mode setting
	 */
	static _setRollMode(mode) {
		for ( let select of $(".roll-type-select") ) {
			for ( let option of select.options ) {
				option.selected = option.value === mode;
			}
		}
	}
}

/**
 * The combat and turn order tracker tab
 * @extends {SidebarTab}
 */
class CombatTracker extends SidebarTab {
	constructor(options) {
		super(options);
		if ( !this.popOut ) game.combats.apps.push(this);

		/**
		 * Record a reference to the currently highlighted Token
		 * @type {Token|null}
		 * @private
		 */
		this._highlighted = null;

		/**
		 * Record the currently tracked Combat encounter
		 * @type {Combat|null}
		 */
		this.viewed = null;

		// Initialize the starting encounter
		this.initialize({render: false});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "combat",
			template: "templates/sidebar/combat-tracker.html",
			title: "Combat Tracker",
			scrollY: [".directory-list"]
		});
	}

	/* -------------------------------------------- */

	/**
	 * Return an array of Combat encounters which occur within the current Scene.
	 * @type {Combat[]}
	 */
	get combats() {
		const currentScene = game.scenes.current?.id || null;
		return game.combats.filter(c => (c.data.scene === null) || (c.data.scene === currentScene));
	}

	/* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */

	/** @inheritdoc */
	createPopout() {
		const pop = super.createPopout();
		pop.initialize({combat: this.viewed, render: true});
		return pop;
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the combat tracker to display a specific combat encounter.
	 * If no encounter is provided, the tracker will be initialized with the first encounter in the viewed scene.
	 * @param {Combat|null} combat    The combat encounter to initialize
	 * @param {boolean} render        Whether to re-render the sidebar after initialization
	 */
	initialize({combat=null, render=true}={}) {

		// Retrieve a default encounter if none was provided
		if ( combat === null ) {
			const combats = this.combats;
			combat = combats.length ? combats.find(c => c.data.active) || combats[0] : null;
		}

		// Set flags
		this.viewed = combat;
		this._highlighted = null;

		// Trigger data computation
		if ( combat && !combat.turns ) combat.turns = combat.setupTurns();

		// Also initialize the popout
		if ( this._popout ) this._popout.initialize({combat, render: false});

		// Render the tracker
		if ( render ) this.render();
	}

	/* -------------------------------------------- */

	/**
	 * Scroll the combat log container to ensure the current Combatant turn is centered vertically
	 */
	scrollToTurn() {
		const combat = this.viewed;
		if ( !combat ) return;
		let active = this.element.find(".active")[0];
		if ( !active ) return;
		let container = active.parentElement;
		const nViewable = Math.floor(container.offsetHeight / active.offsetHeight);
		container.scrollTop = (combat.turn * active.offsetHeight) - ((nViewable/2) * active.offsetHeight);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async getData(options) {

		// Get the combat encounters possible for the viewed Scene
		const combat = this.viewed;
		const hasCombat = combat !== null;
		const combats = this.combats;
		const currentIdx = combats.findIndex(c => c === combat);
		const previousId = currentIdx > 0 ? combats[currentIdx-1].id : null;
		const nextId = currentIdx < combats.length - 1 ? combats[currentIdx+1].id : null;
		const settings = game.settings.get("core", Combat.CONFIG_SETTING);

		// Prepare rendering data
		const data = {
			user: game.user,
			combats: combats,
			currentIndex: currentIdx + 1,
			combatCount: combats.length,
			hasCombat: hasCombat,
			combat,
			turns: [],
			previousId,
			nextId,
			started: this.started,
			control: false,
			settings
		};
		if ( !hasCombat ) return data;

		// Format information about each combatant in the encounter
		let hasDecimals = false;
		const turns = [];
		for ( let [i, combatant] of combat.turns.entries() ) {
			if ( !combatant.isVisible ) continue;

			// Prepare turn data
			const resource = combatant.permission >= CONST.ENTITY_PERMISSIONS.OBSERVER ? combatant.resource : null
			const turn = {
				id: combatant.id,
				name: combatant.name,
				img: combatant.img,
				active: i === combat.turn,
				owner: combatant.isOwner,
				defeated: combatant.data.defeated,
				hidden: combatant.hidden,
				initiative: combatant.initiative,
				hasRolled: combatant.initiative !== null,
				hasResource: resource !== null,
				resource: resource
			};
			if ( Number.isFinite(turn.initiative) && !Number.isInteger(turn.initiative) ) hasDecimals = true;
			turn.css = [
				turn.active ? "active" : "",
				turn.hidden ? "hidden" : "",
				turn.defeated ? "defeated" : ""
			].join(" ").trim();

			// Cached thumbnail image for video tokens
			if ( VideoHelper.hasVideoExtension(turn.img) ) {
				if ( combatant._thumb ) turn.img = combatant._thumb;
				else turn.img = combatant._thumb = await game.video.createThumbnail(combatant.img, {width: 100, height: 100});
			}

			// Actor and Token status effects
			turn.effects = new Set();
			if ( combatant.token ) {
				combatant.token.data.effects.forEach(e => turn.effects.add(e));
				if ( combatant.token.data.overlayEffect ) turn.effects.add(combatant.token.data.overlayEffect);
			}
			if ( combatant.actor ) combatant.actor.temporaryEffects.forEach(e => {
				if ( e.getFlag("core", "statusId") === CONFIG.Combat.defeatedStatusId ) turn.defeated = true;
				else if ( e.data.icon ) turn.effects.add(e.data.icon);
			});
			turns.push(turn);
		}

		// Format initiative numeric precision
		const precision = CONFIG.Combat.initiative.decimals;
		turns.forEach(t => {
			if ( t.initiative !== null ) t.initiative = t.initiative.toFixed(hasDecimals ? precision : 0);
		});

		// Merge update data for rendering
		return foundry.utils.mergeObject(data, {
			round: combat.data.round,
			turn: combat.data.turn,
			turns: turns,
			control: combat.combatant?.players?.includes(game.user)
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		super.activateListeners(html);
		const tracker = html.find("#combat-tracker");
		const combatants = tracker.find(".combatant");

		// Create new Combat encounter
		html.find('.combat-create').click(ev => this._onCombatCreate(ev));

		// Display Combat settings
		html.find('.combat-settings').click(ev => {
			ev.preventDefault();
			new CombatTrackerConfig().render(true);
		});

		// Cycle the current Combat encounter
		html.find('.combat-cycle').click(ev => this._onCombatCycle(ev));

		// Combat control
		html.find('.combat-control').click(ev => this._onCombatControl(ev));

		// Combatant control
		html.find('.combatant-control').click(ev => this._onCombatantControl(ev));

		// Hover on Combatant
		combatants.hover(this._onCombatantHoverIn.bind(this), this._onCombatantHoverOut.bind(this));

		// Click on Combatant
		combatants.click(this._onCombatantMouseDown.bind(this));

		// Context on right-click
		if ( game.user.isGM ) this._contextMenu(html);

		// Intersection Observer for Combatant avatars
		const observer = new IntersectionObserver(this._onLazyLoadImage.bind(this), { root: tracker[0] });
		combatants.each((i, li) => observer.observe(li));
	}

	/* -------------------------------------------- */

	/**
	 * Handle new Combat creation request
	 * @param {Event} event
	 * @private
	 */
	async _onCombatCreate(event) {
		event.preventDefault();
		let scene = game.scenes.current;
		const cls = getDocumentClass("Combat");
		const combat = await cls.create({scene: scene?.id});
		await combat.activate();
		this.initialize(combat);
	}

	/* -------------------------------------------- */

	/**
	 * Handle a Combat deletion request
	 * @param {Event} event
	 * @private
	 */
	async _onCombatDelete(event) {
		event.preventDefault();
		let btn = event.currentTarget;
		if ( btn.hasAttribute("disabled") ) return;
		let cbt = game.combats.get(btn.getAttribute("data-combat-id"));
		await cbt.delete();
	}

	/* -------------------------------------------- */

	/**
	 * Handle a Combat cycle request
	 * @param {Event} event
	 * @private
	 */
	async _onCombatCycle(event) {
		event.preventDefault();
		const btn = event.currentTarget;
		const combat = game.combats.get(btn.dataset.combatId);
		if ( !combat ) return;
		await combat.activate();
		this.initialize({combat});
	}

	/* -------------------------------------------- */

	/**
	 * Handle click events on Combat control buttons
	 * @private
	 * @param {Event} event   The originating mousedown event
	 */
	async _onCombatControl(event) {
		event.preventDefault();
		const combat = this.viewed;
		const ctrl = event.currentTarget;
		if ( ctrl.getAttribute("disabled") ) return;
		else ctrl.setAttribute("disabled", true);
		const fn = combat[ctrl.dataset.control];
		if ( fn ) await fn.bind(combat)();
		ctrl.removeAttribute("disabled");
	}

	/* -------------------------------------------- */

	/**
	 * Handle a Combatant control toggle
	 * @private
	 * @param {Event} event   The originating mousedown event
	 */
	async _onCombatantControl(event) {
		event.preventDefault();
		event.stopPropagation();
		const btn = event.currentTarget;
		const li = btn.closest(".combatant");
		const combat = this.viewed;
		const c = combat.combatants.get(li.dataset.combatantId);

		// Switch control action
		switch (btn.dataset.control) {

			// Toggle combatant visibility
			case "toggleHidden":
				return c.update({hidden: !c.hidden});

			// Toggle combatant defeated flag
			case "toggleDefeated":
				return this._onToggleDefeatedStatus(c);

			// Roll combatant initiative
			case "rollInitiative":
				return combat.rollInitiative([c.id]);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle toggling the defeated status effect on a combatant Token
	 * @param {Combatant} combatant     The combatant data being modified
	 * @return {Promise}                A Promise that resolves after all operations are complete
	 * @private
	 */
	async _onToggleDefeatedStatus(combatant) {
		let isDefeated = !combatant.data.defeated;
		await combatant.update({defeated: isDefeated});
		const token = canvas.tokens.get(combatant.data.tokenId);
		if ( !token ) return;

		// Push the defeated status to the token
		let status = CONFIG.statusEffects.find(e => e.id === CONFIG.Combat.defeatedStatusId);
		let effect = token.actor && status ? status : CONFIG.controlIcons.defeated;
		await token.toggleEffect(effect, {overlay: true, active: isDefeated});
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-down event on a combatant name in the tracker
	 * @param {Event} event   The originating mousedown event
	 * @return {Promise}      A Promise that resolves once the pan is complete
	 * @private
	 */
	async _onCombatantMouseDown(event) {
		event.preventDefault();

		const li = event.currentTarget;
		const combatant = this.viewed.combatants.get(li.dataset.combatantId);
		const token = combatant.token;
		if ( !token?.actor?.testUserPermission(game.user, "OBSERVED") ) return;
		const now = Date.now();

		// Handle double-left click to open sheet
		const dt = now - this._clickTime;
		this._clickTime = now;
		if ( dt <= 250 ) {
			if ( token.actor ) token.actor.sheet.render(true);
		}

		// Control and pan on single-left
		else {
			token.object.control({releaseOthers: true});
			return canvas.animatePan({x: token.data.x, y: token.data.y});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-hover events on a combatant in the tracker
	 * @private
	 */
	_onCombatantHoverIn(event) {
		event.preventDefault();
		if ( !canvas.ready ) return;
		const li = event.currentTarget;
		const combatant = this.viewed.combatants.get(li.dataset.combatantId);
		const token = combatant.token?.object;
		if ( token?.isVisible ) {
			if ( !token._controlled ) token._onHoverIn(event);
			this._highlighted = token;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-unhover events for a combatant in the tracker
	 * @private
	 */
	_onCombatantHoverOut(event) {
		event.preventDefault();
		if ( this._highlighted ) this._highlighted._onHoverOut(event);
		this._highlighted = null;
	}

	/* -------------------------------------------- */

	/**
	 * Attach context menu options to elements in the tracker
	 * @param {jQuery} html     The HTML element to which context options are attached
	 * @private
	 */
	_contextMenu(html) {
		const entryOptions = this._getEntryContextOptions();

		// Dispatch Hooks down the chain
		for ( let cls of this.constructor._getInheritanceChain() ) {
			Hooks.call(`get${cls.name}EntryContext`, html, entryOptions);
		}
		if (entryOptions) new ContextMenu(html, ".directory-item", entryOptions);
	}

	/* -------------------------------------------- */

	/**
	 * Get the sidebar directory entry context options
	 * @return {Object}   The sidebar entry context options
	 * @private
	 */
	_getEntryContextOptions() {
		return [
			{
				name: "COMBAT.CombatantUpdate",
				icon: '<i class="fas fa-edit"></i>',
				callback: this._onConfigureCombatant.bind(this)
			},
			{
				name: "COMBAT.CombatantClear",
				icon: '<i class="fas fa-undo"></i>',
				condition: li => {
					const combatant = this.viewed.combatants.get(li.data("combatant-id"));
					return combatant?.data?.initiative ?? false;
				},
				callback: li => {
					const combatant = this.viewed.combatants.get(li.data("combatant-id"));
					if ( combatant ) return combatant.update({initiative: null});
				}
			},
			{
				name: "COMBAT.CombatantReroll",
				icon: '<i class="fas fa-dice-d20"></i>',
				callback: li => {
					const combatant = this.viewed.combatants.get(li.data("combatant-id"));
					if ( combatant ) return this.viewed.rollInitiative([combatant.id]);
				}
			},
			{
				name: "COMBAT.CombatantRemove",
				icon: '<i class="fas fa-skull"></i>',
				callback: li => {
					const combatant = this.viewed.combatants.get(li.data("combatant-id"));
					if ( combatant ) return combatant.delete();
				}
			}
		];
	}

	/* -------------------------------------------- */

	/**
	 * Display a dialog which prompts the user to enter a new initiative value for a Combatant
	 * @param {jQuery} li
	 * @private
	 */
	_onConfigureCombatant(li) {
		const combatant = this.viewed.combatants.get(li.data('combatant-id'));
		new CombatantConfig(combatant, {
			top: Math.min(li[0].offsetTop, window.innerHeight - 350),
			left: window.innerWidth - 720,
			width: 400
		}).render(true);
	}
}

/**
 * A compendium of knowledge arcane and mystical!
 * @extends {SidebarTab}
 */
class CompendiumDirectory extends SidebarTab {

	/** @override */
	static get defaultOptions() {
		return foundry.utils.mergeObject(super.defaultOptions, {
			id: "compendium",
			template: "templates/sidebar/compendium-directory.html",
			title: "Compendium Packs"
		});
	}

	/* -------------------------------------------- */

	/** @override */
	getData(options) {

		// Filter packs for visibility
		let packs = game.packs.filter(p => game.user.isGM || !p.private);

		// Sort packs by Entity type
		const packData = packs.sort((a,b) => a.metadata.entity.localeCompare(b.metadata.entity)).reduce((obj, pack) => {
			const documentName = pack.documentClass.documentName;
			if ( !obj.hasOwnProperty(documentName) ) obj[documentName] = {
				label: documentName,
				packs: []
			};
			obj[documentName].packs.push(pack);
			return obj;
		}, {});

		// Sort packs within type
		for ( let [e, p] of Object.entries(packData) ) {
			p.packs = p.packs.sort((a,b) => a.title.localeCompare(b.title));
		}

		// Return data to the sidebar
		return {
			user: game.user,
			packs: packData
		}
	}

	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {

		// Click to open
		html.find('.compendium-pack').click(ev => {
			const li = ev.currentTarget;
			const pack = game.packs.get(li.dataset.pack);
			if ( li.dataset.open === "1" ) pack.apps.forEach(app => app.close());
			else {
				li.dataset.open = "1";
				const icon = li.querySelector("i.folder");
				icon.classList.replace("fa-folder", "fa-folder-open");
				pack.render(true);
			}
		});

		// Options below are GM only
		if ( !game.user.isGM ) return;

		// Create Compendium
		html.find('.create-compendium').click(this._onCreateCompendium.bind(this));
		
		// Compendium context menu
		this._contextMenu(html);
	}

	/* -------------------------------------------- */

	/**
	 * Compendium sidebar Context Menu creation
	 * @param {jQuery} html     The HTML being rendered for the compendium directory
	 * @protected
	 */
	_contextMenu(html) {
		const entryOptions = this._getEntryContextOptions();

		// Dispatch Hooks down the chain
		for ( let cls of this.constructor._getInheritanceChain() ) {
			Hooks.call(`get${cls.name}EntryContext`, html, entryOptions);
		}
		if (entryOptions) new ContextMenu(html, ".compendium-pack", entryOptions);
	}

	/* -------------------------------------------- */

	/**
	 * Get the sidebar directory entry context options
	 * @return {Object}   The sidebar entry context options
	 * @private
	 */
	_getEntryContextOptions() {
		return [
			{
				name: "COMPENDIUM.ToggleVisibility",
				icon: '<i class="fas fa-eye"></i>',
				callback: li => {
					let pack = game.packs.get(li.data("pack"));
					pack.configure({private: !pack.private});
				}
			},
			{
				name: "COMPENDIUM.ToggleLocked",
				icon: '<i class="fas fa-lock"></i>',
				callback: li => {
					let pack = game.packs.get(li.data("pack"));
					const isUnlock = pack.locked;
					if ( isUnlock && (pack.metadata.package !== "world")) {
						return Dialog.confirm({
							title: `${game.i18n.localize("COMPENDIUM.ToggleLocked")}: ${pack.title}`,
							content: `<p><strong>${game.i18n.localize("Warning")}:</strong> ${game.i18n.localize("COMPENDIUM.ToggleLockedWarning")}</p>`,
							yes: () => pack.configure({locked: !pack.locked}),
							options: {
								top: Math.min(li[0].offsetTop, window.innerHeight - 350),
								left: window.innerWidth - 720,
								width: 400
							}
						});
					}
					else return pack.configure({locked: !pack.locked});
				}
			},
			{
				name: "COMPENDIUM.Duplicate",
				icon: '<i class="fas fa-copy"></i>',
				callback: li => {
					let pack = game.packs.get(li.data("pack"));
					const html = `<form>
						<div class="form-group">
								<label>${game.i18n.localize("COMPENDIUM.DuplicateTitle")}</label>
								<input type="text" name="label" value="${pack.title}"/>
								<p class="notes">${game.i18n.localize("COMPENDIUM.DuplicateHint")}</p>
						</div>
					</form>`;
					return Dialog.confirm({
						title: `${game.i18n.localize("COMPENDIUM.ToggleLocked")}: ${pack.title}`,
						content: html,
						yes: html => {
							const label = html.querySelector('input[name="label"]').value;
							return pack.duplicateCompendium({label})
						},
						options: {
							top: Math.min(li[0].offsetTop, window.innerHeight - 350),
							left: window.innerWidth - 720,
							width: 400,
							jQuery: false
						}
					});
				}
			},
			{
				name: "COMPENDIUM.ImportAll",
				icon: '<i class="fas fa-download"></i>',
				callback: li => {
					let pack = game.packs.get(li.data("pack"));
					const html = `<form>
						<div class="form-group">
								<label>${game.i18n.localize("FOLDER.Name")}</label>
								<input type="text" name="folderName" value="${pack.title}"/>
								<p class="notes">${game.i18n.localize("COMPENDIUM.ImportAllHint")}</p>
						</div>
					</form>`;
					return Dialog.confirm({
						title: `${game.i18n.localize("COMPENDIUM.ImportAll")}: ${pack.title}`,
						content: html,
						yes: html => {
							const folderName = html.querySelector('input[name="folderName"]').value;
							return pack.importAll({folderName});
						},
						options: {
							top: Math.min(li[0].offsetTop, window.innerHeight - 350),
							left: window.innerWidth - 720,
							width: 400,
							jQuery: false
						}
					});
				}
			},
			{
				name: "COMPENDIUM.Delete",
				icon: '<i class="fas fa-trash"></i>',
				condition: li => {
					let pack = game.packs.get(li.data("pack"));
					return pack.metadata.package === "world";
				},
				callback: li => {
					let pack = game.packs.get(li.data("pack"));
					this._onDeleteCompendium(pack);
				}
			}
		];
	}

	/* -------------------------------------------- */

	/**
	 * Handle a Compendium Pack creation request
	 * @param {PointerEvent} event      The originating click event
	 * @private
	 */
	async _onCreateCompendium(event) {
		event.preventDefault();
		const types = CONST.COMPENDIUM_ENTITY_TYPES;
		const html = await renderTemplate('templates/sidebar/compendium-create.html', {types});
		return Dialog.prompt({
			title: game.i18n.localize("COMPENDIUM.Create"),
			content: html,
			label: game.i18n.localize("COMPENDIUM.Create"),
			callback: html => {
					const form = html.querySelector("#compendium-create");
					const fd = new FormDataExtended(form);
					const metadata = fd.toObject();
					if ( !metadata.label ) {
						const err = new Error(game.i18n.localize("COMPENDIUM.ErrorRequireTitle"));
						return ui.notifications.warn(err.message);
					}
					CompendiumCollection.createCompendium(metadata).then(() => this.render());
				},
			options: { jQuery: false }
		});
	}

	/* -------------------------------------------- */

	/**
	 * Handle a Compendium Pack deletion request
	 * @param {Object} pack   The pack object requested for deletion
	 * @private
	 */
	_onDeleteCompendium(pack) {
		return Dialog.confirm({
			title: `${game.i18n.localize("COMPENDIUM.Delete")}: ${pack.title}`,
			content: `<h4>${game.i18n.localize("AreYouSure")}</h4><p>${game.i18n.localize("COMPENDIUM.DeleteWarning")}</p>`,
			yes: () => pack.deleteCompendium(),
			defaultYes: false
		})
	}
}

/**
 * A directory listing of Item Documents in the Sidebar.
 * @extends {SidebarDirectory}
 */
class ItemDirectory extends SidebarDirectory {

	/** @override */
	static documentName = "Item";

	/* -------------------------------------------- */

	/** @override */
	_canDragDrop(selector) {
		return game.user.can("ITEM_CREATE");
	}

	/* -------------------------------------------- */

	/** @override */
	_getEntryContextOptions() {
		const options = super._getEntryContextOptions();
		return [
			{
				name: "ITEM.ViewArt",
				icon: '<i class="fas fa-image"></i>',
				condition: li => {
					const item = game.items.get(li.data("entityId"));
					return item.data.img !== CONST.DEFAULT_TOKEN;
				},
				callback: li => {
					const item = game.items.get(li.data("entityId"));
					new ImagePopout(item.data.img, {
						title: item.name,
						shareable: true,
						uuid: item.uuid
					}).render(true);
				}
			}
		].concat(options);
	}
}


/**
 * A directory listing of JournalEntry Documents in the Sidebar.
 * @extends {SidebarDirectory}
 */
class JournalDirectory extends SidebarDirectory {

	/** @override */
	static documentName = "JournalEntry";

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = "journal";
		options.template = "templates/sidebar/journal-directory.html";
		return options;
	}

	/* -------------------------------------------- */

	/** @override */
	get title() {
		return game.i18n.localize("JOURNAL.Title");
	}

	/* -------------------------------------------- */

	/** @override */
	_getEntryContextOptions() {
		const options = super._getEntryContextOptions();
		return options.concat([
			{
				name: "SIDEBAR.JumpPin",
				icon: '<i class="fas fa-crosshairs"></i>',
				condition: li => {
					const entry = game.journal.get(li.data("entity-id"));
					return !!entry.sceneNote;
				},
				callback: li => {
					const entry = game.journal.get(li.data("entity-id"));
					return entry.panToNote();
				}
			}
		]);
	}
}


/**
 * A directory list of Macro Documents. Unlike other directories, this app is only rendered in pop-out mode.
 * @extends {SidebarDirectory}
 *
 * @see {@link Macros}        The WorldCollection of Macro Entities
 * @see {@link Macro}         The Macro Entity
 * @see {@link MacroConfig}   The Macro Configuration Sheet
 */
class MacroDirectory extends SidebarDirectory {
	constructor(options={}) {
		options.popOut = true;
		super(options);
		delete ui.sidebar.tabs["macros"];
		game.macros.apps.push(this);
	}

	/** @override */
	static documentName = "Macro";

	/* -------------------------------------------- */

	/** @override */
	async _onCreate(event) {
		event.preventDefault();
		const name = game.i18n.format("ENTITY.New", {entity: game.i18n.localize("ENTITY.Macro")});
		const macro = await Macro.create({name, type: "chat", scope: "global"}, {temporary: true});
		macro.sheet.render(true);
	}
}

/**
 * A directory listing of audio Playlist Documents in the Sidebar.
 * @extends {SidebarDirectory}
 */
class PlaylistDirectory extends SidebarDirectory {
	constructor(options) {
		super(options);

		/**
		 * Track the playlist IDs which are currently expanded in their display
		 * @type {Set<string>}
		 */
		this._expanded = this._createExpandedSet();

		/**
		 * Are the global volume controls currently expanded?
		 * @type {boolean}
		 * @private
		 */
		this._volumeExpanded = false;

		/**
		 * Cache the set of Playlist documents that are displayed as playing when the directory is rendered
		 * @type {Playlist[]}
		 */
		this._playingPlaylists = [];

		/**
		 * Cache the set of PlaylistSound documents that are displayed as playing when the directory is rendered
		 * @type {PlaylistSound[]}
		 */
		this._playingSounds = [];

		// Update timestamps every second
		setInterval(this._updateTimestamps.bind(this), 1000);
	}

	/** @override */
	static documentName = "Playlist";

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.dragDrop[0].dragSelector = ".playlist-name";
		options.renderUpdateKeys = ["name", "playing", "mode", "sounds", "sort", "sorting", "folder"];
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the set of Playlists which should be displayed in an expanded form
	 * @returns {Set<string>}
	 * @private
	 */
	_createExpandedSet() {
		const expanded = new Set();
		for ( let playlist of this.documents ) {
			if ( playlist.playing ) expanded.add(playlist.id);
		}
		return expanded;
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * Return an Array of the Playlist entities which are currently playing
	 * @return {Playlist[]}
	 */
	get playing() {
		return this._playingPlaylists;
	}

	/* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async _render(force, options) {
		this._playingPlaylists = [];
		this._playingSounds = [];
		this._playingSoundsData = [];
		return super._render(force, options);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData(options) {
		this._prepareTreeData(this.tree);
		return foundry.utils.mergeObject(super.getData(options), {
			playingSounds: this._playingSoundsData,
			showPlaying: this._playingSoundsData.length > 0,
			playlistModifier: AudioHelper.volumeToInput(game.settings.get("core", "globalPlaylistVolume")),
			ambientModifier: AudioHelper.volumeToInput(game.settings.get("core", "globalAmbientVolume")),
			interfaceModifier: AudioHelper.volumeToInput(game.settings.get("core", "globalInterfaceVolume")),
			volumeExpanded: this._volumeExpanded
		});
	}

	/* -------------------------------------------- */

	/**
	 * Augment the tree directory structure with playlist-level data objects for rendering
	 * @param {object} leaf   The tree leaf node being prepared
	 * @private
	 */
	_prepareTreeData(leaf) {
		leaf.playlists = leaf.content.map(p => this._preparePlaylistData(p));
		for ( let f of leaf.children ) {
			this._prepareTreeData(f);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Create an object of rendering data for each Playlist document being displayed
	 * @param {Playlist} playlist   The playlist to display
	 * @returns {object}            The data for rendering
	 * @private
	 */
	_preparePlaylistData(playlist) {
		const isGM = game.user.isGM;
		if ( playlist.playing ) this._playingPlaylists.push(playlist);

		// Playlist configuration
		const p = playlist.data.toObject(false);
		p.modeTooltip = this._getModeTooltip(p.mode);
		p.modeIcon = this._getModeIcon(p.mode);
		p.disabled = p.mode === CONST.PLAYLIST_MODES.DISABLED;
		p.expanded = this._expanded.has(p._id);
		p.css = [p.expanded ? "" : "collapsed", playlist.playing ? "playing" : ""].filterJoin(" ")
		p.controlCSS = (isGM && !p.disabled) ? "" : "disabled";

		// Playlist sounds
		const sounds = [];
		for ( let sound of playlist.sounds ) {
			if ( !isGM && !sound.playing ) continue;

			// All sounds
			const s = sound.data.toObject(false);
			s.playlistId = playlist.id;
			s.css = s.playing ? "playing" : "";
			s.controlCSS = isGM ? "" : "disabled";
			s.playIcon = this._getPlayIcon(sound);
			s.playTitle = s.pausedTime ? "PLAYLIST.SoundResume" : "PLAYLIST.SoundPlay";

			// Playing sounds
			if ( sound.playing || s.pausedTime ) {
				s.isPaused = !sound.playing && s.pausedTime;
				s.pauseIcon = this._getPauseIcon(sound);
				s.lvolume = AudioHelper.volumeToInput(s.volume);
				s.currentTime = this._formatTimestamp(sound.playing ? sound.sound.currentTime : s.pausedTime);
				s.durationTime = this._formatTimestamp(sound.sound.duration);
				this._playingSounds.push(sound);
				this._playingSoundsData.push(s);
			}
			sounds.push(s);
		}
		p.sounds = sounds.sort((a, b) => a.name.localeCompare(b.name));
		return p;
	}

	/* -------------------------------------------- */

	/**
	 * Get the icon used to represent the "play/stop" icon for the PlaylistSound
	 * @param {PlaylistSound} sound   The sound being rendered
	 * @returns {string}              The icon that should be used
	 * @private
	 */
	_getPlayIcon(sound) {
		if ( !sound.playing ) return sound.data.pausedTime ? "fas fa-play-circle" : "fas fa-play";
		else return "fas fa-square";
	}

	/* -------------------------------------------- */

	/**
	 * Get the icon used to represent the pause/loading icon for the PlaylistSound
	 * @param {PlaylistSound} sound   The sound being rendered
	 * @returns {string}              The icon that should be used
	 * @private
	 */
	_getPauseIcon(sound) {
		return (sound.playing && !sound.sound.loaded) ? "fas fa-spinner fa-spin" : "fas fa-pause";
	}

	/* -------------------------------------------- */

	/**
	 * Given a constant playback mode, provide the FontAwesome icon used to display it
	 * @param {number} mode
	 * @return {string}
	 * @private
	 */
	_getModeIcon(mode) {
		return {
			[CONST.PLAYLIST_MODES.DISABLED]: '<i class="fas fa-ban"></i>',
			[CONST.PLAYLIST_MODES.SEQUENTIAL]: '<i class="far fa-arrow-alt-circle-right"></i>',
			[CONST.PLAYLIST_MODES.SHUFFLE]: '<i class="fas fa-random"></i>',
			[CONST.PLAYLIST_MODES.SIMULTANEOUS]: '<i class="fas fa-compress-arrows-alt"></i>',
		}[mode];
	}

	/* -------------------------------------------- */

	/**
	 * Given a constant playback mode, provide the string tooltip used to describe it
	 * @param {number} mode
	 * @return {string}
	 * @private
	 */
	_getModeTooltip(mode) {
		return {
			[CONST.PLAYLIST_MODES.DISABLED]: game.i18n.localize("PLAYLIST.ModeDisabled"),
			[CONST.PLAYLIST_MODES.SEQUENTIAL]: game.i18n.localize("PLAYLIST.ModeSequential"),
			[CONST.PLAYLIST_MODES.SHUFFLE]: game.i18n.localize("PLAYLIST.ModeShuffle"),
			[CONST.PLAYLIST_MODES.SIMULTANEOUS]: game.i18n.localize("PLAYLIST.ModeSimultaneous")
		}[mode];
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);

		// Volume sliders
		html.find('.global-volume-slider').change(this._onGlobalVolume.bind(this));
		html.find('.sound-volume').change(this._onSoundVolume.bind(this));

		// Collapse/Expand
		html.find(".playlist-name").click(this._onPlaylistCollapse.bind(this));
		html.find("#global-volume .playlist-header").click(this._onVolumeCollapse.bind(this))

		// All options below require a GM user
		if (!game.user.isGM) return;

		// Playlist Control Events
		html.on("click", "a.sound-control", event => {
			event.preventDefault();
			const btn = event.currentTarget;
			const action = btn.dataset.action;
			if (!action || btn.classList.contains("disabled")) return;

			// Delegate to Playlist and Sound control handlers
			switch (action) {
				case "playlist-mode":
					return this._onPlaylistToggleMode(event);
				case "playlist-play":
				case "playlist-stop":
					return this._onPlaylistPlay(event, action === "playlist-play");
				case "playlist-forward":
				case "playlist-backward":
					return this._onPlaylistSkip(event, action);
				case "sound-create":
					return this._onSoundCreate(event);
				case "sound-pause":
				case "sound-play":
				case "sound-stop":
					return this._onSoundPlay(event, action);
				case "sound-repeat":
					return this._onSoundToggleMode(event);
			}
		});
	}

	/* -------------------------------------------- */

	/**
	 * Handle global volume change for the playlist sidebar
	 * @param {MouseEvent} event   The initial click event
	 * @private
	 */
	_onGlobalVolume(event) {
		event.preventDefault();
		const slider = event.currentTarget;
		const volume = AudioHelper.inputToVolume(slider.value);
		return game.settings.set("core", slider.name, volume);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	collapseAll() {
		super.collapseAll();
		const el = this.element[0];
		for ( let p of el.querySelectorAll("li.playlist") ) {
			this._collapse(p, true);
		}
		this._expanded.clear();
		this._collapse(el.querySelector("#global-volume"), true);
		this._volumeExpanded = false;
	}

	/* -------------------------------------------- */

	/**
	 * Handle Playlist collapse toggle
	 * @param {MouseEvent} event   The initial click event
	 * @private
	 */
	_onPlaylistCollapse(event) {
		event.preventDefault();
		const li = event.currentTarget.closest(".playlist");
		const playlistId = li.dataset.entityId;
		const wasExpanded = this._expanded.has(playlistId);
		this._collapse(li, wasExpanded);
		if ( wasExpanded ) this._expanded.delete(playlistId);
		else this._expanded.add(playlistId);
	}

	/* -------------------------------------------- */

	/**
	 * Handle global volume control collapse toggle
	 * @param {MouseEvent} event   The initial click event
	 * @private
	 */
	_onVolumeCollapse(event) {
		event.preventDefault();
		const div = event.currentTarget.parentElement;
		this._volumeExpanded = !this._volumeExpanded;
		this._collapse(div, !this._volumeExpanded);
	}

	/* -------------------------------------------- */

	/**
	 * Helper method to render the expansion or collapse of playlists
	 * @private
	 */
	_collapse(el, collapse, speed = 250) {
		const ol = el.querySelector(".playlist-sounds");
		const icon = el.querySelector("i.collapse");
		if (collapse) { // Collapse the sounds
			$(ol).slideUp(speed, () => {
				el.classList.add("collapsed");
				icon.classList.replace("fa-angle-down", "fa-angle-up");
			});
		}
		else { // Expand the sounds
			$(ol).slideDown(speed, () => {
				el.classList.remove("collapsed");
				icon.classList.replace("fa-angle-up", "fa-angle-down");
			});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle Playlist playback state changes
	 * @param {MouseEvent} event    The initial click event
	 * @param {boolean} playing     Is the playlist now playing?
	 * @private
	 */
	_onPlaylistPlay(event, playing) {
		const li = event.currentTarget.closest(".playlist");
		const playlist = game.playlists.get(li.dataset.entityId);
		if (playing) {
			this._expanded.add(playlist.id);
			return playlist.playAll();
		} else {
			this._expanded.delete(playlist.id);
			return playlist.stopAll();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle advancing the playlist to the next (or previous) sound
	 * @param {MouseEvent} event    The initial click event
	 * @param {string} action       The control action requested
	 * @private
	 */
	_onPlaylistSkip(event, action) {
		const li = event.currentTarget.closest(".playlist");
		const playlist = game.playlists.get(li.dataset.entityId);
		return playlist.playNext(undefined, {direction: action === "playlist-forward" ? 1 : -1});
	}

	/* -------------------------------------------- */

	/**
	 * Handle cycling the playback mode for a Playlist
	 * @param {MouseEvent} event   The initial click event
	 * @private
	 */
	_onPlaylistToggleMode(event) {
		const li = event.currentTarget.closest(".playlist");
		const playlist = game.playlists.get(li.dataset.entityId);
		return playlist.cycleMode();
	}

	/* -------------------------------------------- */

	/**
	 * Handle Playlist track addition request
	 * @param {MouseEvent} event   The initial click event
	 * @private
	 */
	_onSoundCreate(event) {
		const li = $(event.currentTarget).parents('.playlist');
		const playlist = game.playlists.get(li.data("entityId"));
		const sound = new PlaylistSound({name: game.i18n.localize("SOUND.New")}, {parent: playlist});
		sound.sheet.render(true, {top: li[0].offsetTop, left: window.innerWidth - 670});
	}

	/* -------------------------------------------- */

	/**
	 * Modify the playback state of a Sound within a Playlist
	 * @param {MouseEvent} event    The initial click event
	 * @param {string} action       The sound control action performed
	 * @private
	 */
	_onSoundPlay(event, action) {
		const li = event.currentTarget.closest(".sound");
		const playlist = game.playlists.get(li.dataset.playlistId);
		const sound = playlist.sounds.get(li.dataset.soundId);
		switch ( action ) {
			case "sound-play":
				return playlist.playSound(sound);
			case "sound-pause":
				return sound.update({playing: false, pausedTime: sound.sound.currentTime});
			case "sound-stop":
				return playlist.stopSound(sound);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle volume adjustments to sounds within a Playlist
	 * @param {Event} event   The initial change event
	 * @private
	 */
	_onSoundVolume(event) {
		event.preventDefault();
		const slider = event.currentTarget;
		const li = slider.closest(".sound");
		const playlist = game.playlists.get(li.dataset.playlistId);
		const sound = playlist.sounds.get(li.dataset.soundId);

		// Get the desired target volume
		const volume = AudioHelper.inputToVolume(slider.value);
		if ( volume === sound.data.volume ) return;

		// Immediately apply a local adjustment
		if ( sound.sound ) {
			const localVolume = volume * game.settings.get("core", "globalPlaylistVolume");
			sound.sound.fade(localVolume, {duration: PlaylistSound.VOLUME_DEBOUNCE_MS});
		}

		// Debounce a change to the database
		if ( sound.isOwner ) sound.debounceVolume(volume);
	}

	/* -------------------------------------------- */

	/**
	 * Handle changes to the sound playback mode
	 * @param {Event} event   The initial click event
	 * @private
	 */
	_onSoundToggleMode(event) {
		event.preventDefault();
		const li = event.currentTarget.closest(".sound");
		const playlist = game.playlists.get(li.dataset.playlistId);
		const sound = playlist.sounds.get(li.dataset.soundId);
		return sound.update({repeat: !sound.data.repeat});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onSearchFilter(event, query, rgx, html) {
		const isSearch = !!query;
		const playlistIds = new Set();
		const soundIds = new Set();
		const folderIds = new Set();

		// Match documents and folders
		if (isSearch) {

			// Match Playlists and Sounds
			for (let d of this.documents) {
				let matched = false;
				for (let s of d.sounds) {
					if (s.playing || rgx.test(SearchFilter.cleanQuery(s.name))) {
						soundIds.add(s.id);
						matched = true;
					}
				}
				if (matched || d.playing || rgx.test(SearchFilter.cleanQuery(d.name))) {
					playlistIds.add(d.id);
					if (d.data.folder) folderIds.add(d.data.folder);
				}
			}

			// Include parent Folders
			const folders = this.folders.sort((a, b) => a.depth - b.depth);
			for (let f of folders) {
				if (folderIds.has(f.id) && f.data.parent) {
					folderIds.add(f.data.parent);
				}
			}
		}

		// Toggle each directory item
		for (let el of html.querySelectorAll(".directory-item")) {
			if (el.classList.contains("global-volume")) continue;

			// Playlists
			if (el.classList.contains("entity")) {
				const pid = el.dataset["entityId"];
				let mp = !isSearch || playlistIds.has(pid);
				el.style.display = mp ? "flex" : "none";

				// Sounds
				const sounds = el.querySelector(".playlist-sounds");
				for (let li of sounds.children ) {
					let ms = !isSearch || soundIds.has(li.dataset["soundId"])
					li.style.display = ms ? "flex" : "none";
					if ( ms ) mp = true;
				}
				let showExpanded = this._expanded.has(pid) || (isSearch && mp);
				el.classList.toggle("collapsed", !showExpanded);
			}

			// Folders
			else if (el.classList.contains("folder")) {
				let hidden = isSearch && !folderIds.has(el.dataset["folderId"]);
				el.style.display = hidden ? "none" : "flex";
				let expanded = (isSearch && folderIds.has(el.dataset["folderId"])) ||
					(!isSearch && game.folders._expanded[el.dataset.folderId]);
				el.classList.toggle("collapsed", !expanded);
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Update the displayed timestamps for all currently playing audio sources.
	 * Runs on an interval every 1000ms.
	 * @private
	 */
	_updateTimestamps() {
		if ( !this._playingSounds.length ) return;
		const playing = this.element.find("#currently-playing")[0];
		if ( !playing ) return;
		for ( let sound of this._playingSounds ) {
			const li = playing.querySelector(`.sound[data-sound-id="${sound.id}"]`);
			if ( !li ) continue;

			// Update current and max playback time
			const current = li.querySelector("span.current");
			const ct = sound.playing ? sound.sound.currentTime : sound.data.pausedTime;
			if ( current ) current.textContent = this._formatTimestamp(ct);
			const max = li.querySelector("span.duration");
			if ( max ) max.textContent = this._formatTimestamp(sound.sound.duration);

			// Remove the loading spinner
			const play = li.querySelector("a.pause i.fas");
			if ( play.classList.contains("fa-spinner") ) {
				play.classList.remove("fa-spin");
				play.classList.replace("fa-spinner", "fa-pause");
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Format the displayed timestamp given a number of seconds as input
	 * @param {number} seconds    The current playback time in seconds
	 * @returns {string}          The formatted timestamp
	 * @private
	 */
	_formatTimestamp(seconds) {
		seconds = seconds ?? 0;
		let minutes = Math.floor(seconds / 60);
		seconds = Math.round(seconds % 60);
		return `${minutes}:${seconds.paddedString(2)}`;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_contextMenu(html) {
		super._contextMenu(html);
		const entryOptions = this._getSoundContextOptions();

		// Dispatch Hooks down the chain
		for ( let cls of this.constructor._getInheritanceChain() ) {
			Hooks.call(`get${cls.name}SoundContext`, html, entryOptions);
		}
		new ContextMenu(html, ".playlist .sound", entryOptions);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_getFolderContextOptions() {
		const options = super._getFolderContextOptions();
		options.findSplice(o => o.name === "PERMISSION.Configure");
		return options;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_getEntryContextOptions() {
		const options = super._getEntryContextOptions();
		options.findSplice(o => o.name === "PERMISSION.Configure");
		options.unshift({
			name: "PLAYLIST.Edit",
			icon: '<i class="fas fa-edit"></i>',
			callback: li => {
				const playlist = game.playlists.get(li.data("entity-id"));
				const sheet = playlist.sheet;
				sheet.render(true, this.popOut ? {} : {
					top: li[0].offsetTop - 24,
					left: window.innerWidth - ui.sidebar.position.width - sheet.options.width - 10
				});
			}
		})
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Get context menu options for individual sound effects
	 * @return {Object}   The context options for each sound
	 * @private
	 */
	_getSoundContextOptions() {
		return [
			{
				name: "PLAYLIST.SoundEdit",
				icon: '<i class="fas fa-edit"></i>',
				callback: li => {
					const playlistId = li.parents(".playlist").data("entity-id");
					const playlist = game.playlists.get(playlistId);
					const sound = playlist.sounds.get(li.data("sound-id"));
					const sheet = sound.sheet;
					sheet.render(true, this.popOut ? {} : {
						top: li[0].offsetTop - 24,
						left: window.innerWidth - ui.sidebar.position.width - sheet.options.width - 10
					});
				}
			},
			{
				name: "PLAYLIST.SoundPreload",
				icon: '<i class="fas fa-download"></i>',
				callback: li => {
					const playlistId = li.parents(".playlist").data("entity-id");
					const playlist = game.playlists.get(playlistId);
					const sound = playlist.sounds.get(li.data("sound-id"));
					game.audio.preload(sound);
				}
			},
			{
				name: "PLAYLIST.SoundDelete",
				icon: '<i class="fas fa-trash"></i>',
				callback: li => {
					const playlistId = li.parents(".playlist").data("entity-id");
					const playlist = game.playlists.get(playlistId);
					const sound = playlist.sounds.get(li.data("sound-id"));
					return sound.deleteDialog({
						top: Math.min(li[0].offsetTop, window.innerHeight - 350),
						left: window.innerWidth - 720
					})
				}
			},
		];
	}
}
/**
 * A directory list of RollTable Documents in the Sidebar.
 * @extends {SidebarDirectory}
 */
class RollTableDirectory extends SidebarDirectory {

	/** @override */
	static documentName = "RollTable";
}

/**
 * A directory listing of active game scenes
 * @extends {SidebarDirectory}
 */
class SceneDirectory extends SidebarDirectory {

	/** @override */
	static documentName = "Scene";

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _render(force, options) {
		if ( !game.user.isGM ) return;
		return super._render(force, options);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_getEntryContextOptions() {
		let options = super._getEntryContextOptions();
		options = [
			{
				name: "SCENES.View",
				icon: '<i class="fas fa-eye"></i>',
				condition: li => !canvas.ready || (li.data("entityId") !== canvas.scene.id),
				callback: li => {
					const scene = game.scenes.get(li.data("entityId"));
					scene.view();
				}
			},
			{
				name: "SCENES.Activate",
				icon: '<i class="fas fa-bullseye"></i>',
				condition: li => game.user.isGM && !game.scenes.get(li.data("entityId")).data.active,
				callback: li => {
					const scene = game.scenes.get(li.data("entityId"));
					scene.activate();
				}
			},
			{
				name: "SCENES.Configure",
				icon: '<i class="fas fa-cogs"></i>',
				callback: li => {
					const scene = game.scenes.get(li.data("entityId"));
					scene.sheet.render(true);
				}
			},
			{
				name: "SCENES.Notes",
				icon: '<i class="fas fa-scroll"></i>',
				condition: li => {
					const scene = game.scenes.get(li.data("entityId"));
					return !!scene.journal;
				},
				callback: li => {
					const scene = game.scenes.get(li.data("entityId"));
					const entry = scene.journal;
					if ( entry ) {
						const sheet = entry.sheet;
						sheet.options.sheetMode = "text";
						sheet.render(true);
					}
				}
			},
			{
				name: "SCENES.ToggleNav",
				icon: '<i class="fas fa-compass"></i>',
				condition: li => {
					const scene = game.scenes.get(li.data("entityId"));
					return game.user.isGM && ( !scene.data.active );
				},
				callback: li => {
					const scene = game.scenes.get(li.data("entityId"));
					scene.update({navigation: !scene.data.navigation});
				}
			},
			{
				name: "SCENES.GenerateThumb",
				icon: '<i class="fas fa-image"></i>',
				condition: li => {
					const scene = game.scenes.get(li[0].dataset.entityId);
					return !!scene.data.img || scene.data.tiles.length;
				},
				callback: li => {
					const scene = game.scenes.get(li[0].dataset.entityId);
					scene.createThumbnail().then(data => {
						scene.update({thumb: data.thumb}, {diff: false});
						ui.notifications.info(`Regenerated thumbnail image for ${scene.name} background image`);
					});
				}
			}
		].concat(options);

		// Remove the permissions entry
		let idx = options.findIndex(o => o.name === "PERMISSION.Configure");
		options.splice(idx, 1);
		return options;
	}
}

/**
 * A SidebarTab for providing help messages and settings configurations.
 * The Settings sidebar is the furthest-to-right using a triple-cogs icon.
 * @extends {SidebarTab}
 */
class Settings extends SidebarTab {

	/** @override */
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = "settings";
		options.template = "templates/sidebar/settings.html";
		options.title = "Settings";
		return options;
	}

	/* -------------------------------------------- */

	/** @override */
	getData(options) {
		if (game.data.coreUpdate) game.data.coreUpdate.type = game.i18n.localize("Software");
		if (game.data.systemUpdate) game.data.systemUpdate.type = game.i18n.localize("System");
		return {
			user: game.user,
			system: game.system,
			coreVersion: game.data.version,
			canConfigure: game.user.can("SETTINGS_MODIFY"),
			canSetup: game.user.hasRole("GAMEMASTER"),
			coreUpdate: game.user.isGM && game.data.coreUpdate ? game.i18n.format("SETUP.UpdateAvailable", game.data.coreUpdate) : false,
			systemUpdate: game.user.isGM && game.data.systemUpdate ? game.i18n.format("SETUP.UpdateAvailable",
					{ type: game.data.systemUpdate.type, channel: game.data.system.data.title, version: game.data.systemUpdate.version}) : false,
			modules: game.data.modules.reduce((n, m) => n + (m.active ? 1 : 0), 0)
		};
	}

	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		html.find("button[data-action]").click(this._onSettingsButton.bind(this));
		html.find(".notification-pip.update").click(this._onUpdateNotificationClick.bind(this))
	}

	/* -------------------------------------------- */

	/**
	 * Delegate different actions for different settings buttons
	 * @param {MouseEvent} event    The originating click event
	 * @private
	 */
	_onSettingsButton(event) {
		event.preventDefault();
		const button = event.currentTarget;
		switch (button.dataset.action) {
			case "configure":
				game.settings.sheet.render(true);
				break;
			case "modules":
				new ModuleManagement().render(true);
				break;
			case "world":
				new WorldConfig(game.world, { inWorld: true }).render(true);
				break;
			case "players":
				return ui.menu.items.players.onClick();
			case "setup":
				return game.shutDown();
			case "controls":
				new ControlsReference().render(true);
				break;
			case "docs":
				new FrameViewer("https://foundryvtt.com/kb", {
					title: "Foundry VTT Documentation"
				}).render(true);
				break;
			case "wiki":
				new FrameViewer("https://foundryvtt.wiki/", {
					title: "Foundry VTT Community Wiki"
				}).render(true);
				break;
			case "invitations":
				new InvitationLinks().render(true);
				break;
			case "logout":
				return ui.menu.items.logout.onClick();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Executes with the update notification pip is clicked
	 * @param {MouseEvent} event    The originating click event
	 * @private
	 */
	_onUpdateNotificationClick(event)
	{
		event.preventDefault();
		ui.notifications.notify(game.i18n.localize(event.target.dataset.action === "core-update" ? "SETUP.CoreUpdateInstructions" : "SETUP.SystemUpdateInstructions"))
	}
}


/* -------------------------------------------- */


/**
 * A simple window application which shows the built documentation pages within an iframe
 * @type {Application}
 */
class FrameViewer extends Application {
	constructor(url, options) {
		super(options);
		this.url = url;
	}

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		const options = super.defaultOptions;

		// Default positioning
		let h = window.innerHeight * 0.9,
				w = Math.min(window.innerWidth * 0.9, 1200);
		options.height = h;
		options.width = w;
		options.top = (window.innerHeight - h) / 2;
		options.left = (window.innerWidth - w) / 2;
		options.id = "documentation";
		options.template = "templates/apps/documentation.html";
		return options;
	}

	/* -------------------------------------------- */

	/** @override */
	async getData(options) {
		return {
			src: this.url
		};
	}

	/* -------------------------------------------- */

	/** @override */
	async close(options) {
		this.element.find("#docs").remove();
		return super.close(options);
	}
}

/* -------------------------------------------- */

/**
 * A helper class providing utility methods for PIXI Canvas animation
 */
class CanvasAnimation {
	static get ticker() {
		return canvas.app.ticker;
	}

	/**
	 * Track an object of active animations by name, context, and function
	 * This allows a currently playing animation to be referenced and terminated
	 * @type {Object<string, {fn: Function, context: PIXI.Container, resolve: Function}>}
	 */
	static animations = {};

	/* -------------------------------------------- */

	/**
	 * Apply a linear animation from the current value of some attribute to a new value
	 * Resolve a Promise once the animation has concluded and the attributes have reached their new target
	 * @param {object[]} attributes   An array of attributes to animate. Structure of the Array is shown in the example
	 *
	 * @param {object} options        Additional options which customize the animation
	 *
	 * @param {Container} [options.context]     An animation context to use which defines scope
	 * @param {string} options.name             Provide a unique animation name which may be referenced later
	 * @param {number} [options.duration=1000]  The duration in milliseconds over which the animation should occur
	 * @param {Function} [options.ontick]       A function which defines additional behaviors to apply every animation frame
	 * @return {Promise}            A Promise which resolves once the linear animation has concluded
	 *
	 * @example
	 * let animation = [
	 *   {
	 *     parent: token,
	 *     attribute: x,
	 *     to: 1000
	 *   },
	 *   {
	 *     parent: token,
	 *     attribute: y,
	 *     to: 2000
	 *   }
	 * ];
	 * CanvasAnimation.animateLinear(attributes, {duration:500, ontick: console.log("ticking")});
	 */
	static async animateLinear(attributes, {context, name, duration = 1000, ontick} = {}) {

		// Prepare attributes
		attributes = attributes.map(a => {
			a.delta = a.to - a.parent[a.attribute];
			a.done = 0;
			a.remaining = Math.abs(a.delta);
			return a;
		}).filter(a => a.delta !== 0);

		// Register the request function and context
		context = context || canvas.stage;

		// Dispatch the animation request and return as a Promise
		return this._animatePromise(this._animateFrame, context, name, attributes, duration, ontick);
	}

	/* -------------------------------------------- */

	/**
	 * If an animation using a certain name already exists, terminate it
	 * @param {string} name       The animation name to terminate
	 */
	static terminateAnimation(name) {
		let animation = this.animations[name];
		if (animation) animation.resolve(false);
	}

	/* -------------------------------------------- */

	/**
	 * Asynchronously animate a transition function and resolve a Promise once the animation has completed
	 * @param {Function} fn         A suitable transition function. See PIXI.Ticker for details
	 * @param {PIXI.Container} context The Canvas container providing scope for the transition
	 * @param {string} name         Provide a unique animation name which may be referenced later
	 * @param {object} attributes   The attributes being animated by the function
	 * @param {number} duration     The duration in milliseconds over which the animation should occur
	 * @param {Function} ontick     A function which defines additional behaviors to apply every animation frame
	 * @return {Promise}            A Promise which resolves once the animation has completed
	 * @private
	 */
	static async _animatePromise(fn, context, name, attributes, duration, ontick) {
		if (name) this.terminateAnimation(name);
		let animate;
		return new Promise((resolve, reject) => {
			animate = dt => fn(dt, resolve, reject, attributes, duration, ontick);
			this.ticker.add(animate, context);
			if (name) this.animations[name] = {fn: animate, context, resolve};
		})
		.catch(err => {
			console.error(err)
		})
		.finally(() => {
			this.ticker.remove(animate, context);
			if (name) delete this.animations[name];
		});
	}

	/* -------------------------------------------- */

	/**
	 * Generic ticker function to implement the animation.
	 * This animation wrapper executes once per frame for the duration of the animation event.
	 * Once the animated attributes have converged to their targets, it resolves the original Promise.
	 * The user-provided ontick function runs each frame update to apply additional behaviors.
	 * @private
	 */
	static _animateFrame(deltaTime, resolve, reject, attributes, duration, ontick) {
		let complete = attributes.length === 0;
		let dt = (duration * PIXI.settings.TARGET_FPMS) / deltaTime;

		// Update each attribute
		try {
			for (let a of attributes) {
				let da = a.delta / dt;
				a.d = da;
				if (a.remaining < (Math.abs(da) * 1.25)) {
					a.parent[a.attribute] = a.to;
					a.done = a.delta;
					a.remaining = 0;
					complete = true;
				} else {
					a.parent[a.attribute] += da;
					a.done += da;
					a.remaining = Math.abs(a.delta) - Math.abs(a.done);
				}
			}
			if (ontick) ontick(dt, attributes);
		} catch (err) {
			reject(err);
		}

		// Resolve the original promise once the animation is complete
		if (complete) resolve(true);
	}
}
/**
 * A special type of PIXI.Container which draws its contents to a cached RenderTexture.
 * This is accomplished by overriding the Container#render method to draw to our own special RenderTexture.
 * @extends {PIXI.Container}
 */
class CachedContainer extends PIXI.Container {
	constructor() {
		super();
		const renderer = canvas.app?.renderer;

		/**
		 * The RenderTexture that is the render destination for the contents of this Container
		 * @type {PIXI.RenderTexture}
		 */
		Object.defineProperty(this, "renderTexture", {
			value: PIXI.RenderTexture.create({
				width: renderer?.screen.width ?? window.innerWidth,
				height: renderer?.screen.height ?? window.innerHeight,
				resolution: renderer.resolution ?? PIXI.settings.RESOLUTION
			}),
			writable: false
		});

		// Listen for resize events
		this._onResize = () => this._resize(renderer)
		renderer.on("resize", this._onResize);
	}

	/**
	 * An object which stores a reference to the normal renderer target and source frame.
	 * We track this so we can restore them after rendering our cached texture.
	 * @type {{sourceFrame: PIXI.Rectangle, renderTexture: PIXI.RenderTexture}}
	 * @private
	 */
	_backup = {
		renderTexture: undefined,
		sourceFrame: new PIXI.Rectangle()
	}

	/**
	 * An RGBA array used to define the clear color of the RenderTexture
	 * @type {number[]}
	 */
	clearColor = [0,0,0,1];

	/**
	 * Should our Container also be displayed on screen, in addition to being drawn to the cached RenderTexture?
	 * @type {boolean}
	 */
	displayed = false;

	/* ---------------------------------------- */

	/** @inheritdoc */
	destroy(options) {
		if ( this._onResize ) canvas.app.renderer.off("resize", this._onResize);
		if ( this.renderTexture ) this.renderTexture.destroy(true);
		super.destroy(options);
	}

	/* ---------------------------------------- */

	/** @inheritdoc */
	render(renderer) {
		this._bind(renderer); // Bind our cached texture
		super.render(renderer); // Draw to our cached texture
		this._unbind(renderer); // Restore the original target
		if ( this.displayed ) super.render(renderer); // Draw to the screen
	}

	/* ---------------------------------------- */

	/**
	 * Bind our cached RenderTexture to the Renderer, replacing the original target.
	 * @param {PIXI.Renderer} renderer      The active canvas renderer
	 * @private
	 */
	_bind(renderer) {

		// Get the RenderTexture to bind
		const tex = this.renderTexture;
		const rt = renderer.renderTexture;

		// Backup the current render target
		this._backup.renderTexture = rt.current;
		this._backup.sourceFrame.copyFrom(rt.sourceFrame);

		// Bind our texture to the renderer
		renderer.batch.flush();
		rt.bind(tex, undefined, undefined);
		rt.clear(this.clearColor);

		// Enable Filters which are applied to this Container to apply to our cached RenderTexture
		const fs = renderer.filter.defaultFilterStack;
		if ( fs.length > 1 ) {
			fs[fs.length - 1].renderTexture = tex;
		}
	}

	/* ---------------------------------------- */

	/**
	 * Remove our cached RenderTexture from the Renderer, re-binding the original target.
	 * @param {PIXI.Renderer} renderer      The active canvas renderer
	 * @private
	 */
	_unbind(renderer) {
		renderer.batch.flush();

		// Restore Filters to apply to the original RenderTexture
		const fs = renderer.filter.defaultFilterStack;
		if ( fs.length > 1 ) {
			fs[fs.length - 1].renderTexture = this._backup.renderTexture;
		}

		// Re-bind the original RenderTexture to the renderer
		renderer.renderTexture.bind(this._backup.renderTexture, this._backup.sourceFrame, undefined);
		this._backup.renderTexture = undefined;
	}

	/* ---------------------------------------- */

	/**
	 * Resize the cached RenderTexture when the dimensions or resolution of the Renderer have changed.
	 * @param {PIXI.Renderer} renderer
	 * @private
	 */
	_resize(renderer) {
		const rt = this.renderTexture;
		const screen = renderer?.screen;
		if ( !rt || !screen ) return;
		if ( (rt.width !== screen.width) || (rt.height !== screen.height) ) rt.resize(screen.width, screen.height);
		if ( rt.baseTexture.resolution !== renderer.resolution ) rt.baseTexture.resolution = renderer.resolution;
	}
}

/**
 * A generic helper for drawing a standard Control Icon
 * @type {PIXI.Container}
 */
class ControlIcon extends PIXI.Container {
	constructor({texture, size=40, borderColor=0xFF5500, tint=null}={}, ...args) {
		super(...args);

		// Define arguments
		this.iconSrc = texture;
		this.size = size;
		this.rect = [-2, -2, size+4, size+4];
		this.borderColor = borderColor;
		this.tintColor = tint;

		// Define hit area
		this.interactive = true;
		this.interactiveChildren = false;
		this.hitArea = new PIXI.Rectangle(...this.rect);

		// Background
		this.bg = this.addChild(new PIXI.Graphics());

		// Icon
		this.icon = this.addChild(new PIXI.Sprite());

		// Border
		this.border = this.addChild(new PIXI.Graphics());

		// Draw asynchronously
		this.draw();
	}

	/* -------------------------------------------- */

	async draw() {

		// Load the icon texture
		this.texture = this.texture ?? await loadTexture(this.iconSrc);

		// Draw background
		this.bg.clear().beginFill(0x000000, 0.4).lineStyle(2, 0x000000, 1.0).drawRoundedRect(...this.rect, 5).endFill();

		// Draw border
		this.border.clear().lineStyle(2, this.borderColor, 1.0).drawRoundedRect(...this.rect, 5).endFill();
		this.border.visible = false;

		// Draw icon
		this.icon.texture = this.texture;
		this.icon.width = this.icon.height = this.size;
		this.icon.tint = Number.isNumeric(this.tintColor) ? this.tintColor : 0xFFFFFF;
		return this;
	}

	/* -------------------------------------------- */

	_onHoverIn(event) {
		this.border.visible = true;
	}

	_onHoverOut(event) {
		this.border.visible = false;
	}
}
/**
 * A Loader class which helps with loading video and image textures
 */
class TextureLoader {

	/**
	 * The cached mapping of textures
	 * @type {Map<string,{tex: PIXI.Texture, time: number}>}
	 */
	cache = new Map();

	/**
	 * The duration in milliseconds for which a texture will remain cached
	 * @type {number}
	 */
	static CACHE_TTL = 1000;

	/* -------------------------------------------- */

	/**
	 * Load all the textures which are required for a particular Scene
	 * @param {Scene} scene           The Scene to load
	 * @param {object} [options={}]   Additional options that configure texture loading
	 * @param {boolean} [options.expireCache=true]  Destroy other expired textures
	 * @return {Promise<void>}
	 */
	static loadSceneTextures(scene, {expireCache=true}={}) {
		const sd = scene.data;
		let toLoad = [];

		// Scene background and foreground textures
		if ( sd.img ) toLoad.push(sd.img);
		if ( sd.foreground ) toLoad.push(sd.foreground);

		// Tiles
		toLoad = toLoad.concat(sd.tiles.reduce((arr, t) => {
			if ( t.data.img ) arr.push(t.data.img);
			return arr;
		}, []));

		// Tokens
		toLoad = toLoad.concat(sd.tokens.reduce((arr, t) => {
			if ( t.data.img ) arr.push(t.data.img);
			return arr;
		}, []));

		// Control Icons
		toLoad = toLoad.concat(Object.values(CONFIG.controlIcons)).concat(CONFIG.statusEffects.map(e => e.icon ?? e));

		// Load files
		const showName = scene.active || scene.visible;
		const loadName = showName ? (scene.data.navName || scene.data.name) : "...";
		return this.loader.load(toLoad, {
			message: game.i18n.format("SCENES.Loading", {name: loadName}),
			expireCache: expireCache
		});
	}

	/* -------------------------------------------- */

	/**
	 * Load an Array of provided source URL paths
	 * @param {string[]} sources      The source URLs to load
	 * @param {object} [options={}]   Additional options which modify loading
	 * @param {string} [options.message]              The status message to display in the load bar
	 * @param {boolean} [options.expireCache=false]   Expire other cached textures?
	 * @return {Promise}              A Promise which resolves once all textures are loaded
	 */
	async load(sources, {message, expireCache=false}={}) {

		// Filter for textures which do not already exist
		sources = sources.filter(src => {
			let tex = this.getCache(src);
			return !tex?.baseTexture?.valid;
		});

		// Create an array of Promises
		const progress = {message: message, loaded: 0, failed: 0, total: sources.length, pct: 0};
		const promises = sources.map(src => {
			let promise = VideoHelper.hasVideoExtension(src) ? this.loadVideoTexture(src) : this.loadImageTexture(src);
			return promise.then(() => this._onProgress(src, progress)).catch(err => this._onError(src, progress, err));
		});

		// Expire other cached textures
		if ( expireCache) this.expireCache();

		// Load all media
		return Promise.all(promises);
	}

	/* -------------------------------------------- */

	/**
	 * Load a single texture on-demand from a given source URL path
	 * @param {string} src                The source texture path to load
	 * @return {Promise<PIXI.Texture>}    The loaded texture object
	 */
	async loadTexture(src) {
		let tex = this.getCache(src);
		if ( tex && tex.baseTexture && tex.baseTexture.valid ) return tex;
		return VideoHelper.hasVideoExtension(src) ? this.loadVideoTexture(src) : this.loadImageTexture(src);
	}

	/* -------------------------------------------- */

	/**
	 * Log texture loading progress in the console and in the Scene loading bar
	 * @private
	 */
	_onProgress(src, progress, message) {
		progress.loaded++;
		progress.pct = Math.round((progress.loaded + progress.failed) * 100 / progress.total);
		SceneNavigation._onLoadProgress(progress.message, progress.pct);
		console.log(`${vtt} | Loaded ${src} (${progress.pct}%)`);
	}

	/* -------------------------------------------- */

	/**
	 * Log failed texture loading
	 * @private
	 */
	_onError(src, progress, error) {
		progress.failed++;
		progress.pct = Math.round((progress.loaded + progress.failed) * 100 / progress.total);
		SceneNavigation._onLoadProgress(progress.message, progress.pct);
		console.warn(`${vtt} | Loading failed for ${src} (${progress.pct}%): ${error.message}`);
	}

	/* -------------------------------------------- */

	/**
	 * Load an image texture from a provided source url
	 * @param {string} src
	 * @return {Promise<PIXI.Texture>}
	 */
	async loadImageTexture(src) {

		// Create the Image element
		const img = new Image(src);
		img.crossOrigin = "anonymous";
		img.decoding = "async";
		img.loading = "eager";

		// Wait for the image to load
		return new Promise((resolve, reject) => {

			// Create the texture on successful load
			img.onload = () => {
				img.height = img.naturalHeight;
				img.width = img.naturalWidth;
				const bt = PIXI.BaseTexture.from(img);
				const tex = new PIXI.Texture(bt);
				this.setCache(src, tex);
				resolve(tex);
			};

			// Handle errors for valid URLs due to CORS
			img.onerror = () => this._attemptCORSReload(src, resolve, reject);
			img.src = src;
		});
	}

	/* -------------------------------------------- */

	/**
	 * If an attempted image load failed, we may attempt a re-load in case the issue was CORS + caching
	 * Cross-origin requests which failed might be CORS, or might be 404, no way to know - so try a 2nd time
	 * @param {string} src        The source URL being attempted
	 * @param {Function} resolve  Resolve the promise
	 * @param {Function} reject   Reject the promise
	 * @private
	 */
	async _attemptCORSReload(src, resolve, reject) {
		const fail = `Failed to load texture ${src}`;

		// Try to parse the URL
		let url;
		try {
			url = new URL(src);
		} catch(err) {
			return reject(`${fail}: Invalid URL`);
		}

		// Skip same-origin resources
		if ( url.origin === window.location.origin ) return reject(`${fail}: Invalid URL`);

		// Skip resource which have already been retried
		if ( /\?cors-retry=/.test(url.search) )  return reject(`${fail}: CORS failure`);

		// Retry loading a cross-origin resource with a cache-busting parameter
		url.search += `?cors-retry=${Date.now()}`;
		return this.loadImageTexture(url.href).then(tex => {
			this.setCache(src, tex);
			resolve(tex);
		}).catch(err => reject(`${fail}: CORS failure`));
	}

	/* -------------------------------------------- */

	/**
	 * Load a video texture from a provided source url
	 * @param {string} src
	 * @return {Promise<PIXI.Texture>}
	 */
	async loadVideoTexture(src) {
		if ( !VideoHelper.hasVideoExtension(src) ) {
			throw new Error(`${src} is not a valid video texture`);
		}

		// Create a Video element
		const video = document.createElement("VIDEO");
		video.preload = "auto";
		video.autoplay = false;
		video.crossOrigin = "anonymous";
		video.src = src;

		// Begin loading and resolve or reject
		return new Promise((resolve, reject) => {
			video.oncanplay = () => {
				video.height = video.videoHeight;
				video.width = video.videoWidth;
				const bt = PIXI.BaseTexture.from(video, {resourceOptions: {autoPlay: false}});
				const tex = new PIXI.Texture(bt);
				this.setCache(src, tex);
				resolve(tex);
			};
			video.onerror = reject;
			video.load();
		});
	}

	/* -------------------------------------------- */
	/*  Cache Controls                              */
	/* -------------------------------------------- */

	/**
	 * Add an image url to the texture cache
	 * @param {string} src          The source URL
	 * @param {PIXI.Texture} tex    The readied texture
	 */
	setCache(src, tex) {
		this.cache.set(src, {
			tex: tex,
			time: Date.now()
		});
	}

	/* -------------------------------------------- */

	/**
	 * Retrieve a texture from the texture cache
	 * @param {string} src          The source URL
	 */
	getCache(src) {
		const val = this.cache.get(src);
		if ( !val ) return undefined;
		val.time = Date.now();
		return val?.tex;
	}

	/* -------------------------------------------- */

	/**
	 * Expire (and destroy) textures from the cache which have not been used for more than CACHE_TTL milliseconds.
	 */
	expireCache() {
		const t = Date.now();
		for ( let [key, obj] of this.cache.entries() ) {
			if ( (t - obj.time) > TextureLoader.CACHE_TTL ) {
				console.log(`Expiring ${key}`);
				obj.tex.destroy(true);
				this.cache.delete(key);
			}
		}
	}
}

/**
 * A global reference to the singleton texture loader
 * @type {TextureLoader}
 */
TextureLoader.loader = new TextureLoader();


/* -------------------------------------------- */


/**
 * Test whether a file source exists by performing a HEAD request against it
 * @param {string} src    The source URL or path to test
 * @return {boolean}      Does the file exist at the provided url?
 */
async function srcExists(src) {
	return fetch(src, { method: 'HEAD' }).then(resp => {
		return resp.status < 400;
	}).catch(err => false);
}


/* -------------------------------------------- */


/**
 * Get a single texture from the cache
 * @param {string} src
 * @return {PIXI.Texture}
 */
function getTexture(src) {
	let cached = TextureLoader.loader.getCache(src);
	if ( !cached || !cached.valid ) return null;
	return cached;
}


/* -------------------------------------------- */


/**
 * Load a single texture and return a Promise which resolves once the texture is ready to use
 * @param {string} src        The requested texture source
 * @param {string} fallback   A fallback texture to use if the requested source is unavailable or invalid
 * @return {PIXI.Texture}
 */
async function loadTexture(src, {fallback}={}) {
	let tex = null;
	try {
		tex = await TextureLoader.loader.loadTexture(src);
	}
	catch(err) {
		err.message = `The requested texture ${src} could not be loaded: ${err.message}`;
		console.error(err);
		if ( fallback ) tex = await loadTexture(fallback);
	}
	if ( !tex?.valid ) throw new Error(`Invalid BaseTexture ${src}`);
	return tex;
}
/**
 * Handle mouse interaction events for a Canvas object.
 * There are three phases of events: hover, click, and drag
 *
 * Hover Events:
 * _handleMouseOver
 *  action: hoverIn
 * _handleMouseOut
 *  action: hoverOut
 *
 * Left Click and Double-Click
 * _handleMouseDown
 *  action: clickLeft
 *  action: clickLeft2
 *
 * Right Click and Double-Click
 * _handleRightDown
 *  action: clickRight
 *  action: clickRight2
 *
 * Drag and Drop
 * _handleMouseMove
 *  action: dragLeftStart
 *  action: dragLeftMove
 *  action: dragRightStart
 *  action: dragLeftMove
 * _handleMouseUp
 *  action: dragLeftDrop
 *  action: dragRightDrop
 * _handleDragCancel
 *  action: dragLeftCancel
 *  action: dragRightCancel
 */
class MouseInteractionManager {
	constructor(object, layer, permissions={}, callbacks={}, options={}) {
		this.object = object;
		this.layer = layer;
		this.permissions = permissions;
		this.callbacks = callbacks;

		/**
		 * Interaction options which configure handling workflows
		 * @type {{target: PIXI.DisplayObject, dragResistance: number}}
		 */
		this.options = options;

		/**
		 * The current interaction state
		 * @type {number}
		 */
		this.state = this.states.NONE;

		/**
		 * Bound handlers which can be added and removed
		 * @type {Object<Function>}
		 */
		this.handlers = {};

		/**
		 * The drag handling time
		 * @type {number}
		 */
		this.dragTime = 0;

		/**
		 * The throttling time below which a mouse move event will not be handled
		 * @type {number}
		 * @private
		 */
		this._dragThrottleMS = Math.ceil(1000 / canvas.app.ticker.maxFPS);

		/**
		 * The time of the last left-click event
		 * @type {number}
		 */
		this.lcTime = 0;

		/**
		 * The time of the last right-click event
		 * @type {number}
		 */
		this.rcTime = 0;

		/**
		 * A flag for whether we are right-click dragging
		 * @type {boolean}
		 */
		this._dragRight = false;

		/**
		 * An optional ControlIcon instance for the object
		 * @type {ControlIcon}
		 */
		this.controlIcon = this.options.target ? this.object[this.options.target] : undefined;
	}

	/**
	 * Enumerate the states of a mouse interaction workflow.
	 * 0: NONE - the object is inactive
	 * 1: HOVER - the mouse is hovered over the object
	 * 2: CLICKED - the object is clicked
	 * 3: DRAG - the object is being dragged
	 * 4: DROP - the object is being dropped
	 * @enum {number}
	 */
	static INTERACTION_STATES = {
		NONE: 0,
		HOVER: 1,
		CLICKED: 2,
		DRAG: 3,
		DROP: 4
	};

	/* -------------------------------------------- */

	/**
	 * Get the target
	 * @return {*}
	 */
	get target() {
		return this.options.target ? this.object[this.options.target] : this.object;
	}

	/* -------------------------------------------- */

	/**
	 * Activate interactivity for the handled object
	 */
	activate() {

		// Remove existing listeners
		this.state = this.states.NONE;
		this.target.removeAllListeners();

		// Create bindings for all handler functions
		this.handlers = {
			"mouseover": this._handleMouseOver.bind(this),
			"mouseout": this._handleMouseOut.bind(this),
			"mousedown": this._handleMouseDown.bind(this),
			"rightdown": this._handleRightDown.bind(this),
			"mousemove": this._handleMouseMove.bind(this),
			"mouseup": this._handleMouseUp.bind(this),
			"contextmenu": this._handleDragCancel.bind(this)
		};

		// Activate hover events to start the workflow
		this._activateHoverEvents();

		// Set the target as interactive
		this.target.interactive = true;
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Test whether the current user has permission to perform a step of the workflow
	 * @param {string} action     The action being attempted
	 * @param {Event} event       The event being handled
	 * @return {boolean}          Can the action be performed?
	 */
	can(action, event) {
		const fn = this.permissions[action];
		if ( typeof fn === "boolean" ) return fn;
		if ( fn instanceof Function ) return fn.call(this.object, game.user, event);
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Execute a callback function associated with a certain action in the workflow
	 * @param {string} action     The action being attempted
	 * @param {Event} event       The event being handled
	 */
	callback(action, event) {
		const fn = this.callbacks[action];
		if ( fn instanceof Function ) return fn.call(this.object, event);
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the possible interaction states which can be observed
	 * @return {Object<string, number>}
	 */
	get states() {
		return this.constructor.INTERACTION_STATES;
	}

	/* -------------------------------------------- */
	/*  Listener Activation and Deactivation        */
	/* -------------------------------------------- */

	/**
	 * Activate a set of listeners which handle hover events on the target object
	 * @private
	 */
	_activateHoverEvents() {

		// Disable and re-register mouseover and mouseout handlers
		this.target.off("mouseover", this.handlers.mouseover).on("mouseover", this.handlers.mouseover);
		this.target.off("mouseout", this.handlers.mouseout).on("mouseout", this.handlers.mouseout);

		// Add a one-time mousemove event in case our cursor is already over the target element
		this.target.once("mousemove", this.handlers.mouseover);
	}

	/* -------------------------------------------- */

	/**
	 * Activate a new set of listeners for click events on the target object
	 * @private
	 */
	_activateClickEvents() {
		this._deactivateClickEvents();
		this.target.on("mousedown", this.handlers.mousedown);
		this.target.on("mouseup", this.handlers.mouseup);
		this.target.on("mouseupoutside", this.handlers.mouseup);
		this.target.on("rightdown", this.handlers.rightdown);
		this.target.on("rightup", this.handlers.mouseup);
		this.target.on("rightupoutside", this.handlers.mouseup);
	}

	/* -------------------------------------------- */

	/**
	 * Deactivate event listeners for click events on the target object
	 * @private
	 */
	_deactivateClickEvents() {
		this.target.off("mousedown", this.handlers.mousedown);
		this.target.off("mouseup", this.handlers.mouseup);
		this.target.off("mouseupoutside", this.handlers.mouseup);
		this.target.off("rightdown", this.handlers.rightdown);
		this.target.off("rightup", this.handlers.mouseup);
		this.target.off("rightupoutside", this.handlers.mouseup);
	}

	/* -------------------------------------------- */

	/**
	 * Activate events required for handling a drag-and-drop workflow
	 * @private
	 */
	_activateDragEvents() {
		this._deactivateDragEvents();
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | activateDragEvents`);
		this.layer.on("mousemove", this.handlers.mousemove);
		if ( !this._dragRight ) {
			canvas.app.view.addEventListener("contextmenu", this.handlers.contextmenu, {capture: true});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Deactivate events required for handling drag-and-drop workflow.
	 * @private
	 */
	_deactivateDragEvents() {
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | deactivateDragEvents`);
		this.layer.off("mousemove", this.handlers.mousemove);
		canvas.app.view.removeEventListener("contextmenu", this.handlers.contextmenu, {capture: true});
	}

	/* -------------------------------------------- */
	/*  Hover In and Hover Out                      */
	/* -------------------------------------------- */

	/**
	 * Handle mouse-over events which activate downstream listeners and do not stop propagation.
	 * @private
	 */
	_handleMouseOver(event) {

		// Ignore hover events during a drag workflow
		if ( this.state >= this.states.DRAG ) return;

		// Handle new hover events
		const action = "hoverIn";
		if ( this.object._controlled === false) this.state = this.states.NONE;
		if ( this.state !== this.states.NONE ) return;
		if ( !this.can(action, event) ) return;
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | ${action}`);

		// Activate click event listeners
		this._activateClickEvents();

		// Assign event data and call the provided handler
		event.data.object = this.object;
		this.state = Math.max(this.state || 0, this.states.HOVER);

		// Callback
		return this.callback(action, event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-out events which terminate hover workflows and do not stop propagation.
	 * @private
	 */
	_handleMouseOut(event) {
		const action = "hoverOut";
		if ( (this.state === this.states.NONE) || (this.state >= this.states.DRAG) )  return;

		// Downgrade hovers by deactivating events
		if ( this.state === this.states.HOVER ) {
			this.state = this.states.NONE;
			this._deactivateClickEvents();
		}

		// Handle callback actions if permitted
		if ( !this.can(action, event) ) return;
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | ${action}`);
		return this.callback(action, event);
	}

	/* -------------------------------------------- */
	/*  Left Click and Double Click                 */
	/* -------------------------------------------- */

	/**
	 * Handle mouse-down events which activate downstream listeners.
	 * Stop further propagation only if the event is allowed by either single or double-click.
	 * @private
	 */
	_handleMouseDown(event) {
		if ( ![this.states.HOVER, this.states.CLICKED, this.states.DRAG].includes(this.state) ) return;
		if ( event.data.originalEvent.button !== 0 ) return; // Only support standard left-click
		canvas.currentMouseManager = this;

		// Determine double vs single click
		const now = Date.now();
		const isDouble = (now - this.lcTime) <= 250;
		this.lcTime = now;

		// Update event data
		event.data.object = this.object;
		event.data.origin = event.data.getLocalPosition(this.layer);

		// Dispatch to double and single-click handlers
		if ( isDouble && this.can("clickLeft2", event) ) return this._handleClickLeft2(event);
		else return this._handleClickLeft(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-down which trigger a single left-click workflow.
	 * @private
	 */
	_handleClickLeft(event) {
		const action = "clickLeft";
		if ( !this.can(action, event) ) return;
		event.stopPropagation();
		this._dragRight = false;

		// Upgrade hover to clicked
		if ( this.state === this.states.HOVER ) this.state = this.states.CLICKED;
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | ${action}`);

		// Trigger callback functions
		this.callback(action, event);

		// Activate drag handlers
		if ( (this.state < this.states.DRAG) && this.can("dragStart", event) ) {
			this._activateDragEvents();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-down which trigger a single left-click workflow.
	 * @private
	 */
	_handleClickLeft2(event) {
		event.stopPropagation();
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | clickLeft2`);
		return this.callback("clickLeft2", event);
	}

	/* -------------------------------------------- */
	/*  Right Click and Double Click                */
	/* -------------------------------------------- */

	/**
	 * Handle right-click mouse-down events.
	 * Stop further propagation only if the event is allowed by either single or double-click.
	 * @private
	 */
	_handleRightDown(event) {
		if ( ![this.states.HOVER, this.states.CLICKED, this.states.DRAG].includes(this.state) ) return;
		if ( event.data.originalEvent.button !== 2 ) return; // Only support standard left-click
		canvas.currentMouseManager = this;

		// Determine double vs single click
		const now = Date.now();
		const isDouble = (now - this.rcTime) <= 250;
		this.rcTime = now;

		// Update event data
		event.data.object = this.object;
		event.data.origin = event.data.getLocalPosition(this.layer);

		// Dispatch to double and single-click handlers
		if ( isDouble && this.can("clickRight2", event) ) return this._handleClickRight2(event);
		else return this._handleClickRight(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle single right-click actions.
	 * @private
	 */
	_handleClickRight(event) {
		const action = "clickRight";
		if ( !this.can(action, event) ) return;
		event.stopPropagation();
		this._dragRight = true;

		// Upgrade hover to clicked
		if ( this.state === this.states.HOVER ) this.state = this.states.CLICKED;
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | ${action}`);

		// Trigger callback function
		this.callback(action, event);

		// Activate drag handlers
		if ( (this.state < this.states.DRAG) && this.can("dragRight", event) ) {
			this._activateDragEvents();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle double right-click actions.
	 * @private
	 */
	_handleClickRight2(event) {
		event.stopPropagation();
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | clickRight2`);
		return this.callback("clickRight2", event);
	}

	/* -------------------------------------------- */
	/*  Drag and Drop                               */
	/* -------------------------------------------- */

	/**
	 * Handle mouse movement during a drag workflow
	 * @private
	 */
	_handleMouseMove(event) {
		if ( ![this.states.CLICKED, this.states.DRAG].includes(this.state) ) return;

		// Limit dragging to 60 updates per second
		const now = Date.now();
		if ( (now - this.dragTime) < this._dragThrottleMS ) return;
		this.dragTime = now;

		// Get the new destination
		event.data.destination = event.data.getLocalPosition(this.layer);

		// Begin a new drag event
		if ( this.state === this.states.CLICKED ) {
			const dx = event.data.destination.x - event.data.origin.x;
			const dy = event.data.destination.y - event.data.origin.y;
			const dz = Math.hypot(dx, dy);
			const r = this.options.dragResistance || (canvas.dimensions.size / 4);
			if ( dz >= r ) {
				this.state = this.states.DRAG;
				return this._handleDragStart(event);
			}
		}

		// Continue a drag event
		else return this._handleDragMove(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle the beginning of a new drag start workflow, moving all controlled objects on the layer
	 * @private
	 */
	_handleDragStart(event) {
		const action = this._dragRight ? "dragRightStart" : "dragLeftStart";
		if ( !this.can(action, event) ) return;
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | ${action}`);
		return this.callback(action, event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle the continuation of a drag workflow, moving all controlled objects on the layer
	 * @private
	 */
	_handleDragMove(event) {
		const action = this._dragRight ? "dragRightMove" : "dragLeftMove";
		this.state = this.states.DRAG;
		if ( !this.can(action, event) ) return;
		return this.callback(action, event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse up events which may optionally conclude a drag workflow
	 * @private
	 */
	_handleMouseUp(event) {
		if ( this.state >= this.states.DRAG ) {
			event.stopPropagation();
			if ( event.type.startsWith("right") && !this._dragRight ) return;
			this._handleDragDrop(event);
		}

		// Continue a multi-click drag workflow
		if ( event.data.originalEvent.defaultPrevented ) {
			this.state = this.states.DRAG;
			return;
		}

		// Cancel the workflow
		return this._handleDragCancel(event.data.originalEvent);
	}

	/* -------------------------------------------- */

	/**
	 * Handle the conclusion of a drag workflow, placing all dragged objects back on the layer
	 * @private
	 */
	_handleDragDrop(event) {
		const action = this._dragRight ? "dragRightDrop" : "dragLeftDrop";
		if (!this.can(action, event)) return;
		if ( CONFIG.debug.mouseInteraction ) console.log(`${this.object.constructor.name} | ${action}`);

		// Update event data
		event.data.object = this.object;
		event.data.destination = event.data.getLocalPosition(this.layer);
		this.state = this.states.DROP;

		// Callback
		this.callback(action, event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle the cancellation of a drag workflow, resetting back to the original state
	 * @param {PointerEvent} event
	 * @private
	 */
	_handleDragCancel(event) {
		this.cancel(event);
	}

	/* -------------------------------------------- */

	/**
	 * A public method to cancel a current interaction workflow from this manager.
	 * @param {Event} event     The event that initiates the cancellation
	 */
	cancel(event) {
		const endState = this.state;
		canvas.currentMouseManager = null;
		if ( endState <= this.states.HOVER ) return;

		// Dispatch a cancellation callback
		if ( endState >= this.states.DRAG ) {
			const action = this._dragRight ? "dragRightCancel" : "dragLeftCancel";
			if (CONFIG.debug.mouseInteraction) console.log(`${this.object.constructor.name} | ${action}`);
			this.callback(action, event);
		}

		// Continue a multi-click drag workflow if the default event was prevented in the callback
		if ( event.defaultPrevented ) {
			this.state = this.states.DRAG;
			return;
		}

		// Deactivate the drag workflow
		this._deactivateDragEvents();
		this.state = this.states.HOVER;
	}
}

/**
 * A helper class which manages the refresh workflow for perception layers on the canvas.
 * This controls the logic which batches multiple requested updates to minimize the amount of work required.
 * A singleton instance is available as canvas#perception.
 * @see {Canvas#perception}
 */
class PerceptionManager {
	constructor() {
		this._reset();
	}

	/**
	 * The number of milliseconds by which to throttle non-immediate refreshes
	 * @type {number}
	 * @private
	 */
	_throttleMS

	/**
	 * An internal tracker for the last time that a perception refresh was executed
	 * @type {number}
	 * @private
	 */
	_refreshTime;

	/**
	 * An internal tracker for the window timeout that applies a debounce to the refresh
	 * @type {number}
	 * @private
	 */
	_timeout;

	/**
	 * Cache a reference to the canvas scene to avoid attempting scheduled refreshes after the scene is changed
	 * @type {string}
	 * @private
	 */
	_scene;

	/**
	 * The default values of update parameters.
	 * When a refresh occurs, the staged parameters are reset to these initial values.
	 * @type {object}
	 */
	static DEFAULTS = {
		lighting: {
			initialize: false,
			refresh: false
		},
		sight: {
			initialize: false,
			refresh: false,
			noUpdateFog: false,
			forceUpdateFog: false
		},
		sounds: {
			initialize: false,
			refresh: false,
			fade: false
		},
		foreground: {
			refresh: false
		}
	}

	/**
	 * The configured parameters for the next refresh.
	 * @type {object}
	 */
	params = {}

	/* -------------------------------------------- */

	/**
	 * Cancel any pending perception refresh.
	 */
	cancel() {
		if ( this._timeout ) window.clearTimeout(this._timeout);
		this._timeout = undefined;
	}

	/* -------------------------------------------- */

	/**
	 * Schedule a perception update with requested parameters.
	 * @param {Object} options
	 */
	schedule(options={}) {
		this._set(options);
		this._update(false);
	}

	/* -------------------------------------------- */

	/**
	 * Perform an immediate perception update.
	 */
	update(options={}) {
		this._set(options);
		this._update(true);
	}

	/* -------------------------------------------- */

	/**
	 * A helper function to perform an immediate initialization plus incremental refresh.
	 */
	initialize() {
		return this.update({
			lighting: {initialize: true, refresh: true},
			sight: {initialize: true, refresh: true},
			sounds: {initialize: true, refresh: true},
			foreground: {refresh: true},
		});
	}

	/* -------------------------------------------- */

	/**
	 * A helper function to perform an incremental refresh only.
	 */
	refresh() {
		return this.update({
			lighting: {refresh: true},
			sight: {refresh: true},
			sounds: {refresh: true},
			foreground: {refresh: true},
		});
	}

	/* -------------------------------------------- */
	/*  Internal Helpers                            */
	/* -------------------------------------------- */

	/**
	 * Set option flags which configure the next perception update
	 * @param {object} options
	 * @private
	 */
	_set(options) {
		for ( let [layer, params] of Object.entries(options) ) {
			for ( let [k, v] of Object.entries(params) ) {
				this.params[layer][k] = Boolean(this.params[layer][k] + v);
			}
		}
		if ( this._throttleMS === undefined ) this._throttleMS = Math.round(1000 / game.settings.get("core", "maxFPS"));
	}

	/* -------------------------------------------- */

	/**
	 * Perform the perception update workflow
	 * @param {boolean} immediate     Perform the workflow immediately, otherwise it is throttled
	 * @private
	 */
	_update(immediate=false) {
		const p = this.params;
		const t = Date.now();

		// Apply both throttle and debounce
		if ( !immediate ) {
			const d = this._refreshTime ? t - this._refreshTime : 0;
			if ( !this._timeout ) {
				this._timeout = window.setTimeout(() => this._update(), this._throttleMS - d);
				this._refreshTime = t;
				return;
			}
			else if ( d < this._throttleMS ) return;
		}

		// When an update occurs, reset refresh parameters
		this.cancel();
		this._refreshTime = undefined;
		if ( !canvas.ready ) return;

		// Initialize perception sources for each layer
		if ( p.lighting.initialize ) canvas.lighting.initializeSources();
		if ( p.sight.initialize ) canvas.sight.initializeSources();
		if ( p.sounds.initialize ) canvas.sounds.initializeSources();

		// First update occlusion state of tiles in the Foreground layer
		if ( p.foreground.refresh ) {
			canvas.foreground.updateOcclusion();
			canvas.foreground.refresh();
		}

		// Next refresh lighting to establish the coloration channels for the Scene
		if ( p.lighting.refresh ) canvas.lighting.refresh();

		// Next refresh vision and fog of war
		if ( p.sight.refresh ) canvas.sight.refresh({
			noUpdateFog: p.sight.noUpdateFog,
			forceUpdateFog: p.sight.forceUpdateFog
		});

		// Lastly update the playback of ambient sounds
		if ( p.sounds.refresh ) canvas.sounds.refresh({fade: p.sounds.fade ? 250 : 0});

		// Reset flags
		this._reset();
	}

	/* -------------------------------------------- */

	/**
	 * Reset the values of a pending refresh back to their default states.
	 */
	_reset() {
		this.params = foundry.utils.deepClone(this.constructor.DEFAULTS);
	}
}

/**
 * An extension of the base PIXI.Polygon class designed for polygons which are constructed as a radius around
 * some central origin.
 * @extends {PIXI.Polygon}
 */
class SourcePolygon extends PIXI.Polygon {
	constructor(x, y, radius, ...points) {
		super(...points);
		this.x = x;
		this.y = y;
		this.radius = radius;
	}

	/** @inheritdoc */
	clone() {
		return new this.constructor(this.x, this.y, this.radius, this.points)
	}

	/**
	 * Optimize Polygon membership test by first checking the hypotenuse of the candidate point against the known origin
	 * @see PIXI.Polygon#contains
	 * @param {number} x      The candidate x-coordinate
	 * @param {number} y      The candidate y-coordinate
	 * @returns {boolean}     Is the provided point contained within the SourcePolygon?
	 */
	contains(x, y) {
		const dx = x - this.x;
		const dy = y - this.y;
		if ( (dx * dx) + (dy * dy) > (this.radius * this.radius) ) return false;
		return super.contains(x, y);
	}
}

/**
 * @typedef {Object} QuadtreeObject
 * @property {Rectangle} r
 * @property {*} t
 * @property {Set<Quadtree>} [n]
 */

/**
 * A Quadtree implementation that supports collision detection for rectangles.
 *
 * @param {Rectangle}                       The outer bounds of the region
 * @param {object} options                  Additional options which configure the Quadtree
 * @param {number} options.maxObjects       The maximum number of objects per node
 * @param {number} options.maxDepth         The maximum number of levels within the root Quadtree
 * @param {number} options._depth           The depth level of the sub-tree. For internal use
 * @param {number} options._root            The root of the quadtree. For internal use
 */
class Quadtree {
	constructor(bounds, {maxObjects=20, maxDepth=4, _depth=0, _root}={}, ) {

		/**
		 * The bounding rectangle of the region
		 * @type {Rectangle}
		 */
		this.bounds = bounds;

		/**
		 * The maximum number of objects allowed within this node before it must split
		 * @type {number}
		 */
		this.maxObjects = maxObjects;

		/**
		 * The maximum number of levels that the base quadtree is allowed
		 * @type {number}
		 */
		this.maxDepth = maxDepth;

		/**
		 * The depth of this node within the root Quadtree
		 * @type {number}
		 */
		this.depth = _depth;

		/**
		 * The objects contained at this level of the tree
		 * @type {QuadtreeObject[]}
		 */
		this.objects = [];

		/**
		 * Children of this node
		 * @type {Quadtree[]}
		 */
		this.nodes = [];

		/**
		 * The root Quadtree
		 * @type {Quadtree}
		 */
		this.root = _root || this;
	}

	/**
	 * A constant that enumerates the index order of the quadtree nodes from top-left to bottom-right.
	 * @enum {number}
	 */
	static INDICES = {
		"tl": 0,
		"tr": 1,
		"bl": 2,
		"br": 3
	};

	/* -------------------------------------------- */

	/**
	 * Return an array of all the objects in the Quadtree (recursive)
	 * @return {QuadtreeObject[]}
	 */
	get all() {
		if ( this.nodes.length ) {
			return this.nodes.reduce((arr, n) => arr.concat(n.all), []);
		}
		return this.objects;
	}

	/* -------------------------------------------- */
	/*  Tree Management                             */
	/* -------------------------------------------- */

	/**
	 * Split this node into 4 sub-nodes.
	 * @return {Quadtree}     The split Quadtree
	 */
	split() {
		const b = this.bounds;
		const w = b.width / 2;
		const h = b.height / 2;
		const options = {
			maxObjects: this.maxObjects,
			maxDepth: this.maxDepth,
			_depth: this.depth + 1,
			_root: this.root
		};

		// Create child quadrants
		this.nodes[Quadtree.INDICES.tl] = new Quadtree(new PIXI.Rectangle(b.x, b.y, w, h), options);
		this.nodes[Quadtree.INDICES.tr] = new Quadtree(new PIXI.Rectangle(b.x+w, b.y, w, h), options);
		this.nodes[Quadtree.INDICES.bl] = new Quadtree(new PIXI.Rectangle(b.x, b.y+h, w, h), options);
		this.nodes[Quadtree.INDICES.br] = new Quadtree(new PIXI.Rectangle(b.x+w, b.y+h, w, h), options);

		// Assign current objects to child nodes
		for ( let o of this.objects ) {
			o.n.delete(this);
			this.insert(o);
		}
		this.objects = [];
		return this;
	}

	/* -------------------------------------------- */
	/*  Object Management                           */
	/* -------------------------------------------- */

	/**
	 * Clear the quadtree of all existing contents
	 * @return {Quadtree}     The cleared Quadtree
	 */
	clear() {
		this.objects = [];
		for ( let n of this.nodes ) {
			n.clear();
		}
		this.nodes = [];
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Add a rectangle object to the tree
	 * @param {QuadtreeObject} obj  The object being inserted
	 * @return {Quadtree[]}         The Quadtree nodes the object was added to.
	 */
	insert(obj) {
		obj.n = obj.n || new Set();

		// If we will exceeded the maximum objects we need to split
		if ( (this.objects.length === this.maxObjects - 1) && (this.depth < this.maxDepth) ) {
			if ( !this.nodes.length ) this.split();
		}

		// If this node has children, recursively insert
		if ( this.nodes.length ) {
			let nodes = this.getChildNodes(obj.r);
			return nodes.reduce((arr, n) => arr.concat(n.insert(obj)), []);
		}

		// Otherwise store the object here
		obj.n.add(this);
		this.objects.push(obj);
		return [this];
	}

	/* -------------------------------------------- */

	/**
	 * Remove an object from the quadtree
	 * @param {target} target     The quadtree target being removed
	 * @return {Quadtree}         The Quadtree for method chaining
	 */
	remove(target) {
		this.objects.findSplice(o => o.t === target);
		for ( let n of this.nodes ) {
			n.remove(target);
		}
		return this;
	}

	/* -------------------------------------------- */
	/*  Target Identification                       */
	/* -------------------------------------------- */

	/**
	 * Get all the objects which could collide with the provided rectangle
	 * @param {Rectangle} rect  The target rectangle
	 * @param {Set} [_s]        The existing result set, for internal use.
	 * @returns {Set}           The objects in the Quadtree which represent potential collisions
	 */
	getObjects(rect, _s) {
		const objects = _s || new Set();

		// Recursively retrieve objects from child nodes
		if ( this.nodes.length ) {
			const nodes = this.getChildNodes(rect);
			for ( let n of nodes ) {
				n.getObjects(rect, objects);
			}
		}

		// Otherwise retrieve from this node
		else {
			for ( let o of this.objects)  {
				objects.add(o.t);
			}
		}

		// Return the result set
		return objects;
	}

	/* -------------------------------------------- */

	/**
	 * Obtain the leaf nodes to which a target rectangle belongs.
	 * This traverses the quadtree recursively obtaining the final nodes which have no children.
	 * @param {Rectangle} rect  The target rectangle.
	 * @return {Quadtree[]}     The Quadtree nodes to which the target rectangle belongs
	 */
	getLeafNodes(rect) {
		if ( !this.nodes.length ) return [this];
		const nodes = this.getChildNodes(rect);
		return nodes.reduce((arr, n) => arr.concat(n.getLeafNodes(rect)), []);
	}

	/* -------------------------------------------- */

	/**
	 * Obtain the child nodes within the current node which a rectangle belongs to.
	 * Note that this function is not recursive, it only returns nodes at the current or child level.
	 * @param {Rectangle} rect  The target rectangle.
	 * @return {Quadtree[]}     The Quadtree nodes to which the target rectangle belongs
	 */
	getChildNodes(rect) {

		// If this node has no children, use it
		if ( !this.nodes.length ) return [this];

		// Prepare data
		const nodes = [];
		const hx = this.bounds.x + (this.bounds.width / 2);
		const hy = this.bounds.y + (this.bounds.height / 2);

		// Determine orientation relative to the node
		const startTop = rect.y <= hy;
		const startLeft = rect.x <= hx;
		const endBottom = (rect.y + rect.height) > hy;
		const endRight = (rect.x + rect.width) > hx;

		// Top-left
		if ( startLeft && startTop ) nodes.push(this.nodes[Quadtree.INDICES.tl]);

		// Top-right
		if ( endRight && startTop ) nodes.push(this.nodes[Quadtree.INDICES.tr]);

		// Bottom-left
		if ( startLeft && endBottom ) nodes.push(this.nodes[Quadtree.INDICES.bl]);

		// Bottom-right
		if ( endRight && endBottom ) nodes.push(this.nodes[Quadtree.INDICES.br]);
		return nodes;
	}

	/* -------------------------------------------- */

	/**
	 * Identify all nodes which are adjacent to this one within the parent Quadtree.
	 * @returns {Quadtree[]}
	 */
	getAdjacentNodes() {
		const bounds = this.bounds.clone().pad(1);
		return this.root.getLeafNodes(bounds);
	}

	/* -------------------------------------------- */

	/**
	 * Visualize the nodes and objects in the quadtree
	 * @param {boolean} [objects]    Visualize the rectangular bounds of objects in the Quadtree. Default is false.
	 */
	visualize({objects=false}={}) {
		const debug = canvas.controls.debug;
		if ( this.depth === 0 ) debug.clear().endFill();
		debug.lineStyle(2, 0x00FF00, 0.5).drawRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
		if ( objects ) {
			for ( let o of this.objects ) {
				debug.lineStyle(2, 0xFF0000, 0.5).drawRect(o.r.x, o.r.y, Math.max(o.r.width, 1), Math.max(o.r.height, 1));
			}
		}
		for ( let n of this.nodes ) {
			n.visualize({objects});
		}
	}
}

/**
 * @typedef {Object} RayIntersection
 * @property {number} x     The x-coordinate of intersection
 * @property {number} y     The y-coordinate of intersection
 * @property {number} t0    The proximity to the Ray origin, as a ratio of distance
 * @property {number} t1    The proximity to the Ray destination, as a ratio of distance
 */

/**
 * A ray for the purposes of computing sight and collision
 * Given points A[x,y] and B[x,y]
 *
 * Slope-Intercept form:
 * y = a + bx
 * y = A.y + ((B.y - A.Y) / (B.x - A.x))x
 *
 * Parametric form:
 * R(t) = (1-t)A + tB
 *
 * @param {{x: number, y: number}} A      The origin of the Ray
 * @param {{x: number, y: number}} B      The destination of the Ray
 */
class Ray {
	constructor(A, B) {

		/**
		 * The origin point, {x, y}
		 * @type {Point}
		 */
		this.A = A;

		/**
		 * The destination point, {x, y}
		 * @type {Point}
		 */
		this.B = B;

		/**
		 * The origin y-coordinate
		 * @type {number}
		 */
		this.y0 = A.y;

		/**
		 * The origin x-coordinate
		 * @type {number}
		 */
		this.x0 = A.x;

		/**
		 * The horizontal distance of the ray, x1 - x0
		 * @type {number}
		 */
		this.dx = B.x - A.x;

		/**
		 * The vertical distance of the ray, y1 - y0
		 * @type {number}
		 */
		this.dy = B.y - A.y;

		/**
		 * The slope of the ray, dy over dx
		 * @type {number}
		 */
		this.slope = this.dy / this.dx;
	}

	/* -------------------------------------------- */
	/*  Attributes                                  */
	/* -------------------------------------------- */

	/**
	 * The cached angle, computed lazily in Ray#angle
	 * @type {number}
	 * @private
	 */
	_angle = undefined;

	/**
	 * The cached distance, computed lazily in Ray#distance
	 * @type {number}
	 * @private
	 */
	_distance = undefined;

	/* -------------------------------------------- */

	/**
	 * The normalized angle of the ray in radians on the range (-PI, PI).
	 * The angle is computed lazily (only if required) and cached.
	 * @type {number}
	 */
	get angle() {
		if ( this._angle === undefined ) this._angle = Math.atan2(this.dy, this.dx);
		return this._angle;
	}
	set angle(value) {
		this._angle = Number(value);
	}

	/* -------------------------------------------- */

	/**
	 * A bounding rectangle that encompasses the Ray
	 * @type {NormalizedRectangle}
	 */
	get bounds() {
		return new NormalizedRectangle(this.A.x, this.A.y, this.dx, this.dy);
	}

	/* -------------------------------------------- */

	/**
	 * The distance (length) of the Ray in pixels.
	 * The distance is computed lazily (only if required) and cached.
	 * @type {number}
	 */
	get distance() {
		if ( this._distance === undefined ) this._distance = Math.hypot(this.dx, this.dy);
		return this._distance;
	}
	set distance(value) {
		this._distance = Number(value);
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * A factory method to construct a Ray from an origin point, an angle, and a distance
	 * @param {number} x          The origin x-coordinate
	 * @param {number} y          The origin y-coordinate
	 * @param {number} radians    The ray angle in radians
	 * @param {number} distance   The distance of the ray in pixels
	 * @return {Ray}              The constructed Ray instance
	 */
	static fromAngle(x, y, radians, distance) {
		const dx = Math.cos(radians);
		const dy = Math.sin(radians);
		const ray = Ray.fromArrays([x ,y], [x + (dx * distance), y + (dy * distance)]);
		ray._angle = Math.normalizeRadians(radians); // Store the angle, cheaper to compute here
		ray._distance = distance; // Store the distance, cheaper to compute here
		return ray;
	}

	/* -------------------------------------------- */

	/**
	 * A factory method to construct a Ray from points in array format.
	 * @param {number[]} A    The origin point [x,y]
	 * @param {number[]} B    The destination point [x,y]
	 * @return {Ray}          The constructed Ray instance
	 */
	static fromArrays(A, B) {
		return new this({x: A[0], y: A[1]}, {x: B[0], y: B[1]});
	}

	/* -------------------------------------------- */

	/**
	 * Project the Array by some proportion of it's initial distance.
	 * Return the coordinates of that point along the path.
	 * @param {number} t    The distance along the Ray
	 * @return {Object}     The coordinates of the projected point
	 */
	project(t) {
		return {
			x: this.A.x + (t * this.dx),
			y: this.A.y + (t * this.dy)
		}
	}

	/* -------------------------------------------- */

	/**
	 * Reverse the direction of the Ray, returning a second Ray
	 * @returns {Ray}
	 */
	reverse() {
		const r = new Ray(this.B, this.A);
		r._distance = this._distance;
		r._angle = Math.PI - this._angle;
		return r;
	}

	/* -------------------------------------------- */

	/**
	 * Create a new ray which uses the same origin point, but a slightly offset angle and distance
	 * @param {number} offset       An offset in radians which modifies the angle of the original Ray
	 * @param {number} [distance]   A distance the new ray should project, otherwise uses the same distance.
	 * @return {Ray}                A new Ray with an offset angle
	 */
	shiftAngle(offset, distance) {
		return Ray.fromAngle(this.x0, this.y0, this.angle + offset, distance || this.distance);
	}

	/* -------------------------------------------- */

	/**
	 * Find the point I[x,y] and distance t* on ray R(t) which intersects another ray
	 * http://paulbourke.net/geometry/pointlineplane/
	 *
	 * @param {number[]} coords     An array of coordinates [x0, y0, x1, y1] which defines a line segment to test
	 *
	 * @return {RayIntersection|boolean}
	 *    The point of collision [x,y] the position of that collision point along the Ray (t0) an the tested
	 *    segment (t1). Returns false if no collision occurs.
	 */
	intersectSegment(coords) {
		return this.constructor._getIntersection(this.A.x, this.A.y, this.B.x, this.B.y, ...coords);
	}

	/* -------------------------------------------- */

	/**
	 * An internal helper method for computing the intersection between two lines.
	 * @returns {RayIntersection|boolean}
	 * @private
	 */
	static _getIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
		let e = 1e-12;

		// Length 0 === false
		if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {
			return false
		}

		// Check denominator - avoid parallel lines where d = 0
		let d = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
		if (d === 0) {
			return false
		}

		// Get vector distances
		let t0 = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / d;
		let t1 = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / d;

		// Confirm the solution lies within both segments
		const collides = Number.between(t0, 0-e, 1+e) && Number.between(t1, 0-e, 1+e);
		if (!collides) return false;

		// Return an objects with the point of intersection and the distance from the origin
		return {
			x: x1 + t0 * (x2 - x1),
			y: y1 + t0 * (y2 - y1),
			t0: t0,
			t1: t1
		}
	}

	/* -------------------------------------------- */
	/*  Deprecations                                */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	get normAngle() {
		let a = this.angle % (2 * Math.PI);
		return a < 0 ? a + (2 * Math.PI) : a;
	}
}


/**
 * A PIXI.Rectangle where the width and height are always positive and the x and y are always the top-left
 * @extends {PIXI.Rectangle}
 */
class NormalizedRectangle extends PIXI.Rectangle {
	constructor(x, y, width, height) {
		x = width > 0 ? x : x + width;
		y = height > 0 ? y : y + height;
		super(x, y, Math.abs(width), Math.abs(height));
	}

	/**
	 * Generate a new rectangle by rotating this one clockwise about its center by a certain number of radians
	 * @param {number} radians        The angle of rotation
	 * @returns {NormalizedRectangle} A new rotated rectangle
	 */
	rotate(radians) {
		return this.constructor.fromRotation(this.x, this.y, this.width, this.height, radians);
	}

	/**
	 * Create normalized rectangular bounds given a rectangle shape and an angle of central rotation.
	 * @param {number} x              The top-left x-coordinate of the un-rotated rectangle
	 * @param {number} y              The top-left y-coordinate of the un-rotated rectangle
	 * @param {number} width          The width of the un-rotated rectangle
	 * @param {number} height         The height of the un-rotated rectangle
	 * @param {number} radians        The angle of rotation about the center
	 * @returns {NormalizedRectangle} The constructed rotated rectangle bounds
	 */
	static fromRotation(x, y, width, height, radians) {
		const rh = (height * Math.abs(Math.cos(radians))) + (width * Math.abs(Math.sin(radians)));
		const rw = (height * Math.abs(Math.sin(radians))) + (width * Math.abs(Math.cos(radians)));
		const rx = x + ((width - rw) / 2);
		const ry = y + ((height - rh) / 2);
		return new NormalizedRectangle(rx, ry, rw, rh);

	}
}

class ResizeHandle extends PIXI.Graphics {
	constructor(offset, handlers={}) {
		super();
		this.offset = offset;
		this.handlers = handlers;
		this.lineStyle(4, 0x000000, 1.0).beginFill(0xFF9829, 1.0).drawCircle(0, 0, 10).endFill();
	}

	/**
	 * Track whether the handle is being actively used for a drag workflow
	 * @type {boolean}
	 */
	active = false;

	/* -------------------------------------------- */

	refresh(bounds) {
		this.position.set(bounds.x + (bounds.width * this.offset[0]), bounds.y + (bounds.height * this.offset[1]));
	}

	/* -------------------------------------------- */

	updateDimensions(current, origin, destination, {aspectRatio=null}={}) {

		// Identify the change in dimensions
		const dx = destination.x - origin.x;
		const dy = destination.y - origin.y;

		// Determine the new width and the new height
		let width = Math.max(origin.width + dx, 24);
		let height = Math.max(origin.height + dy, 24);

		// Constrain the aspect ratio
		if ( aspectRatio ) {
			if ( width >= height ) width = height * aspectRatio;
			else height = width / aspectRatio;
		}

		// Adjust the final points
		return {
			x: current.x,
			y: current.y,
			width: width * Math.sign(current.width),
			height: height * Math.sign(current.height)
		};
	}

	/* -------------------------------------------- */
	/*  Interactivity                               */
	/* -------------------------------------------- */

	activateListeners() {
		this.off("mouseover").off("mouseout").off("mousedown")
			.on("mouseover", this._onHoverIn.bind(this))
			.on("mouseout", this._onHoverOut.bind(this))
			.on("mousedown", this._onMouseDown.bind(this));
		this.interactive = true;
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-over event on a control handle
	 * @param {PIXI.InteractionEvent} event   The mouseover event
	 * @protected
	 */
	_onHoverIn(event) {
		const handle = event.target;
		handle.scale.set(1.5, 1.5);
		event.data["handle"] = event.target;
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-out event on a control handle
	 * @param {PIXI.InteractionEvent} event   The mouseout event
	 * @protected
	 */
	_onHoverOut(event) {
		const {handle} = event.data;
		handle.scale.set(1.0, 1.0);
	}

	/* -------------------------------------------- */

	/**
	 * When we start a drag event - create a preview copy of the Tile for re-positioning
	 * @param {PIXI.InteractionEvent} event   The mousedown event
	 * @protected
	 */
	_onMouseDown(event) {
		if ( this.handlers.canDrag && !this.handlers.canDrag() ) return;
		this.active = true;
	}
}
/**
 * A helper class used by the Sight Layer to represent a source of vision or illumination.
 * @param {PlaceableObject} object      The object responsible for the PointSource
 */
class PointSource {
	constructor(object, sourceType) {

		/**
		 * The object responsible for the PointSource
		 * @type {PlaceableObject}
		 */
		this.object = object;

		/**
		 * The type of source
		 * @type {string}
		 */
		this.sourceType = sourceType;

		/**
		 * The light or darkness container for this source
		 * @type {PIXI.Container}
		 */
		this.illumination = this._createContainer(StandardIlluminationShader);

		/**
		 * This visible color container for this source
		 * @type {PIXI.Container}
		 */
		this.coloration = this._createContainer(StandardColorationShader);

		/**
		 * A flag for whether this source is currently active (rendered) or not
		 * @type {boolean}
		 */
		this.active = false;

		/**
		 * The range of Scene darkness values for which this Source should be active
		 * @type {{min: number, max: number}}
		 */
		this.darkness = {min: 0, max: 0};

		/**
		 * Internal flag for whether this is a darkness source
		 * @type {boolean}
		 */
		this.isDarkness = false;

		/**
		 * Is the light source limited by an angle of emission?
		 * @type {boolean}
		 */
		this.limited = false;

		/**
		 * The maximum radius of emission for this source
		 * @type {number}
		 */
		this.radius = 0;

		/**
		 * Internal flag for animation throttling time
		 * @type {number}
		 */
		this._animateTime = 0;

		/**
		 * An integer seed which de-synchronizes otherwise similar animations
		 * @type {number|null}
		 */
		this._animateSeed = null;

		/**
		 * A flag for the lighting channels version that this source is using.
		 * @type {number}
		 */
		this._lightingVersion = 0;

		/**
		 * A flag for whether to re-initialize illumination shader uniforms the next time the light is rendered.
		 * @type {boolean}
		 */
		this._resetIlluminationUniforms = true;

		/**
		 * A flag for whether to re-initialize coloration shader uniforms the next time the light is rendered.
		 * @type {boolean}
		 */
		this._resetColorationUniforms = true;

		/**
		 * An internal flag for whether to render coloration for this source
		 * @type {boolean}
		 */
		this._hasColor = false;
	}

	/**
	 * The default Geometry stored in the GPU for all Point Source meshes.
	 * @type {PIXI.Geometry}
	 */
	static GEOMETRY = new PIXI.Geometry()
		.addAttribute('aVertexPosition', [-1, -1, 1, -1, 1, 1, -1, 1], 2)
		.addAttribute('aUvs', [0, 0, 1, 0, 1, 1, 0, 1], 2)
		.addIndex([0, 1, 2, 0, 2, 3]);

	/* -------------------------------------------- */

	/**
	 * Create the structure of a source Container which can be rendered to the sight layer shadow-map
	 * @return {PIXI.Container} The constructed light source container
	 * @private
	 */
	_createContainer(shaderCls) {
		const c = new PIXI.Container();

		// Create the Mesh used to render the source
		const state = new PIXI.State();
		const light = new PIXI.Mesh(PointSource.GEOMETRY, shaderCls.create(), state);
		c.light = c.addChild(light);

		// Mask the light using it's FOV polygon
		c.fov = c.addChild(new PIXI.Graphics());
		c.mask = c.fov;

		// Define container properties
		Object.defineProperty(c, "shader", { get: () => c.light.shader, set: shader => c.light.shader = shader });
		Object.defineProperty(c, "uniforms", { get: () => c.light.shader.uniforms });
		return c;
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the source with provided object data.
	 *
	 * @param {object} data       Input data which configures the source.
	 * @param {number} data.x          The x-coordinate of the source location
	 * @param {number} data.y          The y-coordinate of the source location
	 * @param {number} [data.z]        An optional z-index sorting for the source
	 * @param {number} data.dim        The allowed radius of dim vision or illumination
	 * @param {number} data.bright     The allowed radius of bright vision or illumination
	 * @param {number} data.angle      The angle of emission for this point source
	 * @param {number} data.rotation   The angle of rotation for this point source
	 * @param {number} data.color      A tint color for the emitted light, if any
	 * @param {number} data.alpha      An opacity for the emitted light, if any
	 * @param {object} data.darkness   A darkness range (min and max) for which the source should be active
	 * @param {string} data.type       The source type from CONST.SOURCE_TYPES
	 * @param {object} data.animation  An animation configuration for the source
	 * @param {number} data.seed       An integer seed to synchronize (or de-synchronize) animations
	 *
	 * @return {PointSource}      A reference to the initialized source
	 */
	initialize(data={}) {

		// Clean input data
		if ( data.animation instanceof foundry.abstract.DocumentData ) data.animation = data.animation.toObject();
		data.animation = data.animation || {type: null};
		data.angle = data.angle ?? 360;
		data.alpha = data.alpha ?? 0.5;
		data.bright = data.bright ?? 0;
		data.color = typeof data.color === "string" ? foundry.utils.colorStringToHex(data.color) : (data.color ?? null);
		data.darkness = {min: data.darkness?.min ?? 0, max: data.darkness?.max ?? 1};
		data.dim = data.dim ?? 0;
		data.rotation = data.rotation ?? 0;
		data.type = data.type ?? CONST.SOURCE_TYPES.LOCAL;
		data.x = data.x ?? 0;
		data.y = data.y ?? 0;
		data.z = data.z ?? null;

		// Identify changes and assign cleaned data
		const changes = foundry.utils.flattenObject(foundry.utils.diffObject(this, data));
		foundry.utils.mergeObject(this, data);

		// Derived data attributes
		this.colorRGB = foundry.utils.hexToRGB(this.color);
		this.radius = Math.max(Math.abs(this.dim), Math.abs(this.bright));
		this.ratio = Math.clamped(Math.abs(this.bright) / this.radius, 0, 1);
		this.isDarkness = Math.min(this.dim, this.bright) < 0;
		this.limited = this.angle !== 360;
		this._animateSeed = data.seed ?? this._animateSeed ?? Math.floor(Math.random() * 100000);

		// Always update polygons for the source as the environment may have changed
		const origin = {x: this.x, y: this.y};
		const {fov, los} = canvas.walls.computePolygon(origin, this.radius, {
			type: this.sourceType || "sight",
			angle: this.angle,
			rotation: this.rotation,
			unrestricted: this.type === CONST.SOURCE_TYPES.UNIVERSAL
		});
		this.fov = fov;
		this.los = los;

		// Update shaders if the animation type changed
		const updateShaders =["animation.type", "color"].some(k => k in changes);
		if ( updateShaders ) this._initializeShaders();

		// Initialize uniforms if the appearance of the light changed
		if ( updateShaders || ["dim", "bright", "alpha"].some(k => k in changes) ) {
			this._resetColorationUniforms = true;
			this._resetIlluminationUniforms = true;
		}

		// Initialize blend modes and sorting
		this._initializeBlending();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the shaders used for this animation.
	 * Reset the current shader values back to defaults.
	 * Swap to a different Shader instance if necessary.
	 * @private
	 */
	_initializeShaders() {
		const anim = CONFIG.Canvas.lightAnimations[this.animation.type] || {};
		const iCls = anim.illuminationShader || StandardIlluminationShader;
		const cCls = anim.colorationShader || StandardColorationShader;

		// Initialize illumination shader
		const is = this.illumination.shader;
		if ( is?.constructor.name !== iCls.name ) {
			const shader = iCls.create();
			shader.container = this.illumination;
			this.illumination.shader = shader;
			if ( is ) is.destroy();
		}

		// Determine whether the source has coloration
		const cs = this.coloration.shader;
		if ( this.alpha === 0 ) this._hasColor = false;
		else if ( cCls !== StandardColorationShader ) this._hasColor = true;
		else this._hasColor = !!this.color;

		// Change to a different shader class
		if ( cs?.constructor !== cCls ) {
			const shader = cCls.create();
			shader.container = this.coloration;
			this.coloration.shader = shader;
			if ( cs ) cs.destroy();
		}

		// Dispatch a hook which allows for modules to apply fine-grained customization to the source
		Hooks.callAll("initializePointSourceShaders", this, this.animation.type);
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the blend mode and vertical sorting of this source relative to others in the container.
	 * @private
	 */
	_initializeBlending() {
		if ( this.isDarkness ) {
			this.illumination.light.blendMode = PIXI.BLEND_MODES.MIN_COLOR;
			this.illumination.zIndex = this.z ?? 10;
			this.coloration.light.blendMode = PIXI.BLEND_MODES.MULTIPLY;
			this.coloration.zIndex = this.z ?? 10;
		} else {
			this.illumination.light.blendMode = PIXI.BLEND_MODES.MAX_COLOR;
			this.illumination.zIndex = this.z ?? 0;
			this.coloration.light.blendMode = PIXI.BLEND_MODES.SCREEN;
			this.coloration.zIndex = this.z ?? 0;
		}
	}

	/* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */

	/**
	 * Draw the display of this source for the darkness/light container of the SightLayer.
	 * @return {PIXI.Container}         The rendered light container
	 */
	drawLight() {

		// Protect against cases where the canvas is being deactivated
		const shader = this.illumination.shader;
		if ( !shader ) return null;

		// Update shader uniforms
		const iu = shader.uniforms;
		const updateChannels = this._lightingVersion < canvas.lighting.version;
		if ( this._resetIlluminationUniforms || updateChannels ) {
			const channels = canvas.lighting.channels;
			iu.colorDim = this.isDarkness ? channels.dark.rgb : channels.dim.rgb;
			iu.colorBright = this.isDarkness ? channels.black.rgb : channels.bright.rgb;
			this._lightingVersion = canvas.lighting.version;
		}
		if ( this._resetIlluminationUniforms ) {
			iu.ratio = this.ratio;
			this._resetIlluminationUniforms = false;
		}

		// Draw the container
		return this._drawContainer(this.illumination);
	}

	/* -------------------------------------------- */

	/**
	 * Draw and return a container used to depict the visible color tint of the light source on the LightingLayer
	 * @return {PIXI.Container}           An updated color container for the source
	 */
	drawColor() {

		// Protect against cases where no coloration is present
		const shader = this.coloration.shader;
		if ( !shader || !(this._hasColor || this.isDarkness) ) return null;

		// No coloration container present
		if ( this._resetColorationUniforms ) {
			const cu = shader.uniforms;
			cu.darkness = this.isDarkness;
			cu.alpha = this.alpha;
			cu.color = this.color ? this.colorRGB : shader._defaults.color;
			this._resetColorationUniforms = false;
		}

		// Draw the container
		return this._drawContainer(this.coloration);
	}

	/* -------------------------------------------- */

	/**
	 * A common helper function for updating the display of a source container.
	 * Assign the container position, dimensions, and polygons.
	 * @private
	 */
	_drawContainer(c) {
		c.light.position.set(this.x, this.y);
		c.light.width = c.light.height = this.radius * 2;
		c.fov.clear();
		if ( this.radius > 0 ) c.fov.beginFill(0xFFFFFF, 1.0).drawPolygon(this.fov).endFill();
		return c;
	}

	/* -------------------------------------------- */
	/*  Light Source Animation                      */
	/* -------------------------------------------- */

	/**
	 * Animate the PointSource, if an animation is enabled and if it currently has rendered containers.
	 * @param {number} dt         Delta time
	 */
	animate(dt) {
		const animation = this.animation;
		if ( !animation.type || (this.radius === 0) || !this.illumination.shader ) return;
		const fn = CONFIG.Canvas.lightAnimations[animation.type]?.animation;
		if ( fn ) fn.call(this, dt, animation);
	}

	/* -------------------------------------------- */

	/**
	 * A torch animation where the luminosity and coloration decays each frame and is revitalized by flashes
	 * @param {number} dt         Delta time
	 * @param {number} speed      The animation speed, from 1 to 10
	 * @param {number} intensity  The animation intensity, from 1 to 10
	 */
	animateTorch(dt, { speed = 5, intensity = 5 }) {
		const t = canvas.app.ticker.lastTime;
		this._animTime = t / (5000 / speed);
		const iu = this.illumination.uniforms;
		const cu = this.coloration.uniforms;
		const w = 0.5 * (Math.cos(t * 0.01) + 1);
		const wave = (a, b, w) => (a - b) * w + b;

		// When a "flash" occurs
		if ((t > (this._flashTime || 0))) {

			// Randomize the next time to flash
			const s = (11 - speed) * 50;
			const deltaMS = Math.random() * s;
			this._flashTime = t + deltaMS;

			// Randomize the color intensity of the flash
			const mu = this.alpha - cu.alpha;                                 // On average, increase to the normal alpha
			const sigma = intensity * 0.05;                                   // Variance of the spikes
			const epsilon = twist.normal(mu, sigma);
			const maxA = Math.min(this.alpha * 1.1, 0.5 + (this.alpha / 2));  // Maximum alpha that the spike can reach
			cu.alpha = Math.clamped(cu.alpha + epsilon, cu.alpha, maxA);
			const ei = twist.normal(1 - iu.alpha, sigma);
			iu.alpha = Math.clamped(iu.alpha + ei, iu.alpha, 1);

			// Boost the ratio of bright:dim
			iu.ratio = this.ratio * iu.alpha;
			cu.ratio = iu.ratio;
		}

		// Animate the dampening process
		const dc = 0.0005 * (speed + intensity);
		const dw = dc / 2;
		const wv = wave(1.0 + dw, 1.0 - dw, w);
		iu.alpha = iu.alpha * (1.0 - dc) * wv;
		iu.ratio = iu.ratio * (1.0 - dc) * wv;
		cu.alpha = cu.alpha * (1.0 - dc) * wv;
		cu.ratio = cu.ratio * (1.0 - dc) * wv;
		cu.time = iu.time = this._animTime;
	}

	/* -------------------------------------------- */

	/**
	 * A basic "pulse" animation which expands and contracts.
	 * @param {number} dt         Delta time
	 * @param {number} speed      The animation speed, from 1 to 10
	 * @param {number} intensity  The animation intensity, from 1 to 10
	 */
	animatePulse(dt, { speed = 5, intensity = 5 } = {}) {
		this._animTime = canvas.app.ticker.lastTime / (5000 / speed);
		const i = (10 - intensity) * 0.1;
		const si = Math.sqrt(i);
		const w = 0.5 * (Math.cos(this._animTime * 2.5) + 1);
		const wave = (a, b, w) => (a - b) * w + b;

		// Pulse coloration
		const co = this.coloration;
		co.uniforms.intensity = intensity;
		co.uniforms.time = this._animTime;
		co.uniforms.alpha = wave(this.alpha, this.alpha * si, w);
		co.uniforms.pulse = wave(1.2, i, w);

		// Pulse illumination
		const il = this.illumination;
		il.uniforms.intensity = intensity;
		il.uniforms.time = this._animTime;
		il.uniforms.alpha = wave(1.1, 1.1 * si, w);
		il.uniforms.ratio = wave(this.ratio, this.ratio * i, w);
	}

	/* -------------------------------------------- */

	/**
	 * Emanate waves of light from the source origin point
	 * @param {number} dt         Delta time
	 * @param {number} speed      The animation speed, from 1 to 10
	 * @param {number} intensity  The animation intensity, from 1 to 10
	 */
	animateTime(dt, {speed=5, intensity=5}={}) {
		this._animTime = (canvas.app.ticker.lastTime / (5000/speed)) + this._animateSeed;
		const co = this.coloration;
		co.uniforms.intensity = intensity;
		co.uniforms.time = this._animTime;
		const il = this.illumination;
		il.uniforms.intensity = intensity;
		il.uniforms.time = this._animTime;
	}

	/* -------------------------------------------- */

	/**
	 * Evolve a value using a stochastic AR(1) process
	 * @param {number} y        The current value
	 * @param {number} phi      The decay rate of prior values
	 * @param {number} center   The stationary mean of the series
	 * @param {number} sigma    The volatility of the process - standard deviation of the error term
	 * @param {number|null} max The maximum allowed outcome, or null
	 * @param {number|null} min The minimum allowed outcome, or null
	 * @return {number}         The new value of the process
	 * @private
	 */
	_ar1(y, {phi=0.5, center=0, sigma=0.1, max=null, min=null}={}) {
		let yt = center + (phi * (y - center)) + twist.normal(0, sigma);
		if ( max !== null ) yt = Math.min(yt, max);
		if ( min !== null ) yt = Math.max(yt, min);
		return yt;
	}
}

/**
 * A subclass of Set which manages the Token ids which the User has targeted.
 * @extends {Set}
 * @see User#targets
 */
class UserTargets extends Set {
	constructor(user) {
		super();
		if ( user.targets ) throw new Error(`User ${user.id} already has a targets set defined`);
		this.user = user;
	}

	/**
	 * Return the Token IDs which are user targets
	 * @type {string[]}
	 */
	get ids() {
		return Array.from(this).map(t => t.id);
	}

	/** @override */
	add(token) {
		super.add(token);
		this._hook(token, true);
	}

	/** @override */
	clear() {
		const tokens = Array.from(this);
		super.clear();
		tokens.forEach(t => this._hook(t, false));
	}

	/** @override */
	delete(token) {
		super.delete(token);
		this._hook(token, false);
	}

	/**
	 * Dispatch the targetToken hook whenever the user's target set changes
	 * @private
	 */
	_hook(token, targeted) {
		Hooks.callAll("targetToken", this.user, token, targeted);
	}
}
/**
 * An extension of the default PIXI.Text object which forces double resolution.
 * At default resolution Text often looks blurry or fuzzy.
 */
class PreciseText extends PIXI.Text {
	constructor(...args) {
		super(...args);
		this._autoResolution = false;
		this._resolution = 2;
	}
}
/**
 * The DrawingsLayer subclass of PlaceablesLayer.
 * This layer implements a container for drawings which are rendered immediately above the BackgroundLayer. *
 * @extends {PlaceablesLayer}
 */
class DrawingsLayer extends PlaceablesLayer {

	/** @inheritdoc */
	static get layerOptions() {
		return foundry.utils.mergeObject(super.layerOptions, {
			name: "drawings",
			canDragCreate: true,
			controllableObjects: true,
			rotatableObjects: true,
			zIndex: 20
		});
	}

	/** @inheritdoc */
	static documentName = "Drawing";

	/**
	 * The named game setting which persists default drawing configuration for the User
	 * @type {string}
	 */
	static DEFAULT_CONFIG_SETTING = "defaultDrawingConfig";

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * Use an adaptive precision depending on the size of the grid
	 * @type {number}
	 */
	get gridPrecision() {
		if ( canvas.scene.data.gridType === CONST.GRID_TYPES.GRIDLESS ) return 0;
		return canvas.dimensions.size >= 128 ? 16 : 8;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get hud() {
		return canvas.hud.drawing;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Render a configuration sheet to configure the default Drawing settings
	 */
	configureDefault() {
		const defaults = this._getNewDrawingData({});
		const d = new DrawingDocument(defaults);
		new DrawingConfig(d, {configureDefault: true}).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Override the deactivation behavior of this layer.
	 * Placeables on this layer remain visible even when the layer is inactive.
	 */
	deactivate() {
		super.deactivate();
		if (this.objects) this.objects.visible = true;
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Get initial data for a new drawing.
	 * Start with some global defaults, apply user default config, then apply mandatory overrides per tool.
	 * @param {Object} origin     The initial coordinate
	 * @return {Object}           The new drawing data
	 */
	_getNewDrawingData(origin) {
		const tool = game.activeTool;

		// Get saved user defaults
		const defaults = game.settings.get("core", this.constructor.DEFAULT_CONFIG_SETTING) || {};
		const data = foundry.utils.mergeObject(defaults, {
			fillColor: game.user.color,
			strokeColor: game.user.color,
			fontFamily: CONFIG.defaultFontFamily
		}, {overwrite: false, inplace: false});

		// Mandatory additions
		data.x = origin.x;
		data.y = origin.y;
		data.author = game.user.id;

		// Tool-based settings
		switch ( tool ) {
			case "rect":
				data.type = CONST.DRAWING_TYPES.RECTANGLE;
				data.points = [];
				break;
			case "ellipse":
				data.type = CONST.DRAWING_TYPES.ELLIPSE;
				data.points = [];
				break;
			case "polygon":
				data.type = CONST.DRAWING_TYPES.POLYGON;
				data.points = [[0, 0]];
				break;
			case "freehand":
				data.type = CONST.DRAWING_TYPES.FREEHAND;
				data.points = [[0, 0]];
				data.bezierFactor = data.bezierFactor ?? 0.5;
				break;
			case "text":
				data.points = [];
				data.type = CONST.DRAWING_TYPES.TEXT;
				data.fillColor = "#FFFFFF";
				data.fillAlpha = 0.10;
				data.strokeColor = "#FFFFFF";
				data.text = data.text || "New Text";
		}
		return data;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_onClickLeft(event) {
		const {preview, createState, originalEvent} = event.data;

		// Continue polygon point placement
		if ( createState >= 1 && preview.isPolygon ) {
			let point = event.data.destination;
			if ( !originalEvent.shiftKey ) point = canvas.grid.getSnappedPosition(point.x, point.y, this.gridPrecision);
			preview._addPoint(point, false);
			preview._chain = true; // Note that we are now in chain mode
			return preview.refresh();
		}

		// Standard left-click handling
		super._onClickLeft(event);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onClickLeft2(event) {
		const {createState, preview} = event.data;

		// Conclude polygon placement with double-click
		if ( createState >= 1 && preview.isPolygon ) {
			event.data.createState = 2;
			return this._onDragLeftDrop(event);
		}

		// Standard double-click handling
		super._onClickLeft2(event);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _onDragLeftStart(event) {
		await super._onDragLeftStart(event);
		const data = this._getNewDrawingData(event.data.origin);
		const document = new DrawingDocument(data, {parent: canvas.scene});
		const drawing = new Drawing(document);
		event.data.preview = this.preview.addChild(drawing);
		return drawing.draw();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftMove(event) {
		const {preview, createState} = event.data;
		if ( !preview ) return;
		if ( preview.parent === null ) { // In theory this should never happen, but rarely does
			this.preview.addChild(preview);
		}
		if (createState >= 1 ) {
			preview._onMouseDraw(event);
			if ( preview.data.type !== CONST.DRAWING_TYPES.POLYGON ) event.data.createState = 2;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handling of mouse-up events which conclude a new object creation after dragging
	 * @private
	 */
	async _onDragLeftDrop(event) {
		const { createState, destination, origin, preview } = event.data;

		// Successful drawing completion
		if ( createState === 2 ) {
			const distance = Math.hypot(destination.x - origin.x, destination.y - origin.y);
			const minDistance = distance >= (canvas.dimensions.size / 8);
			const completePolygon = preview.isPolygon && (preview.data.points.length > 2);

			// Create a completed drawing
			if ( minDistance || completePolygon ) {
				event.data.createState = 0;
				const data = preview.data;

				// Set default text values
				if (data.type === CONST.DRAWING_TYPES.TEXT) {
					data.fillColor = null;
					data.fillAlpha = 0;
					data.strokeColor = null;
					data.strokeWidth = 0;
				}

				// Create the object
				preview._chain = false;
				const cls = getDocumentClass("Drawing");
				const createData = this.constructor.placeableClass.normalizeShape(data);
				const drawing = await cls.create(createData, {parent: canvas.scene});
				const o = drawing.object;
				o._creating = true;
				o._pendingText = "";
				if ( drawing.data.type !== CONST.DRAWING_TYPES.FREEHAND ) o.control({isNew: true});
			}

			// Cancel the preview
			return this._onDragLeftCancel(event);
		}

		// In-progress polygon
		if ( (createState === 1) && preview.isPolygon ) {
			event.data.originalEvent.preventDefault();
			if ( preview._chain ) return;
			return this._onClickLeft(event);
		}

		// Incomplete drawing
		return this._onDragLeftCancel(event);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftCancel(event) {
		const preview = this.preview.children?.[0] || null;
		if ( preview?._chain ) {
			preview._removePoint();
			preview.refresh();
			if (preview.data.points.length) return event.preventDefault();
		}
		super._onDragLeftCancel(event);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onClickRight(event) {
		const preview = this.preview.children?.[0] || null;
		if ( preview ) return canvas.mouseInteractionManager._dragRight = false;
		super._onClickRight(event);
	}
}

/**
 * A CanvasLayer for displaying visual effects like weather, transitions, flashes, or more
 * @type {CanvasLayer}
 */
class EffectsLayer extends CanvasLayer {

	/**
	 * The weather overlay container
	 * @type {PIXI.Container}
	 */
	weather;

	/**
	 * The currently active weather effect
	 * @type {SpecialEffect}
	 */
	weatherEffect;

	/**
	 * Track any active emitters within this Scene
	 * @type {Object[]}
	 */
	emitters = [];

	/**
	 * An occlusion filter that prevents weather from being displayed in certain regions
	 * @type {AbstractBaseMaskFilter}
	 */
	weatherOcclusionFilter;

	/* -------------------------------------------- */

	/** @inheritdoc */
	static get layerOptions() {
		return foundry.utils.mergeObject(super.layerOptions, {
			name: "effects",
			zIndex: 700
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async tearDown() {
		if ( this.weatherEffect ) this.weatherEffect.stop();
		this.weather = this.weatherEffect = null;
		return super.tearDown();
	}

	/* -------------------------------------------- */

	/** @override */
	async draw() {
		this.weatherOcclusionFilter = InverseOcclusionMaskFilter.create({
			alphaOcclusion: 0,
			uMaskSampler: canvas.foreground.occlusionMask.renderTexture
		}, "b");
		this.drawWeather();
	}

	/* -------------------------------------------- */

	/**
	 * Draw the weather container.
	 * @returns {PIXI.Container|null}    The weather container, or null if no effect is present
	 */
	drawWeather() {
		if ( this.weatherEffect )	this.weatherEffect.stop();
		const effect = CONFIG.weatherEffects[canvas.scene.data.weather];
		if ( !effect ) {
			this.weatherOcclusionFilter.enabled = false;
			return null;
		}

		// Create the effect and begin playback
		if ( !this.weather ) this.weather = this.addChild(new PIXI.Container());
		this.weatherEffect = new effect(this.weather);
		this.weatherEffect.play();

		// Apply occlusion filter
		this.weatherOcclusionFilter.enabled = true;
		this.weather.filters = [this.weatherOcclusionFilter];
		return this.weather;
	}
}

/**
 * The Lighting Layer which displays darkness and light within the rendered Scene.
 * Lighting Layer (Container)
 *   Illumination Container [MULTIPLY]
 *     Background (Graphics)
 *     Light (Container) [LOS Mask]
 *       Source 1, ..., Source N (Container)
 *     Darkness (Container)
 *       Source 1, ..., Source N (Container)
 *   Coloration Container [ADD_NPM]
 * @extends {PlaceablesLayer}
 *
 * @example <caption>The lightingRefresh hook</caption>
 * Hooks.on("lightingRefresh", layer => {});
 */
class LightingLayer extends PlaceablesLayer {
	constructor(...args) {
		super(...args);

		/**
		 * A mapping of light sources which are active within the rendered Scene
		 * @type {Collection<string,PointSource>}
		 */
		this.sources = new foundry.utils.Collection();

		/**
		 * Increment this whenever lighting channels are re-configured.
		 * This informs lighting and vision sources whether they need to re-render.
		 * @type {number}
		 */
		this.version = 0;

		/**
		 * The currently displayed darkness level, which may override the saved Scene value
		 * @type {number}
		 * @private
		 */
		this.darknessLevel = 0;

		/**
		 * The current client setting for whether global illumination is used or not
		 * @type {boolean}
		 */
		this.globalLight = false;

		/**
		 * The coloration container which visualizes the effect of light sources
		 * @type {PIXI.Container}
		 */
		this.coloration = null;

		/**
		 * The illumination container which visualizes darkness and light
		 * @type {PIXI.Container}
		 */
		this.illumination = null;

		/**
		 * A flag for whether the darkness level is currently animating
		 * @type {boolean}
		 */
		this._animating = false;

		/**
		 * An array of light sources which are currently animated
		 * @type {PointSource[]}
		 */
		this._animatedSources = [];
	}

	/**
	 * A mapping of different light level channels
	 * @typedef {{hex: number, rgb: number[]}} LightChannel
	 * @type {{black: LightChannel, dark: LightChannel, dim: LightChannel, bright: LightChannel}}
	 */
	channels;

	/** @inheritdoc */
	static documentName = "AmbientLight";

	/** @inheritdoc */
	static get layerOptions() {
		return foundry.utils.mergeObject(super.layerOptions, {
			name: "lighting",
			rotatableObjects: true,
			quadtree: true,
			zIndex: 300
		});
	}

	/* -------------------------------------------- */

	/**
	 * Configure the lighting channels which are inputs to the ShadowMap
	 * @return {{black: object, dark: object, dim: object, bright: object}}
	 * @private
	 */
	_configureChannels(darkness=null) {
		this.version++;
		let {darknessColor, daylightColor, lightLevels, darknessLightPenalty} = CONFIG.Canvas;
		const {dark, dim, bright} = lightLevels;
		darkness = darkness ?? canvas.scene.data.darkness;
		const channels = { canvas: {}, background: {}, black: {}, bright: {}, dark: {}, dim: {} };

		// The canvas background is a blend between the Scene background color and the darkness level
		const darknessRGB = foundry.utils.hexToRGB(darknessColor);
		const sceneRGB = foundry.utils.hexToRGB(canvas.backgroundColor);
		channels.canvas.rgb = darknessRGB.map((c, i) => ((1-darkness) + (darkness*c)) *sceneRGB[i]);
		channels.canvas.hex = foundry.utils.rgbToHex(channels.canvas.rgb);

		// The background is based on the darkness color and the darkness level
		const daylightRGB = canvas.scene.data.tokenVision ? foundry.utils.hexToRGB(daylightColor) : [1.0, 1.0, 1.0];
		channels.background.rgb = darknessRGB.map((c, i) => (darkness * c) + ((1-darkness) * daylightRGB[i]));
		channels.background.hex = foundry.utils.rgbToHex(channels.background.rgb);

		// Magical darkness and blackness is based on the true darkness color
		channels.dark.rgb = darknessRGB.map(c => (1 + dark) * c);
		channels.dark.hex = foundry.utils.rgbToHex(channels.dark.rgb);
		channels.black.rgb = channels.dark.rgb.map(c => 0.5 * c);
		channels.black.hex = foundry.utils.rgbToHex(channels.black.rgb);

		// Bright light is penalized by the darkness level
		const penalty = 1 - (darknessLightPenalty * darkness);
		channels.bright.rgb = [1,1,1].map(c => bright * c * penalty);
		channels.bright.hex = foundry.utils.rgbToHex(channels.bright.rgb);

		// Dim light is halfway between darkness and bright
		channels.dim.rgb = channels.bright.rgb.map((c, i) => (dim * c) + ((1 - dim) * darknessRGB[i]));
		channels.dim.hex = foundry.utils.rgbToHex(channels.dim.rgb);
		return channels;
	}

	/* -------------------------------------------- */
	/*  Rendering
	/* -------------------------------------------- */

	/** @override */
	async draw() {
		await super.draw();

		// Configure the layer
		this.globalLight = canvas.scene.data.globalLight;

		// Create containers
		this.lighting = this.addChildAt(new PIXI.Container(), 0);
		this.illumination = this.lighting.addChild(this._drawIlluminationContainer());
		this.coloration = this.lighting.addChild(this._drawColorationContainer());

		// Draw the background
		const bgRect = canvas.dimensions.rect.clone().pad(CONFIG.Canvas.blurStrength * 2);
		this.illumination.background.clear().beginFill(0xFFFFFF, 1.0).drawShape(bgRect).endFill();

		// Activate animation
		this.activateAnimation();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the coloration container which is responsible for rendering the visible hue of a light source.
	 * Apply an additive blend to the entire container after each individual light source is blended via screen.
	 * @return {PIXI.Container}
	 * @private
	 */
	_drawColorationContainer() {
		const c = new PIXI.Container();
		c.filter = canvas.blurDistance ?
			new PIXI.filters.FXAAFilter() :
			new PIXI.filters.AlphaFilter(1.0);
		c.filter.blendMode = PIXI.BLEND_MODES.ADD;
		c.filters = [c.filter];
		c.sortableChildren = true;
		return c;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the illumination container which is responsible for displaying darkness and light.
	 * @return {PIXI.Container}
	 * @private
	 */
	_drawIlluminationContainer() {
		const c = new PIXI.Container();
		c.background = c.addChild(new PIXI.Graphics());
		c.lights = c.addChild(new PIXI.Container());
		c.lights.sortableChildren = true;
		c.filter = canvas.blurDistance ? canvas.createBlurFilter() : new PIXI.filters.AlphaFilter(1.0);
		c.filter.blendMode = PIXI.BLEND_MODES.MULTIPLY;
		c.filters = [c.filter];
		c.filterArea = canvas.app.renderer.screen;
		return c;
	}

	/* -------------------------------------------- */
	/*  Layer Methods                               */
	/* -------------------------------------------- */

	/**
	 * Does this scene currently benefit from global illumination?
	 * @returns {boolean}
	 */
	hasGlobalIllumination() {
		const sd = canvas.scene.data;
		return sd.globalLight && (!sd.globalLightThreshold || (this.darknessLevel <= sd.globalLightThreshold));
	}

	/* -------------------------------------------- */

	/**
	 * Initialize all AmbientLight sources which are present on this layer
	 */
	initializeSources() {
		this.darknessLevel = canvas.scene.data.darkness;
		this.sources.clear();
		for ( let light of this.placeables ) {
			light.updateSource({defer: true});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the active display of the LightingLayer.
	 * Update the scene background color, light sources, and darkness sources
	 * @param {number} [darkness]       An override darkness level to which the layer should be temporarily rendered
	 */
	refresh(darkness) {
		const priorLevel = this.darknessLevel;
		const darknessChanged = (darkness !== undefined) && (darkness !== priorLevel)
		this.darknessLevel = darkness = Math.clamped(darkness ?? this.darknessLevel, 0, 1);

		// Update lighting channels
		if ( darknessChanged || !this.channels ) this.channels = this._configureChannels(darkness);

		// Track global illumination
		let refreshVision = false;
		const globalLight = this.hasGlobalIllumination();
		if ( globalLight !== this.globalLight ) {
			this.globalLight = globalLight;
			canvas.perception.schedule({sight: {initialize: true, refresh: true}});
		}

		// Clear currently rendered sources
		const ilm = this.illumination;
		ilm.lights.removeChildren();
		const col = this.coloration;
		col.removeChildren();
		this._animatedSources = [];

		// Tint the background color
		canvas.app.renderer.backgroundColor = this.channels.canvas.hex;
		ilm.background.tint = this.channels.background.hex;

		// Render light sources
		for ( let sources of [this.sources, canvas.sight.sources] ) {
			for ( let source of sources ) {

				// Check the active state of the light source
				const isActive = darkness.between(source.darkness.min, source.darkness.max);
				if ( source.active !== isActive ) refreshVision = true;
				source.active = isActive;
				if ( !source.active ) continue;

				// Draw the light update
				const light = source.drawLight();
				if ( light ) ilm.lights.addChild(light);
				const color = source.drawColor();
				if ( color ) col.addChild(color);
				if ( source.animation?.type ) this._animatedSources.push(source);
			}
		}

		// Draw non-occluded roofs that block light
		const displayRoofs = canvas.foreground.displayRoofs;
		for ( let roof of canvas.foreground.roofs ) {
			if ( !displayRoofs || roof.occluded) continue;
			const si = roof.getRoofSprite();
			if ( !si ) continue;

			// Block illumination
			si.tint = this.channels.background.hex;
			this.illumination.lights.addChild(si)

			// Block coloration
			const sc = roof.getRoofSprite();
			sc.tint = 0x000000;
			this.coloration.addChild(sc);
		}

		// Refresh vision if necessary
		if ( refreshVision ) canvas.perception.schedule({sight: {refresh: true}});

		// Refresh audio if darkness changed
		if ( darknessChanged ) {
			this._onDarknessChange(darkness, priorLevel);
			canvas.sounds._onDarknessChange(darkness, priorLevel);
		}

		// Dispatch a hook that modules can use
		Hooks.callAll("lightingRefresh", this);
	}

	/* -------------------------------------------- */

	/** @override */
	async tearDown() {
		this.version = 0;
		this.channels = undefined;
		this.deactivateAnimation();
		return super.tearDown();
	}

	/* -------------------------------------------- */
	/*  Animation                                   */
	/* -------------------------------------------- */

	/**
	 * Activate light source animation for AmbientLight objects within this layer
	 */
	activateAnimation() {
		this.deactivateAnimation();
		if ( game.settings.get("core", "lightAnimation") === false ) return;
		this._animateTime = Date.now();
		canvas.app.ticker.add(this._animateSource, this);
	}

	/* -------------------------------------------- */

	/**
	 * Deactivate light source animation for AmbientLight objects within this layer
	 */
	deactivateAnimation() {
		canvas.app.ticker.remove(this._animateSource, this);
	}

	/* -------------------------------------------- */

	/**
	 * The ticker handler which manages animation delegation
	 * @param {number} dt   Delta time
	 * @private
	 */
	_animateSource(dt) {
		for ( let source of this._animatedSources ) {
			source.animate(dt);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Animate a smooth transition of the darkness overlay to a target value.
	 * Only begin animating if another animation is not already in progress.
	 * @param {number} target     The target darkness level between 0 and 1
	 * @param {number} duration   The desired animation time in milliseconds. Default is 10 seconds
	 * @return {Promise}          A Promise which resolves once the animation is complete
	 */
	async animateDarkness(target=1.0, {duration=10000}={}) {
		const animationName = "lighting.animateDarkness";
		CanvasAnimation.terminateAnimation(animationName);
		if ( target === this.darknessLevel ) return false;
		if ( duration <= 0 ) return this.refresh(target);

		// Prepare the animation data object
		this._animating = true;
		const animationData = [{
			parent: {darkness: this.darknessLevel},
			attribute: "darkness",
			to: Math.clamped(target, 0, 1)
		}];

		// Trigger the animation function
		return CanvasAnimation.animateLinear(animationData, {
			name: animationName,
			duration: duration,
			ontick: (dt, attributes) => {
				this.refresh(attributes[0].parent.darkness)
			}
		});
	}

	/* -------------------------------------------- */

	/**
	 * Actions to take when the darkness level of the Scene is changed
	 * @param {number} darkness   The new darkness level
	 * @param {number} prior      The prior darkness level
	 * @private
	 */
	_onDarknessChange(darkness, prior) {
		if ( !this._active ) return;
		for ( let light of this.placeables ) {
			light.refreshControl();
		}
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	async _onDragLeftStart(event) {
		await super._onDragLeftStart(event);
		const origin = event.data.origin;

		// Create the preview source
		const doc = new AmbientLightDocument({x: origin.x, y: origin.y, type: "l"}, {parent: canvas.scene});
		const preview = new AmbientLight(doc);
		event.data.preview = this.preview.addChild(preview);
		this.sources.set(preview.sourceId, preview.source);
		this.deactivateAnimation();
		return preview.draw();
	}

	/* -------------------------------------------- */

	/** @override */
	_onDragLeftMove(event) {
		const { destination, createState, preview, origin } = event.data;
		if ( createState === 0 ) return;

		// Update the light radius
		const radius = Math.hypot(destination.x - origin.x, destination.y - origin.y);

		// Update the preview object data
		preview.data.dim = radius * (canvas.dimensions.distance / canvas.dimensions.size);
		preview.data.bright = preview.data.dim / 2;
		preview.refresh();

		// Refresh the layer display
		preview.updateSource();

		// Confirm the creation state
		event.data.createState = 2;
	}

	/* -------------------------------------------- */

	/** @override */
	_onDragLeftCancel(event) {
		super._onDragLeftCancel(event);
		this.sources.delete("Light.preview");
		this.refresh();
		this.activateAnimation();
	}

	/* -------------------------------------------- */

	/** @override */
	_onMouseWheel(event) {

		// Identify the hovered light source
		const light = this._hover;
		if ( !light || (light.data.angle === 360) ) return;

		// Determine the incremental angle of rotation from event data
		let snap = event.shiftKey ? 15 : 3;
		let delta = snap * Math.sign(event.deltaY);
		return light.rotate(light.data.rotation + delta, snap);
	}
}

/**
 * A PlaceablesLayer designed for rendering the visual Scene for a specific vertical cross-section.
 * Each MapLayer contains a single background image as well as an arbitrary number of Tile objects.
 * @extends {PlaceablesLayer}
 */
class MapLayer extends PlaceablesLayer {
	constructor({bgPath, level=1}={}) {
		super();

		/**
		 * The numeric Scene level to which this layer belongs
		 * @type {number}
		 */
		this.level = level;

		/**
		 * The background source path
		 * @type {string}
		 */
		this.bgPath = bgPath;
	}

	/**
	 * The layer background image
	 * @type {PIXI.Sprite}
	 */
	bg;

	/** @inheritdoc */
	static documentName = "Tile";

	/* -------------------------------------------- */
	/*  Layer Attributes                            */
	/* -------------------------------------------- */

	/** @inheritdoc */
	static get layerOptions() {
		return foundry.utils.mergeObject(super.layerOptions, {
			name: "background",
			zIndex: 0,
			controllableObjects: true,
			rotatableObjects: true
		});
	}

	/* -------------------------------------------- */

	/**
	 * Return the base HTML image or video element which is used to generate the background Sprite.
	 * @type {HTMLImageElement|HTMLVideoElement}
	 */
	get bgSource() {
		if ( !this.bg || !this.bg.texture || !this.bg.texture.valid ) return null;
		const tex = this.bg.texture.baseTexture;
		return tex.resource.source;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get hud() {
		return canvas.hud.tile;
	}

	/* -------------------------------------------- */

	/**
	 * Is the background texture used in this layer a video?
	 * @type {boolean}
	 */
	get isVideo() {
		let source = this.bgSource;
		return ( source && source.tagName === "VIDEO" );
	}

	/* -------------------------------------------- */

	/**
	 * An array of Tile objects which are rendered within the objects container
	 * @type {Tile[]}
	 */
	get tiles() {
		return this.objects.children;
	}

	/* -------------------------------------------- */
	/*  Layer Methods                               */
	/* -------------------------------------------- */

	/** @inheritdoc */
	deactivate() {
		super.deactivate();
		this.objects.visible = true;
		return this;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async tearDown() {
		if ( this.isVideo ) this.bgSource.pause();
		this.bg = undefined;
		for ( let tile of this.tiles ) {
			if ( tile.isVideo ) {
				game.video.stop(tile.sourceElement);
			}
		}
		return super.tearDown();
	}

	/* -------------------------------------------- */
	/*  Layer Rendering                             */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async draw() {
		await super.draw();

		// Draw the background image or video
		this.bg = this._drawBackground();

		// Enable playback for video backgrounds
		if ( this.isVideo ) {
			this.bgSource.loop = true;
			this.bgSource.volume = game.settings.get("core", "globalAmbientVolume");
			game.video.play(this.bgSource);
		}
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the background Sprite for the layer, aligning its dimensions with those configured for the canvas.
	 * @returns {PIXI.Sprite}   The rendered Sprite, or undefined if no background is present
	 * @private
	 */
	_drawBackground() {

		// Get the background texture
		const tex = getTexture(this.bgPath);
		if ( !tex ) return undefined; // Require the texture to have already been loaded

		// Create the Sprite
		const d = canvas.dimensions;
		const bg = new PIXI.Sprite(tex);
		bg.position.set(d.paddingX - d.shiftX, d.paddingY - d.shiftY);
		bg.width = d.sceneWidth;
		bg.height = d.sceneHeight;

		// Add the Sprite to the container and return
		return this.addChildAt(bg, 0);
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async _onDragLeftStart(event) {
		await super._onDragLeftStart(event);
		const tile = this.constructor.placeableClass.createPreview(event.data.origin);
		event.data.preview = this.preview.addChild(tile);
		this.preview._creating = false;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftMove(event) {
		const { destination, createState, preview, origin, originalEvent } = event.data;
		if ( createState === 0 ) return;

		// Determine the drag distance
		const dx = destination.x - origin.x;
		const dy = destination.y - origin.y;
		const dist = Math.min(Math.abs(dx), Math.abs(dy));

		// Update the preview object
		preview.data.width = (originalEvent.altKey ? dist * Math.sign(dx) : dx);
		preview.data.height = (originalEvent.altKey ? dist * Math.sign(dy) : dy);
		if ( !originalEvent.shiftKey ) {
			const half = canvas.dimensions.size / 2;
			preview.data.width = preview.data.width.toNearest(half);
			preview.data.height = preview.data.height.toNearest(half);
		}
		preview.refresh();

		// Confirm the creation state
		event.data.createState = 2;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftDrop(event) {
		const { createState, preview } = event.data;
		if ( createState !== 2 ) return;

		// Re-normalize the dropped shape
		const r = new NormalizedRectangle(preview.data.x, preview.data.y, preview.data.width, preview.data.height);
		preview.data.update(r);

		// Require a minimum created size
		if ( Math.hypot(r.width, r.height) < (canvas.dimensions.size / 2) ) return;

		// Render the preview sheet for confirmation
		preview.sheet.render(true, {preview: true});
		this.preview._creating = true;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftCancel(event) {
		if ( this.preview._creating ) return;
		return super._onDragLeftCancel(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle drop events for Tile data on the Tiles Layer
	 * @param {DragEvent} event     The concluding drag event
	 * @param {object} data         The extracted Tile data
	 * @private
	 */
	async _onDropData(event, data) {
		if ( !data.img ) return;
		if ( !this._active ) this.activate();

		// Get the data for the tile to create
		const createData = await this._getDropData(event, data);

		// Validate that the drop position is in-bounds and snap to grid
		if ( !canvas.grid.hitArea.contains(createData.x, createData.y) ) return false;

		// Create the Tile Document
		const cls = getDocumentClass(this.constructor.documentName);
		return cls.create(createData, {parent: canvas.scene});
	}

	/* -------------------------------------------- */

	/**
	 * Prepare the data object when a new Tile is dropped onto the canvas
	 * @param {DragEvent} event     The concluding drag event
	 * @param {object} data         The extracted Tile data
	 * @returns {object}            The prepared data to create
	 */
	async _getDropData(event, data) {

		// Determine the tile size
		const tex = await loadTexture(data.img);
		const ratio = canvas.dimensions.size / (data.tileSize || canvas.dimensions.size);
		data.width = tex.baseTexture.width * ratio;
		data.height = tex.baseTexture.height * ratio;

		// Determine the final position and snap to grid unless SHIFT is pressed
		data.x = data.x - (data.width / 2);
		data.y = data.y - (data.height / 2);
		if ( !event.shiftKey ) {
			const {x, y} = canvas.grid.getSnappedPosition(data.x, data.y);
			data.x = x;
			data.y = y;
		}

		// Create the tile as hidden if the ALT key is pressed
		if ( event.altKey ) data.hidden = true;
		return data;
	}
}

/**
 * An extension of the MapLayer that displays underfoot in the background of the Scene.
 * @extends {MapLayer}
 */
class BackgroundLayer extends MapLayer {

	/**
	 * The outline of the scene
	 * @type {PIXI.Graphics}
	 */
	outline;

	/* -------------------------------------------- */
	/*  Layer Methods                               */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async draw() {
		await super.draw();
		this.outline = this._drawOutline();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw a background outline which emphasizes what portion of the canvas is playable space and what is buffer.
	 * @returns {PIXI.Graphics}
	 * @private
	 */
	_drawOutline() {
		const sd = canvas.scene.data;
		const displayCanvasBorder = sd.padding !== 0;
		const displaySceneOutline = !sd.img;
		if ( !(displayCanvasBorder || displaySceneOutline) ) return undefined;

		// Draw the outline
		const outline = new PIXI.Graphics();
		if ( displayCanvasBorder ) outline.lineStyle(8, 0x000000, 0.25).drawShape(canvas.dimensions.rect);
		if ( displaySceneOutline ) {
			outline.lineStyle(4, 0x000000, 0.25).beginFill(0xFFFFFF, 0.025).drawShape(canvas.dimensions.sceneRect).endFill();
		}
		return this.addChildAt(outline, 0);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getDocuments() {
		return this.documentCollection.filter(doc => !doc.data.overhead);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getZIndex() {
		return (this.level-1) * 1000;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	storeHistory(type, data) {
		const [bg, fg] = data.partition(d => d.overhead);
		if ( fg.length ) canvas.foreground.storeHistory(type, fg);
		if ( bg.length ) super.storeHistory(type, bg);
	}
}

/**
 * An extension of the MapLayer that displays overhead in the foreground of the Scene.
 * @extends {MapLayer}
 */
class ForegroundLayer extends MapLayer {

	/** @inheritdoc */
	static get layerOptions() {
		return foundry.utils.mergeObject(super.layerOptions, {
			name: "foreground"
		});
	}

	/* -------------------------------------------- */

	/**
	 * Get an array of overhead Tile objects which are roofs
	 * @returns {PIXI.DisplayObject[]}
	 */
	get roofs() {
		return this.placeables.filter(t => t.data.occlusion.mode === CONST.TILE_OCCLUSION_MODES.ROOF);
	}

	/* -------------------------------------------- */

	/**
	 * Determine whether to display roofs
	 * @type {boolean}
	 */
	get displayRoofs() {
		const restrictVision = canvas.sight.sources.size ||  !game.user.isGM;
		const mapLayerActive = canvas.foreground._active || canvas.background._active;
		return mapLayerActive || restrictVision;
	}

	/* -------------------------------------------- */
	/*  Layer Methods                               */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async draw() {

		// Create a CachedContainer with the overhead tile occlusion mask
		this.occlusionMask = this._drawOcclusionMask();

		// Construct layer contents
		await super.draw();
		this.addChildAt(this.occlusionMask, 0);

		// Warn about mismatched foreground size
		if ( this.bg && canvas.background.bg ) {
			const bgTex = canvas.background.bg.texture;
			const fgTex = this.bg.texture;
			if ((bgTex.width !== fgTex.width) || (bgTex.height !== fgTex.height)) {
				ui.notifications.warn("WARNING.ForegroundDimensionsMismatch", {localize: true});
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Draw the container used to cache the position of Token occlusion shapes to a RenderTexture
	 * @returns {CachedContainer}
	 * @private
	 */
	_drawOcclusionMask() {
		const c = new CachedContainer();
		c.roofs = c.addChild(new PIXI.Container());
		c.roofs.blendMode = PIXI.BLEND_MODES.MAX_COLOR;
		c.tokens = c.addChild(new PIXI.Graphics());
		c.tokens.blendMode = PIXI.BLEND_MODES.MAX_COLOR;
		if ( canvas.blurDistance ) c.filters = [canvas.createBlurFilter()];
		return c;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	deactivate() {
		super.deactivate();
		this.refresh();
		canvas.perception.schedule({lighting: {refresh: true}});
		return this;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async tearDown() {
		this.occlusionMask.destroy();
		return super.tearDown();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getZIndex() {
		return super.getZIndex() + 200;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getDocuments() {
		return this.documentCollection.filter(doc => doc.data.overhead);
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the display of tiles on the Foreground Layer depending on Token occlusion.
	 */
	refresh() {

		// Toggle the opacity of the container when the background tiles layer is active
		this.alpha = canvas.background._active ? 0.25 : 1.0;

		// Refresh the visibility of each tile based on current occlusion
		const displayRoofs = this.displayRoofs;
		for ( let t of this.tiles ) {
			if ( !t.tile ) continue;
			t.occlusionFilter.enabled = false; // Disable the occlusion filter, only enable it for RADIAL mode
			switch ( t.data.occlusion.mode ) {
				case CONST.TILE_OCCLUSION_MODES.NONE:
					t.tile.alpha = Math.min(t.data.hidden ? 0.5 : 1.0, t.data.alpha);
					break;
				case CONST.TILE_OCCLUSION_MODES.FADE:
				case CONST.TILE_OCCLUSION_MODES.ROOF:
					if (t.occluded) t.tile.alpha = t.data.occlusion.alpha;
					else if (!displayRoofs) t.tile.alpha = 0.25;
					else t.tile.alpha = Math.min(t.data.hidden ? 0.5 : 1.0, t.data.alpha);
					break;
				case CONST.TILE_OCCLUSION_MODES.RADIAL:
					t.occlusionFilter.uniforms.alphaOcclusion = t.data.occlusion.alpha;
					t.occlusionFilter.enabled = true;
					t.tile.alpha = displayRoofs ? 1.0 : 0.25;
					break;
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Update occlusion for all tiles on the foreground layer
	 */
	updateOcclusion() {
		const tokens = game.user.isGM ? canvas.tokens.controlled : canvas.tokens.ownedTokens;
		this._drawOcclusionShapes(tokens);
		this.occlusionMask.roofs.removeChildren();
		for ( let tile of this.tiles ) {
			tile.updateOcclusion(tokens);
			if ( tile.isRoof && (tile.occluded || !this.displayRoofs) ) {
				const s = tile.getRoofSprite();
				s.tint = 0x0000FF;
				this.occlusionMask.roofs.addChild(s);
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Draw the container which caches token-based occlusion shapes
	 * @param {Token[]} tokens      The set of currently observed tokens
	 * @private
	 */
	_drawOcclusionShapes(tokens) {
		if (!this.tiles.length) return;
		const g = this.occlusionMask.tokens;
		g.clear().beginFill(0x00FF00, 1.0); // Draw radial occlusion using the green channel
		for (let token of tokens) {
			const c = token.center;
			const r = Math.max(token.w, token.h);
			g.drawCircle(c.x, c.y, r); // TODO - don't drawCircle every time, just move an existing circle with setPosition
		}
		g.endFill();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _getDropData(event, data) {
		const toCreate = await super._getDropData(event, data);
		toCreate.overhead = true;
		return toCreate;
	}
}

/**
 * The Notes Layer which contains Note canvas objects
 * @extends {PlaceablesLayer}
 */
class NotesLayer extends PlaceablesLayer {

	/** @inheritdoc */
	static get layerOptions() {
		return foundry.utils.mergeObject(super.layerOptions, {
			name: "notes",
			canDragCreate: false,
			sortActiveTop: true,
			zIndex: 60
		});
	}

	/** @inheritdoc */
	static documentName = "Note";

	/**
	 * The named core setting which tracks the toggled visibility state of map notes
	 * @type {string}
	 */
	static TOGGLE_SETTING = "notesDisplayToggle";

	/* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */

	/** @inheritdoc */
	activate() {
		super.activate();
		if ( this.objects ) {
			this.placeables.forEach(p => p.controlIcon.visible = true);
		}
		return this;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	deactivate() {
		super.deactivate();
		const isToggled = game.settings.get("core", this.constructor.TOGGLE_SETTING);
		if ( this.objects ) {
			this.objects.visible = isToggled;
			this.placeables.forEach(p => p.controlIcon.visible = isToggled);
		}
		this.interactiveChildren = isToggled;
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Register game settings used by the NotesLayer
	 */
	static registerSettings() {
		game.settings.register("core", this.TOGGLE_SETTING, {
			name: "Map Note Toggle",
			scope: "client",
			type: Boolean,
			config: false,
			default: false
		});
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_onMouseDown(event) {}

	/* -------------------------------------------- */

	/**
	 * Handle JournalEntry entity drop data
	 * @param {DragEvent} event   The drag drop event
	 * @param {object} data       The dropped data transfer data
	 * @protected
	 */
	async _onDropData(event, data) {

		// Acquire Journal entry
		const entry = await JournalEntry.fromDropData(data);

		// Get the world-transformed drop position
		let t = this.worldTransform;
		const tx = (event.clientX - t.tx) / canvas.stage.scale.x;
		const ty = (event.clientY - t.ty) / canvas.stage.scale.y;
		const [x, y] = canvas.grid.getCenter(tx, ty);
		if ( !canvas.grid.hitArea.contains(x, y) ) return false;
		const noteData = {entryId: entry.data._id, x: x, y: y}

		// Create a NoteConfig sheet instance to finalize the creation
		const cls = getDocumentClass("Note")
		const document = new cls(noteData, {parent: canvas.scene});
		if ( !document.canUserModify(game.user, "create" ) ) {
			return ui.notifications.warn(game.i18n.format("NOTE.WarningNoCreate", {name: entry.name}));
		}

		// Create the preview object to complete creation
		const object = new Note(document);
		this.activate();
		this.preview.addChild(object);
		await object.draw();
		object.sheet.render(true, {
			top: event.clientY - 20,
			left: event.clientX + 40
		});
	}
}

/**
 * The Sight Layer which implements dynamic vision, lighting, and fog of war
 * This layer uses an event-driven workflow to perform the minimal required calculation in response to changes.
 * @see {PointSource}
 * @extends {CanvasLayer}
 *
 * The container structure of this layer is as follows:
 * sight: SightLayer              The SightLayer itself
 *   msk: PIXI.Graphics           A masking rectangle that restricts exploration to the scene background
 *   unexplored: PIXI.Graphics    An unexplored background that spans the entire scene canvas
 *   explored: PIXI.Container     The exploration container
 *      revealed: PIXI.Container  The container of areas which have been previously revealed
 *        saved: PIXI.Sprite      The saved FOW exploration texture from the database
 *        pending: PIXI.Container A container of pending exploration polygons that have not yet been saved
 *        roofs: PIXI.Container   A container of occluded roof sprites which should not be marked as explored
 *      current: PIXI.Container   The current vision container
 *        los: PIXI.Graphics      The current line-of-sight polygon
 *        fov: PIXI.Graphics      The current filed-of-view polygon
 *      msk: PIXI.Graphics        The masking rectangle that limits exploration to the Scene background
 *
 * @example <caption>The sightRefresh hook</caption>
 * Hooks.on("sightRefresh", layer => {});
 */
class SightLayer extends CanvasLayer {
	constructor() {
		super();

		/**
		 * The FogExploration document which applies to this canvas view
		 * @type {FogExploration|null}
		 */
		this.exploration = null;

		/**
		 * A Collection of vision sources which are currently active within the rendered Scene.
		 * @type {Collection<string,PointSource>}
		 */
		this.sources = new foundry.utils.Collection();

		/**
		 * The canonical line-of-sight polygon which defines current Token visibility.
		 * @type {PIXI.Graphics}
		 */
		this.los = new PIXI.Graphics();

		/**
		 * A status flag for whether the layer initialization workflow has succeeded
		 * @type {boolean}
		 * @private
		 */
		this._initialized = false;

		/**
		 * The downscaling resolution used for the saved fog texture
		 * @type {number}
		 */
		this._fogResolution = 1;

		/**
		 * A pool of fog of war exploration containers that can be recycled
		 * @type {PIXI.Container[]}
		 */
		this._visionPool = [];

		/**
		 * Track whether fog of war exploration has been updated and required saving
		 * @type {boolean}
		 * @private
		 */
		this._fogUpdated = false;

		/**
		 * Track the number of moves which have updated fog of war
		 * @type {number}
		 * @private
		 */
		this._fogUpdates = 0;

		/**
		 * A debounced function to save fog of war exploration once a stream of updates have stopped
		 * @type {Function}
		 */
		this.debounceSaveFog = foundry.utils.debounce(this.saveFog.bind(this), 1000);
	}

	/**
	 * Define the threshold value for the number of distinct Wall endpoints.
	 * Below this threshold, exact vision computation is used by casting a Ray at every endpoint.
	 * Above this threshold, approximate vision computation is used by culling to only nearby endpoints.
	 * @type {number}
	 */
	static EXACT_VISION_THRESHOLD = 200;

	/**
	 * Define the number of positions that are explored before a set of fog updates are pushed to the server.
	 * @type {number}
	 */
	static FOG_COMMIT_THRESHOLD = 10;

	/* -------------------------------------------- */

	/** @override */
	static get layerOptions() {
		return foundry.utils.mergeObject(super.layerOptions, {
			name: "sight",
			zIndex: 400
		});
	}

	/* -------------------------------------------- */

	/**
	 * Does the currently viewed Scene support Token field of vision?
	 * @type {boolean}
	 */
	get tokenVision() {
		return canvas.scene.data.tokenVision;
	}

	/* -------------------------------------------- */

	/**
	 * Does the currently viewed Scene support fog of war exploration?
	 * @type {boolean}
	 */
	get fogExploration() {
		return canvas.scene.data.fogExploration;
	}

	/* -------------------------------------------- */
	/*  Layer Initialization                        */
	/* -------------------------------------------- */

	/** @override */
	async tearDown() {
		const wasDeleted = !game.scenes.has(canvas.scene?.id);
		if ( (this._fogUpdates || this._fogUpdated) && !wasDeleted ) {
			await this.saveFog();
		}
		this.exploration = null;
		this.sources.clear();
		this._initialized = false;
		return super.tearDown();
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the Sight Layer. Initialization has the following hierarchical workflow:
	 *
	 * Initialize Layer (reset entire layer)
	 *  InitializeLights (used to reset all lights)
	 *    UpdateLight (update a single light)
	 *  InitializeTokens (reset all tokens)
	 *    UpdateToken (update a single token)
	 *  Initialize Fog (reset FOW state)
	 */
	async initialize() {
		this._initialized = false;

		// If there are pending fog updates, save them first
		if ( this._fogUpdates || this._fogUpdated ) await this.saveFog();

		// Initialize Fog
		await this.initializeFog();

		// If Token vision is not used in this Scene, we can simply hide the layer
		this.visible = this.tokenVision;
		this._initialized = true;
	}

	/* -------------------------------------------- */

	/**
	 * Initialize fog of war - resetting it when switching scenes or re-drawing the canvas
	 * @return {Promise<void>}
	 */
	async initializeFog() {
		if ( !this.tokenVision ) return;
		if ( !this.exploration ) await this.loadFog();
	}

	/* -------------------------------------------- */

	/**
	 * Initialize all Token sight sources which are present on this layer
	 */
	initializeSources() {
		this.sources.clear();
		for ( let token of canvas.tokens.placeables ) {
			token.updateSource({defer: true});
		}
	}

	/* -------------------------------------------- */
	/*  Layer Rendering                             */
	/* -------------------------------------------- */

	/** @override */
	async draw() {
		await super.draw();
		this.removeChildren();

		// Internal stored variables
		this._fogResolution = this._configureFogResolution();
		const d = canvas.dimensions;

		// Unexplored area is obscured by darkness. We need a larger rectangle so that the blur filter doesn't clip
		this.unexplored = this.addChild(new PIXI.Graphics());
		const r = d.rect.clone().pad(CONFIG.Canvas.blurStrength+2);
		this.unexplored.beginFill(0xFFFFFF, 1.0).drawShape(r).endFill();

		// Exploration container
		this.explored = this.addChild(new PIXI.Container());
		if ( canvas.scene.data.padding !== 0 ) {
			this.explored.msk = this.addChild(new PIXI.Graphics());
			this.explored.msk.beginFill(0xFFFFFF, 1.0).drawShape(canvas.dimensions.sceneRect).endFill();
		} else this.explored.msk = null;
		this.explored.mask = this.explored.msk;

		// Past exploration updates
		this.revealed = this.explored.addChild(new PIXI.Container());
		this.saved = this.revealed.addChild(new PIXI.Sprite());
		this.saved.position.set(d.paddingX, d.paddingY);
		this.saved.width = d.sceneWidth;
		this.saved.height = d.sceneHeight;

		// Pending exploration containers
		this.pending = this.revealed.addChild(new PIXI.Container());

		// The current vision container
		this.current = this.explored.addChild(this._createVisionContainer());

		// Apply a multiply blend filter to the fog container
		this.filter = canvas.blurDistance ? canvas.createBlurFilter() : new PIXI.filters.AlphaFilter(1.0);
		this.filter.blendMode = PIXI.BLEND_MODES.MULTIPLY;
		this.filter.autoFit = false;
		this.filters = [this.filter];
		this.filterArea = canvas.app.screen;

		// Return the layer
		this.visible = false;
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Construct a vision container that is used to render a single view position.
	 * These containers are placed into the _visionPool and recycled as needed.
	 * @return {PIXI.Container}
	 * @private
	 */
	_createVisionContainer() {
		const c = new PIXI.Container();
		c.fov = c.addChild(new PIXI.Graphics());
		c.los = c.addChild(new PIXI.Graphics());
		c.mask = c.los;
		c._explored = false;
		return c;
	}

	/* -------------------------------------------- */

	/**
	 * Obtain a vision container from the recycling pool, or create one if no container exists.
	 * Assign the container as the current fog exploration and the current LOS polygon.
	 * @return {PIXI.Container}
	 * @private
	 */
	_getVisionContainer() {
		const c = this._visionPool.length ? this._visionPool.pop() : this._createVisionContainer();
		this.current = this.explored.addChild(c);
		this.los = c.los;
		return c;
	}

	/* -------------------------------------------- */

	/**
	 * Return a vision container back to the pool, recycling it for future use.
	 * @param {PIXI.Container} c    The container to recycle
	 * @private
	 */
	_recycleVisionContainer(c) {
		c.los.clear();
		c.fov.clear();
		if ( c.roofs ) c.removeChild(c.roofs);
		c.fov.tint = 0xFFFFFF;
		c._explored = false;
		this._visionPool.push(c);
	}

	/* -------------------------------------------- */

	/**
	 * Update the display of the sight layer.
	 * Organize sources into rendering queues and draw lighting containers for each source
	 *
	 * @param {boolean} [forceUpdateFog]  Always update the Fog exploration progress for this update
	 * @param {boolean} [noUpdateFog]     Never update the Fog exploration progress for this update
	 */
	refresh({forceUpdateFog=false, noUpdateFog=false}={}) {
		if ( !this._initialized ) return;
		if ( !this.tokenVision ) {
			this.visible = false;
			return this.restrictVisibility()
		}

		// Configuration variables
		const d = canvas.dimensions;
		const exc = CONFIG.Canvas.exploredColor;

		// Recycle the current vision, either adding it to pending fog or returning it to the pool
		const prior = this.explored.removeChild(this.current);
		if ( prior._explored ) {
			prior.fov.tint = exc
			this.pending.addChild(prior);
		}
		else this._recycleVisionContainer(prior);

		// Obtain a new vision container from the rotating pool
		const vision = this._getVisionContainer();

		// Draw standard vision sources
		let inBuffer = canvas.scene.data.padding === 0;
		for ( let source of this.sources ) {
			source.active = true;
			if ( !inBuffer && !d.sceneRect.contains(source.x, source.y) ) inBuffer = true;

			// Global illumination, everything in LOS is visible
			if ( canvas.lighting.globalLight ) {
				vision.fov.beginFill(0xFFFFFF, 1.0).drawShape(d.rect).endFill();
			}

			// Sight-based visibility
			else {
				vision.fov.beginFill(exc, 1.0).drawCircle(source.x, source.y, d.size / 2);
				if ( source.radius > 0 ) vision.fov.beginFill(0xFFFFFF, 1.0).drawPolygon(source.fov).endFill();
			}

			// Mask with LOS polygon
			vision.los.beginFill(0xFFFFFF, 1.0).drawPolygon(source.los).endFill();
			if (!noUpdateFog) this.updateFog(source, forceUpdateFog);
		}

		// Draw global or universal light sources
		for ( let source of canvas.lighting.sources ) {
			if ( !this.sources.size || !source.active ) continue;
			vision.fov.beginFill(0xFFFFFF, 1.0).drawPolygon(source.fov).endFill();
			if ( (source.type === CONST.SOURCE_TYPES.LOCAL) || source.isDarkness ) continue;
			vision.los.beginFill(0xFFFFFF, 1.0).drawPolygon(source.fov).endFill();
		}

		// Asynchronously commit pending fog exploration if enough positions have been explored
		if ( this._fogUpdates >= SightLayer.FOG_COMMIT_THRESHOLD ) this.commitFog();

		// Alter visibility of the vision layer
		this.visible = this.sources.size || !game.user.isGM;
		this.unexplored.tint = CONFIG.Canvas.unexploredColor;

		// Apply a mask to the exploration container
		if ( this.explored.msk ) {
			const noMask = this.sources.size && inBuffer;
			this.explored.mask = noMask ? null : this.explored.msk;
			this.explored.msk.visible = !noMask;
		}

		// Alter visibility of the lighting layer
		canvas.lighting.illumination.lights.mask = this.visible ? this.los : null;
		canvas.lighting.coloration.mask = this.visible ? this.los : null;

		// Restrict the visibility of other canvas objects
		this.restrictVisibility();

		// Log debug status
		if ( CONFIG.debug.sight ) {
			const perf = SightLayer._performance;
			let ns = Math.round((performance.now() - perf.start) * 100) / 100;
			console.log(`Rendered Sight Layer update | ${ns}ms | ${perf.rays} rays | ${perf.tests} tests`);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Restrict the visibility of certain canvas assets (like Tokens or DoorControls) based on the visibility polygon
	 * These assets should only be displayed if they are visible given the current player's field of view
	 */
	restrictVisibility() {

		// Tokens
		for ( let t of canvas.tokens.placeables ) {
			t.visible = ( !this.tokenVision && !t.data.hidden ) || t.isVisible;
		}

		// Door Icons
		for ( let d of canvas.controls.doors.children ) {
			d.visible = !this.tokenVision || d.isVisible;
		}

		// Dispatch a hook that modules can use
		Hooks.callAll("sightRefresh", this);
	}

	/* -------------------------------------------- */

	/**
	 * Test whether a point on the Canvas is visible based on the current vision and LOS polygons
	 *
	 * @param {Point} point           The point in space to test, an object with coordinates x and y.
	 * @param {number} tolerance      A numeric radial offset which allows for a non-exact match. For example, if
	 *                                tolerance is 2 then the test will pass if the point is within 2px of a vision
	 *                                polygon.
	 * @param {PIXI.DisplayObject} [object]   An optional reference to the object whose visibility is being tested
	 *
	 * @return {boolean}              Whether the point is currently visible.
	 */
	testVisibility(point, {tolerance=2, object=null}={}) {
		const visionSources = this.sources;
		const lightSources = canvas.lighting.sources;
		if ( !visionSources.size ) return game.user.isGM;

		// Determine the array of offset points to test
		const t = tolerance;
		const offsets = t > 0 ? [[0, 0],[-t,0],[t,0],[0,-t],[0,t],[-t,-t],[-t,t],[t,t],[t,-t]] : [[0,0]];
		const points = offsets.map(o => new PIXI.Point(point.x + o[0], point.y + o[1]));

		// Test that a point falls inside a line-of-sight polygon
		let inLOS = false;
		for ( let source of visionSources.values() ) {
			if ( points.some(p => source.los.contains(p.x, p.y) ) ) {
				inLOS = true;
				break;
			}
		}
		if ( !inLOS ) return false;

		// If global illumination is active, nothing more is required
		if ( canvas.lighting.globalLight ) return true;

		// Test that a point is also within some field-of-vision polygon
		for ( let source of visionSources.values() ) {
			if ( points.some(p => source.fov.contains(p.x, p.y)) ) return true;
		}
		for ( let source of lightSources.values() ) {
			if ( points.some(p => source.fov.contains(p.x, p.y)) ) return true;
		}
		return false;
	}

	/* -------------------------------------------- */
	/*  Fog of War Management                       */
	/* -------------------------------------------- */

	/**
	 * Once a new Fog of War location is explored, composite the explored container with the current staging sprite
	 * Save that staging Sprite as the rendered fog exploration and swap it out for a fresh staging texture
	 * Do all this asynchronously, so it doesn't block token movement animation since this takes some extra time
	 */
	commitFog() {
		if ( CONFIG.debug.fog ) console.debug("SightLayer | Committing fog exploration to render texture.");
		const r = this.revealed;
		this._fogUpdates = 0;

		// Protect against an invalid render texture
		if ( !this.saved.texture.valid ) {
			this.saved.texture = PIXI.Texture.EMPTY;
		}

		// Create a staging texture and render the entire fog container to it
		const d = canvas.dimensions;
		const tex = PIXI.RenderTexture.create({
			width: d.sceneWidth,
			height: d.sceneHeight,
			resolution: this._fogResolution
		});
		const transform = new PIXI.Matrix(1, 0, 0, 1, -d.paddingX, -d.paddingY);

		// Render the texture (temporarily disabling the masking rectangle)
		canvas.app.renderer.render(r, tex, undefined, transform);

		// Swap the staging texture to the rendered Sprite
		this.saved.texture.destroy(true);
		this.saved.texture = tex;
		this.pending.removeChildren().forEach(c => this._recycleVisionContainer(c));

		// Record that fog was updated and schedule a save
		this._fogUpdated = true;
		this.debounceSaveFog();
	}

	/* -------------------------------------------- */

	/**
	 * Load existing fog of war data from local storage and populate the initial exploration sprite
	 * @return {Promise<(PIXI.Texture|void)>}
	 */
	async loadFog() {
		if ( CONFIG.debug.fog ) console.debug("SightLayer | Loading saved FogExploration for Scene.");

		// Remove the previous render texture if one exists
		if ( this.saved.texture.valid ) {
			this.saved.texture.destroy(true);
		}

		// Take no further action if vision or fog is not used
		if ( !this.tokenVision || !this.fogExploration ) return;

		// Load existing FOW exploration data or create a new placeholder
		this.exploration = await FogExploration.get();
		if ( !this.exploration ) this.exploration = new FogExploration();

		// Extract the fog data image
		let render = tex => this.saved.texture = tex;
		return await new Promise(resolve => {
			let tex = this.exploration.getTexture();
			if ( tex === null ) {
				render(PIXI.Texture.EMPTY);
				return resolve(PIXI.Texture.EMPTY)
			}
			if ( tex.baseTexture.valid ) {
				render(tex);
				return resolve(tex);
			}
			else tex.on("update", tex => {
				render(tex);
				resolve(tex);
			});
		});
	}

	/* -------------------------------------------- */

	/**
	 * Dispatch a request to reset the fog of war exploration status for all users within this Scene.
	 * Once the server has deleted existing FogExploration documents, the _onResetFog handler will re-draw the canvas.
	 */
	async resetFog() {
		if ( CONFIG.debug.fog ) console.debug("SightLayer | Resetting fog of war exploration for Scene.");
		game.socket.emit("resetFog", canvas.scene.id, FogExploration._onResetFog);
	}

	/* -------------------------------------------- */

	/**
	 * Save Fog of War exploration data to a base64 string to the FogExploration document in the database.
	 * Assumes that the fog exploration has already been rendered as fog.rendered.texture.
	 */
	async saveFog() {
		if ( !this.tokenVision || !this.fogExploration || !this.exploration ) return;

		// If there are pending fog updates, we need to first commit them
		if (this._fogUpdates) this.commitFog();
		if (!this._fogUpdated) return;
		this._fogUpdated = false;
		if (CONFIG.debug.fog) console.debug("SightLayer | Saving exploration progress to FogExploration document.");

		// Use the existing rendered fog to create a Sprite and downsize to save with smaller footprint
		const d = canvas.dimensions;
		const fog = new PIXI.Sprite(this.saved.texture);
		let scl = d.width > 1920 ? 1920 / d.width : 1.0;
		fog.scale.set(scl, scl);

		// Add the fog to a temporary container to bound it's dimensions and export to base data
		const stage = new PIXI.Container();
		stage.addChild(fog);

		// Create or update fog exploration
		const updateData = {explored: canvas.app.renderer.extract.base64(stage), timestamp: Date.now()}
		if (!this.exploration.id) {
			this.exploration.data.update(updateData);
			this.exploration = await this.exploration.constructor.create(this.exploration.toJSON());
		} else await this.exploration.update(updateData)
	}

	/* -------------------------------------------- */

	/**
	 * Update the fog layer when a player token reaches a board position which was not previously explored
	 * @param {PointSource} source   The vision source for which the fog layer should update
	 * @param {boolean} force             Force fog to be updated even if the location is already explored
	 */
	updateFog(source, force=false) {
		if ( !this.fogExploration || !this.exploration ) return;
		const explored = this.exploration.explore(source, force);
		if ( explored ) {
			this.current._explored = true;
			this._fogUpdates++;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Choose an adaptive fog rendering resolution which downscales the saved fog textures for larger dimension Scenes
	 * @return {number}
	 * @private
	 */
	_configureFogResolution() {
		const d = canvas.dimensions;
		const pixels = d.sceneWidth * d.sceneHeight;
		if (pixels > (16000**2)) return 0.25;
		else if (pixels > (8000**2)) return 0.5;
		else return 1.0;
	}

	/* -------------------------------------------- */

	/**
	 * If fog of war data is reset from the server, re-draw the canvas
	 * @return {Promise}
	 */
	async _handleResetFog() {
		ui.notifications.info(`Fog of War exploration progress was reset for this Scene`);
		this._fogUpdated = false;
		this._fogUpdates = 0;
		await canvas.draw();
	}

	/* -------------------------------------------- */
	/*  Helper Functions                            */
	/* -------------------------------------------- */

	/**
	 * Visualize the sight layer to understand algorithm performance.
	 * @param {Rectangle} bounds        The initial rectangular bounds of the vision check
	 * @param {PointArray[]} endpoints  The wall endpoints being tested
	 * @param {Ray[]} rays              The array of cast vision Rays
	 * @param {PIXI.Polygon} los        The resulting line-of-sight polygon
	 * @param {PIXI.Polygon} fov        The resulting field-of-vision polygon
	 */
	_visualizeSight(bounds, endpoints, rays, los, fov) {
		const debug = canvas.controls.debug;
		debug.clear();

		// Relevant polygons
		if ( bounds ) debug.lineStyle(0).beginFill(0x66FFFF, 0.1).drawShape(bounds);
		debug.beginFill(0x66FFFF, 0.1).drawShape(los);
		debug.beginFill(0xFF66FF, 0.1).drawShape(fov).endFill();

		// Tested endpoints
		endpoints.forEach(pt => debug.beginFill(0x00FFFF, 1.0).drawCircle(pt[0], pt[1], 6));

		// Cast rays
		for ( let r of rays ) {
			debug.lineStyle(1, 0x00FF00).moveTo(r.A.x, r.A.y).lineTo(r.los.x, r.los.y)
				.lineStyle(2, 0xFF0000).drawCircle(r.fov.x, r.fov.y, 4).drawCircle(r.los.x, r.los.y, 4);
		}
	}

	/* -------------------------------------------- */
	/*  Deprecations                                */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.2
	 * @see WallsLayer#computePolygon
	 * @ignore
	 */
	static computeSight(origin, radius, {angle=360, density=6, rotation=0, unrestricted=false}={}) {
		console.warn(`SightLayer.computeSight is deprecated in favor of WallsLayer#computePolygon and should no longer be used`);
		return canvas.walls.computePolygon(origin, radius, {type: "sight", angle, density, rotation, unrestricted});
	}
}

/**
 * This Canvas Layer provides a container for AmbientSound objects.
 * @extends {PlaceablesLayer}
 * @see {@link AmbientSound}
 */
class SoundsLayer extends PlaceablesLayer {

	/**
	 * Track whether to actively preview ambient sounds with mouse cursor movements
	 * @type {boolean}
	 */
	livePreview = false;

	/* -------------------------------------------- */

	/** @inheritdoc */
	static get layerOptions() {
		return foundry.utils.mergeObject(super.layerOptions, {
			name: "sounds",
			zIndex: 300
		});
	}

	/** @inheritdoc */
	static documentName = "AmbientSound";

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async tearDown() {
		this.stopAll();
		return super.tearDown();
	}

	/* -------------------------------------------- */

	/**
	 * Initialize all AmbientSound sources which are present on this layer
	 */
	initializeSources() {
		for ( let sound of this.placeables ) {
			sound.updateSource({defer: true});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Update all AmbientSound effects in the layer by toggling their playback status.
	 * Sync audio for the positions of tokens which are capable of hearing.
	 * @param {object} [options={}]   Additional options forwarded to AmbientSound synchronization
	 */
	refresh(options={}) {
		if ( !this.placeables.length ) return;
		if ( game.audio.locked ) {
			return game.audio.pending.push(() => this.refresh(options));
		}
		const tokens = game.user.isGM ? canvas.tokens.controlled : canvas.tokens.ownedTokens;
		const listeners = tokens.map(t => t.center);
		this._syncPositions(listeners, options);
	}

	/* -------------------------------------------- */

	/**
	 * Preview ambient audio for a given mouse cursor position
	 * @param {Point} position      The cursor position to preview
	 */
	previewSound(position) {
		if ( !this.placeables.length || game.audio.locked ) return;
		return this._syncPositions([position], {fade: 50});
	}

	/* -------------------------------------------- */

	/**
	 * Terminate playback of all ambient audio sources
	 */
	stopAll() {
		this.placeables.forEach(s => s.sync(false));
	}

	/* -------------------------------------------- */

	/**
	 * Sync the playing state and volume of all AmbientSound objects based on the position of listener points
	 * @param {Point[]} listeners     Locations of listeners which have the capability to hear
	 * @param {object} [options={}]   Additional options forwarded to AmbientSound synchronization
	 * @private
	 */
	_syncPositions(listeners, options) {
		if ( !this.placeables.length || game.audio.locked ) return;
		const sounds = {};
		for ( let sound of this.placeables ) {
			const p = sound.data.path;
			const r = sound.radius;
			if ( !p ) continue;

			// Track one audible object per unique sound path
			if ( !(p in sounds) ) sounds[p] = {path: p, audible: false, volume: 0, sound};
			const s = sounds[p];
			if ( !sound.isAudible ) continue; // The sound may not be currently audible

			// Determine whether the sound is audible, and its greatest audible volume
			for ( let l of listeners ) {
				if ( !sound.fov.contains(l.x, l.y) ) continue;
				s.audible = true;
				const distance = Math.hypot(l.x - sound.x, l.y - sound.y);
				let volume = sound.data.volume;
				if ( sound.data.easing ) volume *= this._getEasingVolume(distance, r);
				if ( !s.volume || (volume > s.volume) ) s.volume = volume;
			}
		}

		// For each audible sound, sync at the target volume
		for ( let s of Object.values(sounds) ) {
			s.sound.sync(s.audible, s.volume, options)
		}
	}

	/* -------------------------------------------- */

	/**
	 * Define the easing function used to map radial distance to volume.
	 * Uses cosine easing which graduates from volume 1 at distance 0 to volume 0 at distance 1
	 * @returns {number}            The target volume level
	 * @private
	 */
	_getEasingVolume(distance, radius) {
		const x = Math.clamped(distance, 0, radius) / radius;
		return (Math.cos(Math.PI * x) + 1) * 0.5;
	}

	/* -------------------------------------------- */

	/**
	 * Actions to take when the darkness level of the Scene is changed
	 * @param {number} darkness   The new darkness level
	 * @param {number} prior      The prior darkness level
	 * @private
	 */
	_onDarknessChange(darkness, prior) {
		this.refresh();
		if ( !this._active ) return;
		for ( let sound of this.placeables ) {
			sound.refreshControl();
		}
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Handle mouse cursor movements which may cause ambient audio previews to occur
	 * @param {PIXI.InteractionEvent} event     The initiating mouse move interaction event
	 */
	_onMouseMove(event) {
		if ( !this.livePreview ) return;
		if ( canvas.tokens._active && canvas.tokens.controlled.length )  return;
		const position = event.data.getLocalPosition(this);
		this.previewSound(position);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _onDragLeftStart(event) {
		await super._onDragLeftStart(event);
		const origin = event.data.origin;
		const doc = new AmbientSoundDocument({x: origin.x, y: origin.y, type: "l"}, {parent: canvas.scene});
		const sound = new AmbientSound(doc);
		event.data.preview = this.preview.addChild(sound);
		this.preview._creating = false;
		return sound.draw();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftMove(event) {
		const { destination, createState, preview, origin } = event.data;
		if ( createState === 0 ) return;
		const d = canvas.dimensions;
		const radius = Math.hypot(destination.x - origin.x, destination.y - origin.y);
		preview.data.radius = radius * (d.distance / d.size);
		preview.updateSource();
		preview.refresh();
		event.data.createState = 2;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _onDragLeftDrop(event) {
		const { createState, destination, origin, preview } = event.data;
		if ( createState !== 2 ) return;

		// Render the preview sheet for confirmation
		const radius = Math.hypot(destination.x - origin.x, destination.y - origin.y);
		if ( radius < (canvas.dimensions.size / 2) ) return;

		// Clean the data and render the creation sheet
		preview.data.update({
			x: Math.round(preview.data.x),
			y: Math.round(preview.data.y),
			radius: Math.floor(preview.data.radius * 100) / 100
		})
		preview.sheet.render(true);
		this.preview._creating = true;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftCancel(event) {
		if ( this.preview._creating ) return;
		return super._onDragLeftCancel(event);
	}

	/* -------------------------------------------- */
	/*  DEPRECATIONS                                */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.2
	 * @ignore
	 */
	update(options) {
		console.warn("SoundsLayer#update has been renamed to SoundsLayer#refresh to be consistent with other canvas layers");
		return this.refresh(options);
	}
}

/**
 * This Canvas Layer provides a container for MeasuredTemplate objects.
 * @extends {PlaceablesLayer}
 * @see {@link MeasuredTemplate}
 */
class TemplateLayer extends PlaceablesLayer {

	/** @inheritdoc */
	static get layerOptions() {
		return foundry.utils.mergeObject(super.layerOptions, {
			name: "templates",
			canDragCreate: true,
			rotatableObjects: true,
			sortActiveTop: true,
			zIndex: 50
		});
	}

	/** @inheritdoc */
	static documentName = "MeasuredTemplate";

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/** @inheritdoc */
	activate() {
		super.activate();
		if ( this.objects ) {
			this.placeables.forEach(p => {
				try {
					p.controlIcon.visible = true;
					p.ruler.visible = true;
				} catch(err) {
					console.error(err);
				}
			});
		}
		return this;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	deactivate() {
		super.deactivate();
		if ( this.objects ) {
			this.objects.visible = true;
			this.placeables.forEach(p => {
				try {
					p.controlIcon.visible = false;
					p.ruler.visible = false;
				} catch(err) {
					console.error(err);
				}
			});
		}
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Register game settings used by the TemplatesLayer
	 */
	static registerSettings() {
		game.settings.register("core", "coneTemplateType", {
			name: "TEMPLATE.ConeTypeSetting",
			hint: "TEMPLATE.ConeTypeSettingHint",
			scope: "world",
			config: true,
			default: "round",
			type: String,
			choices: {
				"flat": "TEMPLATE.ConeTypeFlat",
				"round": "TEMPLATE.ConeTypeRound"
			},
			onChange: () => canvas.templates?.placeables.filter(t => t.data.t === "cone").forEach(t => t.draw())
		});
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async _onDragLeftStart(event) {
		await super._onDragLeftStart(event);

		// Create the new preview template
		const tool = game.activeTool;
		const origin = event.data.origin;

		// Create the template
		const data = {
			user: game.user.id,
			t: tool,
			x: origin.x,
			y: origin.y,
			distance: 1,
			direction: 0,
			fillColor: game.user.data.color || "#FF0000"
		};

		// Apply some type-specific defaults
		const defaults = CONFIG.MeasuredTemplate.defaults;
		if ( tool === "cone") data["angle"] = defaults.angle;
		else if ( tool === "ray" ) data["width"] = (defaults.width * canvas.dimensions.distance);

		// Create a preview template
		const doc = new MeasuredTemplateDocument(data, {parent: canvas.scene});
		const template = new MeasuredTemplate(doc);
		event.data.preview = this.preview.addChild(template);
		return template.draw();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftMove(event) {
		const { destination, createState, preview, origin } = event.data;
		if ( createState === 0 ) return;

		// Snap the destination to the grid
		event.data.destination = canvas.grid.getSnappedPosition(destination.x, destination.y, this.gridPrecision);

		// Compute the ray
		const ray = new Ray(origin, destination);
		const ratio = (canvas.dimensions.size / canvas.dimensions.distance);

		// Update the preview object
		preview.data.direction = Math.normalizeDegrees(Math.toDegrees(ray.angle));
		preview.data.distance = ray.distance / ratio;
		preview.refresh();

		// Confirm the creation state
		event.data.createState = 2;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onMouseWheel(event) {

		// Determine whether we have a hovered template?
		const template = this._hover;
		if ( !template ) return;

		// Determine the incremental angle of rotation from event data
		let snap = event.shiftKey ? 15 : 5;
		let delta = snap * Math.sign(event.deltaY);
		return template.rotate(template.data.direction + delta, snap);
	}
}

/**
 * The Tokens Container
 * @type {PlaceablesLayer}
 */
class TokenLayer extends PlaceablesLayer {
	constructor() {
		super();

		/**
		 * The current index position in the tab cycle
		 * @type {number|null}
		 * @private
		 */
		this._tabIndex = null;

		/**
		 * Remember the last drawn wildcard token image to avoid repetitions
		 * @type {string}
		 */
		this._lastWildcard = null;
	}


	/* -------------------------------------------- */

	/** @inheritdoc */
	static get layerOptions() {
		return foundry.utils.mergeObject(super.layerOptions, {
			name: "tokens",
			canDragCreate: false,
			controllableObjects: true,
			rotatableObjects: true,
			zIndex: 100
		});
	}

	/** @inheritdoc */
	static documentName = "Token";

	/* -------------------------------------------- */

	/** @inheritdoc */
	get gridPrecision() {
		return 1; // Snap tokens to top-left
	}

	/* -------------------------------------------- */
	/*  Properties
	/* -------------------------------------------- */

	/**
	 * Token objects on this layer utilize the TokenHUD
	 */
	get hud() {
		return canvas.hud.token;
	}

	/**
	 * An Array of tokens which belong to actors which are owned
	 * @type {Token[]}
	 */
	get ownedTokens() {
		return this.placeables.filter(t => t.actor && t.actor.isOwner);
	}

	/* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */

	/** @override */
	async tearDown() {

		// Conclude token animation
		this.concludeAnimation();

		// Reset the synthetic token collection
		game.actors.tokens = {};

		// Release tokens and destroy the layer
		return super.tearDown();
	}

	/* -------------------------------------------- */

	/** @override */
	activate() {
		super.activate();
		if ( canvas.controls ) canvas.controls.doors.visible = true;
		this._tabIndex = null;
		return this;
	}

	/* -------------------------------------------- */

	/** @override */
	deactivate() {
		super.deactivate();
		if ( this.objects ) this.objects.visible = true;
		if ( canvas.controls ) canvas.controls.doors.visible = false;
		return this;
	}

	/* -------------------------------------------- */

	/** @override */
	selectObjects({x, y, width, height, releaseOptions={}, controlOptions={}}={}) {
		controlOptions.releaseOthers = false;
		return super.selectObjects({x, y, width, height, releaseOptions, controlOptions});
	}

	/* -------------------------------------------- */

	/**
	 * Target all Token instances which fall within a coordinate rectangle.
	 *
	 * @param {number} x                The top-left x-coordinate of the selection rectangle
	 * @param {number} y                The top-left y-coordinate of the selection rectangle
	 * @param {number} width            The width of the selection rectangle
	 * @param {number} height           The height of the selection rectangle
	 * @param {boolean} releaseOthers   Whether or not to release other targeted tokens
	 * @return {number}                 The number of Token instances which were targeted.
	 */
	targetObjects({x, y, width, height}, {releaseOthers=true}={}) {
		const user = game.user;

		// Get the set of targeted tokens
		const targets = this.placeables.filter(obj => {
			if ( !obj.visible ) return false;
			let c = obj.center;
			return Number.between(c.x, x, x+width) && Number.between(c.y, y, y+height);
		});

		// Maybe release other targets
		if ( releaseOthers ) {
			for ( let t of user.targets ) {
				if ( !targets.includes(t) ) t.setTarget(false, {releaseOthers: false, groupSelection: true});
			}
		}

		// Acquire targets for tokens which are not yet targeted
		targets.forEach(t => {
			if ( !user.targets.has(t) ) t.setTarget(true, {releaseOthers: false, groupSelection: true});
		});

		// Broadcast the target change
		user.broadcastActivity({targets: user.targets.ids});

		// Return the number of targeted tokens
		return user.targets.size;
	}

	/* -------------------------------------------- */

	/**
	 * Cycle the controlled token by rotating through the list of Owned Tokens that are available within the Scene
	 * Tokens are currently sorted in order of their TokenID
	 *
	 * @param {boolean} forwards  Which direction to cycle. A truthy value cycles forward, while a false value
	 *                            cycles backwards.
	 * @param {boolean} reset     Restart the cycle order back at the beginning?
	 * @return {Token|null}       The Token object which was cycled to, or null
	 */
	cycleTokens(forwards, reset) {
		let next = null;
		if ( reset ) this._tabIndex = null;
		const order = this._getCycleOrder();

		// If we are not tab cycling, try and jump to the currently controlled or impersonated token
		if ( this._tabIndex === null ) {
			this._tabIndex = 0;

			// Determine the ideal starting point based on controlled tokens or the primary character
			let current = this.controlled.length ? order.find(t => this.controlled.includes(t)) : null;
			if ( !current && game.user.character ) {
				const actorTokens = game.user.character.getActiveTokens();
				current = actorTokens.length ? order.find(t => actorTokens.includes(t)) : null;
			}
			current = current || order[this._tabIndex] || null;

			// Either start cycling, or cancel
			if ( !current ) return null;
			next = current;
		}

		// Otherwise, cycle forwards or backwards
		else {
			if ( forwards ) this._tabIndex = this._tabIndex < (order.length - 1) ? this._tabIndex + 1 : 0;
			else this._tabIndex = this._tabIndex > 0 ? this._tabIndex - 1 : order.length - 1;
			next = order[this._tabIndex];
			if ( !next ) return null;
		}

		// Pan to the token and control it (if possible)
		canvas.animatePan({x: next.center.x, y: next.center.y, duration: 250});
		next.control();
		return next;
	}

	/* -------------------------------------------- */

	/**
	 * Add or remove the set of currently controlled Tokens from the active combat encounter
	 * @param {boolean} state         The desired combat state which determines if each Token is added (true) or
	 *                                removed (false)
	 * @param {Combat|null} combat    A Combat encounter from which to add or remove the Token
	 * @param {Token|null} [token]    A specific Token which is the origin of the group toggle request
	 * @return {Promise<Combat>}      The updated Combat encounter
	 */
	async toggleCombat(state=true, combat=null, {token=null}={}) {

		// Reference the combat encounter displayed in the Sidebar if none was provided
		combat = combat ?? game.combats.viewed;
		if ( !combat ) {
			if ( game.user.isGM ) {
				const cls = getDocumentClass("Combat")
				combat = await cls.create({scene: canvas.scene.id, active: true});
			}
			else return ui.notifications.warn("COMBAT.NoneActive", {localize: true});
		}

		// Process each controlled token, as well as the reference token
		const tokens = this.controlled.filter(t => t.inCombat !== state);
		if ( token && !token._controlled && (token.inCombat !== state) ) tokens.push(token);

		// Add tokens to the Combat encounter
		if ( state ) {
			const createData = tokens.map(t => {return {tokenId: t.id, actorId: t.data.actorId, hidden: t.data.hidden}});
			return combat.createEmbeddedDocuments("Combatant", createData);
		}

		// Remove Tokens from combat
		if ( !game.user.isGM ) return combat;
		const tokenIds = new Set(tokens.map(t => t.id));
		const combatantIds = combat.combatants.reduce((ids, c) => {
			if (tokenIds.has(c.data.tokenId)) ids.push(c.id);
			return ids;
		}, []);
		return combat.deleteEmbeddedDocuments("Combatant", combatantIds);
	}

	/* -------------------------------------------- */

	/**
	 * Get the tab cycle order for tokens by sorting observable tokens based on their distance from top-left.
	 * @return {Token[]}
	 * @private
	 */
	_getCycleOrder() {
		const observable = this.placeables.filter(t => {
			return game.user.isGM || (t.actor?.testUserPermission(game.user, "OBSERVER") ?? false);
		});
		observable.sort((a, b) => Math.hypot(a.x, a.y) - Math.hypot(b.x, b.y));
		return observable;
	}

	/* -------------------------------------------- */

	/**
	 * Immediately conclude the animation of any/all tokens
	 */
	concludeAnimation() {
		this.placeables.filter(t => t._movement).forEach(t => {
			let ray = t._movement;
			t._movement = null;
			t.stopAnimation();
			t.position.set(ray.B.x, ray.B.y);
		});
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Handle dropping of Actor data onto the Scene canvas
	 * @private
	 */
	async _onDropActorData(event, data) {

		// Ensure the user has permission to drop the actor and create a Token
		if ( !game.user.can("TOKEN_CREATE") ) {
			return ui.notifications.warn(`You do not have permission to create new Tokens!`);
		}

		// Acquire dropped data and import the actor
		let actor = await Actor.implementation.fromDropData(data);
		if ( !actor.isOwner ) {
			return ui.notifications.warn(`You do not have permission to create a new Token for the ${actor.name} Actor.`);
		}
		if ( actor.compendium ) actor = await Actor.implementation.create(actor.toJSON());

		// Prepare the Token data
		const td = await actor.getTokenData({x: data.x, y: data.y, hidden: event.altKey});

		// Bypass snapping
		if ( event.shiftKey ) td.update({
			x: td.x - (td.width * canvas.grid.w / 2),
			y: td.y - (td.height * canvas.grid.h / 2)
		});

		// Otherwise snap to nearest vertex, adjusting for large tokens
		else {
			const hw = canvas.grid.w/2;
			const hh = canvas.grid.h/2;
			td.update(canvas.grid.getSnappedPosition(td.x - (td.width*hw), td.y - (td.height*hh)));
		}

		// Validate the final position
		if ( !canvas.dimensions.rect.contains(td.x, td.y) ) return false;

		// Submit the Token creation request and activate the Tokens layer (if not already active)
		this.activate();
		const cls = getDocumentClass("Token");
		return cls.create(td, {parent: canvas.scene});
	}
}

/**
 * The Walls canvas layer which provides a container for Wall objects within the rendered Scene.
 * @extends {PlaceablesLayer}
 * @see {@link WallDocument}
 * @see {@link Wall}
 */
class WallsLayer extends PlaceablesLayer {
	constructor() {
		super();

		/**
		 * A graphics layer used to display chained Wall selection
		 * @type {PIXI.Graphics}
		 */
		this.chain = null;

		/**
		 * An array of all the unique perception-blocking endpoints which are present in the layer
		 * We keep this array cached for faster sight polygon computations
		 * @type {PointArray[]}
		 */
		this.endpoints = [];

		/**
		 * Track whether we are currently within a chained placement workflow
		 * @type {boolean}
		 */
		this._chain = false;

		/**
		 * Track whether the layer is currently toggled to snap at exact grid precision
		 * @type {boolean}
		 */
		this._forceSnap = false;

		/**
		 * Track the most recently created or updated wall data for use with the clone tool
		 * @type {Object|null}
		 * @private
		 */
		this._cloneType = null;

		/**
		 * Reference the last interacted wall endpoint for the purposes of chaining
		 * @type {{id: string|null, point: PointArray}}
		 * @private
		 */
		this.last = {
			id: null,
			point: null
		};
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/** @inheritdoc */
	static get layerOptions() {
		return foundry.utils.mergeObject(super.layerOptions, {
			name: "walls",
			controllableObjects: true,
			objectClass: Wall,
			quadtree: true,
			sheetClass: WallConfig,
			sortActiveTop: true,
			zIndex: 40
		});
	}

	/** @inheritdoc */
	static documentName = "Wall";

	/* -------------------------------------------- */

	/**
	 * An Array of Wall instances in the current Scene which act as Doors.
	 * @type {Wall[]}
	 */
	get doors() {
		return this.objects.children.filter(w => w.data.door > CONST.WALL_DOOR_TYPES.NONE);
	}

	/* -------------------------------------------- */

	/**
	 * Gate the precision of wall snapping to become less precise for small scale maps.
	 * @type {number}
	 */
	get gridPrecision() {

		// Force snapping to grid vertices
		if ( this._forceSnap ) return canvas.grid.type <= CONST.GRID_TYPES.SQUARE ? 1 : 5;

		// Normal snapping precision
		let size = canvas.dimensions.size;
		if ( size >= 128 ) return 16;
		else if ( size >= 64 ) return 8;
		else if ( size >= 32 ) return 4;
		return 1;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async draw() {
		await super.draw();
		this.last = {id: null, point: null};
		this.chain = this.addChildAt(new PIXI.Graphics(), 0);
		this.highlightControlledSegments();
		return this;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	deactivate() {
		super.deactivate();
		if ( !canvas.ready ) return;
		if ( this.chain ) this.chain.clear();
		this.initialize();
		canvas.perception.initialize();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Perform initialization steps for the WallsLayer whenever the composition of walls in the Scene is changed.
	 * Cache unique wall endpoints and identify interior walls using overhead roof tiles.
	 */
	initialize() {
		this.endpoints = WallsLayer.getUniqueEndpoints(this.placeables, {
			blockMovement: false,
			blockSenses: true
		});
		this.identifyInteriorWalls();
	}

	/* -------------------------------------------- */

	/**
	 * Identify walls which are treated as "interior" because they are contained fully within a roof tile.
	 */
	identifyInteriorWalls() {
		for ( let r of canvas.foreground.roofs ) {
			for ( let w of this.placeables ) {
				const isInterior = r.containsPixel(w.data.c[0], w.data.c[1]) && r.containsPixel(w.data.c[2], w.data.c[3]);
				if ( isInterior ) w.roof = r;
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Given a point and the coordinates of a wall, determine which endpoint is closer to the point
	 * @param {Point} point         The origin point of the new Wall placement
	 * @param {Wall} wall           The existing Wall object being chained to
	 * @return {PointArray}         The [x,y] coordinates of the starting endpoint
	 */
	static getClosestEndpoint(point, wall) {
		const c = wall.coords;
		const a = [c[0], c[1]];
		const b = [c[2], c[3]];

		// Exact matches
		if ( a.equals([point.x, point.y]) ) return a;
		else if ( b.equals([point.x, point.y]) ) return b;

		// Closest match
		const da = Math.hypot(point.x - a[0], point.y - a[1]);
		const db = Math.hypot(point.x - b[0], point.y - b[1]);
		return da < db ? a : b;
	}

	/* -------------------------------------------- */

	/**
	 * Given an array of Wall instances, identify the unique endpoints across all walls.
	 * @param {Wall[]|Set<Wall>} walls  An collection of Wall objects
	 * @param {object} [options={}]     Additional options which modify the set of endpoints identified
	 * @param {NormalizedRectangle} [options.bounds]  An optional bounding rectangle within which the endpoint must lie.
	 * @param {string} [options.type=movement]        The type of polygon being computed: "movement", "sight", or "sound"
	 * @return {PointArray[]}           An array of endpoints
	 */
	static getUniqueEndpoints(walls, {bounds, type="movement"}={}) {
		const unique = new Set();
		const endpoints = [];
		const wallType = this._mapWallCollisionType(type);

		// Define the adding function
		const set = pt => {
			if ( bounds && !bounds.contains(pt[0], pt[1]) ) return;
			let k = pt.join(",");
			if ( unique.has(k) ) return;
			endpoints.push(pt);
			unique.add(k);
		};

		// Iterate over provided walls
		for (let w of walls) {
			if ( w.data[wallType] === CONST.WALL_SENSE_TYPES.NONE ) continue;
			set(w.data.c.slice(0, 2));
			set(w.data.c.slice(2));
		}
		return endpoints;
	}

	/* -------------------------------------------- */

	/**
	 * Test whether movement along a given Ray collides with a Wall.
	 * @param {Ray} ray                             The attempted movement
	 * @param {object} [options={}]                 Options which customize how collision is tested
	 * @param {string} [options.type=movement]        Which collision type to check: movement, sight, sound
	 * @param {string} [options.mode=any]             Which type of collisions are returned: any, closest, all
	 * @returns {boolean}                           Does a collision occur along the tested Ray?
	 */
	checkCollision(ray, {type="movement", mode="any"}={}) {
		if ( !canvas.grid.hitArea.contains(ray.B.x, ray.B.y) ) return true;
		if ( !canvas.scene.data.walls.size ) return false;
		return this.getRayCollisions(ray, {type, mode});
	}

	/* -------------------------------------------- */

	/**
	 * Highlight the endpoints of Wall segments which are currently group-controlled on the Walls layer
	 */
	highlightControlledSegments() {
		if ( !this.chain ) return;
		const drawn = new Set();
		const c = this.chain.clear();

		// Determine circle radius and line width
		let lw = 2;
		if ( canvas.dimensions.size > 150 ) lw = 4;
		else if ( canvas.dimensions.size > 100 ) lw = 3;
		const  cr = lw * 2;
		let cr2 = cr * 2;
		let cr4 = cr * 4;

		for ( let p of Object.values(this._controlled) ) {
			let p1 = p.coords.slice(0, 2);
			if ( !drawn.has(p1.join(".")) ) c.lineStyle(cr, 0xFF9829).drawRoundedRect(p1[0] - cr2, p1[1] - cr2, cr4, cr4, cr);
			let p2 = p.coords.slice(2);
			if ( !drawn.has(p2.join(".")) ) c.lineStyle(cr, 0xFF9829).drawRoundedRect(p2[0] - cr2, p2[1] - cr2, cr4, cr4, cr);
			c.lineStyle(cr2, 0xFF9829).moveTo(...p1).lineTo(...p2);
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	releaseAll(options) {
		if ( this.chain ) this.chain.clear();
		return super.releaseAll(options);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async pasteObjects(position, options) {
		if ( !this._copy.length ) return [];
		const cls = this.constructor.placeableClass;

		// Transform walls to reference their upper-left coordinates as {x,y}
		const [xs, ys] = this._copy.reduce((arr, w) => {
			arr[0].push(Math.min(w.data.c[0], w.data.c[2]));
			arr[1].push(Math.min(w.data.c[1], w.data.c[3]));
			return arr;
		}, [[], []]);

		// Get the top-left most coordinate
		const topX = Math.min(...xs);
		const topY = Math.min(...ys);

		// Get the magnitude of shift
		const dx = Math.floor(topX - position.x);
		const dy = Math.floor(topY - position.y);
		const shift = [dx, dy, dx, dy];

		// Iterate over objects
		const toCreate = [];
		for ( let w of this._copy ) {
			let data = w.document.toJSON();
			data.c = data.c.map((c, i) => c - shift[i]);
			delete data._id;
			toCreate.push(data);
		}

		// Call paste hooks
		Hooks.call(`paste${cls.name}`, this._copy, toCreate);

		// Create all objects
		let created = await canvas.scene.createEmbeddedDocuments("Wall", toCreate);
		ui.notifications.info(`Pasted data for ${toCreate.length} ${cls.name} objects.`);
		return created;
	}

	/* -------------------------------------------- */

	/**
	 * Pan the canvas view when the cursor position gets close to the edge of the frame
	 * @param {MouseEvent} event    The originating mouse movement event
	 * @param {number} x            The x-coordinate
	 * @param {number} y            The y-coordinate
	 * @private
	 */
	_panCanvasEdge(event, x, y) {

		// Throttle panning by 20ms
		const now = Date.now();
		if ( now - (event.data.panTime || 0) <= 100 ) return;
		event.data.panTime = now;

		// Determine the amount of shifting required
		const pad = 50;
		const shift = 500 / canvas.stage.scale.x;

		// Shift horizontally
		let dx = 0;
		if ( x < pad ) dx = -shift;
		else if ( x > window.innerWidth - pad ) dx = shift;

		// Shift vertically
		let dy = 0;
		if ( y < pad ) dy = -shift;
		else if ( y > window.innerHeight - pad ) dy = shift;

		// Enact panning
		if (( dx || dy ) && !this._panning ) {
			return canvas.animatePan({x: canvas.stage.pivot.x + dx, y: canvas.stage.pivot.y + dy, duration: 100});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Get the endpoint coordinates for a wall placement, snapping to grid at a specified precision
	 * Require snap-to-grid until a redesign of the wall chaining system can occur.
	 * @param {Object} point          The initial candidate point
	 * @param {boolean} [snap=true]   Whether to snap to grid
	 * @return {number[]}             The endpoint coordinates [x,y]
	 * @private
	 */
	_getWallEndpointCoordinates(point, {snap=true}={}) {
		if ( snap ) point = canvas.grid.getSnappedPosition(point.x, point.y, this.gridPrecision);
		return [point.x, point.y].map(Math.floor);
	}

	/* -------------------------------------------- */

	/**
	 * The Scene Controls tools provide several different types of prototypical Walls to choose from
	 * This method helps to translate each tool into a default wall data configuration for that type
	 * @param {string} tool     The active canvas tool
	 * @private
	 */
	_getWallDataFromActiveTool(tool) {

		// Using the clone tool
		if ( tool === "clone" && this._cloneType ) return this._cloneType;

		// Using a wall type
		const wallData = {};
		wallData.move = ( tool === "ethereal" ) ? CONST.WALL_MOVEMENT_TYPES.NONE : CONST.WALL_MOVEMENT_TYPES.NORMAL;
		wallData.sense = ( tool === "invisible" ) ? CONST.WALL_SENSE_TYPES.NONE : CONST.WALL_SENSE_TYPES.NORMAL;
		if ( tool === "terrain" ) wallData.sense = CONST.WALL_SENSE_TYPES.LIMITED;
		else if ( tool === "doors" ) wallData.door = CONST.WALL_DOOR_TYPES.DOOR;
		else if ( tool === "secret" ) wallData.door = CONST.WALL_DOOR_TYPES.SECRET;
		return wallData;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_onClickLeft(event) {
		const {createState} = event.data;

		// Conclude a chained wall creation
		if ( this._chain && (createState === 2) ) return this._onDragLeftDrop(event);
		this._chain = game.keyboard.isCtrl(event);

		// Begin a new wall creation
		super._onClickLeft(event);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftStart(event) {
		const { origin, originalEvent } = event.data;
		const tool = game.activeTool;
		event.data.createState = 0;

		// Construct new wall data
		const data = this._getWallDataFromActiveTool(tool);
		const snap = this._forceSnap || !originalEvent.shiftKey;

		// Determine the starting coordinates
		const pt = (this._chain && this.last.id) ? this.last.point : this._getWallEndpointCoordinates(origin, {snap});
		data.c = pt.concat(pt);

		// Create the preview Wall
		const doc = new WallDocument(data, {parent: canvas.scene});
		const wall = new Wall(doc);
		event.data.createState = 1;
		event.data.preview = this.preview.addChild(wall);
		return wall.draw();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftMove(event) {
		const { destination, preview } = event.data;
		if ( !preview ) return;
		if ( preview.parent === null ) { // In theory this should never happen, but rarely does
			this.preview.addChild(preview);
		}
		preview.data.c = preview.data.c.slice(0, 2).concat([destination.x, destination.y]);
		preview.refresh();
		event.data.createState = 2;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _onDragLeftDrop(event) {
		const { createState, destination, originalEvent, preview } = event.data;

		// Prevent default to allow chaining to continue
		const isCtrl = game.keyboard.isCtrl(event);
		if ( isCtrl ) {
			originalEvent.preventDefault();
			this._chain = true;
			if ( createState !== 2 ) return;
		} else this._chain = false;

		// Successful wall completion
		if ( createState === 2 ) {
			event.data.createState = 0;

			// Get final endpoint location
			const snap = this._forceSnap || !originalEvent.shiftKey;
			let dest = this._getWallEndpointCoordinates(destination, {snap});
			const coords = preview.data.c.slice(0, 2).concat(dest);
			preview.data.c = coords;

			// Ignore walls which are collapsed
			if ( (coords[0] === coords[2]) && (coords[1] === coords[3]) ) return this._onDragLeftCancel(originalEvent);

			// Create the Wall
			this.last = {id: "preview", point: dest};
			const cls = getDocumentClass(this.constructor.documentName);
			const w = await cls.create(preview.data.toObject(false), {parent: canvas.scene});
			this.last.id = w.id;
			this.preview.removeChild(preview);

			// Maybe chain
			if (this._chain) {
				event.data.origin = {x: dest[0], y: dest[1]};
				return this._onDragLeftStart(event);
			}
		}

		// Partial wall completion
		return this._onDragLeftCancel(event);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftCancel(event) {
		this._chain = false;
		super._onDragLeftCancel(event);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onClickRight(event) {
		if ( event.data.createState > 0 ) return this._onDragLeftCancel(event);
	}

	/* -------------------------------------------- */
	/*  Source Polygon Computation                  */
	/* -------------------------------------------- */

	/**
	 * Compute source polygons of a requested type for a given origin position and maximum radius.
	 * This method returns two polygons, one which is unrestricted by the provided radius, and one that is constrained
	 * by the maximum radius.
	 *
	 * @param {Point} origin            An point with coordinates x and y representing the origin of the test
	 * @param {number} radius           A distance in canvas pixels which reflects the visible range
	 * @param {object} [options={}]     Additional options which modify the sight computation
	 * @param {string} [options.type=sight]     The type of polygon being computed: "movement", "sight", or "sound"
	 * @param {number} [options.angle=360]      An optional limited angle of emission with which to restrict polygons
	 * @param {number} [options.density=6]      The desired radial density of emission for rays, in degrees
	 * @param {number} [options.rotation=0]     The current angle of rotation, used when the angle is limited
	 * @param {boolean} [options.unrestricted=false]  Compute sight that is fully unrestricted by walls
	 *
	 * @returns {{rays: Ray[], los: PIXI.Polygon, fov: PIXI.Polygon}}   The computed rays and polygons
	 */
	computePolygon(origin, radius, {type="sight", angle=360, density=6, rotation=0, unrestricted=false}={}) {

		// Determine the maximum ray distance needs to reach all areas of the canvas
		let d = canvas.dimensions;
		let {x, y} = origin;
		const dx = Math.max(origin.x, d.width - origin.x);
		const dy = Math.max(origin.y, d.height - origin.y);
		const distance = Math.max(radius, Math.hypot(dx, dy));
		const limit = radius / distance;
		const wallType = this.constructor._mapWallCollisionType(type);

		// Determine the direction of facing, the angle of vision, and the angles of boundary rays
		const limitAngle = angle.between(0, 360, false);
		const aMin = limitAngle ? Math.normalizeRadians(Math.toRadians(rotation + 90 - (angle / 2))) : -Math.PI;
		const aMax = limitAngle ? aMin + Math.toRadians(angle) : Math.PI;

		// For high wall count maps, restrict to a subset of endpoints using quadtree bounds
		// Target wall endpoints within the vision radius or within 10 grid units, whichever is larger
		let endpoints = unrestricted ? [] : this.endpoints;
		let bounds = null;
		if ( endpoints.length > SightLayer.EXACT_VISION_THRESHOLD ) {
			const rb2 = Math.max(d.size * 10, radius);
			bounds = new NormalizedRectangle(origin.x - rb2, origin.y - rb2, (2 * rb2), (2 * rb2));
			let walls = this.quadtree.getObjects(bounds);
			endpoints = WallsLayer.getUniqueEndpoints(walls, {bounds, type});
		}

		// Cast sight rays at target endpoints using the full unrestricted line-of-sight distance
		const rays = WallsLayer.castRays(x, y, distance, {density, endpoints, limitAngle, aMin, aMax});
		const rayQueue = new Set(rays);

		// Record which Rays appear in each Quadtree quadrant
		const quadMap = new Map();
		for ( let r of rays ) {
			r._cs = null;
			r._c = null;
			const nodes = this.quadtree.getLeafNodes(r.bounds);
			for ( let n of nodes ) {
				let s = quadMap.get(n);
				if ( !s ) {
					s = new Set();
					quadMap.set(n, s);
				}
				s.add(r);
			}
		}

		// Identify the closest quadtree vertex as the origin point for progressive testing
		const quadSize = Math.max(d.sceneWidth, d.sceneHeight) / (this.quadtree.maxDepth * 2);
		const originNode = this.quadtree.getLeafNodes({x: origin.x, y: origin.y, width: 0, height: 0})[0];
		const ob = originNode.bounds;
		const testFrame = new PIXI.Rectangle((origin.x - ob.x) < (ob.width / 2) ? ob.x : ob.x + ob.width,
			(origin.y - ob.y) < (ob.height / 2) ? ob.y : ob.y + ob.height, 0, 0).pad(quadSize);

		// Iterate until we have matched all rays or run out of quadtree nodes
		const nodeQueue = new Set(unrestricted ? [] : this.quadtree.getLeafNodes(testFrame));
		const testedNodes = new Set();
		while ( rayQueue.size && nodeQueue.size ) {

			// Check every ray+wall collision for each quadrant in the batch
			const nodes = Array.from(nodeQueue);
			for (let node of nodes) {
				const rays = quadMap.get(node) || [];

				// Iterate over each wall which appears in the quadrant
				for (let obj of node.objects) {
					const w = obj.t;
					let wt = w.data[wallType];

					// Coerce interior walls beneath roofs as vision blocking for sight polygons
					const isInterior = (type === "sight") && (w.roof?.occluded === false);
					if ( isInterior ) wt = CONST.WALL_SENSE_TYPES.NORMAL;

					// Ignore walls and open doors that don't block senses
					else if ( wt === CONST.WALL_SENSE_TYPES.NONE ) continue;
					else if ((w.data.door > CONST.WALL_DOOR_TYPES.NONE) && (w.data.ds === CONST.WALL_DOOR_STATES.OPEN)) continue;

					// Iterate over rays
					for (let r of rays) {
						if ( r._c || !w.canRayIntersect(r) ) continue;

						// Test collision for the ray
						const x = WallsLayer.testWall(r, w);
						if ( SightLayer._performance ) SightLayer._performance.tests++;
						if ( !x ) continue;

						// Flag the collision
						r._cs = r._cs || new Map();
						const pt = (Math.round(x.x) << 16) + Math.round(x.y); // 32 bit integer, x[16]y[16]
						const c = r._cs.get(pt);
						if ( c ) {
							c.type = Math.min(wt, c.type);
							for ( let n of obj.n ) c.nodes.push(n);
						}
						else {
							x.type = wt;
							x.nodes = Array.from(obj.n);
							r._cs.set(pt, x);
						}
					}
				}

				// Mark this node as tested
				testedNodes.add(node);
				nodeQueue.delete(node);
			}

			// After completing a batch of quadrants, test rays that were hit for the closest collision
			for ( let r of rayQueue ) {
				if ( !r._cs ) continue;
				const closest = WallsLayer.getClosestCollision([...r._cs.values()]);
				if ( closest && closest.nodes.every(n => testedNodes.has(n)) ) {
					rayQueue.delete(r);
					r._c = closest;
				}
			}

			// If all rays have been hit we are done, otherwise expand the test frame
			if ( !rayQueue.size ) break;
			while ( (nodeQueue.size === 0) && (testedNodes.size < quadMap.size) ) {
				testFrame.pad(quadSize);
				for ( let a of this.quadtree.getLeafNodes(testFrame)) {
					if (!testedNodes.has(a)) nodeQueue.add(a);
				}
			}
		}

		// Construct visibility polygons
		const losPoints = [];
		const fovPoints = [];
		for ( let r of rays ) {
			r.los = r._c || { x: r.B.x, y: r.B.y, t0: 1, t1: 0};
			losPoints.push(r.los);
			r.fov = r.los.t0 <= limit ? r.los : r.project(limit);
			fovPoints.push(r.fov)
		}
		const los = new SourcePolygon(x, y, distance, ...losPoints);
		const fov = new SourcePolygon(x, y, radius, ...fovPoints);

		// Visualize vision rendering
		if ( CONFIG.debug.sightRays ) canvas.sight._visualizeSight(bounds, endpoints, rays, los, fov);
		if ( CONFIG.debug.sight && SightLayer._performance ) SightLayer._performance.rays = rays.length;

		// Return rays and polygons
		return {rays, los, fov};
	}

	/* -------------------------------------------- */

	/**
	 * Get the set of wall collisions for a given Ray
	 * @param {Ray} ray                   The Ray being tested
	 * @param {object} [options={}]       Options which customize how collision is tested
	 * @param {string} [options.type=movement]        Which collision type to check: movement, sight, sound
	 * @param {string} [options.mode=any]             Which type of collisions are returned: any, closest, all
	 * @param {object} [options._performance]           Internal performance tracking
	 *
	 * @return {object[]|object|boolean}  An array of collisions, if mode is "all"
	 *                                    The closest collision, if mode is "closest"
	 *                                    Whether any collision occurred if mode is "any"
	 */
	getRayCollisions(ray, {type="movement", mode="all", _performance}={}) {

		// Define inputs
		const angleBounds = [ray.angle - (Math.PI/2), ray.angle + (Math.PI/2)];
		const isClosest = mode === "closest";
		const isAny = mode === "any";
		const wallType = this.constructor._mapWallCollisionType(type);

		// Track collisions
		const collisions = {};
		let collided = false;

		// Track quadtree nodes and walls which have already been tested
		const testedNodes = new Set();
		const testedWalls = new Set();

		// Expand the ray outward from the origin, identifying candidate walls as we go
		const stages = 4;
		for ( let i=1; i<=stages; i++ ) {

			// Determine and iterate over the (unordered) set of nodes to test at this level of projection
			const limit = i < stages ? ray.project(i / stages) : ray.B;
			const bounds = new NormalizedRectangle(ray.A.x, ray.A.y, limit.x - ray.A.x, limit.y - ray.A.y);
			const nodes = this.quadtree.getLeafNodes(bounds);
			for ( let n of nodes ) {
				if ( testedNodes.has(n) ) continue;
				testedNodes.add(n);

				// Iterate over walls in the node to test
				const objects = n.objects;
				for ( let o of objects ) {
					const w = o.t;
					const wt = w.data[wallType];
					if (testedWalls.has(w)) continue;
					testedWalls.add(w);

					// Skip walls which don't fit the criteria
					if ( wt === CONST.WALL_SENSE_TYPES.NONE ) continue;
					if ((w.data.door > CONST.WALL_DOOR_TYPES.NONE) && (w.data.ds === CONST.WALL_DOOR_STATES.OPEN)) continue;
					if (w.direction !== null) { // Directional walls where the ray angle is not in the same hemisphere
						if (!w.isDirectionBetweenAngles(...angleBounds)) continue;
					}

					// Test a single wall
					const x = WallsLayer.testWall(ray, w);
					if (_performance) _performance.tests++;
					if (!x) continue;
					if (isAny) return true;

					// Update a known collision point to flag the sense type
					const pt = `${x.x},${x.y}`;
					let c = collisions[pt];
					if (c) {
						c.type = Math.min(wt, c.type);
						for ( let n of o.n ) c.nodes.push(n);
					} else {
						x.type = wt;
						x.nodes = Array.from(o.n);
						collisions[pt] = x;
						collided = true;
					}
				}
			}

			// At this point we may be done if the closest collision has been fully tested
			if ( isClosest && collided ) {
				const closest = this.getClosestCollision(Object.values(collisions));
				if ( closest && closest.nodes.every(n => testedNodes.has(n) ) ) {
					return closest;
				}
			}
		}

		// Return the collision result
		if ( isAny ) return false;
		if ( isClosest ) {
			const closest = this.getClosestCollision(Object.values(collisions));
			return closest || null;
		}
		return Object.values(collisions);
	}

	/* -------------------------------------------- */
	/*  Helper Methods                              */
	/* -------------------------------------------- */

	/**
	 * A helper method responsible for casting rays at wall endpoints.
	 * Rays are restricted by limiting angles.
	 *
	 * @param {number} x                  The origin x-coordinate
	 * @param {number} y                  The origin y-coordinate
	 * @param {number} distance           The ray distance
	 * @param {number} density            The desired radial density
	 * @param {PointArray[]} endpoints    An array of endpoints to target
	 * @param {boolean} limitAngle        Whether the rays should be cast subject to a limited angle of emission
	 * @param {number} aMin               The minimum bounding angle
	 * @param {number} aMax               The maximum bounding angle
	 *
	 * @returns {Ray[]}                   An array of Ray objects
	 */
	static castRays(x, y, distance, {density=4, endpoints, limitAngle=false, aMin, aMax}={}) {
		const rOffset = 0.02;

		// Enforce that all rays increase in angle from minimum towards maximum
		const rMin = limitAngle ? Ray.fromAngle(x, y, aMin, distance) : null;
		const rMax = limitAngle ? Ray.fromAngle(x, y, aMax, distance) : null;

		// Define de-duping casting function
		const cast = (ray, filter=false) => {
			const a = ray.angle.toNearest(rOffset);
			if ( filter && angles.has(a) ) return;
			rays.push(ray);
			angles.add(a);
		};

		// Track rays and unique emission angles
		const angles = new Set();
		const rays = [];

		// First prioritize rays which are cast directly at wall endpoints
		for ( let e of endpoints ) {
			let angle = Math.atan2(e[1]-y, e[0]-x);
			if ( limitAngle ) {
				angle = this._normalizeAngle(aMin, angle);
				if ( !angle.between(aMin, aMax) ) continue;
			}
			const ray = Ray.fromAngle(x, y, angle, distance);
			cast(ray, false);
		}

		// Next cast rays at any non-duplicate offset angles
		const nr = rays.length;
		for ( let i=0; i<nr; i++ ) {
			const r = rays[i];
			cast(r.shiftAngle(rOffset), true);
			cast(r.shiftAngle(-rOffset), true);
		}

		// Add additional limiting and central rays
		if ( limitAngle ) {
			const aCenter = aMin + ((aMax - aMin) / 2) + Math.PI;
			const rCenter = Ray.fromAngle(x, y, aCenter, 0);
			rCenter._isCenter = true;
			cast(rMin, true);
			cast(rCenter, true);
			cast(rMax, true);
		}

		// Add additional approximate rays to reach a desired radial density
		if ( !!density ) {
			const rDensity = Math.toRadians(density);
			const nFill = Math.ceil((aMax - aMin) / rDensity);
			for ( let a of Array.fromRange(nFill) ) {
				cast(Ray.fromAngle(x, y, aMin + (a * rDensity), distance), true);
			}
		}

		// Sort rays counter-clockwise (increasing radians)
		rays.sort((r1, r2) => r1.angle - r2.angle);
		return rays;
	}

	/* -------------------------------------------- */

	/**
	 * Test a single Ray against a single Wall
	 * @param {Ray} ray                 The Ray being tested
	 * @param {Wall} wall               The Wall against which to test
	 * @return {RayIntersection|null}   A RayIntersection if a collision occurred, or null
	 */
	static testWall(ray, wall) {
		let i = ray.intersectSegment(wall.data.c);
		return ( i && i.t0 > 0 ) ? i : null;
	}

	/* -------------------------------------------- */

	/**
	 * Identify the closest collision point from an array of collisions
	 * @param {RayIntersection[]} collisions  An array of intersection points
	 * @return {RayIntersection|null}         The closest blocking intersection or null if no collision occurred
	 */
	static getClosestCollision(collisions) {
		if ( !collisions.length ) return null;
		collisions.sort((a, b) => a.t0 - b.t0);
		let closest = ( collisions[0].type === CONST.WALL_SENSE_TYPES.LIMITED ) ? collisions[1] : collisions[0];
		return closest || null;
	}

	/* -------------------------------------------- */

	/**
	 * Normalize an angle to ensure it is baselined to be the smallest angle that is greater than a minimum.
	 * @param {number} aMin       The lower-bound minimum angle
	 * @param {number} angle      The angle to adjust
	 * @return {number}           The adjusted angle which is greater than or equal to aMin.
	 * @private
	 */
	static _normalizeAngle(aMin, angle) {
		while ( angle < aMin ) {
			angle += (2*Math.PI);
		}
		return angle;
	}

	/* -------------------------------------------- */

	/**
	 * Map source types to wall collision types
	 * @param {string} type     The source polygon type
	 * @returns {string}        The wall collision attribute
	 * @private
	 */
	static _mapWallCollisionType(type) {
		return {movement: "move", light: "sense", sight: "sense", sound: "sound"}[type];
	}

	/* -------------------------------------------- */
	/*  Deprecations                                */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	get blockVision() {
		console.warn("The WallsLayer#blockVision attribute is deprecated since version 0.8.0");
		return this.objects.children.filter(w => w.data.sense !== CONST.WALL_SENSE_TYPES.NONE);
	}

	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	get blockMovement() {
		console.warn("The WallsLayer#blockMovement attribute is deprecated since version 0.8.0");
		return this.objects.children.filter(w => w.data.move !== CONST.WALL_MOVEMENT_TYPES.NONE);
	}

}


/**
 * The Drawing object is an implementation of the PlaceableObject container.
 * Each Drawing is a placeable object in the DrawingsLayer.
 * @extends {PlaceableObject}
 */
class Drawing extends PlaceableObject {
	constructor(...args) {
		super(...args);

		/**
		 * The inner drawing container
		 * @type {PIXI.Container}
		 */
		this.drawing = null;

		/**
		 * The primary drawing shape
		 * @type {PIXI.Graphics}
		 */
		this.shape = null;

		/**
		 * Text content, if included
		 * @type {PIXI.Text}
		 */
		this.text = null;

		/**
		 * The Graphics outer frame and handles
		 * @type {PIXI.Container}
		 */
		this.frame = null;

		/**
		 * Internal timestamp for the previous freehand draw time, to limit sampling
		 * @type {number}
		 * @private
		 */
		this._drawTime = 0;
		this._sampleTime = 0;

		/**
		 * Internal flag for the permanent points of the polygon
		 * @type {boolean}
		 * @private
		 */
		this._fixedPoints = foundry.utils.deepClone(this.data.points || []);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	static embeddedName = "Drawing";

	/* -------------------------------------------- */

	/**
	 * The rate at which points are sampled (in milliseconds) during a freehand drawing workflow
	 * @type {number}
	 */
	static FREEHAND_SAMPLE_RATE = 75;

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * A Boolean flag for whether or not the Drawing utilizes a tiled texture background
	 * @type {boolean}
	 */
	get isTiled() {
		return this.data.fillType === CONST.DRAWING_FILL_TYPES.PATTERN;
	}

	/* -------------------------------------------- */

	/**
	 * A Boolean flag for whether or not the Drawing is a Polygon type (either linear or freehand)
	 * @type {boolean}
	 */
	get isPolygon() {
		return [CONST.DRAWING_TYPES.POLYGON, CONST.DRAWING_TYPES.FREEHAND].includes(this.data.type);
	}

	/* -------------------------------------------- */
	/* Rendering                                    */
	/* -------------------------------------------- */

	/** @override */
	async draw() {
		this.clear();
		this._cleanData();

		// Load the background texture, if one is defined
		if ( this.data.texture ) {
			this.texture = await loadTexture(this.data.texture, {fallback: 'icons/svg/hazard.svg'});
		} else {
			this.texture = null;
		}

		// Create the inner Drawing container
		this._createDrawing();

		// Control Border
		this._createFrame();

		// Apply the z-index
		this.zIndex = this.data.z;

		// Render Appearance
		this.refresh();

		// Enable Interactivity, if this is a true Drawing
		if ( this.id ) this.activateListeners();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Clean the drawing data to constrain its allowed position
	 * @private
	 */
	_cleanData() {

		// Constrain drawing position
		const d = canvas.dimensions;
		const x = this.data.width < 0 ?
			Math.clamped(this.data.x, -this.data.width, d.width) : // negative width
			Math.clamped(this.data.x, 0, d.width-this.data.width); // positive width
		const y = this.data.height < 0 ?
			Math.clamped(this.data.y, -this.data.height, d.height) : // negative height
			Math.clamped(this.data.y, 0, d.height-this.data.height); // positive height
		this.data.update({x, y});

		// Reset pending text
		this._pendingText = this.data.text ?? "";
	}

	/* -------------------------------------------- */

	/**
	 * Create the components of the drawing element, the drawing container, the drawn shape, and the overlay text
	 */
	_createDrawing() {

		// Drawing container
		this.drawing = this.addChild(new PIXI.Container());

		// Drawing Shape
		this.shape = this.drawing.addChild(new PIXI.Graphics());

		// Overlay Text
		const hasText = this.data.type === CONST.DRAWING_TYPES.TEXT || this.data.text;
		this.text = hasText ? this.drawing.addChild(this._createText()) : null;
	}

	/* -------------------------------------------- */

	/**
	 * Create elements for the foreground text
	 * @private
	 */
	_createText() {
		if ( this.text && !this.text._destroyed ) {
			this.text.destroy();
			this.text = null;
		}
		const isText = this.data.type === CONST.DRAWING_TYPES.TEXT;
		const stroke = Math.max(Math.round(this.data.fontSize / 32), 2);

		// Define the text style
		const textStyle = new PIXI.TextStyle({
			fontFamily: this.data.fontFamily || CONFIG.defaultFontFamily,
			fontSize: this.data.fontSize,
			fill: this.data.textColor || "#FFFFFF",
			stroke: "#111111",
			strokeThickness: stroke,
			dropShadow: true,
			dropShadowColor: "#000000",
			dropShadowBlur: Math.max(Math.round(this.data.fontSize / 16), 2),
			dropShadowAngle: 0,
			dropShadowDistance: 0,
			align: isText ? "left" : "center",
			wordWrap: !isText,
			wordWrapWidth: 1.5 * this.data.width,
			padding: stroke
		});

		// Create the text container
		return new PreciseText(this.data.text, textStyle);
	}

	/* -------------------------------------------- */

	/**
	 * Create elements for the Drawing border and handles
	 * @private
	 */
	_createFrame() {
		this.frame = this.addChild(new PIXI.Container());
		this.frame.border = this.frame.addChild(new PIXI.Graphics());
		this.frame.handle = this.frame.addChild(new ResizeHandle([1,1]));
	}

	/* -------------------------------------------- */

	/** @override */
	refresh() {
		if ( this._destroyed || this.shape._destroyed ) return;
		const isTextPreview = (this.data.type === CONST.DRAWING_TYPES.TEXT) && this._controlled;
		this.shape.clear();

		// Outer Stroke
		if ( this.data.strokeWidth || isTextPreview ) {
			let sc = foundry.utils.colorStringToHex(this.data.strokeColor || "#FFFFFF");
			this.shape.lineStyle(this.data.strokeWidth ?? 8, sc, this.data.strokeAlpha ?? 1);
		}

		// Fill Color or Texture
		if ( this.data.fillType || isTextPreview ) {
			const fc = foundry.utils.colorStringToHex(this.data.fillColor || "#FFFFFF");
			if ( (this.data.fillType === CONST.DRAWING_FILL_TYPES.PATTERN) && this.texture ) {
				this.shape.beginTextureFill({
					texture: this.texture,
					color: fc || 0xFFFFFF,
					alpha: fc ? this.data.fillAlpha : 1
				});
			} else {
				const fa = isTextPreview ? 0.25 : this.data.fillAlpha;
				this.shape.beginFill(fc, fa);
			}
		}

		// Draw the shape
		switch ( this.data.type ) {
			case CONST.DRAWING_TYPES.RECTANGLE:
			case CONST.DRAWING_TYPES.TEXT:
				this._drawRectangle();
				break;
			case CONST.DRAWING_TYPES.ELLIPSE:
				this._drawEllipse();
				break;
			case CONST.DRAWING_TYPES.POLYGON:
				this._drawPolygon();
				break;
			case CONST.DRAWING_TYPES.FREEHAND:
				this._drawFreehand();
				break;
		}

		// Conclude fills
		this.shape.lineStyle(0x000000, 0.0).closePath();
		this.shape.endFill();

		// Set shape rotation, pivoting about the non-rotated center
		this.shape.pivot.set(this.data.width / 2, this.data.height / 2);
		this.shape.position.set(this.data.width / 2, this.data.height / 2);
		this.shape.rotation = Math.toRadians(this.data.rotation || 0);

		// Update text position and visibility
		if ( this.text ) {
			this.text.alpha = this.data.textAlpha || 1.0;
			this.text.pivot.set(this.text.width / 2, this.text.height / 2);
			this.text.position.set(
				(this.text.width / 2) + ((this.data.width - this.text.width) / 2),
				(this.text.height / 2) + ((this.data.height - this.text.height) / 2)
			);
			this.text.rotation = this.shape.rotation;
		}

		// Determine shape bounds and update the frame
		const bounds = this.drawing.getLocalBounds();
		if ( this.id && this._controlled ) this._refreshFrame(bounds);
		else this.frame.visible = false;

		// Toggle visibility
		this.position.set(this.data.x, this.data.y);
		this.drawing.hitArea = bounds;
		this.alpha = this.data.hidden ? 0.5 : 1.0;
		this.visible = !this.data.hidden || game.user.isGM;
	}

	/* -------------------------------------------- */

	/**
	 * Draw rectangular shapes
	 * @private
	 */
	_drawRectangle() {
		let hs = this.data.strokeWidth / 2;
		this.shape.drawRect(hs, hs, this.data.width - (2*hs), this.data.height - (2*hs));
	}

	/* -------------------------------------------- */

	/**
	 * Draw ellipsoid shapes
	 * @private
	 */
	_drawEllipse() {
		let hw = this.data.width / 2,
				hh = this.data.height / 2,
				hs = this.data.strokeWidth / 2;
		this.shape.drawEllipse(hw, hh, Math.abs(hw) - hs, Math.abs(hh) - hs);
	}

	/* -------------------------------------------- */

	/**
	 * Draw polygonal shapes
	 * @private
	 */
	_drawPolygon() {
		let points = this.data.points || [];
		if ( points.length < 2 ) return;
		else if ( points.length === 2 ) this.shape.endFill();

		// Get drawing points
		let last = points[points.length - 1];
		let isClosed = points[0].equals(last);

		// If the polygon is closed, or if we are filling it, we can shortcut using the drawPolygon helper
		if ( points.length > 2 && (isClosed || this.data.fillType) ) this.shape.drawPolygon(points.deepFlatten());

		// Otherwise, draw each line individually
		else {
			this.shape.moveTo(...points[0]);
			for ( let p of points.slice(1) ) {
				this.shape.lineTo(...p);
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Draw freehand shapes with bezier spline smoothing
	 * @private
	 */
	_drawFreehand() {
		let factor = this.data.bezierFactor ?? 0.5;

		// Get drawing points
		let points = this.data.points;
		let last = points[points.length - 1];
		let isClosed = points[0].equals(last);

		// Handle edge cases
		this.shape.moveTo(...points[0]);
		if ( points.length < 2 ) return;
		else if ( points.length === 2 ) {
			this.shape.lineTo(...points[1]);
			return;
		}

		// Set initial conditions
		let [previous, point] = points.slice(0, 2);
		if ( this.data.fillType ) points = points.concat([previous, point]);
		let cp0 = this._getBezierControlPoints(factor, last, previous, point).next_cp0;
		let cp1, next_cp0, next;

		// Begin iteration
		for ( let i = 1; i < points.length; i++ ) {
			next = points[i+1];
			if ( next ) {
				let bp = this._getBezierControlPoints(factor, previous, point, next);
				cp1 = bp.cp1;
				next_cp0 = bp.next_cp0;
			}

			// First point
			if ( (i === 1) && !isClosed ) {
				this.shape.quadraticCurveTo(cp1.x, cp1.y, point[0], point[1]);
			}

			// Last Point
			else if ( (i === points.length - 1) && !isClosed ) {
				this.shape.quadraticCurveTo(cp0.x, cp0.y, point[0], point[1]);
			}

			// Bezier points
			else {
				this.shape.bezierCurveTo(cp0.x, cp0.y, cp1.x, cp1.y, point[0], point[1]);
			}

			// Increment
			previous = point;
			point = next;
			cp0 = next_cp0;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Attribution: The equations for how to calculate the bezier control points are derived from Rob Spencer's article:
	 * http://scaledinnovation.com/analytics/splines/aboutSplines.html
	 * @param {number} factor       The smoothing factor
	 * @param {number[]} previous   The prior point
	 * @param {number[]} point      The current point
	 * @param {number[]} next       The next point
	 * @private
	 */
	_getBezierControlPoints(factor, previous, point, next) {

		// Calculate distance vectors
		let vector = { x: next[0] - previous[0], y: next[1] - previous[1] },
				preDistance = Math.hypot(previous[0] - point[0], previous[1] - point[1]),
				postDistance = Math.hypot(next[0] - point[0], next[1] - point[1]),
				distance = preDistance + postDistance;

		// Compute control point locations
		let cp0d = distance === 0 ? 0 : factor * (preDistance / distance),
				cp1d = distance === 0 ? 0 : factor * (postDistance / distance);

		// Return points
		return {
			cp1: {
				x: point[0] - (vector.x * cp0d),
				y: point[1] - (vector.y * cp0d)
			},
			next_cp0: {
				x: point[0] + (vector.x * cp1d),
				y: point[1] + (vector.y * cp1d)
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the boundary frame which outlines the Drawing shape
	 * @private
	 */
	_refreshFrame({x, y, width, height}) {

		// Determine the border color
		const colors = CONFIG.Canvas.dispositionColors;
		let bc = colors.INACTIVE;
		if ( this._controlled ) {
			bc = this.data.locked ? colors.HOSTILE : colors.CONTROLLED;
		}

		// Draw the border
		const pad = 6;
		const t = CONFIG.Canvas.objectBorderThickness;
		const h = Math.round(t/2);
		const o = Math.round(h/2) + pad;
		this.frame.border.clear()
			.lineStyle(t, 0x000000).drawRect(x - o, y - o, width + (2*o), height + (2*o))
			.lineStyle(h, bc).drawRect(x - o, y - o, width + (2*o), height + (2*o))

		// Draw the handle
		this.frame.handle.position.set(x+width+o, y+height+o);
		this.frame.handle.clear()
			.beginFill(0x000000, 1.0).lineStyle(h, 0x000000).drawCircle(0, 0, pad+h)
			.lineStyle(h, bc).drawCircle(0, 0, pad);
		this.frame.visible = true;
	}

	/* -------------------------------------------- */

	/**
	 * Add a new polygon point to the drawing, ensuring it differs from the last one
	 * @private
	 */
	_addPoint(position, temporary=true) {
		const point = [position.x - this.data.x, position.y - this.data.y];
		const points = this._fixedPoints.concat([point]);
		this.data.update({points});
		if ( !temporary ) {
			this._fixedPoints = points
			this._drawTime = Date.now();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Remove the last fixed point from the polygon
	 * @private
	 */
	_removePoint() {
		if ( this._fixedPoints.length ) this._fixedPoints.pop();
		this.data.update({points: this._fixedPoints});
	}

	/* -------------------------------------------- */

	/** @override */
	_onControl(options) {
		super._onControl(options);
		if ( this.data.type === CONST.DRAWING_TYPES.TEXT ) {
			this._onkeydown = this._onDrawingTextKeydown.bind(this);
			if ( !options.isNew ) this._pendingText = this.data.text;
			document.addEventListener("keydown", this._onkeydown);
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onRelease(options) {
		super._onRelease(options);
		if ( this._onkeydown ) {
			document.removeEventListener("keydown", this._onkeydown);
			this._onkeydown = null;
		}
		if ( this.data.type === CONST.DRAWING_TYPES.TEXT ) {
			// There is some chance the document was already deleted via another pathway such as the DEL key
			if ( !canvas.scene.drawings.has(this.id) ) return;
			let text = this._pendingText ?? this.data.text;
			if ( text === "" ) return this.document.delete();
			if ( this._pendingText ) {    // Submit pending text
				const update = {text: this._pendingText, width: this.data.width, height: this.data.height};
				this._pendingText = "";
				return this.document.update(update);
			}
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onDelete(...args) {
		super._onDelete(...args);
		if ( this._onkeydown ) document.removeEventListener("keydown", this._onkeydown);
	}

	/* -------------------------------------------- */

	/**
	 * Handle text entry in an active text tool
	 * @param {KeyboardEvent} event
	 * @private
	 */
	_onDrawingTextKeydown(event) {

		// Ignore events when an input is focused, or when ALT or CTRL modifiers are applied
		if ( event.altKey || event.ctrlKey || event.metaKey ) return;
		if ( game.keyboard.hasFocus ) return;

		// Track refresh or conclusion conditions
		let conclude = ["Escape", "Enter"].includes(event.key);
		let refresh = false;

		// Submitting the change, update or delete
		if ( event.key === "Enter" ) {
			if ( this._pendingText ) {
				const updateData = {text: this._pendingText, width: this.data.width, height: this.data.height};
				return this.document.update(updateData, {diff: false}).then(() => this.release())
			}
			else return this.document.delete();
		}

		// Cancelling the change
		else if ( event.key === "Escape" ) {
			this._pendingText = this.data.text;
			refresh = true;
		}

		// Deleting a character
		else if ( event.key === "Backspace" ) {
			this._pendingText = this._pendingText.slice(0, -1);
			refresh = true;
		}

		// Typing text (any single char)
		else if ( /^.$/.test(event.key) ) {
			this._pendingText += event.key;
			refresh = true;
		}

		// Stop propagation if the event was handled
		if ( refresh || conclude ) {
			event.preventDefault();
			event.stopPropagation();
		}

		// Refresh the display
		if ( refresh ) {
			this.text.text = this._pendingText;
			this.data.width = this.text.width + 100;
			this.data.height = this.text.height + 50;
			this.refresh();
		}

		// Conclude the workflow
		if ( conclude ) {
			this.release();
		}
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/** @override */
	_onUpdate(data) {

		// Fully re-draw when certain core aspects are changed
		const keys = new Set(Object.keys(data));
		const redraw = ["type", "text", "texture", "fontFamily", "fontSize", "textColor"];
		if ( redraw.some(k => keys.has(k)) ) {
			this.draw().then(() => super._onUpdate(data));
		}

		// Otherwise simply refresh the existing drawing
		else super._onUpdate(data);
	}

	/* -------------------------------------------- */
	/*  Permission Controls                         */
	/* -------------------------------------------- */

	/** @override */
	_canControl(user, event) {
		if ( this._creating ) {  // Allow one-time control immediately following creation
			delete this._creating;
			return true;
		}
		if ( this._controlled ) return true;
		if ( game.activeTool !== "select" ) return false;
		return user.isGM || (user.id === this.data.author);
	}

	/* -------------------------------------------- */

	/** @override */
	_canConfigure(user, event) {
		return this._controlled;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	activateListeners() {
		super.activateListeners();
		this.frame.handle.off("mouseover").off("mouseout").off("mousedown")
			.on("mouseover", this._onHandleHoverIn.bind(this))
			.on("mouseout", this._onHandleHoverOut.bind(this))
			.on("mousedown", this._onHandleMouseDown.bind(this));
		this.frame.handle.interactive = true;
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse movement which modifies the dimensions of the drawn shape
	 * @param {PIXI.InteractionEvent} event
	 * @private
	 */
	_onMouseDraw(event) {
		const {destination, originalEvent} = event.data;
		const isShift = originalEvent.shiftKey;
		const isAlt = originalEvent.altKey;

		// Determine position
		let position = destination;
		if ( !isShift && (this.data.type !== CONST.DRAWING_TYPES.FREEHAND) ) {
			position = canvas.grid.getSnappedPosition(position.x, position.y, this.layer.gridPrecision);
		} else {
			position = {x: Math.round(position.x), y: Math.round(position.y)};
		}

		// Drag differently depending on shape type
		switch ( this.data.type ) {

			// Freehand Shapes
			case CONST.DRAWING_TYPES.FREEHAND:
				const now = Date.now();

				// If the time since any drawing activity last occurred exceeds the sample rate - upgrade the prior point
				if ( (now - this._drawTime) >= this.constructor.FREEHAND_SAMPLE_RATE ) {
					this._sampleTime = now;
				}

				// Determine whether the new point should be permanent based on the time since last sample
				let takeSample = (now - this._drawTime) >= this.constructor.FREEHAND_SAMPLE_RATE;
				this._addPoint(position, !takeSample);
				break;

			// Polygon Shapes
			case CONST.DRAWING_TYPES.POLYGON:
				this._addPoint(position, true);
				break;

			// Geometric Shapes
			default:
				let dx = (position.x - this.data.x) || (canvas.dimensions.size * Math.sign(this.data.width) * 0.5);
				let dy = (position.y - this.data.y) || (canvas.dimensions.size * Math.sign(this.data.height) * 0.5);
				if ( isAlt ) {
					dx = Math.abs(dy) < Math.abs(dx) ? Math.abs(dy) * Math.sign(dx) : dx;
					dy = Math.abs(dx) < Math.abs(dy) ? Math.abs(dx) * Math.sign(dy) : dy;
				}
				this.data.update({width: dx, height: dy});
		}

		// Refresh the display
		this.refresh();
	}

	/* -------------------------------------------- */
	/*  Interactivity                               */
	/* -------------------------------------------- */

	/** @override */
	_onDragLeftStart(event) {
		if ( this._dragHandle ) return this._onHandleDragStart(event);
		if ( this._pendingText ) this.data.text = this._pendingText;
		return super._onDragLeftStart(event);
	}

	/* -------------------------------------------- */

	/** @override */
	_onDragLeftMove(event) {
		if ( this._dragHandle ) return this._onHandleDragMove(event);
		return super._onDragLeftMove(event);
	}

	/* -------------------------------------------- */

	/** @override */
	async _onDragLeftDrop(event) {
		if ( this._dragHandle ) return this._onHandleDragDrop(event);

		// Update each dragged Drawing, confirming pending text
		const clones = event.data.clones || [];
		const updates = clones.map(c => {
			let dest = {x: c.data.x, y: c.data.y};
			if ( !event.data.originalEvent.shiftKey ) {
				dest = canvas.grid.getSnappedPosition(c.data.x, c.data.y, this.layer.gridPrecision);
			}

			// Define the update
			const update = {
				_id: c._original.id,
				x: dest.x,
				y: dest.y,
				rotation: c.data.rotation,
				text: c._original._pendingText ? c._original._pendingText : c.data.text
			};

			// Commit pending text
			if ( c._original._pendingText ) {
				update.text = c._original._pendingText;
			}

			// Hide the original until after the update processes
			c._original.visible = false;
			return update;
		});
		return canvas.scene.updateEmbeddedDocuments("Drawing", updates, {diff: false});
	}

	/* -------------------------------------------- */

	/** @override */
	_onDragLeftCancel(event) {
		if ( this._dragHandle ) return this._onHandleDragCancel(event);
		return super._onDragLeftCancel(event);
	}

	/* -------------------------------------------- */
	/*  Resize Handling                             */
	/* -------------------------------------------- */

	/**
	 * Handle mouse-over event on a control handle
	 * @param {PIXI.InteractionEvent} event   The mouseover event
	 * @private
	 */
	_onHandleHoverIn(event) {
		const handle = event.target;
		handle.scale.set(1.5, 1.5);
		event.data["handle"] = event.target;
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-out event on a control handle
	 * @param {PIXI.InteractionEvent} event   The mouseout event
	 * @private
	 */
	_onHandleHoverOut(event) {
		event.data["handle"].scale.set(1.0, 1.0);
	}

	/* -------------------------------------------- */

	/**
	 * When we start a drag event - create a preview copy of the Tile for re-positioning
	 * @param {PIXI.InteractionEvent} event   The mousedown event
	 * @private
	 */
	_onHandleMouseDown(event) {
		if ( !this.data.locked ) {
			this._dragHandle = true;
			this._original = this.document.toJSON();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle the beginning of a drag event on a resize handle
	 * @param {PIXI.InteractionEvent} event   The mouse interaction event
	 * @private
	 */
	_onHandleDragStart(event) {
		const handle = event.data.handle;
		const aw = Math.abs(this.data.width);
		const ah = Math.abs(this.data.height);
		const x0 = this.data.x + (handle.offset[0] * aw);
		const y0 = this.data.y + (handle.offset[1] * ah);
		event.data.origin = {x: x0, y: y0, width: aw, height: ah};
	}

	/* -------------------------------------------- */

	/**
	 * Handle mousemove while dragging a tile scale handler
	 * @param {PIXI.InteractionEvent} event   The mouse interaction event
	 * @private
	 */
	_onHandleDragMove(event) {
		const {destination, origin, originalEvent} = event.data;

		// Pan the canvas if the drag event approaches the edge
		canvas._onDragCanvasPan(originalEvent);

		// Update Drawing dimensions
		const dx = destination.x - origin.x;
		const dy = destination.y - origin.y;
		const update = this._rescaleDimensions(this._original, dx, dy);
		this.document.data.update(update);
		this.refresh();
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouseup after dragging a tile scale handler
	 * @param {PIXI.InteractionEvent} event   The mouseup event
	 * @private
	 */
	_onHandleDragDrop(event) {
		let {destination, origin, originalEvent} = event.data;
		if ( !originalEvent.shiftKey ) {
			destination = canvas.grid.getSnappedPosition(destination.x, destination.y, this.layer.gridPrecision);
		}

		// Update Drawing dimensions
		const dx = destination.x - origin.x;
		const dy = destination.y - origin.y;
		const update = this._rescaleDimensions(this._original, dx, dy);
		return this.document.update(update, {diff: false});
	}

	/* -------------------------------------------- */

	/**
	 * Handle cancellation of a drag event for one of the resizing handles
	 * @private
	 */
	_onHandleDragCancel(event) {
		this.document.data.update(this._original);
		this._dragHandle = false;
		delete this._original;
		this.refresh();
	}

	/* -------------------------------------------- */

	/**
	 * Apply a vectorized rescaling transformation for the drawing data
	 * @param {Object} original     The original drawing data
	 * @param {number} dx           The pixel distance dragged in the horizontal direction
	 * @param {number} dy           The pixel distance dragged in the vertical direction
	 * @private
	 */
	_rescaleDimensions(original, dx, dy) {
		let {points, width, height} = original;
		width += dx;
		height += dy;
		points = points || [];

		// Rescale polygon points
		if ( this.isPolygon ) {
			const scaleX = 1 + (dx / original.width);
			const scaleY = 1 + (dy / original.height);
			points = points.map(p => [p[0]*scaleX, p[1]*scaleY]);
		}

		// Constrain drawing bounds by the contained text size
		if ( this.data.text ) {
			const textBounds = this.text.getLocalBounds();
			width = Math.max(textBounds.width + 16, width);
			height = Math.max(textBounds.height + 8, height);
		}

		// Normalize the shape
		return this.constructor.normalizeShape({
			x: original.x,
			y: original.y,
			width: width,
			height: height,
			points: points
		});
	}

	/* -------------------------------------------- */

	/**
	 * Adjust the location, dimensions, and points of the Drawing before committing the change
	 * @param {Object} data   The Drawing data pending update
	 * @return {Object}       The adjusted data
	 * @private
	 */
	static normalizeShape(data) {

		// Adjust shapes with an explicit points array
		let points = data.points;
		if ( points && points.length ) {

			// De-dupe any points which were repeated in sequence
			points = points.reduce((arr, p1) => {
				let p0 = arr.length ? arr[arr.length - 1] : null;
				if ( !p0 || !p1.equals(p0) ) arr.push(p1);
				return arr;
			}, []);

			// Adjust points for the minimal x and y values
			const [xs, ys] = data.points.reduce((arr, p) => {
				arr[0].push(p[0]);
				arr[1].push(p[1]);
				return arr;
			}, [[], []]);

			// Determine minimal and maximal points
			let minX = Math.min(...xs);
			let maxX = Math.max(...xs);
			let minY = Math.min(...ys);
			let maxY = Math.max(...ys);

			// Normalize points
			points = points.map(p => [p[0] - minX, p[1] - minY]);

			// Update data
			data.x += minX;
			data.y += minY;
			data.width = maxX - minX;
			data.height = maxY - minY;
			data.points = points;
		}

		// Adjust rectangles
		else {
			const {x, y, width, height} = data;
			const adjusted = new NormalizedRectangle(x, y, width, height);
			data.x = adjusted.x;
			data.y = adjusted.y;
			data.width = adjusted.width;
			data.height = adjusted.height;
		}
		return data;
	}

	/* -------------------------------------------- */
	/*  Deprecated                                  */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	get author() {
		console.warn("The Drawing#author property has been deprecated in favor of DrawingDocument#author and support will be removed in 0.9.0");
		return this.document.author;
	}

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	get owner() {
		console.warn("The Drawing#owner property has been deprecated in favor of DrawingDocument#isOwner and support will be removed in 0.9.0");
		return this.document.isOwner;
	}
}

/**
 * An AmbientLight is an implementation of PlaceableObject which represents a dynamic light source within the Scene.
 * @extends {PlaceableObject}
 */
class AmbientLight extends PlaceableObject {
	constructor(document) {
		super(document);

		/**
		 * A reference to the PointSource object which defines this light source area of effect
		 * @type {PointSource}
		 */
		this.source = new PointSource(this, "light");
	}

	/**
	 * A reference to the ControlIcon used to configure this light
	 * @type {ControlIcon}
	 */
	controlIcon

	/* -------------------------------------------- */

	/** @inheritdoc */
	static embeddedName = "AmbientLight";

	/* -------------------------------------------- */

	/** @inheritdoc */
	get bounds() {
		const r = Math.max(this.dimRadius, this.brightRadius);
		return new NormalizedRectangle(this.data.x - r, this.data.y - r, this.data.x + (2*r), this.data.y + (2*r));
	}

	/* -------------------------------------------- */

	/**
	 * Test whether a specific AmbientLight source provides global illumination
	 * @type {boolean}
	 */
	get global() {
		return this.document.isGlobal;
	}

	/* -------------------------------------------- */

	/**
	 * The maximum radius in pixels of the light field
	 * @type {number}
	 */
	get radius() {
		return Math.max(Math.abs(this.dimRadius), Math.abs(this.brightRadius));
	}

	/* -------------------------------------------- */

	/**
	 * Get the pixel radius of dim light emitted by this light source
	 * @type {number}
	 */
	get dimRadius() {
		let d = canvas.dimensions;
		return ((this.data.dim / d.distance) * d.size);
	}

	/* -------------------------------------------- */

	/**
	 * Get the pixel radius of bright light emitted by this light source
	 * @type {number}
	 */
	get brightRadius() {
		let d = canvas.dimensions;
		return ((this.data.bright / d.distance) * d.size);
	}

	/* -------------------------------------------- */

	/**
	 * Is this ambient light is currently visible based on its hidden state and the darkness level of the Scene?
	 * @type {boolean}
	 */
	get isVisible() {
		if ( this.data.hidden ) return false;
		return this.layer.darknessLevel.between(this.data.darkness.min ?? 0, this.data.darkness.max ?? 1);
	}

	/* -------------------------------------------- */
	/* Rendering
	/* -------------------------------------------- */

	/** @inheritdoc */
	async draw() {

		// Draw containers
		this.clear();
		this.field = this.addChild(new PIXI.Graphics());
		this.controlIcon = this.addChild(this._drawControlIcon());

		// Initial rendering
		this.updateSource({defer: true});
		this.refresh();
		if ( this.id ) this.activateListeners();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the ControlIcon for the AmbientLight
	 * @return {ControlIcon}
	 * @private
	 */
	_drawControlIcon() {
		const size = Math.max(Math.round((canvas.dimensions.size * 0.5) / 20) * 20, 40);
		let icon = new ControlIcon({texture: CONFIG.controlIcons.light, size: size });
		icon.x -= (size * 0.5);
		icon.y -= (size * 0.5);
		return icon;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	refresh() {
		const active = this.layer._active;

		// Update position and FOV
		this.position.set(this.data.x, this.data.y);
		this.field.position.set(-this.data.x, -this.data.y);

		// Draw the light preview field
		const l = this.field.clear();
		if ( active ) l.lineStyle(2, 0xEEEEEE, 0.4).drawShape(this.source.fov);

		// Update control icon appearance
		this.refreshControl();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the display of the ControlIcon for this AmbientLight source
	 */
	refreshControl() {
		this.controlIcon.texture = getTexture(this.isVisible ? CONFIG.controlIcons.light : CONFIG.controlIcons.lightOff);
		this.controlIcon.tintColor = this.data.hidden ? 0xFF3300 : 0xFFFFFF;
		this.controlIcon.borderColor = this.data.hidden ? 0xFF3300 : 0xFF5500;
		this.controlIcon.draw();
		this.controlIcon.visible = this.layer._active;
		this.controlIcon.border.visible = this._hover;
	}

	/* -------------------------------------------- */
	/*  Light Source Management                     */
	/* -------------------------------------------- */

	/**
	 * The named identified for the source object associated with this light
	 * @return {string}
	 */
	get sourceId() {
		return "Light." + (this._original?.id ?? this.id ?? "preview");
	}

	/* -------------------------------------------- */

	/**
	 * Update the source object associated with this light
	 * @param {boolean} defer     Defer refreshing the LightingLayer to manually call that refresh later.
	 * @param {boolean} deleted   Indicate that this light source has been deleted.
	 */
	updateSource({defer=false, deleted=false}={}) {
		if ( deleted ) {
			this.layer.sources.delete(this.sourceId);
			return defer ? null : this.layer.refresh();
		}

		// Update source data
		this.source.initialize({
			x: this.data.x,
			y: this.data.y,
			z: this.document.getFlag("core", "priority") || null,
			dim: this.dimRadius,
			bright: this.brightRadius,
			angle: this.data.angle,
			rotation: this.data.rotation,
			color: this.data.tintColor,
			alpha: this.data.tintAlpha,
			animation: this.data.lightAnimation,
			seed: this.document.getFlag("core", "animationSeed"),
			darkness: this.data.darkness,
			type: this.data.t
		});

		// Update the lighting layer sources
		const isActive = (this.source.radius > 0) && !this.data.hidden;
		if ( isActive ) this.layer.sources.set(this.sourceId, this.source);
		else this.layer.sources.delete(this.sourceId);

		// Refresh the layer, unless we are deferring that update
		if ( !defer ) canvas.perception.schedule({lighting: {refresh: true}, sight: {refresh: true}});
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_onCreate(...args) {
		super._onCreate(...args);
		this.updateSource();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onUpdate(...args) {
		this.updateSource();
		super._onUpdate(...args);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDelete(...args) {
		super._onDelete(...args);
		this.updateSource({deleted: true});
	}

	/* -------------------------------------------- */
	/*  Mouse Interaction Handlers                  */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_canHUD(user, event) {
		return user.isGM; // Allow GMs to single right-click
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_canConfigure(user, event) {
		return false; // Double-right does nothing
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onClickRight(event) {
		this.document.update({hidden: !this.data.hidden});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftStart(event) {
		this.layer.deactivateAnimation();
		super._onDragLeftStart(event);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftMove(event) {
		super._onDragLeftMove(event);
		const clones = event.data["clones"] || [];
		for ( let c of clones ) {
			c.updateSource({defer: true});
		}
		this.layer.refresh();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftCancel(event) {
		super._onDragLeftCancel(event);
		this.updateSource();
		this.layer.activateAnimation();
	}
}

/**
 * A Note is an implementation of PlaceableObject which represents an annotated location within the Scene.
 * Each Note links to a JournalEntry entity and represents it's location on the map.
 * @extends {PlaceableObject}
 */
class Note extends PlaceableObject {

	/** @inheritdoc */
	static embeddedName = "Note";

	/* -------------------------------------------- */

	/**
	 * The associated JournalEntry which is referenced by this Note
	 * @type {JournalEntry}
	 */
	get entry() {
		return this.document.entry;
	}

	/* -------------------------------------------- */

	/**
	 * The text label used to annotate this Note
	 * @type {string}
	 */
	get text() {
		return this.document.label;
	}

	/* -------------------------------------------- */

	/**
	 * The Map Note icon size
	 * @type {number}
	 */
	get size() {
		return this.data.iconSize || 40;
	}

	/* -------------------------------------------- */
	/* Rendering
	/* -------------------------------------------- */

	/** @inheritdoc */
	async draw() {
		this.clear();

		// Draw the control icon
		this.controlIcon = this.addChild(this._drawControlIcon());

		// Draw the note tooltip
		this.tooltip = this.addChild(this._drawTooltip());

		// Refresh the current display
		this.refresh();

		// Add control interactivity if the placeable has an ID
		if ( this.id ) this.activateListeners();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the ControlIcon for the Map Note
	 * @returns {ControlIcon}
	 * @protected
	 */
	_drawControlIcon() {
		let tint = this.data.iconTint ? foundry.utils.colorStringToHex(this.data.iconTint) : null;
		let icon = new ControlIcon({texture: this.data.icon, size: this.size, tint: tint});
		icon.x -= (this.size / 2);
		icon.y -= (this.size / 2);
		return icon;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the map note Tooltip as a Text object
	 * @returns {PIXI.Text}
	 * @protected
	 */
	_drawTooltip() {

		// Create the Text object
		const textStyle = this._getTextStyle();
		const text = new PreciseText(this.text, textStyle);
		text.visible = false;
		const halfPad = (0.5 * this.size) + 12;

		// Configure Text position
		switch ( this.data.textAnchor ) {
			case CONST.TEXT_ANCHOR_POINTS.CENTER:
				text.anchor.set(0.5, 0.5);
				text.position.set(0, 0);
				break;
			case CONST.TEXT_ANCHOR_POINTS.BOTTOM:
				text.anchor.set(0.5, 0);
				text.position.set(0, halfPad);
				break;
			case CONST.TEXT_ANCHOR_POINTS.TOP:
				text.anchor.set(0.5, 1);
				text.position.set(0, -halfPad);
				break;
			case CONST.TEXT_ANCHOR_POINTS.LEFT:
				text.anchor.set(1, 0.5);
				text.position.set(-halfPad, 0);
				break;
			case CONST.TEXT_ANCHOR_POINTS.RIGHT:
				text.anchor.set(0, 0.5);
				text.position.set(halfPad, 0);
				break;
		}
		return text;
	}

	/* -------------------------------------------- */

	/**
	 * Define a PIXI TextStyle object which is used for the tooltip displayed for this Note
	 * @returns {PIXI.TextStyle}
	 * @protected
	 */
	_getTextStyle() {
		const style = CONFIG.canvasTextStyle.clone();

		// Positioning
		if ( this.data.textAnchor === CONST.TEXT_ANCHOR_POINTS.LEFT ) style.align = "right";
		else if ( this.data.textAnchor === CONST.TEXT_ANCHOR_POINTS.RIGHT ) style.align = "left";

		// Font preferences
		style.fontFamily = this.data.fontFamily || CONFIG.defaultFontFamily;
		style.fontSize = this.data.fontSize;

		// Toggle stroke style depending on whether the text color is dark or light
		const color = this.data.textColor ? foundry.utils.colorStringToHex(this.data.textColor) : 0xFFFFFF;
		const hsv = foundry.utils.rgbToHsv(...foundry.utils.hexToRGB(color));
		style.fill = color;
		style.strokeThickness = 4;
		style.stroke = hsv[2] > 0.6 ? 0x000000 : 0xFFFFFF;
		return style;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	refresh() {
		this.position.set(this.data.x, this.data.y);
		this.controlIcon.border.visible = this._hover;
		this.tooltip.visible = this._hover;
		this.visible = this.entry?.testUserPermission(game.user, "LIMITED") ?? true;
		return this;
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @override */
	_onUpdate(data) {
		this.draw();
	}

	/* -------------------------------------------- */

	/** @override */
	_canHover(user) {
		return true;
	}

	/* -------------------------------------------- */

	/** @override */
	_canView(user) {
		return this.entry?.testUserPermission(game.user, "LIMITED") ?? false;
	}

	/* -------------------------------------------- */

	/** @override */
	_canConfigure(user) {
		return canvas.notes._active && this.document.canUserModify(game.user, "update");
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onHoverIn(event, options) {
		this.zIndex = Math.max(...this.layer.placeables.map(n => n.data.z || 0)) + 1;
		return super._onHoverIn(event, options);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onHoverOut(event) {
		this.zIndex = this.data.z;
		return super._onHoverOut(event);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onClickLeft2(event) {
		if ( this.entry ) this.entry.sheet.render(true);
	}
}

/**
 * An AmbientSound is an implementation of PlaceableObject which represents a dynamic audio source within the Scene.
 * @extends {PlaceableObject}
 */
class AmbientSound extends PlaceableObject {
	constructor(...args) {
		super(...args);

		/**
		 * The Sound which manages playback for this AmbientSound effect
		 * @type {Sound|null}
		 */
		this.sound = this._createSound();
	}

	/** @inheritdoc */
	static embeddedName ="AmbientSound";

	/* -------------------------------------------- */

	/**
	 * Create a Sound used to play this AmbientSound object
	 * @returns {Sound|null}
	 * @private
	 */
	_createSound() {
		if ( !this.id || !this.data.path ) return null;
		return game.audio.create({
			src: this.data.path,
			preload: true,
			autoplay: false,
			singleton: true
		});
	}

	/* -------------------------------------------- */
	/* Properties
	/* -------------------------------------------- */

	/**
	 * Is this ambient sound is currently audible based on its hidden state and the darkness level of the Scene?
	 * @type {boolean}
	 */
	get isAudible() {
		if ( this.data.hidden ) return false;
		return canvas.lighting.darknessLevel.between(this.data.darkness.min ?? 0, this.data.darkness.max ?? 1);
	}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor for the sound type
	 * @type {string}
	 */
	get type() {
		return this.document.type;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor for the sound radius in pixels
	 * @type {number}
	 */
	get radius() {
		let d = canvas.dimensions;
		return ((this.data.radius / d.distance) * d.size);
	}

	/* -------------------------------------------- */
	/* Methods
	/* -------------------------------------------- */

	/**
	 * Toggle playback of the sound depending on whether or not it is audible
	 * @param {boolean} isAudible     Is the sound audible?
	 * @param {number} volume         The target playback volume
	 * @param {object} [options={}]   Additional options which affect sound synchronization
	 * @param {number} [options.fade=250]  A duration in milliseconds to fade volume transition
	 */
	sync(isAudible, volume, {fade=250}={}) {
		const sound = this.sound;
		if ( !sound ) return;
		if ( !sound.loaded ) {
			if ( sound.loading instanceof Promise ) {
				sound.loading.then(() => this.sync(isAudible, volume, {fade}));
			}
			return;
		}

		// Fade the sound out if not currently audible
		if ( !isAudible ) {
			if ( !sound.playing || (sound.volume === 0) ) return;
			if ( fade ) sound.fade(0, {duration: fade});
			else sound.volume = 0;
			return;
		}

		// Begin playback at the desired volume
		if ( !sound.playing ) sound.play({volume: 0, loop: true});

		// Adjust the target volume
		const targetVolume = (volume ?? this.data.volume) * game.settings.get("core", "globalAmbientVolume");
		if ( fade ) sound.fade(targetVolume, {duration: fade});
		else sound.volume = targetVolume;
	}

	/* -------------------------------------------- */
	/* Rendering
	/* -------------------------------------------- */

	/** @inheritdoc */
	clear() {
		if ( this.controlIcon ) {
			this.controlIcon.parent.removeChild(this.controlIcon).destroy();
			this.controlIcon = null;
		}
		return super.clear();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async draw() {

		// Draw containers
		this.clear();
		this.field = this.drawField();
		this.controlIcon = this.addChild(this._drawControlIcon());

		// Initial rendering
		this.updateSource();
		if ( this.id ) this.activateListeners();

		// Refresh the current display
		this.refresh();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the graphical preview of the audio source area of effect
	 * @return {PIXI.Container}
	 * @private
	 */
	drawField() {
		let field = new PIXI.Container();
		field.light = field.addChild(new PIXI.Graphics());
		field.msk = field.addChild(new PIXI.Graphics());
		field.mask = field.msk;
		return this.addChild(field);
	}

	/* -------------------------------------------- */

	/**
	 * Draw the ControlIcon for the AmbientLight
	 * @return {ControlIcon}
	 * @private
	 */
	_drawControlIcon() {
		const size = Math.max(Math.round((canvas.dimensions.size * 0.5) / 20) * 20, 40);
		let icon = new ControlIcon({texture: CONFIG.controlIcons.sound, size: size});
		icon.x -= (size * 0.5);
		icon.y -= (size * 0.5);
		return icon;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	refresh() {

		// Update position and FOV
		this.position.set(this.data.x, this.data.y);

		// Draw the light field
		const displayHidden = this.id && (this.data.hidden || !this.data.path);
		this.field.light.clear()
			.beginFill(0xAADDFF, displayHidden ? 0 : 0.15)
			.lineStyle(1, 0xFFFFFF, 0.5)
			.drawCircle(0, 0, this.radius)
			.endFill();

		// Global light is not masked
		if ( this.type === "g" ) {
			this.field.msk.clear();
			this.field.mask = null;
		}

		// Local light is masked by the FOV polygon
		else {
			this.field.msk.clear()
				.beginFill(0xFFFFFF)
				.drawPolygon(this.fov)
				.endFill();
			this.field.msk.position.set(-this.data.x, -this.data.y);
			this.field.mask = this.field.msk;
		}

		// Update control icon appearance
		this.refreshControl();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the display of the ControlIcon for this AmbientSound source
	 */
	refreshControl() {
		const isHidden = this.id && (this.data.hidden || !this.data.path);
		this.controlIcon.tintColor = isHidden ? 0xFF3300 : 0xFFFFFF;
		this.controlIcon.borderColor = isHidden ? 0xFF3300 : 0xFF5500;
		this.controlIcon.texture = getTexture(this.isAudible ? CONFIG.controlIcons.sound : CONFIG.controlIcons.soundOff);
		this.controlIcon.draw();
		this.controlIcon.visible = this.layer._active;
		this.controlIcon.border.visible = this._hover;
	}

	/* -------------------------------------------- */

	/**
	 * Compute the field-of-vision for an object, determining its effective line-of-sight and field-of-vision polygons
	 * @returns {Object}      An object containing the rays, LOS polygon, and FOV polygon for the light
	 */
	updateSource() {
		const center = this.center;
		const radius = this.radius + (canvas.dimensions.size * 0.1);
		const polygons = this.type === "g" ?
			{rays: null, los: null, fov: new PIXI.Circle(center.x, center.y, this.radius)} :
			canvas.walls.computePolygon(center, radius, {type: "sound"});
		this.vision = { los: polygons.los, fov: polygons.fov };
		return polygons;
	}

	/* -------------------------------------------- */
	/*  Document Event Handlers                     */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_onCreate(...args) {
		super._onCreate(...args);
		canvas.perception.schedule({ sounds: {refresh: true} });
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onUpdate(data, ...args) {
		if ( "path" in data ) {
			if ( this.sound ) this.sound.stop();
			this.sound = this._createSound();
		}

		// Update the source polygon
		if ( ["x", "y", "radius", "type"].some(k => k in data) ) this.updateSource();

		// Standard sound updates
		super._onUpdate(data, ...args);
		canvas.perception.schedule({ sounds: {refresh: true} });
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDelete(...args) {
		super._onDelete(...args);
		if ( this.sound ) {
			if ( !this.sound.loaded && (this.sound.loading instanceof Promise) ) {
				this.sound.loading.then(() => this.sound.stop());
			}
			else this.sound.stop();
		}
		canvas.perception.schedule({ sounds: {refresh: true} });
	}

	/* -------------------------------------------- */
	/*  Interaction Event Handlers                  */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_canHUD(user, event) {
		return user.isGM; // Allow GMs to single right-click
	}

	/** @inheritdoc */
	_canConfigure(user, event) {
		return false; // Double-right does nothing
	}

	/** @inheritdoc */
	_onClickRight(event) {
		this.document.update({hidden: !this.data.hidden});
	}

	/** @override */
	_onDragLeftMove(event) {
		const {clones, destination, origin, originalEvent} = event.data;
		canvas._onDragCanvasPan(originalEvent);
		const dx = destination.x - origin.x;
		const dy = destination.y - origin.y;
		for ( let c of clones || [] ) {
			c.data.x = c._original.data.x + dx;
			c.data.y = c._original.data.y + dy;
			c.updateSource();
			c.refresh();
		}
	}
}

/**
 * A MeasuredTemplate is an implementation of PlaceableObject which represents an area of the canvas grid which is
 * covered by some effect.
 * @extends {PlaceableObject}
 */
class MeasuredTemplate extends PlaceableObject {
	constructor(document) {
		super(document);

		// Draw portions of the content
		this.controlIcon = null;
		this.template = null;
		this.ruler = null;

		/**
		 * The tiling texture used for this template, if any
		 * @type {PIXI.Texture}
		 */
		this.texture = null;

		/**
		 * The template shape used for testing point intersection
		 * @type {PIXI.Circle | PIXI.Ellipse | PIXI.Polygon | PIXI.Rectangle | PIXI.RoundedRectangle}
		 */
		this.shape = null;

		/**
		 * Create a highlighting layer to use for this Template
		 */
		canvas.grid.addHighlightLayer(`Template.${this.id}`);

		/**
		 * Internal property used to configure the control border thickness
		 * @type {number}
		 * @private
		 */
		this._borderThickness = 3;
	}

	/** @inheritdoc */
	static embeddedName = "MeasuredTemplate";

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * A convenience accessor for the border color as a numeric hex code
	 * @return {number}
	 */
	get borderColor() {
		return this.data.borderColor ? this.data.borderColor.replace("#", "0x") : 0x000000;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor for the fill color as a numeric hex code
	 * @return {number}
	 */
	get fillColor() {
		return this.data.fillColor ? this.data.fillColor.replace("#", "0x") : 0x000000;
	}

	/* -------------------------------------------- */

	/**
	 * A flag for whether the current User has full ownership over the MeasuredTemplate document.
	 * @type {boolean}
	 */
	get owner() {
		return this.document.isOwner;
	}

	/* -------------------------------------------- */
	/*  Rendering
	/* -------------------------------------------- */

	/** @override */
	async draw() {
		this.clear();

		// Load the texture
		if ( this.data.texture ) {
			this.texture = await loadTexture(this.data.texture, {fallback: 'icons/svg/hazard.svg'});
		} else {
			this.texture = null;
		}

		// Template shape
		this.template = this.addChild(new PIXI.Graphics());

		// Rotation handle
		this.handle = this.addChild(new PIXI.Graphics());

		// Draw the control icon
		this.controlIcon = this.addChild(this._drawControlIcon());

		// Draw the ruler measurement
		this.ruler = this.addChild(this._drawRulerText());

		// Update the shape and highlight grid squares
		this.refresh();
		this.highlightGrid();

		// Enable interactivity, only if the Tile has a true ID
		if ( this.id ) this.activateListeners();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the ControlIcon for the MeasuredTemplate
	 * @return {ControlIcon}
	 * @private
	 */
	_drawControlIcon() {
		const size = Math.max(Math.round((canvas.dimensions.size * 0.5) / 20) * 20, 40);
		let icon = new ControlIcon({texture: CONFIG.controlIcons.template, size: size});
		icon.x -= (size * 0.5);
		icon.y -= (size * 0.5);
		return icon;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the Text label used for the MeasuredTemplate
	 * @return {PreciseText}
	 * @private
	 */
	_drawRulerText() {
		const style = CONFIG.canvasTextStyle.clone();
		style.fontSize = Math.max(Math.round(canvas.dimensions.size * 0.36 * 12) / 12, 36);
		const text = new PreciseText(null, style);
		text.anchor.set(0, 1);
		return text;
	}

	/* -------------------------------------------- */

	/** @override */
	refresh() {
		let d = canvas.dimensions;
		this.position.set(this.data.x, this.data.y);

		// Extract and prepare data
		let {direction, distance, angle, width} = this.data;
		distance *= (d.size / d.distance);
		width *= (d.size / d.distance);
		direction = Math.toRadians(direction);

		// Create ray and bounding rectangle
		this.ray = Ray.fromAngle(this.data.x, this.data.y, direction, distance);

		// Get the Template shape
		switch ( this.data.t ) {
			case "circle":
				this.shape = this._getCircleShape(distance);
				break;
			case "cone":
				this.shape = this._getConeShape(direction, angle, distance);
				break;
			case "rect":
				this.shape = this._getRectShape(direction, distance);
				break;
			case "ray":
				this.shape = this._getRayShape(direction, distance, width);
		}

		// Draw the Template outline
		this.template.clear()
			.lineStyle(this._borderThickness, this.borderColor, 0.75)
			.beginFill(0x000000, 0.0);

		// Fill Color or Texture
		if ( this.texture ) this.template.beginTextureFill({
			texture: this.texture
		});
		else this.template.beginFill(0x000000, 0.0);

		// Draw the shape
		this.template.drawShape(this.shape);

		// Draw origin and destination points
		this.template.lineStyle(this._borderThickness, 0x000000)
			.beginFill(0x000000, 0.5)
			.drawCircle(0, 0, 6)
			.drawCircle(this.ray.dx, this.ray.dy, 6);

		// Update visibility
		this.controlIcon.visible = this.layer._active;
		this.controlIcon.border.visible = this._hover;

		// Draw ruler text
		this._refreshRulerText();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Get a Circular area of effect given a radius of effect
	 * @private
	 */
	_getCircleShape(distance) {
		return new PIXI.Circle(0, 0, distance);
	}

	/* -------------------------------------------- */

	/**
	 * Get a Conical area of effect given a direction, angle, and distance
	 * @private
	 */
	_getConeShape(direction, angle, distance) {
		angle = angle || 90;
		const coneType = game.settings.get("core", "coneTemplateType");

		// For round cones - approximate the shape with a ray every 3 degrees
		let angles;
		if ( coneType === "round" ) {
			const da = Math.min(angle, 3);
			angles = Array.fromRange(Math.floor(angle/da)).map(a => (angle/-2) + (a*da)).concat([angle/2]);
		}

		// For flat cones, direct point-to-point
		else {
			angles = [(angle/-2), (angle/2)];
			distance /= Math.cos(Math.toRadians(angle/2));
		}

		// Get the cone shape as a polygon
		const rays = angles.map(a => Ray.fromAngle(0, 0, direction + Math.toRadians(a), distance+1));
		const points = rays.reduce((arr, r) => {
			return arr.concat([r.B.x, r.B.y]);
		}, [0, 0]).concat([0, 0]);
		return new PIXI.Polygon(points);
	}

	/* -------------------------------------------- */

	/**
	 * Get a Rectangular area of effect given a width and height
	 * @private
	 */
	_getRectShape(direction, distance) {
		let d = canvas.dimensions,
				r = Ray.fromAngle(0, 0, direction, distance),
				dx = Math.round(r.dx / (d.size / 2)) * (d.size / 2),
				dy = Math.round(r.dy / (d.size / 2)) * (d.size / 2);

		// Create rectangle shape and draw
		return new NormalizedRectangle(0, 0, dx + Math.sign(dx), dy + Math.sign(dy));
	}

	/* -------------------------------------------- */

	/**
	 * Get a rotated Rectangular area of effect given a width, height, and direction
	 * @private
	 */
	_getRayShape(direction, distance, width) {
		let up = Ray.fromAngle(0, 0, direction - Math.toRadians(90), (width / 2)+1),
				down = Ray.fromAngle(0, 0, direction + Math.toRadians(90), (width / 2)+1),
				l1 = Ray.fromAngle(up.B.x, up.B.y, direction, distance+1),
				l2 = Ray.fromAngle(down.B.x, down.B.y, direction, distance+1);

		// Create Polygon shape and draw
		const points = [down.B.x, down.B.y, up.B.x, up.B.y, l1.B.x, l1.B.y, l2.B.x, l2.B.y, down.B.x, down.B.y];
		return new PIXI.Polygon(points);
	}

	/* -------------------------------------------- */

	/**
	 * Draw the rotation control handle and assign event listeners
	 * @private
	 */
	_drawRotationHandle(radius) {
		this.handle.clear()
			.lineStyle(this._borderThickness, 0x000000)
			.beginFill(this.borderColor, 1.0)
			.drawCircle(0, 0, radius);
	}

	/* -------------------------------------------- */

	/**
	 * Update the displayed ruler tooltip text
	 * @private
	 */
	_refreshRulerText() {
		let text;
		let u = canvas.scene.data.gridUnits;
		if ( this.data.t === "rect" ) {
			let d = canvas.dimensions;
			let dx = Math.round(this.ray.dx) * (d.distance / d.size);
			let dy = Math.round(this.ray.dy) * (d.distance / d.size);
			let w = Math.round(dx * 10) / 10;
			let h = Math.round(dy * 10) / 10;
			text = `${w}${u} x ${h}${u}`;
		} else {
			let d = Math.round(this.data.distance * 10) / 10;
			text = `${d}${u}`;
		}
		this.ruler.text = text;
		this.ruler.position.set(this.ray.dx + 10, this.ray.dy + 5);
	}

	/* -------------------------------------------- */

	/**
	 * Highlight the grid squares which should be shown under the area of effect
	 */
	highlightGrid() {
		const grid = canvas.grid;
		const d = canvas.dimensions;
		const border = this.borderColor;
		const color = this.fillColor;

		// Only highlight for objects which have a defined shape
		if ( !this.id || !this.shape ) return;

		// Clear existing highlight
		const hl = grid.getHighlightLayer(`Template.${this.id}`);
		hl.clear();

		// If we are in gridless mode, highlight the shape directly
		if ( grid.type === CONST.GRID_TYPES.GRIDLESS ) {
			const shape = this.shape.clone();
			if ( "points" in shape ) {
				shape.points = shape.points.map((p, i) => {
					if ( i % 2 ) return this.y + p;
					else return this.x + p;
				});
			} else {
				shape.x += this.x;
				shape.y += this.y;
			}
			return grid.grid.highlightGridPosition(hl, {border, color, shape});
		}

		// Get number of rows and columns
		const nr = Math.ceil(((this.data.distance * 1.5) / d.distance) / (d.size / grid.h));
		const nc = Math.ceil(((this.data.distance * 1.5) / d.distance) / (d.size / grid.w));

		// Get the offset of the template origin relative to the top-left grid space
		const [tx, ty] = canvas.grid.getTopLeft(this.data.x, this.data.y);
		const [row0, col0] = grid.grid.getGridPositionFromPixels(tx, ty);
		const hx = canvas.grid.w / 2;
		const hy = canvas.grid.h / 2;
		const isCenter = (this.data.x - tx === hx) && (this.data.y - ty === hy);

		// Identify grid coordinates covered by the template Graphics
		for (let r = -nr; r < nr; r++) {
			for (let c = -nc; c < nc; c++) {
				let [gx, gy] = canvas.grid.grid.getPixelsFromGridPosition(row0 + r, col0 + c);
				const testX = (gx+hx) - this.data.x;
				const testY = (gy+hy) - this.data.y;
				let contains = ((r === 0) && (c === 0) && isCenter ) || this.shape.contains(testX, testY);
				if ( !contains ) continue;
				grid.grid.highlightGridPosition(hl, {x: gx, y: gy, border, color});
			}
		}
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/** @override */
	async rotate(angle, snap) {
		const direction = this._updateRotation({angle, snap});
		return this.document.update({direction});
	}

	/* -------------------------------------------- */
	/*  Interactivity                               */
	/* -------------------------------------------- */

	/** @override */
	_canControl(user, event) {
		return user.isGM || (user.id === this.data.user);
	}

	/** @override */
	_canConfigure(user, event) {
		return this._canControl(user, event);
	}

	/** @override */
	_canView(user, event) {
		return this._canControl(user, event);
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/** @override */
	_onUpdate(data, options, userId) {

		// If the texture or type was changed, we need to re-draw the whole thing
		const changed = new Set(Object.keys(data));
		const redraw = ["texture", "type"];
		if ( redraw.some(k => changed.has(k)) ) return this.draw();

		// Otherwise refresh the display and highlighting
		super._onUpdate(data, options, userId);
		this.highlightGrid();
	}

	/* -------------------------------------------- */

	/** @override */
	_onDelete(options, userId) {
		canvas.grid.destroyHighlightLayer(`Template.${this.id}`);
		return super._onDelete(options, userId);
	}
}


/**
 * A Tile is an implementation of PlaceableObject which represents a static piece of artwork or prop within the Scene.
 * Tiles are drawn inside a {@link BackgroundLayer} container.
 * @extends {PlaceableObject}
 *
 * @see {@link TileDocument}
 * @see {@link BackgroundLayer}
 * @see {@link TileSheet}
 * @see {@link TileHUD}
 */
class Tile extends PlaceableObject {

	/* -------------------------------------------- */
	/*  Attributes                                  */
	/* -------------------------------------------- */

	/**
	 * The Tile border frame
	 * @extends {PIXI.Container}
	 * @property {PIXI.Graphics} border
	 * @property {ResizeHandle} handle
	 */
	frame;

	/**
	 * The primary tile image texture
	 * @type {PIXI.Texture}
	 */
	texture;

	/**
	 * The Tile image sprite
	 * @type {PIXI.Sprite}
	 */
	tile;

	/**
	 * A Tile background which is displayed if no valid image texture is present
	 * @type {PIXI.Graphics}
	 */
	bg;

	/**
	 * A cached mapping of non-transparent pixels
	 * @type {{minX: number, minY: number, maxX: number, maxY: number, pixels: Uint8Array|undefined, texture: PIXI.RenderTexture|undefined}}
	 * @private
	 */
	_alphaMap;

	/**
	 * A flag which tracks whether the overhead tile is currently in an occluded state
	 * @type {boolean}
	 */
	occluded = false;

	/** @inheritdoc */
	static embeddedName = "Tile";

	/* -------------------------------------------- */

	/**
	 * Get the native aspect ratio of the base texture for the Tile sprite
	 * @type {number}
	 */
	get aspectRatio() {
		if (!this.texture) return 1;
		let tex = this.texture.baseTexture;
		return (tex.width / tex.height);
	}

	/* -------------------------------------------- */

	/**
	 * The HTML source element for the primary Tile texture
	 * @type {HTMLImageElement|HTMLVideoElement}
	 */
	get sourceElement() {
		return this.texture?.baseTexture.resource.source;
	}

	/* -------------------------------------------- */

	/**
	 * Does this Tile depict an animated video texture?
	 * @type {boolean}
	 */
	get isVideo() {
		const source = this.sourceElement;
		return source?.tagName === "VIDEO";
	}

	/* -------------------------------------------- */

	/**
	 * Is this tile a roof
	 * @returns {boolean}
	 */
	get isRoof() {
		const inForeground = this.parent?.parent === canvas.foreground;
		return inForeground && (this.data.occlusion.mode === CONST.TILE_OCCLUSION_MODES.ROOF);
	}

	/* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */

	/** @inheritdoc */
	async draw() {
		this.clear();

		// Create the image texture
		this.tile = undefined;
		if ( this.data.img ) {
			this.texture = await loadTexture(this.data.img, {fallback: 'icons/svg/hazard.svg'});
			if ( this.texture?.valid ) {

				// Allow for a TilingSprite to be used, if desired by API developers
				const isTiling = this.document.getFlag("core", "isTilingSprite");
				const spriteCls = isTiling ? PIXI.TilingSprite : PIXI.Sprite;

				// Create and anchor the Sprite to the parent container
				this.tile = this.addChild(new spriteCls(this.texture));
				this.tile.anchor.set(0.5, 0.5);

				// Additional configuration for tiling sprites
				if ( isTiling ) {
					this.tile.width = this.data.width;
					this.tile.height = this.data.height;
					// FIXME: This is a workaround currently needed for TilingSprite textures due to a presumed upstream PIXI bug
					this.texture.baseTexture.mipmap = PIXI.MIPMAP_MODES.OFF;
					this.texture.baseTexture.update();
				}
			}
			this.bg = undefined;
		}

		// If there was no valid texture, display a background
		if ( !this.tile ) {
			this.texture = null;
			this.tile = undefined;
			this.bg = this.addChild(new PIXI.Graphics());
		}

		// Create the outer frame for the border and interaction handles
		this.frame = this.addChild(new PIXI.Container());
		this.frame.border = this.frame.addChild(new PIXI.Graphics());
		this.frame.handle = this.frame.addChild(new ResizeHandle([1, 1]));

		// Refresh the current display
		this.refresh();
		this.zIndex = this.data.z;

		// The following options do not apply to preview tiles
		if ( this.id && this.parent ) {

			// Configure Video playback
			if ( this.isVideo ) this.play();

			// Create an alpha map of the tile's pixels
			this._createAlphaMap({
				keepPixels: this.data.overhead,
				keepTexture: this.isRoof
			});

			// Apply an overhead occlusion filter
			if ( this.tile ) {
				this.occlusionFilter = this.data.overhead ? this._createOcclusionFilter() : undefined;
				this.tile.filters = this.data.overhead ? [this.occlusionFilter] : [];
			}

			// Enable interactivity
			this.activateListeners();
		}
		return this;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	refresh() {
		const aw = Math.abs(this.data.width);
		const ah = Math.abs(this.data.height);
		const r = Math.toRadians(this.data.rotation);

		// Update tile appearance
		this.position.set(this.data.x, this.data.y);
		if ( this.tile ) {

			// Tile position
			this.tile.scale.x = this.data.width / this.texture.width;
			this.tile.scale.y = this.data.height / this.texture.height;
			this.tile.position.set(aw/2, ah/2);
			this.tile.rotation = r;

			// Tile appearance
			this.tile.alpha = this.data.hidden ? Math.min(0.5, this.data.alpha) : this.data.alpha;
			this.tile.tint = this.data.tint ? foundry.utils.colorStringToHex(this.data.tint) : 0xFFFFFF;
		}

		// Temporary tile background
		if ( this.bg ) this.bg.clear().beginFill(0xFFFFFF, 0.5).drawRect(0, 0, this.data.width, this.data.height).endFill();

		// Define bounds and update the border frame
		let bounds = ( this.data.width === this.data.height ) ?
			new NormalizedRectangle(0, 0, this.data.width, this.data.height) : // Square tiles
			NormalizedRectangle.fromRotation(0, 0, this.data.width, this.data.height, r); // Non-square tiles
		this.hitArea = this._controlled ? bounds.clone().pad(20) : bounds;
		this._refreshBorder(bounds);
		this._refreshHandle(bounds);

		// Set visibility
		this.visible = !this.data.hidden || game.user.isGM;
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the display of the Tile border
	 * @private
	 */
	_refreshBorder(b) {
		const border = this.frame.border;

		// Determine border color
		const colors = CONFIG.Canvas.dispositionColors;
		let bc = colors.INACTIVE;
		if ( this._controlled ) {
			bc = this.data.locked ? colors.HOSTILE : colors.CONTROLLED;
		}

		// Draw the tile border
		const t = CONFIG.Canvas.objectBorderThickness;
		const h = Math.round(t/2);
		const o = Math.round(h/2);
		border.clear()
			.lineStyle(t, 0x000000, 1.0).drawRoundedRect(b.x-o, b.y-o, b.width+h, b.height+h, 3)
			.lineStyle(h, bc, 1.0).drawRoundedRect(b.x-o, b.y-o, b.width+h, b.height+h, 3);
		border.visible = this._hover || this._controlled;
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the display of the Tile resizing handle
	 * @protected
	 */
	_refreshHandle(b) {
		this.frame.handle.refresh(b);
		this.frame.handle.visible = this._controlled && !this.data.locked;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Play video for this Tile (if applicable).
	 * @param {boolean} [playing]     Should the Tile video be playing?
	 * @param {object} [options={}]   Additional options for modifying video playback
	 * @param {boolean} [options.loop]    Should the video loop?
	 * @param {number} [options.offset]   A specific timestamp between 0 and the video duration to begin playback
	 * @param {number} [options.volume]   Desired volume level of the video's audio channel (if any)
	 */
	play(playing, {loop, offset, volume}={}) {
		const el = this.sourceElement;
		if ( el?.tagName !== "VIDEO" ) return;
		playing = playing ?? this.data.video.autoplay;
		el.loop = loop ?? this.data.video.loop;
		el.volume = volume ?? this.data.video.volume;
		el.muted = el.volume === 0;
		if ( typeof offset === "number" ) el.currentTime = Math.clamped(offset, 0, el.duration);
		if ( playing ) game.video.play(el);
		else el.pause();
	}

	/* -------------------------------------------- */

	/**
	 * Update the occlusion rendering for this overhead Tile for a given controlled Token.
	 * @param {Token[]} tokens     The set of currently controlled Token objects
	 */
	updateOcclusion(tokens) {
		const m = this.data.occlusion.mode;
		let occluded = false;
		if ( m !== CONST.TILE_OCCLUSION_MODES.NONE ) {
			for ( let token of tokens ) {
				occluded = this.testOcclusion(token, {corners: m !== CONST.TILE_OCCLUSION_MODES.ROOF});
				if (occluded) break;
			}
		}
		this.occluded = occluded;
	}

	/* -------------------------------------------- */

	/**
	 * Test whether a specific Token occludes this overhead tile.
	 * Occlusion is tested against 9 points, the center, the four corners-, and the four cardinal directions
	 * @param {Token} token       The Token to test
	 * @param {object} [options]  Additional options that affect testing
	 * @param {boolean} [options.corners=true]  Test corners of the hit-box in addition to the token center?
	 * @returns {boolean}         Is the Token occluded by the Tile?
	 */
	testOcclusion(token, {corners=true}={}) {
		const w = token.w;
		const h = token.h;
		let testPoints = [[w/2,h/2]];
		if ( corners ) {
			const cornerPoints = [[0,0], [w/2,0], [w,0], [w,h/2], [w,h], [w/2,h], [0,h], [0,h/2]];
			testPoints = testPoints.concat(cornerPoints);
		}
		for ( let p of testPoints ) {
			if ( this.containsPixel(token.data.x + p[0], token.data.y + p[1]) ) return true;
		}
		return false;
	}

	/* -------------------------------------------- */

	/**
	 * Test whether the Tile pixel data contains a specific point in canvas space
	 * @param {number} x
	 * @param {number} y
	 * @returns {boolean}
	 */
	containsPixel(x, y) {
		const m = this._alphaMap;

		// Normalize to Tile coordinates
		x -= this.data.x;
		y -= this.data.y;

		// Account for tile rotation
		if ( this.data.rotation !== 0 ) {
			const anchor = {x: this.tile.anchor.x * this.data.width, y: this.tile.anchor.y * this.data.height};
			let r = new Ray(anchor, {x, y});
			r = r.shiftAngle(-this.tile.rotation);
			x = r.B.x;
			y = r.B.y;
		}

		// First test against the bounding box
		if ( (x < m.minX) || (x > m.maxX) ) return false;
		if ( (y < m.minY) || (y > m.maxY) ) return false;

		// Next test a specific pixel
		const px = (Math.round(y) * Math.round(Math.abs(this.data.width))) + Math.round(x);
		return this._alphaMap.pixels[px] === 1;
	}

	/* -------------------------------------------- */

	/**
	 * Draw a sprite for the Roof which can be deducted from the fog exploration container
	 * @returns {PIXI.Sprite}
	 */
	getRoofSprite() {
		if ( !this._alphaMap.texture ) return undefined;
		const s = new PIXI.Sprite(this._alphaMap.texture);
		const t = this.tile;
		s.width = t.width;
		s.height = t.height;
		s.anchor.set(0.5, 0.5);
		s.position.set(this.data.x + t.position.x, this.data.y + t.position.y);
		s.rotation = t.rotation;
		return s;
	}

	/* -------------------------------------------- */

	/**
	 * Swap a Tile from the background to the foreground - or vice versa
	 */
	swapLayer() {
		this.parent.removeChild(this);
		const parent = this.data.overhead ? canvas.foreground.objects : canvas.background.objects;
		parent.addChild(this);
		canvas.perception.schedule({foreground: {refresh: true}});
		this.release();
	}

	/* -------------------------------------------- */

	/**
	 * Created a cached mapping of pixel alpha for this Tile.
	 * Cache the bounding box of non-transparent pixels for the un-rotated shape.
	 * Store an array of booleans for whether each pixel has a non-transparent value.
	 * @param {object} [options={}]                     Options which customize the return value
	 * @param {boolean} [options.keepPixels=false]      Keep the Uint8Array of pixel alphas?
	 * @param {boolean} [options.keepTexture=false]     Keep the pure white RenderTexture?
	 * @returns {{minX: number, minY: number, maxX: number, maxY: number, pixels: Uint8Array|undefined, texture: PIXI.RenderTexture|undefined}}
	 * @private
	 */
	_createAlphaMap({keepPixels=false, keepTexture=false}={}) {

		// Destroy the previous texture
		if ( this._alphaMap?.texture ) {
			this._alphaMap.texture.destroy(true);
			delete this._alphaMap.texture;
		}

		// If no tile texture is present
		const aw = Math.abs(this.data.width);
		const ah = Math.abs(this.data.height);
		if ( !this.texture ) return this._alphaMap = { minX: 0, minY: 0, maxX: aw, maxY: ah };

		// Create a temporary Sprite
		const sprite = new PIXI.Sprite(this.texture);
		sprite.width = this.data.width;
		sprite.height = this.data.height;
		sprite.anchor.set(0.5, 0.5);
		sprite.position.set(aw/2, ah/2);

		// Color matrix filter the sprite to pure white
		const cmf = new PIXI.filters.ColorMatrixFilter();
		cmf.matrix = [1,1,1,1,1, 1,1,1,1,1, 1,1,1,1,1, 1,1,1,1,0]; // Over-multiply alpha to remove transparency
		sprite.filters = [cmf];

		// Render to a texture and extract pixels
		const tex = PIXI.RenderTexture.create({ width: aw, height: ah });
		canvas.app.renderer.render(sprite, tex);
		const pixels = canvas.app.renderer.extract.pixels(tex);

		// Construct an alpha mapping
		const map = {
			pixels: new Uint8Array(pixels.length / 4),
			texture: undefined,
			minX: undefined,
			minY: undefined,
			maxX: undefined,
			maxY: undefined
		}

		// Keep the texture?
		if ( keepTexture ) map.texture = tex;
		else tex.destroy(true);

		// Map the alpha pixels
		for ( let i=0; i<pixels.length; i+=4 ) {
			const n = i / 4;
			const a = pixels[i+3];
			map.pixels[n] = a > 0 ? 1 : 0;
			if ( a > 0 ) {
				const x = n % aw;
				const y = Math.floor(n / aw);
				if ( (map.minX === undefined) || (x < map.minX) ) map.minX = x;
				else if ( (map.maxX === undefined) || (x > map.maxX) ) map.maxX = x;
				if ( (map.minY === undefined) || (y < map.minY) ) map.minY = y;
				else if ( (map.maxY === undefined) || (y > map.maxY) ) map.maxY = y;
			}
		}

		// Maybe discard the raw pixels
		if ( !keepPixels ) map.pixels = undefined;
		return this._alphaMap = map;
	}

	/* -------------------------------------------- */

	/**
	 * Compute the alpha-based bounding box for the tile, including an angle of rotation.
	 * @returns {NormalizedRectangle}
	 * @private
	 */
	_getAlphaBounds() {
		const m = this._alphaMap;
		const r = Math.toRadians(this.data.rotation);
		return NormalizedRectangle.fromRotation(m.minX, m.minY, m.maxX - m.minX, m.maxY - m.minY, r);
	}

	/* -------------------------------------------- */

	/**
	 * Create the filter instance used to reverse-mask overhead tiles using radial or vision-based occlusion.
	 * @returns {AbstractBaseMaskFilter}
	 * @private
	 */
	_createOcclusionFilter() {
		const filter = InverseOcclusionMaskFilter.create({
			uMaskSampler: this.layer.occlusionMask.renderTexture,
			alphaOcclusion: this.data.occlusion.alpha
		}, "g");
		filter.enabled = false;
		return filter;
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @override */
	_onUpdate(data, options={}, userId) {

		// Swap the overhead state
		if ( "overhead" in data ) {
			this.swapLayer();
			return this.draw();
		}

		// Re-draw the image
		if ( "img" in data ) return this.draw();

		// Alter the z-index in the parent container
		if ( "z" in data ) this.zIndex = parseInt(data.z) || 0;

		// Re-create the alpha map if the occlusion shape changed
		const shapeChange = ["width", "height", "scale", "mirrorX", "mirrorY"].some(k => k in data);
		const occlusionChange = foundry.utils.hasProperty(data, "occlusion.mode");
		if ( shapeChange || occlusionChange ) {
			this._createAlphaMap({
				keepPixels: this.data.overhead,
				keepTexture: this.isRoof
			});
		}

		// Refresh the lighting layer mask
		if ( occlusionChange || this.isRoof ) {
			canvas.perception.schedule({lighting: {refresh: true}});
		}

		// Refresh the tile display
		this.refresh();

		// Start or Stop Video
		if ( Object.keys(data).some(k => k.startsWith("video")) ) {
			this.play(options.playVideo);
			if ( this.layer.hud.object === this ) this.layer.hud.render();
		}
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDelete(options, userId){
		super._onDelete(options, userId);
		if ( this.isVideo ) this.play(false);
	}

	/* -------------------------------------------- */
	/*  Interactivity                               */
	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners() {
		super.activateListeners();
		this.frame.handle.off("mouseover").off("mouseout").off("mousedown")
			.on("mouseover", this._onHandleHoverIn.bind(this))
			.on("mouseout", this._onHandleHoverOut.bind(this))
			.on("mousedown", this._onHandleMouseDown.bind(this));
		this.frame.handle.interactive = true;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_canConfigure(user, event) {
		if ( this.data.locked && !this._controlled ) return false;
		return super._canConfigure(user);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onClickLeft2(event) {
		this._dragHandle = false;
		return super._onClickLeft2(event);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftStart(event) {
		if ( this._dragHandle ) return this._onHandleDragStart(event);
		return super._onDragLeftStart(event);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftMove(event) {
		if ( this._dragHandle ) return this._onHandleDragMove(event);
		return super._onDragLeftMove(event);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftDrop(event) {
		if ( this._dragHandle ) return this._onHandleDragDrop(event);
		return super._onDragLeftDrop(event);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftCancel(event) {
		if ( this._dragHandle ) return this._onHandleDragCancel(event);
		return super._onDragLeftCancel(event);
	}

	/* -------------------------------------------- */
	/*  Resize Handling                             */
	/* -------------------------------------------- */

	/**
	 * Handle mouse-over event on a control handle
	 * @param {PIXI.InteractionEvent} event   The mouseover event
	 * @protected
	 */
	_onHandleHoverIn(event) {
		const handle = event.target;
		handle.scale.set(1.5, 1.5);
		event.data["handle"] = event.target;
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-out event on a control handle
	 * @param {PIXI.InteractionEvent} event   The mouseout event
	 * @protected
	 */
	_onHandleHoverOut(event) {
		const {handle} = event.data;
		handle.scale.set(1.0, 1.0);
	}

	/* -------------------------------------------- */

	/**
	 * When we start a drag event - create a preview copy of the Tile for re-positioning
	 * @param {PIXI.InteractionEvent} event   The mousedown event
	 * @protected
	 */
	_onHandleMouseDown(event) {
		if ( !this.data.locked ) this._dragHandle = true;
	}

	/* -------------------------------------------- */

	/**
	 * Handle the beginning of a drag event on a resize handle
	 * @param {PIXI.InteractionEvent} event   The mousedown event
	 * @protected
	 */
	_onHandleDragStart(event) {
		const {handle} = event.data;
		const aw = Math.abs(this.data.width);
		const ah = Math.abs(this.data.height);
		const x0 = this.data.x + (handle.offset[0] * aw);
		const y0 = this.data.y + (handle.offset[1] * ah);
		event.data["origin"] = {x: x0, y: y0, width: aw, height: ah};
	}

	/* -------------------------------------------- */

	/**
	 * Handle mousemove while dragging a tile scale handler
	 * @param {PIXI.InteractionEvent} event   The mousemove event
	 * @protected
	 */
	_onHandleDragMove(event) {
		const {destination, origin, originalEvent} = event.data;
		canvas._onDragCanvasPan(originalEvent);
		const d = this._getResizedDimensions(originalEvent, origin, destination);
		this.data.x = d.x;
		this.data.y = d.y;
		this.data.width = d.width;
		this.data.height = d.height;
		this.data.rotation = 0;
		this.refresh();
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouseup after dragging a tile scale handler
	 * @param {PIXI.InteractionEvent} event   The mouseup event
	 * @protected
	 */
	_onHandleDragDrop(event) {
		let {destination, origin, originalEvent} = event.data;
		if ( !originalEvent.shiftKey ) {
			destination = canvas.grid.getSnappedPosition(destination.x, destination.y, this.layer.gridPrecision);
		}
		const d = this._getResizedDimensions(originalEvent, origin, destination);
		return this.document.update({x: d.x, y: d.y, width: d.width, height: d.height});
	}

	/* -------------------------------------------- */

	/**
	 * Get resized Tile dimensions
	 * @returns {NormalizedRectangle}
	 * @private
	 */
	_getResizedDimensions(event, origin, destination) {
		const o = this.data._source;
		let w = o.width + (destination.x - origin.x);
		let h = o.height + (destination.y - origin.y);
		if ( event.altKey ) {
			const ar = this.texture.width / this.texture.height;
			if ( Math.abs(w) > Math.abs(h) ) h = w / ar;
			else w = h * ar;
		}
		return new NormalizedRectangle(o.x, o.y, w, h);
	}

	/* -------------------------------------------- */

	/**
	 * Handle cancellation of a drag event for one of the resizing handles
	 * @protected
	 */
	_onHandleDragCancel() {
		this.data.reset();
		this._dragHandle = false;
		this.refresh();
	}

	/* -------------------------------------------- */

	/**
	 * Create a preview tile with a background texture instead of an image
	 * @param {object} data     Initial data with which to create the preview Tile
	 * @return {PlaceableObject}
	 */
	static createPreview(data) {
		data.overhead = data.overhead ?? canvas.foreground._active;
		const doc = new TileDocument(data, {parent: canvas.scene});
		const tile = doc.object;
		tile._controlled = true;
		tile.draw().then(() => {  // Swap the z-order of the tile and the frame
			tile.removeChild(tile.frame);
			tile.addChild(tile.frame);
		});
		return tile;
	}
}
/**
 * A Token is an implementation of PlaceableObject which represents an Actor within a viewed Scene on the game canvas.
 * @extends  {PlaceableObject}
 * @see {TokenDocument}
 * @see {TokenLayer}
 */
class Token extends PlaceableObject {
	constructor(...args) {
		super(...args);

		/**
		 * A Ray which represents the Token's current movement path
		 * @type {Ray}
		 * @private
		 */
		this._movement = null;

		/**
		 * An Object which records the Token's prior velocity dx and dy
		 * This can be used to determine which direction a Token was previously moving
		 * @type {{dx: number, dy: number, sx: number, sy:number}}
		 * @private
		 */
		this._velocity = this._getInitialVelocity();

		/**
		 * The Token's most recent valid position
		 * @type {Object}
		 * @private
		 */
		this._validPosition = {x: this.data.x, y: this.data.y};

		/**
		 * Track the set of User entities which are currently targeting this Token
		 * @type {Set.<User>}
		 */
		this.targeted = new Set([]);

		/**
		 * A reference to the PointSource object which defines this vision source area of effect
		 * @type {PointSource}
		 */
		this.vision = new PointSource(this, "sight");

		/**
		 * A reference to the PointSource object which defines this light source area of effect
		 * @type {PointSource}
		 */
		this.light = new PointSource(this, "light");
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	static embeddedName = "Token";

	/* -------------------------------------------- */

	/**
	 * Establish an initial velocity of the token based on it's direction of facing.
	 * Assume the Token made some prior movement towards the direction that it is currently facing.
	 * @returns {{dx: number, sx: number, dy: number, sy: number}}
	 * @private
	 */
	_getInitialVelocity() {
		this._velocity = {dx: 0, dy: 0, sx: 0.1, sy: 0.1}; // Assume top-left towards bottom-right by default
		const r = Ray.fromAngle(this.data.x, this.data.y, Math.toRadians(this.data.rotation + 90), canvas.dimensions.size);
		return this._updateVelocity(r);
	}

	/* -------------------------------------------- */
	/*  Permission Attributes
	/* -------------------------------------------- */

	/**
	 * A convenient reference to the Actor object associated with the Token embedded document.
	 * @returns {Actor|null}
	 */
	get actor() {
		return this.document.actor;
	}

	/* -------------------------------------------- */

	/**
	 * A convenient reference for whether the current User has full control over the Token document.
	 * @type {boolean}
	 */
	get owner() {
		return this.document.isOwner;
	}

	get isOwner() {
		return this.document.isOwner;
	}

	/* -------------------------------------------- */

	/**
	 * A boolean flag for whether the current game User has observer permission for the Token
	 * @type {boolean}
	 */
	get observer() {
		return game.user.isGM || !!this.actor?.testUserPermission(game.user, "OBSERVER");
	}

	/* -------------------------------------------- */

	/**
	 * Is the HUD display active for this token?
	 * @return {boolean}
	 */
	get hasActiveHUD() {
		return this.layer.hud.object === this;
	}

	/* -------------------------------------------- */

	/**
	 * Convenience access to the token's nameplate string
	 * @type {string}
	 */
	get name() {
		return this.document.name;
	}

	/* -------------------------------------------- */
	/*  Rendering Attributes
	/* -------------------------------------------- */

	/**
	 * Translate the token's grid width into a pixel width based on the canvas size
	 * @type {number}
	 */
	get w() {
		return this.data.width * canvas.grid.w;
	}

	/* -------------------------------------------- */

	/**
	 * Translate the token's grid height into a pixel height based on the canvas size
	 * @type {number}
	 */
	get h() {
		return this.data.height * canvas.grid.h;
	}

	/* -------------------------------------------- */

	/**
	 * The Token's current central position
	 * @property x The central x-coordinate
	 * @property y The central y-coordinate
	 * @type {Object}
	 */
	get center() {
		return this.getCenter(this.data.x, this.data.y);
	}

	/* -------------------------------------------- */
	/*  State Attributes
	/* -------------------------------------------- */

	/**
	 * An indicator for whether or not this token is currently involved in the active combat encounter.
	 * @type {boolean}
	 */
	get inCombat() {
		return this.document.inCombat;
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to a Combatant that represents this Token, if one is present in the current encounter.
	 * @type {Combatant|null}
	 */
	get combatant() {
		return this.document.combatant;
	}

	/* -------------------------------------------- */

	/**
	 * An indicator for whether the Token is currently targeted by the active game User
	 * @type {boolean}
	 */
	get isTargeted() {
		return this.targeted.has(game.user);
	}

	/* -------------------------------------------- */

	/**
	 * Determine whether the Token is visible to the calling user's perspective.
	 * Hidden Tokens are only displayed to GM Users.
	 * Non-hidden Tokens are always visible if Token Vision is not required.
	 * Controlled tokens are always visible.
	 * All Tokens are visible to a GM user if no Token is controlled.
	 *
	 * @see {SightLayer#testVisibility}
	 * @type {boolean}
	 */
	get isVisible() {
		const gm = game.user.isGM;
		if ( this.data.hidden ) return gm;
		if (!canvas.sight.tokenVision) return true;
		if ( this._controlled ) return true;
		const tolerance = Math.min(this.w, this.h) / 4;
		return canvas.sight.testVisibility(this.center, {tolerance, object: this});
	}

	/* -------------------------------------------- */
	/*  Lighting and Vision Attributes
	/* -------------------------------------------- */

	/**
	 * Test whether the Token has sight (or blindness) at any radius
	 * @type {boolean}
	 */
	get hasSight() {
		return this.data.vision;
	}

	/* -------------------------------------------- */

	/**
	 * Test whether the Token emits light (or darkness) at any radius
	 * @type {boolean}
	 */
	get emitsLight() {
		return ["dimLight", "brightLight"].some(a => this.data[a] || false);
	}

	/* -------------------------------------------- */

	/**
	 * Test whether the Token has a limited angle of vision or light emission which would require sight to update on Token rotation
	 * @type {boolean}
	 */
	get hasLimitedVisionAngle() {
		return (this.hasSight && (this.data.sightAngle !== 360)) || (this.emitsLight && (this.data.lightAngle !== 360));
	}

	/* -------------------------------------------- */

	/**
	 * Translate the token's sight distance in units into a radius in pixels.
	 * @return {number}     The sight radius in pixels
	 */
	get dimRadius() {
		let r = Math.abs(this.data.dimLight) > Math.abs(this.data.dimSight) ? this.data.dimLight : this.data.dimSight;
		return this.getLightRadius(r);
	}

	/* -------------------------------------------- */

	/**
	 * Translate the token's bright light distance in units into a radius in pixels.
	 * @return {number}       The bright radius in pixels
	 */
	get brightRadius() {
		let r = Math.abs(this.data.brightLight) > Math.abs(this.data.brightSight) ? this.data.brightLight :
			this.data.brightSight;
		return this.getLightRadius(r);
	}

	/* -------------------------------------------- */

	/**
	 * The named identified for the source object associated with this Token
	 * @return {string}
	 */
	get sourceId() {
		return "Token." + (this._original?.id ?? this.id);
	}

	/* -------------------------------------------- */

	/**
	 * Update the light and vision source objects associated with this Token
	 * @param {boolean} [defer]           Defer refreshing the SightLayer to manually call that refresh later.
	 * @param {boolean} [deleted]         Indicate that this light source has been deleted.
	 * @param {boolean} [noUpdateFog]     Never update the Fog exploration progress for this update.
	 */
	updateSource({defer=false, deleted=false, noUpdateFog=false}={}) {
		if ( CONFIG.debug.sight ) {
			SightLayer._performance = { start: performance.now(), tests: 0, rays: 0 }
		}

		// Prepare some common data
		const origin = this.getSightOrigin();
		const sourceId = this.sourceId;
		const d = canvas.dimensions;

		// Update light source
		const isLightSource = this.emitsLight && !this.data.hidden;
		if ( isLightSource && !deleted ) {
			const bright = Math.min(this.getLightRadius(this.data.brightLight), d.maxR);
			const dim = Math.min(this.getLightRadius(this.data.dimLight), d.maxR);
			this.light.initialize({
				x: origin.x,
				y: origin.y,
				dim: dim,
				bright: bright,
				angle: this.data.lightAngle,
				rotation: this.data.rotation,
				color: this.data.lightColor,
				alpha: this.data.lightAlpha,
				animation: this.data.lightAnimation
			});
			canvas.lighting.sources.set(sourceId, this.light);
			if ( !defer ) {
				this.light.drawLight();
				this.light.drawColor();
			}
		}
		else {
			canvas.lighting.sources.delete(sourceId);
			if ( isLightSource && !defer ) canvas.lighting.refresh();
		}

		// Update vision source
		const isVisionSource = this._isVisionSource();
		if ( isVisionSource && !deleted ) {
			let dim = Math.min(this.getLightRadius(this.data.dimSight), d.maxR);
			const bright = Math.min(this.getLightRadius(this.data.brightSight), d.maxR);
			this.vision.initialize({
				x: origin.x,
				y: origin.y,
				dim: dim,
				bright: bright,
				angle: this.data.sightAngle,
				rotation: this.data.rotation
			});
			canvas.sight.sources.set(sourceId, this.vision);
			if ( !defer ) {
				this.vision.drawLight();
				canvas.sight.refresh({noUpdateFog});
			}
		}
		else {
			canvas.sight.sources.delete(sourceId);
			if ( isVisionSource && !defer ) canvas.sight.refresh();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Test whether this Token is a viable vision source for the current User
	 * @return {boolean}
	 * @private
	 */
	_isVisionSource() {
		if ( !canvas.sight.tokenVision || !this.hasSight ) return false;

		// Only display hidden tokens for the GM
		const isGM = game.user.isGM;
		if (this.data.hidden && !isGM) return false;

		// Always display controlled tokens which have vision
		if ( this._controlled ) return true;

		// Otherwise vision is ignored for GM users
		if ( isGM ) return false;

		// If a non-GM user controls no other tokens with sight, display sight anyways
		const canObserve = this.actor?.testUserPermission(game.user, "OBSERVER") ?? false;
		if ( !canObserve ) return false;
		const others = this.layer.controlled.filter(t => !t.data.hidden && t.hasSight);
		return !others.length;
	}

	/* -------------------------------------------- */
	/* Rendering
	/* -------------------------------------------- */

	/** @override */
	async draw() {
		this.clear();
		if ( this.hasActiveHUD ) canvas.tokens.hud.clear();

		// Clean initial data
		this._cleanData();

		// Draw the token as invisible so it will be safely revealed later
		this.visible = false;

		// Load token texture
		this.texture = await loadTexture(this.data.img, {fallback: CONST.DEFAULT_TOKEN});

		// Draw Token components
		this.border = this.addChild(new PIXI.Graphics());
		this.icon = this.addChild(await this._drawIcon());
		this.bars = this.addChild(this._drawAttributeBars());
		this.nameplate = this.addChild(this._drawNameplate());
		this.tooltip = this.addChild(new PIXI.Container());
		this.effects = this.addChild(new PIXI.Container());
		this.target = this.addChild(new PIXI.Graphics());

		// Define initial interactivity and visibility state
		this.hitArea = new PIXI.Rectangle(0, 0, this.w, this.h);
		this.buttonMode = true;

		// Draw the initial position
		this.refresh();
		await this.drawEffects();
		this.drawTooltip();
		this.drawBars();

		// Enable interactivity, only if the Tile has a true ID
		if ( this.id ) this.activateListeners();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Apply initial sanitizations to the provided input data to ensure that a Token has valid required attributes.
	 * @private
	 */
	_cleanData() {

		// Constrain dimensions
		this.data.width = Math.max((this.data.width || 1).toNearest(0.5), 0.5);
		this.data.height = Math.max((this.data.height || 1).toNearest(0.5), 0.5);

		// Constrain canvas coordinates
		if ( !canvas || !this.scene?.active ) return;
		const d = canvas.dimensions;
		this.data.x = Math.clamped(Math.round(this.data.x), 0, d.width - this.w);
		this.data.y = Math.clamped(Math.round(this.data.y), 0, d.height - this.h);
	}

	/* -------------------------------------------- */

	/**
	 * Draw resource bars for the Token
	 * @private
	 */
	_drawAttributeBars() {
		const bars = new PIXI.Container();
		bars.bar1 = bars.addChild(new PIXI.Graphics());
		bars.bar2 = bars.addChild(new PIXI.Graphics());
		return bars;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the Sprite icon for the Token
	 * @return {Promise<PIXI.Sprite>}
	 * @private
	 */
	async _drawIcon() {

		// Create Sprite using the loaded texture
		let icon = new PIXI.Sprite(this.texture);
		icon.anchor.set(0.5, 0.5);
		if ( !this.texture ) return icon;

		// Ensure playback state for video tokens
		const source = foundry.utils.getProperty(this.texture, "baseTexture.resource.source");
		if ( source && (source.tagName === "VIDEO") ) {
			source.loop = true;
			source.muted = true;
			source.currentTime = 0;
			game.video.play(source);
		}

		// Apply color tinting
		icon.tint = this.data.tint ? foundry.utils.colorStringToHex(this.data.tint) : 0xFFFFFF;
		return icon;
	}

	/* -------------------------------------------- */

	/**
	 * Update display of the Token, pulling latest data and re-rendering the display of Token components
	 */
	refresh() {

		// Token position and visibility
		if ( !this._movement ) this.position.set(this.data.x, this.data.y);

		// Size the texture aspect ratio within the token frame
		const tex = this.texture;
		if ( tex ) {
			let aspect = tex.width / tex.height;
			const scale = this.icon.scale;
			if ( aspect >= 1 ) {
				this.icon.width = this.w * this.data.scale;
				scale.y = Number(scale.x);
			} else {
				this.icon.height = this.h * this.data.scale;
				scale.x = Number(scale.y);
			}
		}

		// Mirror horizontally or vertically
		this.icon.scale.x = Math.abs(this.icon.scale.x) * (this.data.mirrorX ? -1 : 1);
		this.icon.scale.y = Math.abs(this.icon.scale.y) * (this.data.mirrorY ? -1 : 1);

		// Set rotation, position, and opacity
		this.icon.rotation = this.data.lockRotation ? 0 : Math.toRadians(this.data.rotation);
		this.icon.position.set(this.w / 2, this.h / 2);
		this.icon.alpha = this.data.hidden ? Math.min(this.data.alpha, 0.5) : this.data.alpha;

		// Refresh Token border and target
		this._refreshBorder();
		this._refreshTarget();

		// Refresh nameplate and resource bars
		this.nameplate.visible = this._canViewMode(this.data.displayName);
		this.bars.visible = this._canViewMode(this.data.displayBars);
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the Token border, taking into consideration the grid type and border color
	 * @private
	 */
	_refreshBorder() {
		this.border.clear();
		const borderColor = this._getBorderColor();
		if( !borderColor ) return;
		const t = CONFIG.Canvas.objectBorderThickness;

		// Draw Hex border for size 1 tokens on a hex grid
		const gt = CONST.GRID_TYPES;
		const hexTypes = [gt.HEXEVENQ, gt.HEXEVENR, gt.HEXODDQ, gt.HEXODDR];
		if ( hexTypes.includes(canvas.grid.type) && (this.data.width === 1) && (this.data.height === 1) ) {
			const polygon = canvas.grid.grid.getPolygon(-1, -1, this.w+2, this.h+2);
			this.border.lineStyle(t, 0x000000, 0.8).drawPolygon(polygon);
			this.border.lineStyle(t/2, borderColor, 1.0).drawPolygon(polygon);
		}

		// Otherwise Draw Square border
		else {
			const h = Math.round(t/2);
			const o = Math.round(h/2);
			this.border.lineStyle(t, 0x000000, 0.8).drawRoundedRect(-o, -o, this.w+h, this.h+h, 3);
			this.border.lineStyle(h, borderColor, 1.0).drawRoundedRect(-o, -o, this.w+h, this.h+h, 3);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Get the hex color that should be used to render the Token border
	 * @return {number|null}   The hex color used to depict the border color
	 * @private
	 */
	_getBorderColor() {
		const colors = CONFIG.Canvas.dispositionColors;
		if ( this._controlled ) return colors.CONTROLLED;
		else if ( this._hover ) {
			let d = parseInt(this.data.disposition);
			if (!game.user.isGM && this.isOwner) return colors.CONTROLLED;
			else if (this.actor?.hasPlayerOwner) return colors.PARTY;
			else if (d === CONST.TOKEN_DISPOSITIONS.FRIENDLY) return colors.FRIENDLY;
			else if (d === CONST.TOKEN_DISPOSITIONS.NEUTRAL) return colors.NEUTRAL;
			else return colors.HOSTILE;
		}
		else return null;
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the target indicators for the Token.
	 * Draw both target arrows for the primary User as well as indicator pips for other Users targeting the same Token.
	 * @private
	 */
	_refreshTarget() {
		this.target.clear();
		if ( !this.targeted.size ) return;

		// Determine whether the current user has target and any other users
		const [others, user] = Array.from(this.targeted).partition(u => u === game.user);
		const userTarget = user.length;

		// For the current user, draw the target arrows
		if ( userTarget ) {
			let p = 4;
			let aw = 12;
			let h = this.h;
			let hh = h / 2;
			let w = this.w;
			let hw = w / 2;
			let ah = canvas.dimensions.size / 3;
			this.target.beginFill(0xFF9829, 1.0).lineStyle(1, 0x000000)
				.drawPolygon([-p,hh, -p-aw,hh-ah, -p-aw,hh+ah])
				.drawPolygon([w+p,hh, w+p+aw,hh-ah, w+p+aw,hh+ah])
				.drawPolygon([hw,-p, hw-ah,-p-aw, hw+ah,-p-aw])
				.drawPolygon([hw,h+p, hw-ah,h+p+aw, hw+ah,h+p+aw]);
		}

		// For other users, draw offset pips
		for ( let [i, u] of others.entries() ) {
			let color = colorStringToHex(u.data.color);
			this.target.beginFill(color, 1.0).lineStyle(2, 0x0000000).drawCircle(2 + (i * 8), 0, 6);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the display of Token attribute bars, rendering latest resource data
	 * If the bar attribute is valid (has a value and max), draw the bar. Otherwise hide it.
	 * @private
	 */
	drawBars() {
		if ( !this.actor || (this.data.displayBars === CONST.TOKEN_DISPLAY_MODES.NONE) ) return;
		["bar1", "bar2"].forEach((b, i) => {
			const bar = this.bars[b];
			const attr = this.document.getBarAttribute(b);
			if ( !attr || (attr.type !== "bar") ) return bar.visible = false;
			this._drawBar(i, bar, attr);
			bar.visible = true;
		});
	}

	/* -------------------------------------------- */

	/**
	 * Draw a single resource bar, given provided data
	 * @param {number} number       The Bar number
	 * @param {PIXI.Graphics} bar   The Bar container
	 * @param {Object} data         Resource data for this bar
	 * @protected
	 */
	_drawBar(number, bar, data) {
		const val = Number(data.value);
		const pct = Math.clamped(val, 0, data.max) / data.max;

		// Determine sizing
		let h = Math.max((canvas.dimensions.size / 12), 8);
		const w = this.w;
		const bs = Math.clamped(h / 8, 1, 2);
		if ( this.data.height >= 2 ) h *= 1.6;  // Enlarge the bar for large tokens

		// Determine the color to use
		const blk = 0x000000;
		let color;
		if ( number === 0 ) color = PIXI.utils.rgb2hex([(1-(pct/2)), pct, 0]);
		else color = PIXI.utils.rgb2hex([(0.5 * pct), (0.7 * pct), 0.5 + (pct / 2)]);

		// Draw the bar
		bar.clear()
		bar.beginFill(blk, 0.5).lineStyle(bs, blk, 1.0).drawRoundedRect(0, 0, this.w, h, 3)
		bar.beginFill(color, 1.0).lineStyle(bs, blk, 1.0).drawRoundedRect(0, 0, pct*w, h, 2)

		// Set position
		let posY = number === 0 ? this.h - h : 0;
		bar.position.set(0, posY);
	}

	/* -------------------------------------------- */

	/**
	 * Draw the token's nameplate as a text object
	 * @return {PIXI.Text}  The Text object for the Token nameplate
	 */
	_drawNameplate() {
		const style = this._getTextStyle();
		const name = new PreciseText(this.data.name, style);
		name.anchor.set(0.5, 0);
		name.position.set(this.w / 2, this.h + 2);
		return name;
	}

	/* -------------------------------------------- */

	/**
	 * Draw a text tooltip for the token which can be used to display Elevation or a resource value
	 */
	drawTooltip() {
		this.tooltip.removeChildren().forEach(c => c.destroy());

		// Create the tooltip Text
		let tip = this._getTooltipText();
		if (!tip.length) return;
		const style = this._getTextStyle();
		const text = new PreciseText(tip, style);
		this.tooltip.addChild(text);

		// Add the tooltip at the top of the parent Token container
		text.anchor.set(0.5, 1);
		this.tooltip.position.set(this.w / 2, -2);
	}

	/* -------------------------------------------- */

	/**
	 * Return the text which should be displayed in a token's tooltip field
	 * @return {string}
	 * @private
	 */
	_getTooltipText() {
		let el = this.data.elevation;
		if (!Number.isFinite(el) || el === 0) return "";
		let units = canvas.scene.data.gridUnits;
		return el > 0 ? `+${el} ${units}` : `${el} ${units}`;
	}

	/* -------------------------------------------- */

	_getTextStyle() {
		const style = CONFIG.canvasTextStyle.clone();
		style.fontSize = 24;
		if (canvas.dimensions.size >= 200) style.fontSize = 28;
		else if (canvas.dimensions.size < 50) style.fontSize = 20;
		style.wordWrapWidth = this.w * 2.5;
		return style
	}

	/* -------------------------------------------- */

	/**
	 * Draw the active effects and overlay effect icons which are present upon the Token
	 */
	async drawEffects() {
		this.effects.removeChildren().forEach(c => c.destroy());
		const tokenEffects = this.data.effects;
		const actorEffects = this.actor?.temporaryEffects || [];
		let overlay = {
			src: this.data.overlayEffect,
			tint: null
		};

		// Draw status effects
		if ( tokenEffects.length || actorEffects.length ) {
			const promises = [];
			let w = Math.round(canvas.dimensions.size / 2 / 5) * 2;
			let bg = this.effects.addChild(new PIXI.Graphics()).beginFill(0x000000, 0.40).lineStyle(1.0, 0x000000);
			let i = 0;

			// Draw actor effects first
			for ( let f of actorEffects ) {
				if ( !f.data.icon ) continue;
				const tint = f.data.tint ? colorStringToHex(f.data.tint) : null;
				if ( f.getFlag("core", "overlay") ) {
					overlay = {src: f.data.icon, tint};
					continue;
				}
				promises.push(this._drawEffect(f.data.icon, i, bg, w, tint));
				i++;
			}

			// Next draw token effects
			for ( let f of tokenEffects ) {
				promises.push(this._drawEffect(f, i, bg, w, null));
				i++;
			}
			await Promise.all(promises);
		}

		// Draw overlay effect
		return this._drawOverlay(overlay)
	}

	/* -------------------------------------------- */

	/**
	 * Draw the overlay effect icon
	 * @return {Promise<void>}
	 * @private
	 */
	async _drawOverlay({src, tint}={}) {
		if ( !src ) return;
		const tex = await loadTexture(src);
		const icon = new PIXI.Sprite(tex);
		const size = Math.min(this.w * 0.6, this.h * 0.6);
		icon.width = icon.height = size;
		icon.position.set((this.w - size) / 2, (this.h - size) / 2);
		icon.alpha = 0.80;
		if ( tint ) icon.tint = tint;
		this.effects.addChild(icon);
	}

	/* -------------------------------------------- */

	/**
	 * Draw a status effect icon
	 * @return {Promise<void>}
	 * @private
	 */
	async _drawEffect(src, i, bg, w, tint) {
		let tex = await loadTexture(src);
		let icon = this.effects.addChild(new PIXI.Sprite(tex));
		icon.width = icon.height = w;
		const nr = Math.floor(this.data.height * 5);
		icon.x = Math.floor(i / nr) * w;
		icon.y = (i % nr) * w;
		if ( tint ) icon.tint = tint;
		bg.drawRoundedRect(icon.x + 1, icon.y + 1, w - 2, w - 2, 2);
		this.effects.addChild(icon);
	}

	/* -------------------------------------------- */

	/**
	 * Helper method to determine whether a token attribute is viewable under a certain mode
	 * @param {number} mode   The mode from CONST.TOKEN_DISPLAY_MODES
	 * @return {boolean}      Is the attribute viewable?
	 * @private
	 */
	_canViewMode(mode) {
		if ( mode === CONST.TOKEN_DISPLAY_MODES.NONE ) return false;
		else if ( mode === CONST.TOKEN_DISPLAY_MODES.ALWAYS ) return true;
		else if ( mode === CONST.TOKEN_DISPLAY_MODES.CONTROL ) return this._controlled;
		else if ( mode === CONST.TOKEN_DISPLAY_MODES.HOVER ) return this._hover;
		else if ( mode === CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER ) return this.isOwner && this._hover;
		else if ( mode === CONST.TOKEN_DISPLAY_MODES.OWNER ) return this.isOwner;
		return false;
	}

	/* -------------------------------------------- */

	/**
	 * Animate Token movement along a certain path which is defined by a Ray object
	 * @param {Ray} ray   The path along which to animate Token movement
	 */
	async animateMovement(ray) {

		// Move distance is 10 spaces per second
		const s = canvas.dimensions.size;
		this._movement = ray;
		const speed = s * 10;
		const duration = (ray.distance * 1000) / speed;

		// Define attributes
		const attributes = [
			{ parent: this, attribute: 'x', to: ray.B.x },
			{ parent: this, attribute: 'y', to: ray.B.y }
		];

		// Determine what type of updates should be animated
		const emits = this.emitsLight;
		const config = {
			animate: game.settings.get("core", "visionAnimation"),
			source: this._isVisionSource() || emits,
			sound: this._controlled || this.observer,
			fog: emits && !this._controlled && (canvas.sight.sources.size > 0)
		}

		// Dispatch the animation function
		let animationName = `Token.${this.id}.animateMovement`;
		await CanvasAnimation.animateLinear(attributes, {
			name: animationName,
			context: this,
			duration: duration,
			ontick: (dt, anim) => this._onMovementFrame(dt, anim, config)
		});

		// Once animation is complete perform a final refresh
		if ( !config.animate ) this._animatePerceptionFrame({source: config.source, sound: config.sound});
		this._movement = null;
	}

	/* -------------------------------------------- */

	/**
	 * Animate the continual revealing of Token vision during a movement animation
	 * @private
	 */
	_onMovementFrame(dt, anim, config) {

		// Update the displayed position of the Token
		this.data.x = this.x;
		this.data.y = this.y;

		// Animate perception changes
		if ( !config.animate || !anim.length ) return;
		let updateFog = config.fog;
		if ( config.source ) {
			const dist = Math.hypot(anim[0].done, anim[1]?.done || 0);
			const n = Math.floor(dist / canvas.dimensions.size);
			if ((n > 0) && (anim[0].dist !== n)) {
				updateFog = true;
				anim[0].dist = n;
			}
		}
		this._animatePerceptionFrame({source: config.source, sound: config.sound, fog: updateFog});
	}

	/* -------------------------------------------- */

	/**
	 * Update perception each frame depending on the animation configuration
	 * @private
	 */
	_animatePerceptionFrame({source=false, sound=false, fog=false}={}) {
		if ( source ) {
			this.updateSource({defer: true});
			canvas.perception.schedule({
				lighting: {refresh: source},
				sight: {refresh: source, forceUpdateFog: fog},
				sounds: { refresh: sound },
				foreground: { refresh: true }
			});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Terminate animation of this particular Token
	 */
	stopAnimation() {
		return CanvasAnimation.terminateAnimation(`Token.${this.id}.animateMovement`);
	}

	/* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */

	/**
	 * Check for collision when attempting a move to a new position
	 * @param {Point} destination   The destination point of the attempted movement
	 * @return {boolean}            A true/false indicator for whether the attempted movement caused a collision
	 */
	checkCollision(destination) {

		// Create a Ray for the attempted move
		let origin = this.getCenter(...Object.values(this._validPosition));
		let ray = new Ray({x: origin.x, y: origin.y}, {x: destination.x, y: destination.y});

		// Shift the origin point by the prior velocity
		ray.A.x -= this._velocity.sx;
		ray.A.y -= this._velocity.sy;

		// Shift the destination point by the requested velocity
		ray.B.x -= Math.sign(ray.dx);
		ray.B.y -= Math.sign(ray.dy);

		// Check for a wall collision
		return canvas.walls.checkCollision(ray);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onControl({releaseOthers=true, pan=false}={}) {
		_token = this;
		this.zIndex = 1;
		this.refresh();
		if ( pan ) canvas.addPendingOperation("Canvas.animatePan", canvas.animatePan, canvas, [{x: this.x, y: this.y}]);
		canvas.perception.schedule({
			sight: {initialize: true, refresh: true},
			lighting: {refresh: true},
			sounds: {refresh: true},
			foreground: {refresh: true}
		});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onRelease(options) {
		super._onRelease(options);
		this.zIndex = 0;
		canvas.perception.schedule({
			sight: {initialize: true, refresh: true},
			lighting: {refresh: true},
			sounds: {refresh: true},
			foreground: {refresh: true}
		});
	}

	/* -------------------------------------------- */

	/**
	 * Get the center-point coordinate for a given grid position
	 * @param {number} x    The grid x-coordinate that represents the top-left of the Token
	 * @param {number} y    The grid y-coordinate that represents the top-left of the Token
	 * @return {Object}     The coordinate pair which represents the Token's center at position (x, y)
	 */
	getCenter(x, y) {
		return {
			x: x + (this.w / 2),
			y: y + (this.h / 2)
		};
	}

	/* -------------------------------------------- */

	/**
	 * Set the token's position by comparing its center position vs the nearest grid vertex
	 * Return a Promise that resolves to the Token once the animation for the movement has been completed
	 * @param {number} x            The x-coordinate of the token center
	 * @param {number} y            The y-coordinate of the token center
	 * @param {object} [options={}] Additional options which configure the token movement
	 * @param {boolean} [options.animate=true]   Animate the movement path
	 * @return {Promise<Token>}     The Token after animation has completed
	 */
	async setPosition(x, y, {animate=true}={}) {

		// Create a Ray for the requested movement
		let origin = this._movement ? this.position : this._validPosition,
				target = {x: x, y: y},
				isVisible = this.isVisible;

		// Create the movement ray
		let ray = new Ray(origin, target);

		// Update the new valid position
		this._validPosition = target;

		// Record the Token's new velocity
		this._velocity = this._updateVelocity(ray);

		// Update visibility for a non-controlled token which may have moved into the controlled tokens FOV
		this.visible = isVisible;

		// Conceal the HUD if it targets this Token
		if ( this.hasActiveHUD ) this.layer.hud.clear();

		// Either animate movement to the destination position, or set it directly if animation is disabled
		if ( animate ) await this.animateMovement(new Ray(this.position, ray.B));
		else this.position.set(x, y);

		// If the movement took a controlled token off-screen, re-center the view
		if (this._controlled && isVisible) {
			let pad = 50;
			let gp = this.getGlobalPosition();
			if ((gp.x < pad) || (gp.x > window.innerWidth - pad) || (gp.y < pad) || (gp.y > window.innerHeight - pad)) {
				canvas.animatePan(this.center);
			}
		}
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Update the Token velocity auto-regressively, shifting increasing weight towards more recent movement
	 * Employ a magic constant chosen to minimize (effectively zero) the likelihood of trigonometric edge cases
	 * @param {Ray} ray     The proposed movement ray
	 * @return {Object}     An updated velocity with directional memory
	 * @private
	 */
	_updateVelocity(ray) {
		const v = this._velocity;
		const m = 0.89734721;
		return {
			dx: ray.dx,
			sx: ray.dx ? (m * Math.sign(ray.dx)) : (0.5 * m * Math.sign(v.sx)),
			dy: ray.dy,
			sy: ray.dy ? (m * Math.sign(ray.dy)) : (0.5 * m * Math.sign(v.sy))
		}
	}

	/* -------------------------------------------- */

	/**
	 * Set this Token as an active target for the current game User
	 * @param {boolean} targeted        Is the Token now targeted?
	 * @param {User|null} user          Assign the token as a target for a specific User
	 * @param {boolean} releaseOthers   Release other active targets for the same player?
	 * @param {boolean} groupSelection  Is this target being set as part of a group selection workflow?
	 */
	setTarget(targeted=true, {user=null, releaseOthers=true, groupSelection=false}={}) {
		user = user || game.user;

		// Release other targets
		if ( user.targets.size && releaseOthers ) {
			user.targets.forEach(t => {
				if ( t !== this ) t.setTarget(false, {releaseOthers: false});
			});
			user.targets.clear();
		}

		// Acquire target
		if ( targeted ) {
			this.targeted.add(user);
			user.targets.add(this);
		}

		// Release target
		else {
			this.targeted.delete(user);
			user.targets.delete(this);
		}

		// Refresh Token display
		this.refresh();

		// Refresh the Token HUD
		if ( this.hasActiveHUD ) this.layer.hud.render();

		// Broadcast the target change
		if ( !groupSelection ) user.broadcastActivity({targets: user.targets.ids});
	}

	/* -------------------------------------------- */

	/**
	 * Add or remove the currently controlled Tokens from the active combat encounter
	 * @param {Combat} [combat]    A specific combat encounter to which this Token should be added
	 * @return {Promise<Token>} The Token which initiated the toggle
	 */
	async toggleCombat(combat) {
		await this.layer.toggleCombat(!this.inCombat, combat, {token: this});
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Toggle an active effect by it's texture path.
	 * Copy the existing Array in order to ensure the update method detects the data as changed.
	 *
	 * @param {string|object} effect  The texture file-path of the effect icon to toggle on the Token.
	 * @param {object} [options]      Additional optional arguments which configure how the effect is handled.
	 * @param {boolean} [options.active]    Force a certain active state for the effect
	 * @param {boolean} [options.overlay]   Whether to set the effect as the overlay effect?
	 * @return {Promise<boolean>}   Was the texture applied (true) or removed (false)
	 */
	async toggleEffect(effect, {active, overlay=false}={}) {
		const fx = this.data.effects;
		const texture = effect.icon ?? effect;

		// Case 1 - handle an active effect object
		if ( effect.icon ) await this._toggleActiveEffect(effect, {overlay});

		// Case 2 - overlay effect
		else if ( overlay ) await this._toggleOverlayEffect(texture, {active});

		// Case 3 - add or remove a standard effect icon
		else {
			const idx = fx.findIndex(e => e === texture);
			if ((idx !== -1) && (active !== true)) fx.splice(idx, 1);
			else if ((idx === -1) && (active !== false)) fx.push(texture);
			await this.document.update({effects: fx}, {diff: false});
		}

		// Update the Token HUD
		if ( this.hasActiveHUD ) canvas.tokens.hud.refreshStatusIcons();
		return active;
	}

	/* -------------------------------------------- */

	/**
	 * A helper function to toggle a status effect which includes an Active Effect template
	 * @return {Promise<boolean>}
	 * @private
	 */
	async _toggleActiveEffect(effectData, {overlay=false}={}) {
		if ( !this.actor || !effectData.id ) return false;
		let state = false;

		// Remove an existing effect
		const existing = this.actor.effects.find(e => e.getFlag("core", "statusId") === effectData.id);
		if ( existing ) {
			await existing.delete();
			// FIXME: The duplicate call is temporarily needed to de-dupe legacy tokens. Remove in 0.9.0
			await this.toggleEffect(effectData.icon, {active: false, overlay});
		}

		// Add a new effect
		else {
			const createData = foundry.utils.deepClone(effectData);
			createData.label = game.i18n.localize(effectData.label);
			createData["flags.core.statusId"] = effectData.id;
			if ( overlay ) createData["flags.core.overlay"] = true;
			delete createData.id;
			const cls = getDocumentClass("ActiveEffect");
			await cls.create(createData, {parent: this.actor});
			state = true;
		}
		return state;
	}

	/* -------------------------------------------- */

	/**
	 * A helper function to toggle the overlay status icon on the Token
	 * @return {Promise<*>}
	 * @private
	 */
	async _toggleOverlayEffect(texture, {active}) {

		// Assign the overlay effect
		active = active ?? this.data.overlayEffect !== texture;
		let effect = active ? texture : null;
		await this.document.update({overlayEffect: effect});

		// Set the defeated status in the combat tracker
		// TODO - deprecate this and require that active effects be used instead
		if ( (texture === CONFIG.controlIcons.defeated) && game.combat ) {
			const combatant = game.combat.getCombatantByToken(this.id);
			if ( combatant ) await combatant.update({defeated: active});
		}
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Toggle the visibility state of any Tokens in the currently selected set
	 * @return {Promise<TokenDocument[]>}     A Promise which resolves to the updated Token documents
	 */
	async toggleVisibility() {
		let isHidden = this.data.hidden;
		const tokens = this._controlled ? canvas.tokens.controlled : [this];
		const updates = tokens.map(t => { return {_id: t.id, hidden: !isHidden}});
		return canvas.scene.updateEmbeddedDocuments("Token", updates);
	}

	/* -------------------------------------------- */

	/**
	 * Return the token's sight origin, tailored for the direction of their movement velocity to break ties with walls
	 * @return {Point}
	 */
	getSightOrigin() {
		let p = this.center;
		return {
			x: p.x - this._velocity.sx,
			y: p.y - this._velocity.sy
		};
	}

	/* -------------------------------------------- */

	/**
	 * A generic transformation to turn a certain number of grid units into a radius in canvas pixels.
	 * This function adds additional padding to the light radius equal to half the token width.
	 * This causes light to be measured from the outer token edge, rather than from the center-point.
	 * @param {number} units  The radius in grid units
	 * @return {number}       The radius in canvas units
	 */
	getLightRadius(units) {
		if (units === 0) return 0;
		const u = Math.abs(units);
		const hw = (this.w / 2);
		return (((u / canvas.dimensions.distance) * canvas.dimensions.size) + hw) * Math.sign(units);
	}

	/* -------------------------------------------- */

	/** @override */
	_getShiftedPosition(dx, dy) {
		let [x, y] = canvas.grid.grid.shiftPosition(this.x, this.y, dx, dy);
		let targetCenter = this.getCenter(x, y);
		let collide = this.checkCollision(targetCenter);
		return collide ? {x: this.data.x, y: this.data.y} : {x, y};
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	rotate(...args) {
		if ( this._movement ) return;
		super.rotate(...args);
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	_onCreate(options, userId) {

		// Initialize Tokens on the Sight Layer if the Token could be a vision source or emits light
		const refreshVision = this.data.vision && this.observer;
		const refreshLighting = this.emitsLight;
		if ( refreshVision || refreshLighting ) {
			this.updateSource({defer: true});
			canvas.perception.schedule({
				sight: {refresh: refreshVision},
				lighting: {refresh: refreshLighting}
			});
		}

		// Draw the object and display the new Token
		this.draw().then(() => {
			if ( !game.user.isGM && this.isOwner ) this.control({pan: true});
			this.visible = this.isVisible;
		});
	}

	/* -------------------------------------------- */

	/** @override */
	_onUpdate(data, options, userId) {
		const keys = Object.keys(data);
		const changed = new Set(keys);
		const fullRedraw = ["img", "name", "width", "height", "tint", "actorId", "actorLink"].some(r => changed.has(r));
		const positionChange = ["x", "y"].some(c => changed.has(c));

		// Full Token re-draw
		if ( fullRedraw ) {
			const visible = this.visible;
			this.draw();
			this.visible = visible;
		}

		// Partial token refresh
		else {
			if ( positionChange ) this.setPosition(this.data.x, this.data.y, options);
			if ( ["effects", "overlayEffect"].some(k => changed.has(k)) ) this.drawEffects();
			if ( changed.has("elevation") ) this.drawTooltip();
			const refreshBars = ["actorData", "displayBars"].some(k => k in data) || keys.some(k => k.startsWith("bar"));
			if ( refreshBars ) this.drawBars();
			this.refresh();
		}

		// Handle changes to the visibility state of the token
		const visibilityChange = changed.has("hidden");
		if ( visibilityChange ) {
			if ( !game.user.isGM ) {
				if ( this._controlled && data.hidden ) this.release();
				else if ( !data.hidden && !canvas.tokens.controlled.length ) this.control({pan: true});
			}
			this.visible = this.isVisible;
		}

		// Determine whether the token's perspective has changed
		const rotationChange = changed.has("rotation") && this.hasLimitedVisionAngle;
		let perspectiveChange = changed.has("vision") ||
			((this.data.vision || this.emitsLight) && (visibilityChange || positionChange || rotationChange)) ||
			(this.data.vision && ["dimSight", "brightSight", "sightAngle"].some(k => changed.has(k))) ||
			["dimLight", "brightLight", "lightAlpha", "lightAngle", "lightColor", "lightAnimation", "width", "height"].some(k => changed.has(k));
		if ( perspectiveChange ) {
			const animating = positionChange && (options.animate !== false);
			if ( !animating ) {  // Immediately update perception if not animating
				this.updateSource({defer: true});
				canvas.perception.schedule({
					lighting: {refresh: true},
					sight: {refresh: true, forceUpdateFog: this.hasLimitedVisionAngle},
					sounds: {refresh: true},
					foreground: {refresh: true}
				});
			}
		}

		// Process Combat Tracker changes
		if ( this.inCombat ) {
			if ( changed.has("name") ) {
				canvas.addPendingOperation(`Combat.setupTurns`, game.combat.setupTurns, game.combat);
			}
			if ( ["effects", "name", "overlayEffect"].some(k => changed.has(k)) ) {
				canvas.addPendingOperation(`CombatTracker.render`, ui.combat.render, ui.combat);
			}
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onDelete(options, userId) {

		// Cancel movement animations
		this.stopAnimation();

		// Remove target (if applicable)
		game.user.targets.delete(this);

		// Process changes to perception
		if (this.emitsLight || this.observer) {
			canvas.addPendingOperation("PerceptionManager#initialize", () => canvas.perception.initialize(), canvas.perception);
		}

		// Remove Combatants
		if (userId === game.user.id) {
			game.combats._onDeleteToken(this.scene.id, this.id);
		}

		// Parent class deletion handlers
		return super._onDelete(options, userId);
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	_canControl(user, event) {
		if ( canvas.controls.ruler.active ) return false;
		const tool = game.activeTool;
		if ( tool === "target" ) return true;
		return game.user.isGM || (this.actor?.testUserPermission(user, "OWNER") ?? false);
	}

	/* -------------------------------------------- */

	/** @override */
	_canHUD(user, event) {
		if ( canvas.controls.ruler.active ) return false;
		return user.isGM || (this.actor?.testUserPermission(user, "OWNER") ?? false);
	}

	/* -------------------------------------------- */

	/** @override */
	_canConfigure(user, event) {
		return true;
	}

	/* -------------------------------------------- */

	/** @override */
	_canHover(user, event) {
		return true;
	}

	/* -------------------------------------------- */

	/** @override */
	_canView(user, event) {
		if ( !this.actor ) ui.notifications.warn("TOKEN.WarningNoActor", {localize: true});
		return this.actor?.testUserPermission(user, "LIMITED");
	}

	/* -------------------------------------------- */

	/** @override */
	_canDrag(user, event) {
		if ( !this._controlled ) return false;
		const tool = game.activeTool;
		if (( tool !== "select" ) || game.keyboard.isCtrl(event) ) return false;
		const blockMove = game.paused && !game.user.isGM;
		return !this._movement && !blockMove;
	}

	/* -------------------------------------------- */

	/** @override */
	_onHoverIn(event, options) {
		const combatant = this.combatant;
		if ( combatant ) {
			const tracker = document.getElementById("combat-tracker");
			const li = tracker.querySelector(`.combatant[data-combatant-id="${combatant.id}"]`);
			if ( li ) li.classList.add("hover");
		}
		return super._onHoverIn(event, options);
	}

	/* -------------------------------------------- */

	/** @override */
	_onHoverOut(event) {
		const combatant = this.combatant;
		if ( combatant ) {
			const tracker = document.getElementById("combat-tracker");
			const li = tracker.querySelector(`.combatant[data-combatant-id="${combatant.id}"]`);
			if ( li ) li.classList.remove("hover");
		}
		return super._onHoverOut(event);
	}

	/* -------------------------------------------- */

	/** @override */
	_onClickLeft(event) {
		const tool = game.activeTool;
		const oe = event.data.originalEvent;
		let isRuler = (tool === "ruler") || ( oe.ctrlKey || oe.metaKey );
		if ( isRuler ) canvas.mouseInteractionManager._handleClickLeft(event);
		if ( tool === "target" ) return this.setTarget(!this.isTargeted, {releaseOthers: !oe.shiftKey});
		super._onClickLeft(event);
	}

	/* -------------------------------------------- */

	/** @override */
	_onClickLeft2(event) {
		const sheet = this.actor.sheet;
		if ( sheet.rendered ) {
			sheet.maximize();
			sheet.bringToTop();
		}
		else sheet.render(true, {token: this.document});
	}

	/* -------------------------------------------- */

	/** @override */
	_onClickRight2(event) {
		if ( this.isOwner ) {
			if ( game.user.can("TOKEN_CONFIGURE") ) return super._onClickRight2(event);
		}
		else return this.setTarget(!this.targeted.has(game.user), {releaseOthers: !event.data.originalEvent.shiftKey});
	}

	/* -------------------------------------------- */

	/** @override */
	_onDragLeftDrop(event) {
		const clones = event.data.clones || [];
		const {originalEvent, destination} = event.data;
		const preview = game.settings.get("core", "tokenDragPreview");

		// Ensure the cursor destination is within bounds
		if ( !canvas.dimensions.rect.contains(destination.x, destination.y) ) return false;

		// Compute the final dropped positions
		const updates = clones.reduce((updates, c) => {

			// Reset vision back to the initial location
			if ( preview )  c._original.updateSource({noUpdateFog: true});

			// Get the snapped top-left coordinate
			let dest = {x: c.data.x, y: c.data.y};
			if ( !originalEvent.shiftKey && (canvas.grid.type !== CONST.GRID_TYPES.GRIDLESS) ) {
				const isTiny = (c.data.width < 1) && (c.data.height < 1);
				dest = canvas.grid.getSnappedPosition(dest.x, dest.y, isTiny ? 2 : 1);
			}

			// Test collision for each moved token vs the central point of it's destination space
			const target = c.getCenter(dest.x, dest.y);
			if ( !game.user.isGM ) {
				c._velocity = c._original._velocity;
				let collides = c.checkCollision(target);
				if ( collides ) {
					ui.notifications.error("ERROR.TokenCollide", {localize: true});
					return updates
				}
			}

			// Otherwise ensure the final token center is in-bounds
			else if ( !canvas.dimensions.rect.contains(target.x, target.y) ) return updates;

			// Perform updates where no collision occurs
			updates.push({_id: c._original.id, x: dest.x, y: dest.y});
			return updates;
		}, []);
		return canvas.scene.updateEmbeddedDocuments("Token", updates);
	}

	/* -------------------------------------------- */

	/** @override */
	_onDragLeftMove(event) {
		const {clones, destination, origin, originalEvent} = event.data;
		const preview = game.settings.get("core", "tokenDragPreview");

		// Pan the canvas if the drag event approaches the edge
		canvas._onDragCanvasPan(originalEvent);

		// Determine dragged distance
		const dx = destination.x - origin.x;
		const dy = destination.y - origin.y;

		// Update the position of each clone
		for ( let c of clones || [] ) {
			const o = c._original;
			const x = o.data.x + dx;
			const y = o.data.y + dy;
			if ( preview && !game.user.isGM ) {
				const collision = o.checkCollision(o.getCenter(x, y));
				if ( collision ) continue;
			}
			c.data.x = x;
			c.data.y = y;
			c.refresh();
			if ( preview ) c.updateSource({noUpdateFog: true});
		}
	}

	/* -------------------------------------------- */
	/*  DEPRECATED FUNCTIONS                        */
	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	static async fromActor(actor, tokenData={}) {
		throw new Error("The Token.fromActor factory method has been deprecated in favor of passing the result from Actor#getTokenData to the TokenDocument constructor")
	}

	/* -------------------------------------------- */

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	getBarAttribute(barName, {alternative}={}) {
		console.warn("The Token#getBarAttribute method has been moved to TokenDocument#getBarAttribute. Support will be removed in 0.9.0")
		return this.document.getBarAttribute(barName, {alternative});
	}
}

/**
 * A "secret" global to help debug attributes of the currently controlled Token.
 * This is only for debugging, and may be removed in the future, so it's not safe to use.
 * @type {Token}
 * @ignore
 */
let _token = null;
/**
 * A Wall is an implementation of PlaceableObject which represents a physical or visual barrier within the Scene.
 * Walls are used to restrict Token movement or visibility as well as to define the areas of effect for ambient lights
 * and sounds.
 * @extends {PlaceableObject}
 * @see {@link WallDocument}
 * @see {@link WallsLayer}
 * @see {@link WallConfig}
 */
class Wall extends PlaceableObject {
	constructor(document) {
		super(document);

		/**
		 * An reference the Door Control icon associated with this Wall, if any
		 * @type {DoorControl|null}
		 * @private
		 */
		this.doorControl = null;
	}

	/**
	 * A reference to an overhead Tile that is a roof, interior to which this wall is contained
	 * @type {Tile}
	 */
	roof;

	/** @inheritdoc */
	static embeddedName = "Wall";

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * A convenience reference to the coordinates Array for the Wall endpoints, [x0,y0,x1,y1].
	 * @type {number[]}
	 */
	get coords() {
		return this.data.c;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get bounds() {
		const [x0, y0, x1, y1] = this.data.c;
		return new NormalizedRectangle(x0, y0, x1-x0, y1-y0);
	}

	/* -------------------------------------------- */

	/**
	 * Return the coordinates [x,y] at the midpoint of the wall segment
	 * @return {Array.<number>}
	 */
	get midpoint() {
		return [(this.coords[0] + this.coords[2]) / 2, (this.coords[1] + this.coords[3]) / 2]
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	get center() {
		const [x,y] = this.midpoint;
		return new PIXI.Point(x, y)
	}

	/* -------------------------------------------- */

	/**
	 * Get the direction of effect for a directional Wall
	 * @return {number|null}   The angle of wall effect
	 */
	get direction() {
		let d = this.data.dir;
		if ( !d ) return null;
		let c = this.coords;
		let angle = Math.atan2(c[3] - c[1], c[2] - c[0]);
		if ( d === CONST.WALL_DIRECTIONS.LEFT ) return angle + (Math.PI / 2);
		else return angle - (Math.PI / 2);
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * This helper converts the wall segment to a Ray
	 * @return {Ray}    The wall in Ray representation
	 */
	toRay() {
		return Ray.fromArrays(this.coords.slice(0, 2), this.coords.slice(2,));
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async draw() {
		this.clear();

		// Draw wall components
		this.directionIcon = this.data.dir ? this.addChild(this._drawDirection()) : null;
		this.line = this.addChild(new PIXI.Graphics());
		this.endpoints = this.addChild(new PIXI.Graphics());

		// Draw current wall
		this.refresh();

		// Enable interactivity, only if the Tile has a true ID
		if ( this.id ) this.activateListeners();
		return this;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_createInteractionManager() {
		const mgr = super._createInteractionManager();
		mgr.options.target = ["endpoints"];
		return mgr;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners() {
		super.activateListeners();
		this.line.interactive = true;
		this.line.on("mouseover", this._onMouseOverLine, this)
						 .on("mouseout", this._onHoverOut, this);
	}

	/* -------------------------------------------- */

	/**
	 * Draw a directional prompt icon for one-way walls to illustrate their direction of effect.
	 * @return {PIXI.Sprite|null}    The drawn icon
	 * @private
	 */
	_drawDirection() {
		if (this.directionIcon) this.removeChild(this.directionIcon);
		let d = this.data.dir;
		if ( !d ) return null;

		// Create the icon
		const icon = PIXI.Sprite.from("icons/svg/wall-direction.svg");
		icon.width = icon.height = 32;

		// Rotate the icon
		let iconAngle = -Math.PI / 2;
		let angle = this.direction;
		icon.anchor.set(0.5, 0.5);
		icon.rotation = iconAngle + angle;
		return icon;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	refresh() {
		const p = this.coords;
		const mp = [(p[0] + p[2]) / 2, (p[1] + p[3]) / 2];
		const wc = this._getWallColor();

		// Determine circle radius and line width
		let lw = 2;
		if ( canvas.dimensions.size > 150 ) lw = 4;
		else if ( canvas.dimensions.size > 100 ) lw = 3;
		const  cr = this._hover ? lw * 3 : lw * 2;
		let lw3 = lw * 3;

		// Draw background
		this.line.clear()
			.lineStyle(lw3, 0x000000, 1.0)
			.moveTo(p[0], p[1])
			.lineTo(p[2], p[3]);
		this.endpoints.clear()
			.beginFill(0x000000, 1.0)
			.drawCircle(p[0], p[1], cr + lw)
			.drawCircle(p[2], p[3], cr + lw);

		// Draw foreground
		this.line.lineStyle(lw, wc, 1.0)
			.lineTo(p[0], p[1]);
		this.endpoints.beginFill(wc, 1.0)
			.drawCircle(p[0], p[1], cr)
			.drawCircle(p[2], p[3], cr);

		// Tint direction icon
		if ( this.directionIcon ) {
			this.directionIcon.position.set(mp[0], mp[1]);
			this.directionIcon.tint = wc;
		}

		// Update line hit area
		this.line.hitArea = this._getWallHitPolygon(p, lw3);
		// this.line.beginFill(0x00FF00, 1.0).drawShape(this.line.hitArea).endFill(); // Debug line hit area
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Compute an approximate Polygon which encloses the line segment providing a specific hitArea for the line
	 * @param {number[]} coords     The original wall coordinates
	 * @param {number} pad          The amount of padding to apply
	 * @return {PIXI.Polygon}       A constructed Polygon for the line
	 * @private
	 */
	_getWallHitPolygon(coords, pad) {

		// Identify wall orientation
		const dx = coords[2] - coords[0];
		const dy = coords[3] - coords[1];

		// Define the array of polygon points
		let points;
		if ( Math.abs(dx) >= Math.abs(dy) ) {
			const sx = Math.sign(dx);
			points = [
				coords[0]-(pad*sx), coords[1]-pad,
				coords[2]+(pad*sx), coords[3]-pad,
				coords[2]+(pad*sx), coords[3]+pad,
				coords[0]-(pad*sx), coords[1]+pad
			];
		} else {
			const sy = Math.sign(dy);
			points = [
				coords[0]-pad, coords[1]-(pad*sy),
				coords[2]-pad, coords[3]+(pad*sy),
				coords[2]+pad, coords[3]+(pad*sy),
				coords[0]+pad, coords[1]-(pad*sy)
			];
		}

		// Return a Polygon which pads the line
		return new PIXI.Polygon(points);
	}

	/* -------------------------------------------- */

	/**
	 * Given the properties of the wall - decide upon a color to render the wall for display on the WallsLayer
	 * @private
	 */
	_getWallColor() {

		// Invisible Walls
		if ( this.data.sense === CONST.WALL_SENSE_TYPES.NONE ) return 0x77E7E8;

		// Terrain Walls
		else if ( this.data.sense === CONST.WALL_SENSE_TYPES.LIMITED ) return 0x81B90C;

		// Ethereal Walls
		else if ( this.data.move === CONST.WALL_SENSE_TYPES.NONE ) return 0xCA81FF;

		// Doors
		else if ( this.data.door === CONST.WALL_DOOR_TYPES.DOOR ) {
			let ds = this.data.ds || CONST.WALL_DOOR_STATES.CLOSED;
			if ( ds === CONST.WALL_DOOR_STATES.CLOSED ) return 0x6666EE;
			else if ( ds === CONST.WALL_DOOR_STATES.OPEN ) return 0x66CC66;
			else if ( ds === CONST.WALL_DOOR_STATES.LOCKED ) return 0xEE4444;
		}

		// Secret Doors
		else if ( this.data.door === CONST.WALL_DOOR_TYPES.SECRET ) {
			let ds = this.data.ds || CONST.WALL_DOOR_STATES.CLOSED;
			if ( ds === CONST.WALL_DOOR_STATES.CLOSED ) return 0xA612D4;
			else if ( ds === CONST.WALL_DOOR_STATES.OPEN ) return 0x7C1A9b;
			else if ( ds === CONST.WALL_DOOR_STATES.LOCKED ) return 0xEE4444;
		}

		// Standard Walls
		else return 0xFFFFBB;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onControl({chain=false}={}) {

		// Add chained walls
		if ( chain ) {
			const links = this.getLinkedSegments();
			for ( let l of links.walls ) {
				l._controlled = true;
				this.layer._controlled[l.id] = l;
			}
		}

		// Draw control highlights
		this.layer.highlightControlledSegments();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onRelease(options) {
		this.layer.highlightControlledSegments();
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	destroy(options) {
		if (this.data.door && this.doorControl) this.doorControl.destroy({children: true});
		super.destroy(options);
	}

	/* -------------------------------------------- */

	/**
	 * Test whether the Wall direction lies between two provided angles
	 * This test is used for collision and vision checks against one-directional walls
	 * @param {number} lower    The lower-bound limiting angle in radians
	 * @param {number} upper    The upper-bound limiting angle in radians
	 * @return {boolean}
	 */
	isDirectionBetweenAngles(lower, upper) {
		let d = this.direction;
		if ( d < lower ) {
			while ( d < lower ) d += (2 * Math.PI);
		} else if ( d > upper ) {
			while ( d > upper ) d -= (2 * Math.PI);
		}
		return ( d > lower && d < upper );
	}

	/* -------------------------------------------- */

	/**
	 * A simple test for whether a Ray can intersect a directional wall
	 * @param {Ray} ray     The ray to test
	 * @return {boolean}    Can an intersection occur?
	 */
	canRayIntersect(ray) {
		if ( this.direction === null ) return true;
		return this.isDirectionBetweenAngles(ray.angle - (Math.PI/2), ray.angle + (Math.PI/2));
	}

	/* -------------------------------------------- */

	/**
	 * Get an Array of Wall objects which are linked by a common coordinate
	 * @returns {Object}    An object reporting ids and endpoints of the linked segments
	 */
	getLinkedSegments() {
		const test = new Set();
		const done = new Set();
		const ids = new Set();
		const objects = [];

		// Helper function to add wall points to the set
		const _addPoints = w => {
			let p0 = w.coords.slice(0,2).join(".");
			if ( !done.has(p0) ) test.add(p0);
			let p1 = w.coords.slice(2,).join(".");
			if ( !done.has(p1) ) test.add(p1);
		};

		// Helper function to identify other walls which share a point
		const _getWalls = p => {
			return canvas.walls.placeables.filter(w => {
				if ( ids.has(w.id) ) return false;
				let p0 = w.coords.slice(0,2).join(".");
				let p1 = w.coords.slice(2,).join(".");
				return ( p === p0 ) || ( p === p1 );
			})
		};

		// Seed the initial search with this wall's points
		_addPoints(this);

		// Begin recursively searching
		while ( test.size > 0 ) {
			const testIds = new Array(...test);
			for ( let p of testIds ) {
				let walls = _getWalls(p);
				walls.forEach(w => {
					_addPoints(w);
					if ( !ids.has(w.id) ) objects.push(w);
					ids.add(w.id);
				});
				test.delete(p);
				done.add(p);
			}
		}

		// Return the wall IDs and their endpoints
		return {
			ids: new Array(...ids),
			walls: objects,
			endpoints: new Array(...done).map(p => p.split(".").map(Number))
		};
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_onCreate(...args) {
		super._onCreate(...args);
		this.layer._cloneType = this.document.toJSON();
		this._onModifyWall(this.data.door !== CONST.WALL_DOOR_TYPES.NONE);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onUpdate(data, ...args) {
		super._onUpdate(data, ...args);

		// Re-draw if the direction changed
		if ( data.hasOwnProperty("dir") ) this.draw();

		// If the wall is controlled, update the highlighted segments
		if ( this._controlled ) {
			canvas.addPendingOperation("WallsLayer.highlightControlledSegments", this.layer.highlightControlledSegments, this.layer);
		}

		// Downstream layer operations
		this.layer._cloneType = this.document.toJSON();

		// // If the type of door or door state has changed also modify the door icon
		const rebuildEndpoints = ["move", "sense", "c"].some(k => k in data);
		const doorChange = this.data.door && (("door" in data) || ("ds" in data));
		if ( rebuildEndpoints || doorChange ) this._onModifyWall(doorChange);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDelete(...args) {
		super._onDelete(...args);
		const wasControlled = this._controlled;

		// Clear last coordinates from the layer
		if ( this.layer.last.id === this.id ) this.layer.last.id = null;

		// Release the deleted wall and update highlighted segments
		this.release();
		if ( wasControlled ) {
			canvas.addPendingOperation("WallsLayer.highlightControlledSegments", this.layer.highlightControlledSegments, this.layer);
		}

		// Refresh the display
		this._onModifyWall(false);
	}

	/* -------------------------------------------- */

	/**
	 * Callback actions when a wall that contains a door is moved or its state is changed
	 * @param {boolean} doorChange   Update vision and sound restrictions
	 * @private
	 */
	_onModifyWall(doorChange=false) {

		// Update WallsLayer data
		canvas.addPendingOperation("WallsLayer.initialize", this.layer.initialize, this.layer);

		// Re-draw door icons
		if ( doorChange ) {
			const dt = this.data.door;
			const hasCtrl = (dt === CONST.WALL_DOOR_TYPES.DOOR) || ((dt === CONST.WALL_DOOR_TYPES.SECRET) && game.user.isGM);
			if ( hasCtrl ) {
				if ( this.doorControl ) this.doorControl.draw(); // Asynchronous
				else canvas.controls.createDoorControl(this);
			}
			else if ( this.doorControl ) {
				this.doorControl.parent.removeChild(this.doorControl);
				this.doorControl = null;
			}
		}

		// Re-initialize perception
		canvas.addPendingOperation("PerceptionManager#initialize", () => canvas.perception.initialize(), canvas.perception);
	}

	/* -------------------------------------------- */
	/*  Interaction Event Callbacks                 */
	/* -------------------------------------------- */

	/** @inheritdoc */
	_canControl(user, event) {
		return !game.keyboard.isCtrl(event);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onHoverIn(event, options) {
		this.zIndex = 1;
		if ( !this.layer._chain && event.data ) {
			const dest = event.data.getLocalPosition(this.layer);
			this.layer.last = {
				id: this.data._id,
				point: WallsLayer.getClosestEndpoint(dest, this)
			};
		}
		return super._onHoverIn(event, options);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onHoverOut(event) {
		this.zIndex = 0;
		return super._onHoverOut(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-hover events on the line segment itself, pulling the Wall to the front of the container stack
	 * @private
	 */
	_onMouseOverLine(event) {
		event.stopPropagation();
		if ( this.layer.preview.children.length ) return;
		this.zIndex = 1;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onClickLeft(event) {
		const oe = event.data.originalEvent;
		if ( this._controlled ) {
			if ( oe.shiftKey ) return this.release();
		}
		else return this.control({releaseOthers: !oe.shiftKey, chain: oe.altKey});
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onClickLeft2(event) {
		const sheet = this.sheet;
		const controlled = this.layer.controlled;
		if ( controlled.length > 1 ) sheet.options.editTargets = controlled.map(w => w.id);
		sheet.render(true);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onClickRight2(event) {
		return this._onClickLeft2(event);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftStart(event) {
		const { origin } = event.data;
		const dLeft = Math.hypot(origin.x - this.coords[0], origin.y - this.coords[1]);
		const dRight = Math.hypot(origin.x - this.coords[2], origin.y - this.coords[3]);
		event.data["fixed"] = dLeft < dRight ? 1 : 0; // Affix the opposite point
		return super._onDragLeftStart(event);
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_onDragLeftMove(event) {
		const {clones, destination, fixed, origin, originalEvent} = event.data;

		// Pan the canvas if the drag event approaches the edge
		canvas._onDragCanvasPan(originalEvent);

		// Group movement
		if ( clones.length > 1 ) {
			const dx = destination.x - origin.x;
			const dy = destination.y - origin.y;
			for ( let c of clones ) {
				c.data.c = c._original.data.c.map((p, i) => i % 2 ? p + dy : p + dx);
			}
		}

		// Single-wall pivot
		else if ( clones.length === 1 ) {
			const w = clones[0];
			const pt = [destination.x, destination.y];
			w.data.c = fixed ? pt.concat(this.coords.slice(2,4)) : this.coords.slice(0, 2).concat(pt);
		}

		// Refresh display
		clones.forEach(c => c.refresh());
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	async _onDragLeftDrop(event) {
		const {clones, destination, fixed, originalEvent} = event.data;
		const layer = this.layer;
		const snap = layer._forceSnap || !originalEvent.shiftKey;

		// Get the snapped final point
		const pt = this.layer._getWallEndpointCoordinates(destination, {snap});

		// Pivot a single wall
		if ( clones.length === 1 ) {
			const p0 = fixed ? this.coords.slice(2,4) : this.coords.slice(0,2);
			const coords = fixed ? pt.concat(p0) : p0.concat(pt);
			if ( (coords[0] === coords[2]) && (coords[1] === coords[3]) ) {
				return this.document.delete(); // If we collapsed the wall, delete it
			}
			this.layer.last.point = pt;
			return this.document.update({c: coords});
		}

		// Drag a group of walls - snap to the end point maintaining relative positioning
		const p0 = fixed ? this.coords.slice(0,2) : this.coords.slice(2,4);
		const dx = pt[0] - p0[0];
		const dy = pt[1] - p0[1];
		const updates = clones.map(w => {
			const c = w._original.data.c;
			return {_id: w._original.id, c: [c[0]+dx, c[1]+dy, c[2]+dx, c[3]+dy]};
		});
		return canvas.scene.updateEmbeddedDocuments("Wall", updates);
	}
}

const BLEND_MODES = {};

/**
 * A custom blend mode equation which chooses the maximum color from each channel within the stack.
 * @type {number[]}
 */
BLEND_MODES.MAX_COLOR = [
	WebGL2RenderingContext.ONE,
	WebGL2RenderingContext.ONE,
	WebGL2RenderingContext.ONE,
	WebGL2RenderingContext.ONE,
	WebGL2RenderingContext.MAX,
	WebGL2RenderingContext.MAX
];

/**
 * A custom blend mode equation which chooses the minimum color from each channel within the stack.
 * @type {number[]}
 */
BLEND_MODES.MIN_COLOR = [
	WebGL2RenderingContext.ONE,
	WebGL2RenderingContext.ONE,
	WebGL2RenderingContext.ONE,
	WebGL2RenderingContext.ONE,
	WebGL2RenderingContext.MIN,
	WebGL2RenderingContext.MAX
];

/**
 * This class defines an interface for masked custom filters
 * @extends {PIXI.Filter}
 * @interface
 */
class AbstractBaseMaskFilter extends PIXI.Filter {

	/**
	 * The default vertex shader used by all instances of AbstractBaseMaskFilter
	 * @type {string}
	 */
	static vertexShader = `
	attribute vec2 aVertexPosition;

	uniform mat3 projectionMatrix;
	uniform vec2 screenDimensions;
	uniform vec4 inputSize;
	uniform vec4 outputFrame;

	varying vec2 vTextureCoord;
	varying vec2 vMaskTextureCoord;

	vec4 filterVertexPosition( void ) {
			vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;
			return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0., 1.);
	}

	// getting normalized coord for the tile texture
	vec2 filterTextureCoord( void ) {
			return aVertexPosition * (outputFrame.zw * inputSize.zw);
	}

	// getting normalized coord for a screen sized mask render texture
	vec2 filterMaskTextureCoord( in vec2 textureCoord ) {
		return (textureCoord * inputSize.xy + outputFrame.xy) / screenDimensions;
	}

	void main() {
		vTextureCoord = filterTextureCoord();
		vMaskTextureCoord = filterMaskTextureCoord(vTextureCoord);
		gl_Position = filterVertexPosition();
	}`;

	/**
	 * The fragment shader which renders this filter.
	 * A subclass of AbstractBaseMaskFilter must implement the fragmentShader(channel) static field.
	 * @type {Function}
	 */
	static fragmentShader = null;

	/**
	 * A factory method for creating the filter using its defined default values
	 * @param {object} [defaultUniforms]    Initial uniforms provided to the filter
	 * @param {string} [channel=r]          A color channel to target for masking.
	 * @return {AbstractBaseMaskFilter}
	 */
	static create(defaultUniforms={}, channel="r") {
		defaultUniforms.screenDimensions = [1, 1];
		return new this(this.vertexShader, this.fragmentShader(channel), defaultUniforms);
	}

	/** @override */
	apply(filterManager, input, output, clear, currentState) {
		const screen = filterManager.renderer.screen ?? null;
		if (screen) this.uniforms.screenDimensions = [screen.width, screen.height];
		filterManager.applyFilter(this, input, output, clear);
	}
}

/* -------------------------------------------- */

/**
 * A filter used to control channels intensity using an externally provided mask texture.
 * The mask channel used must be provided at filter creation.
 * Contributed by SecretFire#4843
 * @extends {AbstractBaseMaskFilter}
 */
class InverseOcclusionMaskFilter extends AbstractBaseMaskFilter {
	static fragmentShader(channel) {
	return `
	precision mediump float;
	varying vec2 vTextureCoord;
	varying vec2 vMaskTextureCoord;
	uniform sampler2D uSampler;
	uniform sampler2D uMaskSampler;
	uniform float alphaOcclusion;
	void main() {
		vec4 tex = texture2D(uMaskSampler, vMaskTextureCoord);
		float mask = 1.0 - tex.${channel} + alphaOcclusion * tex.${channel};
		gl_FragColor = texture2D(uSampler, vTextureCoord) * mask;
	}`;
	};
}

/**
 * This class defines an interface which all shaders utilize
 * @extends {PIXI.Shader}
 * @interface
 */
class AbstractBaseShader extends PIXI.Shader {
	constructor(program, uniforms) {
		super(program, duplicate(uniforms));

		/**
		 * The initial default values of shader uniforms
		 * @type {object}
		 * @private
		 */
		this._defaults = uniforms;
	}

	/**
	 * The default vertex shader used by all instances of AbstractBaseShader
	 * @type {string}
	 */
	static vertexShader = `
	precision mediump float;
	attribute vec2 aVertexPosition;
	attribute vec2 aUvs;
	uniform mat3 translationMatrix;
	uniform mat3 projectionMatrix;
	varying vec2 vUvs;
	
	void main() {
			vUvs = aUvs;
			gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
	}
	`;

	/**
	 * The fragment shader which renders this source.
	 * A subclass of AbstractBaseShader must implement the fragmentShader static field.
	 * @type {string}
	 */
	static fragmentShader = "";

	/**
	 * The default uniform values for the shader.
	 * A subclass of AbstractBaseShader must implement the defaultUniforms static field.
	 * @type {object}
	 */
	static defaultUniforms = {};

	/**
	 * A factory method for creating the shader using its defined default values
	 * @return {AbstractBaseShader}
	 */
	static create(defaultUniforms) {
		const program = PIXI.Program.from(this.vertexShader, this.fragmentShader);
		const uniforms = mergeObject(this.defaultUniforms, defaultUniforms, { inplace: false, insertKeys: false });
		return new this(program, uniforms);
	}

	/**
	 * Reset the shader uniforms back to their provided default values
	 * @private
	 */
	reset() {
		for (let [k, v] of Object.entries(this._defaults)) {
			this.uniforms[k] = v;
		}
	}

	/* -------------------------------------------- */
	/*  GLSL Helper Functions                       */
	/* -------------------------------------------- */

	/**
	 * A Vec3 pseudo-random generator, based on uv position
	 * @type {string}
	 */
	static PRNG3D = `
	vec3 random(in vec3 uv) {
		return vec3(fract(cos(dot(uv, vec3(12.9898,  234.1418,    152.01))) * 43758.5453),
								fract(sin(dot(uv, vec3(80.9898,  545.8937, 151515.12))) * 23411.1789),
								fract(cos(dot(uv, vec3(01.9898, 1568.5439,    154.78))) * 31256.8817));
	}`;

	/* -------------------------------------------- */

	/**
	 * A conventional pseudo-random number generator with the "golden" numbers, based on uv position
	 * @type {string}
	 */
	static PRNG = `
	float random(in vec2 uv) { 
		return fract(cos(dot(uv, vec2(12.9898, 4.1414))) * 43758.5453);
	}`;

	/* -------------------------------------------- */

	/**
	 * A conventional noise generator
	 * @type {string}
	 */
	static NOISE = `
	float noise(in vec2 uv) {
		const vec2 d = vec2(0.0, 1.0);
		vec2 b = floor(uv);
		vec2 f = smoothstep(vec2(0.), vec2(1.0), fract(uv));
		return mix(
			mix(random(b), random(b + d.yx), f.x), 
			mix(random(b + d.xy), random(b + d.yy), f.x), 
			f.y
		);
	}`;

	/* -------------------------------------------- */

	/**
	 * Fractional Brownian Motion for a given number of octaves
	 * @type {string}
	 */
	static FBM(octaves = 4, amp = 1.0) {
		return `float fbm(in vec2 uv) {
			float total = 0.0, amp = ${amp.toFixed(1)};
			for (int i = 0; i < ${octaves}; i++) {
				total += noise(uv) * amp;
				uv += uv;
				amp *= 0.5;
			}
			return total;
		}`;
	}

	/* -------------------------------------------- */

	/**
	 * Fade easing to use with distance in interval [0,1]
	 * @type {string}
	 */
	static FADE(amp = 3, coef = 0.80) {
		return `float fade(in float dist) {
			float ampdist = dist;
			for (int i = 1; i < ${amp}; i++) {
				ampdist *= ampdist;
			}
			return 1.0 - (${coef.toFixed(2)} * ampdist * (${(amp + 1).toFixed(1)} - ${amp.toFixed(1)} * dist));
		}`;
	}

	/* -------------------------------------------- */

	/**
	 * Convert a Hue-Saturation-Brightness color to RGB - useful to convert polar coordinates to RGB
	 * @type {string}
	 */
	static HSB2RGB = `
		vec3 hsb2rgb(in vec3 c) {
		vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0 );
		rgb = rgb*rgb*(3.0-2.0*rgb);
		return c.z * mix(vec3(1.0), rgb, c.y);
	}`;
}

/* -------------------------------------------- */

/**
 * The default coloration shader used by standard rendering and animations
 * A fragment shader which creates a solid light source.
 * @implements {AbstractBaseShader}
 */
class StandardIlluminationShader extends AbstractBaseShader {
	static fragmentShader = `
	precision mediump float;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 colorDim;
	uniform vec3 colorBright;
	varying vec2 vUvs;
	
	void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
			vec3 color = mix(colorDim, colorBright, step(dist, ratio));
			gl_FragColor = vec4(color * alpha, 1.0);
	}`;
	static defaultUniforms = {
		alpha: 1.0,
		ratio: 0.5,
		colorDim: [0.5, 0.5, 0.5],
		colorBright: [1.0, 1.0, 1.0],
		time: 0,
		intensity: 5
	}
}

/* -------------------------------------------- */

/**
 * The default coloration shader used by standard rendering and animations.
 * A fragment shader which creates a light source.
 * @implements {AbstractBaseShader}
 */
class StandardColorationShader extends AbstractBaseShader {
	static fragmentShader = `
	precision mediump float;
	uniform bool darkness;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;
	
	${AbstractBaseShader.FADE(3, 1)}
		
	void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
			vec3 fcolor = (darkness ? vec3(0.0) : color * fade(dist) * alpha);
			gl_FragColor = vec4(fcolor, 1.0);
	}`;
	static defaultUniforms = {
		alpha: 1.0,
		color: [1.0, 1.0, 1.0],
		time: 0,
		intensity: 5,
		darkness: false,
	}
}

/* -------------------------------------------- */

/**
 * Allow coloring of illumination 
 * @implements {StandardIlluminationShader}
 * @author SecretFire
 */
class TorchIlluminationShader extends StandardIlluminationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 colorDim;
	uniform vec3 colorBright;
	varying vec2 vUvs;

	void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;      
			float fade = pow(1.0 - dist, 0.20);

			vec3 color = mix(colorDim, colorBright, step(dist, ratio));
			gl_FragColor = vec4(color * alpha * fade, 1.0);
	}`;
}

/* -------------------------------------------- */

/**
 * Torch animation coloration shader
 * @implements {StandardColorationShader}
 * @author SecretFire
 */
class TorchColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 color;
	varying vec2 vUvs;
	
	const float MU_TWOPI = 0.1591549431;

	float torchfade(in float dist, in float fadepower) {
			return pow(clamp(1.0 - dist, 0.0, 1.0), fadepower);
	}

	void main() {
			vec2 uv = (vUvs * 2.0) - 1.0;
			float dist = length(uv);
			
			// creating the central waving "starlight"
			float angle = atan(uv.x, uv.y) * MU_TWOPI;
			float flame = fract(angle * 64.0 + time);

			// compose the flame, put smooth gradient on all "edges"
			float df = pow( abs(max(flame, 1.0 - flame)), 0.05);

			// inner dancing flame distance
			float distr = dist / ratio * 0.75 / clamp(df, 0.1, 1.0);
			
			// maxing from coloration and the inner dancing flame
			gl_FragColor = vec4( max(color * torchfade(dist, 1.8), 
										           color * torchfade(distr, 1.2) * 1.5)
										       * alpha, 1.0);
	}
	`;

	/** @inheritdoc */
	static defaultUniforms = Object.assign({}, super.defaultUniforms, {
		ratio: 0,
		color: PIXI.utils.hex2rgb(0xb86200)
	});
}

/* -------------------------------------------- */

/**
 * Pulse animation illumination shader
 * @implements {StandardIlluminationShader}
 * @author SecretFire
 */
class PulseIlluminationShader extends StandardIlluminationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 colorDim;
	uniform vec3 colorBright;
	varying vec2 vUvs;

	void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
			float fade = pow(abs(1.0 - dist * dist), 1.01 - ratio);
			vec3 color = mix(colorDim, colorBright, step(dist, ratio));
			gl_FragColor = vec4(color * alpha * fade, 1.0);
	}`;
}

/* -------------------------------------------- */

/**
 * Pulse animation coloration shader
 * @implements {StandardColorationShader}
 * @author SecretFire
 */
class PulseColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float pulse;
	uniform vec3 color;
	varying vec2 vUvs;

	float pfade(in float dist, in float pulse) {
			return pow(1.0 - dist, 1.25 - (pulse * 0.5));
	}

	void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
			gl_FragColor = vec4(color * pfade(dist, pulse) * alpha, 1.0);
	}`;

	/** @inheritdoc */
	static defaultUniforms = Object.assign({}, super.defaultUniforms, {
		pulse: 0,
		color: PIXI.utils.hex2rgb(0xEEEEEE)
	});
}

/* -------------------------------------------- */

/**
 * Energy field animation coloration shader
 * @implements {StandardColorationShader}
 * @author SecretFire
 */
class EnergyFieldColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;

	${AbstractBaseShader.PRNG3D}

	// classic 3d voronoi (with some bug fixes)
	vec3 voronoi3d(const in vec3 x) {
			vec3 p = floor(x);
			vec3 f = fract(x);
		
			float id = 0.0;
			vec2 res = vec2(100.0);
		
			for (int k = -1; k <= 1; k++) {
				for (int j = -1; j <= 1; j++) {
					for (int i = -1; i <= 1; i++) {
					
						vec3 b = vec3(float(i), float(j), float(k));
						vec3 r = vec3(b) - f + random(p + b);
					
						float d = dot(r, r);
						float cond = max(sign(res.x - d), 0.0);
						float nCond = 1.0 - cond;
						float cond2 = nCond * max(sign(res.y - d), 0.0);
						float nCond2 = 1.0 - cond2;
		
						id = (dot(p + b, vec3(1.0, 67.0, 142.0)) * cond) + (id * nCond);
						res = vec2(d, res.x) * cond + res * nCond;
		
						res.y = cond2 * d + nCond2 * res.y;
					}
				}
			}
			// replaced abs(id) by pow( abs(id + 10.0), 0.01)
			// needed to remove artifacts in some specific configuration
			return vec3( sqrt(res), pow( abs(id + 10.0), 0.01) );
	}

	void main() {
			vec2 uv = vUvs;
			float dist = distance(uv, vec2(0.5)) * 2.0;
		
			// Hemispherize and scaling the uv
			float f = (1.0 - sqrt(1.0 - dist)) / dist;
			uv -= vec2(0.5);
			uv *= f * 4.0 * intensity;
			uv += vec2(0.5);
		
			// time and uv motion variables
			float t = time * 0.4;
			float uvx = cos(uv.x - t);
			float uvy = cos(uv.y + t);
			float uvxt = cos(uv.x + sin(t));
			float uvyt = sin(uv.y + cos(t));
		
			// creating the voronoi 3D sphere, applying motion
			vec3 c = voronoi3d(vec3(uv.x - uvx + uvyt, 
										          mix(uv.x, uv.y, 0.5) + uvxt - uvyt + uvx,
										          uv.y + uvxt - uvx));
		
			// applying color and contrast, to create sharp black areas. 
			vec3 fcolor = c.x * c.x * c.x * color * color * 5.0;
		
			// abrupt fading
			float fade = pow(1.0 - dist, 0.20);
		
			gl_FragColor = vec4(fcolor * fade * alpha,1.0);
	}`;

	/** @inheritdoc */
	static defaultUniforms = Object.assign({}, super.defaultUniforms, {
		pulse: 0,
		color: PIXI.utils.hex2rgb(0xCEECEE)
	});
}

/* -------------------------------------------- */

/**
 * Chroma animation coloration shader
 * @implements {StandardColorationShader}
 * @author SecretFire
 */
class ChromaColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;

	${AbstractBaseShader.FADE(3, 1.0)}
	${AbstractBaseShader.HSB2RGB}

	void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
			gl_FragColor = vec4( mix(
				color, 
				hsb2rgb( vec3(time * 0.25, 1.0, 1.0)), 
				intensity*0.1
			) * fade(dist) * alpha, 1.0 );
	}`;

	/** @inheritdoc */
	static defaultUniforms = Object.assign({}, super.defaultUniforms, {
		pulse: 0,
		color: PIXI.utils.hex2rgb(0xCEECEE)
	});
}

/* -------------------------------------------- */

/**
 * Wave animation illumination shader
 * @implements {StandardIlluminationShader}
 * @author SecretFire
 */
class WaveIlluminationShader extends StandardIlluminationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 colorDim;
	uniform vec3 colorBright;
	varying vec2 vUvs;

	const float MAX_INTENSITY = 1.1;
	const float MIN_INTENSITY = 0.8;

	float wave(in float dist) {
			float sinWave = 0.5 * (sin(-time * 6.0 + dist * 10.0 * intensity) + 1.0);
			return ((MAX_INTENSITY - MIN_INTENSITY) * sinWave) + MIN_INTENSITY;
	}

	void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
			vec3 color = mix(colorDim, colorBright, step(dist, ratio)) * wave(dist);
			gl_FragColor = vec4(color * alpha, 1.0);
	}`;
}

/* -------------------------------------------- */

/**
 * Wave animation coloration shader
 * @implements {StandardColorationShader}
 * @author SecretFire
 */
class WaveColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;

	const float MAX_INTENSITY = 1.35;
	const float MIN_INTENSITY = 0.8;

	${AbstractBaseShader.FADE(3, 1.0)}

	float wave(in float dist) {
			float sinWave = 0.5 * (sin(-time * 6.0 + dist * 10.0 * intensity) + 1.0);
			return ((MAX_INTENSITY - MIN_INTENSITY) * sinWave) + MIN_INTENSITY;
	}

	void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
			gl_FragColor = vec4(color * fade(dist) * wave(dist) * alpha, 1.0) ;
	}`;

	/** @inheritdoc */
	static defaultUniforms = Object.assign({}, super.defaultUniforms, {
		color: PIXI.utils.hex2rgb(0x666666)
	});
}

/* -------------------------------------------- */

/**
 * Fog animation coloration shader
 * @extends {StandardColorationShader}
 * @author SecretFire
 */
class FogColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;

	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;

	${AbstractBaseShader.PRNG}
	${AbstractBaseShader.NOISE}
	${AbstractBaseShader.FBM(4, 1.0)}
	${AbstractBaseShader.FADE(5, 1.0)}

	vec3 fog() {
		// constructing the palette
		vec3 c1 = color * 0.20;
		vec3 c2 = color * 0.80;
		vec3 c3 = color * 0.15;
		vec3 c4 = color * 0.85;
		vec3 c5 = c3;
		vec3 c6 = vec3(0.9);

		// creating the deformation
		vec2 uv = vUvs;
		vec2 p = uv.xy * 8.0;

		// time motion fbm and palette mixing
		float q = fbm(p - time * 0.1);
		vec2 r = vec2(fbm(p + q - time * 0.5 - p.x - p.y), fbm(p + q - time * 0.3));
		vec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);

		// returning the color
		return c;
	}

	void main() {
			float intens = intensity * 0.2;
			float dist = distance(vUvs, vec2(0.5)) * 2.0;

			// applying fog
			gl_FragColor = vec4(fog() * 1.25 * intens * fade(dist) * alpha, 1.0);
	}`;

	/** @inheritdoc */
	static defaultUniforms = Object.assign({}, super.defaultUniforms, {
		color: PIXI.utils.hex2rgb(0xCCCCCC)
	});
}

/* -------------------------------------------- */

/**
 * Sunburst animation illumination shader
 * @extends {StandardIlluminationShader}
 * @author SecretFire
 */
class SunburstIlluminationShader extends StandardIlluminationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 colorDim;
	uniform vec3 colorBright;
	varying vec2 vUvs;
	const float MU_TWOPI = 0.1591549431;

	// Smooth back and forth between a and b
	float cosTime(in float a, in float b) {
			return (a - b) * ((cos(time) + 1.0) * 0.5) + b;
	}

	// Create the sunburst effect
	vec3 sunBurst(in vec3 color, in vec2 uv, in float dist) {
	
			// Pulse calibration
			float intensityMod = 1.0 + (intensity * 0.05);
			float lpulse = cosTime(1.3 * intensityMod, 0.85 * intensityMod);
		
			// Compute angle
			float angle = atan(uv.x, uv.y) * MU_TWOPI;
		
			// Creating the beams and the inner light
			float beam = fract(angle * 16.0 + time);
			float light = lpulse * pow(abs(1.0 - dist), 0.65);
		
			// Max agregation of the central light and the two gradient edges
			float sunburst = max(light, max(beam, 1.0 - beam));
		
			// Strong color correction, to desaturate the space between the beams.
			float correction = pow(abs(sunburst), 1.0 - dist);
		
			// Creating the effect : applying color and color correction. ultra saturate the entire output color.
			return smoothstep( 0.2, 1.1, sunburst * color * correction) * 10.0;
	}

	void main() {
		vec2 uv = (2.0 * vUvs) - 1.0;
		float dist = length(uv);

		// Linear interpolation between dim and bright, weighted by distance from center. Ratio is used to lighten color
		vec3 color = mix(colorDim, colorBright, 1.0 - dist) * (1.0 + ratio);

		// Linear interpolation between color and max from color and sunburst, weighted by distance from center
		// the output is used as an illumination mask for the coloration shader. ratio influence luminosity.
		vec3 fcolor = mix(color, max(color, sunBurst(color, uv, dist)), 1.0 - dist) * alpha;
		gl_FragColor = vec4(fcolor, 1.0);
	}`;
}

/**
 * Sunburst animation coloration shader
 * @extends {StandardColorationShader}
 * @author SecretFire
 */
class SunburstColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;
	const float MU_TWOPI = 0.1591549431;

	${AbstractBaseShader.FADE(4, 1.0)}

	// Smooth back and forth between a and b
	float cosTime(in float a, in float b) {
			return (a - b) * ((cos(time) + 1.0) * 0.5) + b;
	}

	// Create a sun burst effect
	vec3 sunBurst(in vec2 uv, in float dist) {
		// pulse calibration
		float intensityMod = 1.0 + (intensity * 0.05);
		float lpulse = cosTime(1.1 * intensityMod, 0.85 * intensityMod);

		// compute angle
		float angle = atan(uv.x, uv.y) * MU_TWOPI;
		
		// creating the beams and the inner light
		float beam = fract(angle * 16.0 + time);
		float light = lpulse * pow(abs(1.0 - dist), 0.65);
		
		// agregation of the central light and the two gradient edges to create the sunburst
		float sunburst = max(light, max(beam, 1.0 - beam));
		
		// strong color correction, to desaturate the space between the sunburst's beams.
		float correction = pow(abs(sunburst), dist * 2.0);
		
		// creating the effect : applying color and color correction. saturate the entire output color.
		return smoothstep( 0.2, 1.1, sunburst * color * correction) * 2.0;
	}

	void main() {
		vec2 uvs = (2.0 * vUvs) - 1.0;
		float dist = length(uvs);
		gl_FragColor = vec4(sunBurst(uvs, dist) * fade(dist) * alpha, 1.0);
	}`;

	/** @inheritdoc */
	static defaultUniforms = Object.assign({}, super.defaultUniforms, {
		color: PIXI.utils.hex2rgb(0xFFDD00)
	});
}

/* -------------------------------------------- */

/**
 * Light dome animation coloration shader
 * @extends {StandardColorationShader}
 * @author SecretFire
 */
class LightDomeColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;
	const vec2 pivot = vec2(0.5);

	// Rotate and scale uv
	vec2 transform(in vec2 uv, in float dist) {
		float hspherize = (1.0 - sqrt(1.0 - dist)) / dist;
		float t = time * 0.02;
		mat2 rotmat = mat2(cos(t), -sin(t), sin(t), cos(t));
		mat2 scalemat = mat2(8.0 * intensity, 0.0, 0.0, 8.0 * intensity);
		uv -= pivot; 
		uv *= rotmat * scalemat * hspherize;
		uv += pivot;
		return uv;
	}

	${AbstractBaseShader.PRNG}
	${AbstractBaseShader.NOISE}
	${AbstractBaseShader.FBM(2)}
	
	vec3 ripples(in vec2 uv) {
			// creating the palette
			vec3 c1 = color * 0.250;
			vec3 c2 = color * 0.001;
			vec3 c3 = vec3(0.02);
			vec3 c4 = color * 2.0;
			vec3 c5 = color * 0.005;
			vec3 c6 = color * 0.002;

			vec2 p = uv + vec2(5.0);
			float q = 2.0 * fbm(p + time * 0.2);
			vec2 r = vec2(fbm(p + q + ( time  ) - p.x - p.y), fbm(p * 2.0 + ( time )));
		
			return color * (
					mix( c1, c2, abs(fbm(p + r)) ) + mix( c3, c4, abs(r.x * r.x * r.x) ) - mix( c5, c6, abs(r.y * r.y) )
			);
	}

	void main() {
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
		
			// to hemispherize, rotate and magnify
			vec2 uv = transform(vUvs, dist);

			// abrupt fade
			float fade = pow(1.0 - dist, 0.25);
		
			gl_FragColor = vec4(ripples(uv) * fade * alpha, 1.0);
	}`;

	/** @inheritdoc */
	static defaultUniforms = Object.assign({}, super.defaultUniforms, {
		color: PIXI.utils.hex2rgb(0xCEECEE)
	});
}

/* -------------------------------------------- */


/**
 * Emanation animation coloration shader
 * @extends {StandardColorationShader}
 * @author SecretFire
 */
class EmanationColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;
	const float MU_TWOPI = 0.1591549431;

	${AbstractBaseShader.FADE(4, 1.0)}

	// Create an emanation composed of n beams, n = intensity
	vec3 beamsEmanation(in vec2 uv, in float dist) {
			float angle = atan(uv.x, uv.y) * MU_TWOPI;

			// create the beams
			float beams = fract( angle * intensity + sin(dist * 10.0 - time));

			// compose the final beams with max, to get a nice gradient on EACH side of the beams.
			beams = max(beams, 1.0 - beams);

			// compute a strong color correction, to desaturate the space between the beams.
			float colorburn = pow(beams, dist * 2.0);

			// creating the effect : applying color and color correction. saturate the entire output color.
			return smoothstep( 0.2, 1.1, beams * color * colorburn) * 3.0;
	}

	void main() {
			// compute uvs and distance
			vec2 uvs = (2.0 * vUvs) - 1.0;
			float dist = length(uvs);

			// apply beams emanation, fade and alpha
			gl_FragColor = vec4(beamsEmanation(uvs, dist) * fade(dist) * alpha, 1.0);
	}`;

	/** @inheritdoc */
	static defaultUniforms = Object.assign({}, super.defaultUniforms, {
		color: PIXI.utils.hex2rgb(0xCEECEE)
	});
}

/* -------------------------------------------- */


/**
 * Ghost light animation illumination shader
 * @extends {StandardIlluminationShader}
 * @author SecretFire
 */
class GhostLightIlluminationShader extends StandardIlluminationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 colorDim;
	uniform vec3 colorBright;
	varying vec2 vUvs;
	const float PI = 3.1415927;

	${AbstractBaseShader.PRNG}
	${AbstractBaseShader.NOISE}
	${AbstractBaseShader.FBM(3, 1.0)}

	void main() {
		
			// Creating distortion with vUvs and fbm
			float distortion1 = fbm(vec2( 
					fbm(vUvs * 5.0 - time * 0.50), 
					fbm((-vUvs - vec2(0.01)) * 5.0 + time * 0.3333334)
			));
		
			float distortion2 = fbm(vec2(
				fbm(-vUvs * 5.0 - time * 0.50),
				fbm((-vUvs + vec2(0.01)) * 5.0 + time * 0.3333334)
			));
			vec2 uv = vUvs;
			
			// time related var
			float t = time * 0.5;
			float tcos = 0.5 * (0.5 * (cos(t)+1.0)) + 0.25;
			float tsin = 0.5 * (0.5 * (sin(t)+1.0)) + 0.25;
		
			// Creating distortions with cos and sin : create fluidity
			vec2 pivot = vec2(0.5);
			uv.x += 0.8 * sin(mix(distortion1 * 0.1, distortion2 * 0.1, tsin));
			uv.y -= 0.8 * cos(mix(distortion1 * 0.1, distortion2 * 0.1, tcos));
			uv -= pivot;
			uv *= 1.13 + 0.9 *(cos(sqrt(mix(distortion1, distortion2,0.5)) +1.0) * 0.5);
			uv += pivot;
			uv -= vec2(0.049,-0.827); 

			float dist = distance(uv, vec2(0.5)) * 2.0;
			vec3 color = mix(colorDim, colorBright, step(dist, ratio));
			gl_FragColor = vec4(color * alpha * mix(
				distortion1 * 1.5 * (intensity * 0.2),
				distortion2 * 1.5 * (intensity * 0.2), tcos
			), 1.0);
	}`;
}

/* -------------------------------------------- */

/**
 * Ghost light animation coloration shader
 * @extends {StandardIlluminationShader}
 * @author SecretFire
 */
class GhostLightColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;
	const float PI = 3.1415927;

	${AbstractBaseShader.PRNG}
	${AbstractBaseShader.NOISE}
	${AbstractBaseShader.FBM(3, 1.0)}

	void main() {
			
			float dist = distance(vUvs, vec2(0.5)) * 2.0;
		
			// Creating distortion with vUvs and fbm
			float distortion1 = fbm(vec2( 
					fbm(vUvs * 3.0 + time * 0.50), 
					fbm((-vUvs + vec2(1.)) * 5.0 + time * 0.3333334)
			));
		
			float distortion2 = fbm(vec2(
				fbm(-vUvs * 3.0 + time * 0.50),
				fbm((-vUvs + vec2(1.)) * 5.0 - time * 0.3333334)
			));
			vec2 uv = vUvs;
			
			// time related var
			float t = time * 0.5;
			float tcos = 0.5 * (0.5 * (cos(t)+1.0)) + 0.25;
			float tsin = 0.5 * (0.5 * (sin(t)+1.0)) + 0.25;
		
			// Creating distortions with cos and sin : create fluidity
			vec2 pivot = vec2(0.5);
			uv -= pivot;
			uv *= tcos*distortion1;
			uv *= tsin*distortion2;
			uv *= fbm(vec2(time + distortion1, time + distortion2));
			uv += pivot;

			vec3 fcolor = distortion1 * distortion1 * 
										distortion2 * distortion2 * 
										color * pow(1.0 - dist, dist);
									 
			gl_FragColor = vec4(fcolor * alpha * mix(
				uv.x + distortion1 * 4.5 * (intensity * 0.2),
				uv.y + distortion2 * 4.5 * (intensity * 0.2), tcos
			), 1.0);
	}`;

	/** @inheritdoc */
	static defaultUniforms = Object.assign({}, super.defaultUniforms, {
		color: PIXI.utils.hex2rgb(0xBDFFE9)
	});
}

/* -------------------------------------------- */

/**
 * Hexagonal dome animation coloration shader
 * @extends {StandardColorationShader}
 * @author SecretFire
 */
class HexaDomeColorationShader extends StandardColorationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform vec3 color;
	varying vec2 vUvs;
	const vec2 pivot = vec2(0.5);

	// rotate and scale uv
	vec2 transform(in vec2 uv, in float dist) {
		float hspherize = (1.0 - sqrt(1.0 - dist)) / dist;
		float t = -time * 0.20;
		float scale = 10.0 / (11.0 - intensity);
		float cost = cos(t);
		float sint = sin(t);

		mat2 rotmat = mat2(cost, -sint, sint, cost);
		mat2 scalemat = mat2(scale, 0.0, 0.0, scale);
		uv -= pivot; 
		uv *= rotmat * scalemat * hspherize;
		uv += pivot;
		return uv;
	}

	// Adapted classic hexa algorithm
	float hexDist(in vec2 uv) {
		vec2 p = abs(uv);
		float c = dot(p, normalize(vec2(1.0, 1.73)));
		c = max(c, p.x);
		return c;
	}

	vec4 hexUvs(in vec2 uv) {
	const vec2 r = vec2(1.0, 1.73);
		const vec2 h = r*0.5;
		
		vec2 a = mod(uv, r) - h;
		vec2 b = mod(uv - h, r) - h;
		vec2 gv = dot(a, a) < dot(b,b) ? a : b;
		
		float x = atan(gv.x, gv.y);
		float y = 0.55 - hexDist(gv);
		vec2 id = uv - gv;
		return vec4(x, y, id.x, id.y);
	}

	vec3 hexa(in vec2 uv) {
		float t = time;
		vec2 uv1 = uv + vec2(0.0, sin(uv.y) * 0.25);
		vec2 uv2 = 0.5 * uv1 + 0.5 * uv + vec2(0.55, 0);
		float a = 0.2;
		float c = 0.5;
		float s = -1.0;
		uv2 *= mat2(c, -s, s, c);

		vec3 col = color;
		float hexy = hexUvs(uv2 * 10.0).y;
		float hexa = smoothstep( 3.0 * (cos(t)) + 4.5, 12.0, hexy * 20.0) * 3.0;

		col *= mix(hexa, 1.0 - hexa, min(hexy, 1.0 - hexy));
		col += color * fract(smoothstep(1.0, 2.0, hexy * 20.0)) * 0.65;

		return col;
	}

	void main() {
		float dist = distance(vUvs, vec2(0.5)) * 2.0;

		// Rotate, magnify and hemispherize the uvs
		vec2 uv = transform(vUvs, dist);

		// Very abrupt fading
		float fade = pow(1.0 - dist, 0.18);
		
		// Hexaify the uv (hemisphere) and apply fade and alpha
		gl_FragColor = vec4(hexa(uv) * 2.0 * fade * alpha, 1.0);
	}`;

	/** @inheritdoc */
	static defaultUniforms = Object.assign({}, super.defaultUniforms, {
		color: PIXI.utils.hex2rgb(0xCEECEE)
	});
}

/* -------------------------------------------- */

/**
 * Roling mass illumination shader - intended primarily for darkness
 * @extends {StandardIlluminationShader}
 * @author SecretFire
 */
class RoilingIlluminationShader extends StandardIlluminationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 colorDim;
	uniform vec3 colorBright;
	varying vec2 vUvs;
	const float PI = 3.1415927;

	${AbstractBaseShader.PRNG}
	${AbstractBaseShader.NOISE}
	${AbstractBaseShader.FBM(3)}

	void main() {
		
		// Creating distortion with vUvs and fbm
		float distortion1 = fbm(vec2( 
			fbm(vUvs * 2.5 + time*0.5),
			fbm( (-vUvs - vec2(0.01)) * 5. + time*0.3333334))
		);
		
		float distortion2 = fbm(vec2(
			fbm(-vUvs * 5. + time*0.5),
			fbm((vUvs + vec2(0.01)) * 2.5 + time*0.3333334))
		);
		
		// Amplify distortions
		vec2 uv = vUvs;
		vec2 pivot = vec2(0.5);
		uv.x += 0.8*sin(min(distortion1*0.1,distortion2*0.1));
		uv.y += 0.8*cos(min(distortion1*0.1,distortion2*0.1));
		uv -= pivot;
		uv *= 1.13 + 0.90*(cos(sqrt(max(distortion1, distortion2))+1.)*0.5);
		uv += pivot;
		uv -= vec2(0.04,0.830); 

		float alphaBright,alphaDim;
		float dist = distance(uv, vec2(0.5)) * 2.0;
		
		// Creating the red spooky membrane around the bright darkness
		if (dist > (ratio - 0.003) && dist < (ratio + 0.003)) {
			float n = ((ratio + 0.003) * 5.0 - dist * 5.0);
			float glow = pow(n, 0.8);
			gl_FragColor = vec4( vec3(2.0,0.0,2.0) * glow, 1.0); 
			return;
		}
		
		// Intensity modifier
		alphaBright = 1.0 - pow(clamp(ratio - dist, 0.0, 1.0), 0.75) * sqrt(2.0 - dist);
		alphaDim = 1.0 - pow(clamp(1.0 - dist, 0.0, 1.0), 0.65);
		float intensMod = (11.0-intensity) * 0.5;

		// Darkness control by intensity
		vec3 color = mix(colorDim * intensMod, colorBright * intensMod, step(dist, ratio));
		gl_FragColor = vec4(color * min(alphaBright, alphaDim) * alpha, 1.0);
	}`;
}

/* -------------------------------------------- */

/**
 * Black Hole animation illumination shader
 * @extends {StandardIlluminationShader}
 * @author SecretFire
 */
class BlackHoleIlluminationShader extends StandardIlluminationShader {
	static fragmentShader = `
	precision mediump float;
	uniform float time;
	uniform float intensity;
	uniform float alpha;
	uniform float ratio;
	uniform vec3 colorBright;
	uniform vec3 colorDim;
	varying vec2 vUvs;
	const float MU_TWOPI = 0.1591549431;

	// create an emanation composed of n beams, n = intensity
	vec3 beamsEmanation(in vec2 uv, in float dist, in vec3 pCol) {
		float angle = atan(uv.x, uv.y) * MU_TWOPI;

		// Create the beams
		float beams = fract(angle * intensity + sin(dist * 30.0 - time));

		// Compose the final beams and reverse beams, to get a nice gradient on EACH side of the beams.
		beams = max(beams, 1.0 - beams);

		// Compute a darkness modifier.
		float darknessPower = pow(beams, 1.5);

		// Creating the effect : applying color and darkness power correction. saturate the entire output color.
		return smoothstep(0.2, 1.1 + (intensity * 0.1), beams * pCol * darknessPower) * intensity;
	}

	void main() {
		// compute uvs and distance
		vec2 uvs = (2.0 * vUvs) - 1.0;
		float dist = length(uvs);
		
		// palette of colors to give the darkness a disturbing purpleish tone
		vec3 pColorDim    = vec3(0.25, 0.10, 0.35);
		vec3 pColorBright = vec3(0.85, 0.80, 0.95);
		
		// smooth mixing of the palette by distance from center and bright ratio
		vec3 pCol = mix(pColorDim, pColorBright, smoothstep(ratio * 0.5, ratio * 1.5, dist));
		
		// Apply darker components of colorDim and mixed emanations/colorBright.
		gl_FragColor = vec4(min(colorDim, 
			mix(colorBright, beamsEmanation(uvs, dist, pCol), 1.0 - sqrt(1.0 - dist))
		 ) * alpha, 1.0);
	}`;
}


/**
 * A single Mouse Cursor
 * @type {PIXI.Container}
 */
class Cursor extends PIXI.Container {
	constructor(user) {
		super();
		this.target = {x: 0, y: 0};
		this.draw(user);

		// Register and add animation
		canvas.app.ticker.add(this._animate, this);
	}

	/* -------------------------------------------- */

	/**
	 * Draw the user's cursor as a small dot with their user name attached as text
	 */
	draw(user) {

		// Cursor dot
		const d = this.addChild(new PIXI.Graphics());
		const color = user.data.color.replace("#", "0x") || 0x42F4E2;
		d.beginFill(color, 0.35).lineStyle(1, 0x000000, 0.5).drawCircle(0, 0, 6);

		// Player name
		const style = CONFIG.canvasTextStyle.clone();
		style.fontSize = 14;
		let n = this.addChild(new PreciseText(user.name, style));
		n.x -= n.width / 2;
		n.y += 10;
	}

	/* -------------------------------------------- */

	/**
	 * Move an existing cursor to a new position smoothly along the animation loop
	 */
	_animate() {
		let dy = this.target.y - this.y,
				dx = this.target.x - this.x;
		if ( Math.abs( dx ) + Math.abs( dy ) < 10 ) return;
		this.x += dx / 10;
		this.y += dy / 10;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	destroy(options) {
		canvas.app.ticker.remove(this._animate, this);
		super.destroy(options);
	}
}

/**
 * An icon representing a Door Control
 * @extends {PIXI.Container}
 */
class DoorControl extends PIXI.Container {
	constructor(wall) {
		super();
		this.wall = wall;
		this.wall.doorControl = this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the DoorControl icon, displaying it's icon texture and border
	 * @return {Promise<DoorControl>}
	 */
	async draw() {

		// Background
		this.bg = this.bg || this.addChild(new PIXI.Graphics());
		this.bg.clear().beginFill(0x000000, 1.0).drawRoundedRect(-2, -2, 44, 44, 5).endFill();
		this.bg.alpha = 0;

		// Control Icon
		this.icon = this.icon || this.addChild(new PIXI.Sprite());
		this.icon.width = this.icon.height = 40;
		this.icon.alpha = 0.6;
		this.icon.texture = this._getTexture();

		// Border
		this.border = this.border || this.addChild(new PIXI.Graphics());
		this.border.clear().lineStyle(1, 0xFF5500, 0.8).drawRoundedRect(-2, -2, 44, 44, 5).endFill();
		this.border.visible = false;

		// Add control interactivity
		this.interactive = true;
		this.interactiveChildren = false;
		this.hitArea = new PIXI.Rectangle(-2, -2, 44, 44);

		// Set position
		this.reposition();
		this.alpha = 1.0;

		// Activate listeners
		this.removeAllListeners();
		this.on("mouseover", this._onMouseOver)
				.on("mouseout", this._onMouseOut)
				.on("mousedown", this._onMouseDown)
				.on('rightdown', this._onRightDown);

		// Return the control icon
		return this;
	}


	/* -------------------------------------------- */

	/**
	 * Get the icon texture to use for the Door Control icon based on the door state
	 * @returns {PIXI.Texture}
	 */
	_getTexture() {

		// Determine displayed door state
		const ds = CONST.WALL_DOOR_STATES;
		let s = this.wall.data.ds;
		if ( !game.user.isGM && (s === ds.LOCKED) ) s = ds.CLOSED;

		// Determine texture path
		const icons = CONFIG.controlIcons;
		let path = {
			[ds.LOCKED]: icons.doorLocked,
			[ds.CLOSED]: icons.doorClosed,
			[ds.OPEN]: icons.doorOpen
		}[s] || icons.doorClosed;
		if ( (s === ds.CLOSED) && (this.wall.data.door === CONST.WALL_DOOR_TYPES.SECRET) ) path = icons.doorSecret;

		// Obtain the icon texture
		return getTexture(path);
	}

	/* -------------------------------------------- */

	reposition() {
		let pos = this.wall.midpoint.map(p => p - 20);
		this.position.set(...pos);
	}

	/* -------------------------------------------- */

	/**
	 * Determine whether the DoorControl is visible to the calling user's perspective.
	 * The control is always visible if the user is a GM and no Tokens are controlled.
	 * @see {SightLayer#testVisibility}
	 * @type {boolean}
	 */
	get isVisible() {
		const w = this.wall;

		// Hide secret doors from players
		if ( (w.data.door === CONST.WALL_DOOR_TYPES.SECRET) && !game.user.isGM ) return false;

		// Hide interior doors that aren't in LOS
		if ( !canvas.sight.sources.size && (w.roof?.occluded === false) ) return false;

		// Display door icons based on LOS polygon
		const [x, y] = w.midpoint;
		const point = new PIXI.Point(x, y);
		return canvas.sight.testVisibility(point, {tolerance: 2, object: this});
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/**
	 * Handle mouse over events on a door control icon.
	 * @param {PIXI.InteractionEvent} event      The originating interaction event
	 * @protected
	 */
	_onMouseOver(event) {
		event.stopPropagation();
		const canControl = game.user.can("WALL_DOORS");
		const blockPaused = game.paused && !game.user.isGM;
		if ( !canControl || blockPaused ) return false;
		this.border.visible = true;
		this.icon.alpha = 1.0;
		this.bg.alpha = 0.25;
		canvas.walls._hover = this.wall;
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse out events on a door control icon.
	 * @param {PIXI.InteractionEvent} event      The originating interaction event
	 * @protected
	 */
	_onMouseOut(event) {
		event.stopPropagation();
		if ( game.paused && !game.user.isGM ) return false;
		this.border.visible = false;
		this.icon.alpha = 0.6;
		this.bg.alpha = 0;
		canvas.walls._hover = null;
	}

	/* -------------------------------------------- */

	/**
	 * Handle left mouse down events on a door control icon.
	 * This should only toggle between the OPEN and CLOSED states.
	 * @param {PIXI.InteractionEvent} event      The originating interaction event
	 * @protected
	 */
	_onMouseDown(event) {
		event.stopPropagation();
		const state = this.wall.data.ds;
		const states = CONST.WALL_DOOR_STATES;

		// Determine whether the player can control the door at this time
		if ( !game.user.can("WALL_DOORS") ) return false;
		if ( game.paused && !game.user.isGM ) {
			ui.notifications.warn("GAME.PausedWarning", {localize: true});
			return false;
		}

		// Play an audio cue for locked doors
		if ( state === states.LOCKED ) {
			AudioHelper.play({src: CONFIG.sounds.lock});
			return false;
		}

		// Toggle between OPEN and CLOSED states
		return this.wall.document.update({ds: state === states.CLOSED ? states.OPEN : states.CLOSED});
	}

	/* -------------------------------------------- */

	/**
	 * Handle right mouse down events on a door control icon.
	 * This should toggle whether the door is LOCKED or CLOSED.
	 * @param {PIXI.InteractionEvent} event      The originating interaction event
	 * @protected
	 */
	_onRightDown(event) {
		event.stopPropagation();
		if ( !game.user.isGM ) return;
		let state = this.wall.data.ds,
				states = CONST.WALL_DOOR_STATES;
		if ( state === states.OPEN ) return;
		state = state === states.LOCKED ? states.CLOSED : states.LOCKED;
		return this.wall.document.update({ds: state});
	}
}


/**
 * A CanvasLayer for displaying UI controls which are overlayed on top of other layers.
 *
 * We track three types of events:
 * 1) Cursor movement
 * 2) Ruler measurement
 * 3) Map pings
 */
class ControlsLayer extends CanvasLayer {
	constructor() {
		super();

		/**
		 * Cursor position indicators
		 * @type {PIXI.Container}
		 */
		this.cursors = null;

		/**
		 * A mapping of user IDs to Cursor instances for quick access
		 * @type {Object}
		 */
		this._cursors = {};

		/**
		 * Door control icons
		 * @type {PIXI.Container|null}
		 */
		this.doors = null;

		/**
		 * Status effect icons
		 */
		this.effects = null;

		/**
		 * Ruler tools, one per connected user
		 * @type {PIXI.Container}
		 */
		this.rulers = null;

		/**
		 * A convenience mapping of user IDs to Ruler instances for quick access
		 * @type {Object}
		 */
		this._rulers = {};

		/**
		 * Canvas selection rectangle
		 * @type {PIXI.Graphics}
		 */
		this.select = null;

		// The controls layer is always interactive
		this.interactiveChildren = true;
	}

	/* -------------------------------------------- */

	/** @override */
	static get layerOptions() {
		return mergeObject(super.layerOptions, { zIndex: 1000 });
	}

	/* -------------------------------------------- */
	/*  Properties and Public Methods               */
	/* -------------------------------------------- */

	/**
	 * A convenience accessor to the Ruler for the active game user
	 * @type {Ruler}
	 */
	get ruler() {
		return this.getRulerForUser(game.user.id);
	}

	/* -------------------------------------------- */

	/**
	 * Get the Ruler display for a specific User ID
	 * @param {string} userId
	 * @return {Ruler|null}
	 */
	getRulerForUser(userId) {
		return this._rulers[userId] || null;
	}


	/* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */

	/** @override */
	draw() {
		this.drawCursors();
		this.drawDoors();
		this.drawRulers();
		this.select = this.addChild(new PIXI.Graphics());
		this.debug = this.addChild(new PIXI.Graphics());
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the cursors container
	 */
	drawCursors() {
		if ( this.cursors ) {
			this.cursors.destroy({children: true});
			this.cursors = null;
		}
		this.cursors = this.addChild(new PIXI.Container());
		for ( let u of game.users.filter(u => u.active && !u.isSelf ) ) {
			this.drawCursor(u);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Draw the Door controls container
	 */
	drawDoors() {

		// Create the container
		if ( this.doors ) this.doors.destroy({children: true});
		this.doors = this.addChild(new PIXI.Container());

		// Iterate over all walls, selecting the doors
		for ( let w of canvas.walls.placeables ) {
			this.createDoorControl(w);
		}

		// Toggle visibility for the set of door control icons
		this.doors.visible = !canvas.walls._active;
	}

	/* -------------------------------------------- */

	/**
	 * Create a Door Control icon for a given Wall object
	 * @param {Wall} wall           The Wall for which to create a DoorControl
	 * @return {DoorControl|null}   The created DoorControl
	 */
	createDoorControl(wall) {
		if ( wall.data.door === CONST.WALL_DOOR_TYPES.NONE ) return null;
		if (( wall.data.door === CONST.WALL_DOOR_TYPES.SECRET ) && !game.user.isGM ) return null;
		const dc = this.doors.addChild(new DoorControl(wall));
		dc.visible = false;
		return dc.draw();
	}

	/* -------------------------------------------- */

	/**
	 * Draw Ruler tools
	 */
	drawRulers() {
		this.rulers = this.addChild(new PIXI.Container());
		for (let u of game.users) {
			let ruler = new Ruler(u);
			this._rulers[u.id] = this.rulers.addChild(ruler);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Draw the select rectangle given an event originated within the base canvas layer
	 * @param {Object} coords   The rectangle coordinates of the form {x, y, width, height}
	 */
	drawSelect({x, y, width, height}) {
		const s = this.select.clear();
		s.lineStyle(3, 0xFF9829, 0.9).drawRect(x, y, width, height);
	}

	/* -------------------------------------------- */

	/** @override */
	deactivate() {
		super.deactivate();
		this.visible = true;
		this.interactiveChildren = true;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */

	/**
	 * Handle mousemove events on the game canvas to broadcast activity of the user's cursor position
	 * @param {PIXI.InteractionEvent} event
	 */
	_onMouseMove(event) {
		const sc = game.user.hasPermission("SHOW_CURSOR");
		const sr = game.user.hasPermission("SHOW_RULER");
		if ( !sc && !sr ) return;
		const position = sr ? event.data.getLocalPosition(this) : null;
		const ruler = sr && (this.ruler._state > 0) ? this.ruler.toJSON() : null;
		game.user.broadcastActivity({
			cursor: position,
			ruler: ruler
		});
	}

	/* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */

	/**
	 * Create and draw the Cursor object for a given User
	 * @param {User} user   The User entity for whom to draw the cursor Container
	 */
	drawCursor(user) {
		if ( user.id in this._cursors ) {
			this._cursors[user.id].destroy({children: true});
			delete this._cursors[user.id];
		}
		return this._cursors[user.id] = this.cursors.addChild(new Cursor(user));
	}

	/* -------------------------------------------- */

	/**
	 * Update the cursor when the user moves to a new position
	 * @param {User} user         The User for whom to update the cursor
	 * @param {Point} position    The new cursor position
	 */
	updateCursor(user, position) {
		if ( !this.cursors ) return;
		const cursor = this._cursors[user.id] || this.drawCursor(user);

		// Ignore cursors on other Scenes
		if ( ( position === null ) || (user.viewedScene !== canvas.scene.id) ) {
			if ( cursor ) cursor.visible = false;
			return;
		}

		// Ignore cursors for users who are not permitted to share
		if ( (user === game.user) || !user.hasPermission("SHOW_CURSOR") ) {
			if ( cursor ) cursor.visible = false;
				return;
		}

		// Show the cursor in its currently tracked position
		cursor.visible = true;
		cursor.target = {x: position.x || 0, y: position.y || 0};
	}

	/* -------------------------------------------- */

	/**
	 * Update display of an active Ruler object for a user given provided data
	 * @param {User} user             The User for whom to update the ruler
	 * @param {object} rulerData      Data which describes the new ruler measurement to display
	 */
	updateRuler(user, rulerData) {

		// Ignore rulers for users who are not permitted to share
		if ( (user === game.user) || !user.hasPermission("SHOW_RULER") ) return;

		// Update the Ruler display for the user
		let ruler = this.getRulerForUser(user.id);
		if ( !ruler ) return;
		if ( rulerData === null ) ruler.clear();
		else ruler.update(rulerData);
	}
}

/**
 * The Ruler - used to measure distances and trigger movements
 * @param {User}  The User for whom to construct the Ruler instance
 * @type {PIXI.Container}
 */
class Ruler extends PIXI.Container {
	constructor(user, {color=null}={}) {
		super();
		user = user || game.user;

		/**
		 * Record the User which this Ruler references
		 * @type {User}
		 */
		this.user = user;

		/**
		 * The ruler name - used to differentiate between players
		 * @type {string}
		 */
		this.name = `Ruler.${user.id}`;

		/**
		 * The ruler color - by default the color of the active user
		 * @type {number|null}
		 */
		this.color = color || colorStringToHex(this.user.data.color) || 0x42F4E2;

		/**
		 * This Array tracks individual waypoints along the ruler's measured path.
		 * The first waypoint is always the origin of the route.
		 * @type {Array.<PIXI.Point>}
		 */
		this.waypoints = [];

		/**
		 * The current destination point at the end of the measurement
		 * @type {PIXI.Point}
		 */
		this.destination = null;

		/**
		 * The Ruler element is a Graphics instance which draws the line and points of the measured path
		 * @type {PIXI.Graphics}
		 */
		this.ruler = this.addChild(new PIXI.Graphics());

		/**
		 * The Labels element is a Container of Text elements which label the measured path
		 * @type {PIXI.Container}
		 */
		this.labels = this.addChild(new PIXI.Container());

		/**
		 * Track the current measurement state
		 * @type {number}
		 */
		this._state = Ruler.STATES.INACTIVE;
	}

	/**
	 * An enumeration of the possible Ruler measurement states.
	 * @enum {number}
	 */
	static STATES = {
		INACTIVE: 0,
		STARTING: 1,
		MEASURING: 2,
		MOVING: 3
	};

	/* -------------------------------------------- */

	/**
	 * Is the Ruler being actively used to measure distance?
	 * @return {boolean}
	 */
	get active() {
		return this.waypoints.length > 0;
	}

	/* -------------------------------------------- */

	/**
	 * Measure the distance between two points and render the ruler UI to illustrate it
	 * @param {PIXI.Point} destination  The destination point to which to measure
	 * @param {boolean} gridSpaces      Restrict measurement only to grid spaces
	 */
	measure(destination, {gridSpaces=true}={}) {
		destination = new PIXI.Point(...canvas.grid.getCenter(destination.x, destination.y));
		const waypoints = this.waypoints.concat([destination]);
		const r = this.ruler;
		this.destination = destination;

		// Iterate over waypoints and construct segment rays
		const segments = [];
		for ( let [i, dest] of waypoints.slice(1).entries() ) {
			const origin = waypoints[i];
			const label = this.labels.children[i];
			const ray = new Ray(origin, dest);
			if ( ray.distance < 10 ) {
				if ( label ) label.visible = false;
				continue;
			}
			segments.push({ray, label});
		}

		// Compute measured distance
		const distances = canvas.grid.measureDistances(segments, {gridSpaces});
		let totalDistance = 0;
		for ( let [i, d] of distances.entries() ) {
			totalDistance += d;
			let s = segments[i];
			s.last = i === (segments.length - 1);
			s.distance = d;
			s.text = this._getSegmentLabel(d, totalDistance, s.last);
		}

		// Clear the grid highlight layer
		const hlt = canvas.grid.highlightLayers[this.name] || canvas.grid.addHighlightLayer(this.name);
		hlt.clear();

		// Draw measured path
		r.clear();
		for ( let s of segments ) {
			const {ray, label, text, last} = s;

			// Draw line segment
			r.lineStyle(6, 0x000000, 0.5).moveTo(ray.A.x, ray.A.y).lineTo(ray.B.x, ray.B.y)
			 .lineStyle(4, this.color, 0.25).moveTo(ray.A.x, ray.A.y).lineTo(ray.B.x, ray.B.y);

			// Draw the distance label just after the endpoint of the segment
			if ( label ) {
				label.text = text;
				label.alpha = last ? 1.0 : 0.5;
				label.visible = true;
				let labelPosition = ray.project((ray.distance + 50) / ray.distance);
				label.position.set(labelPosition.x, labelPosition.y);
			}

			// Highlight grid positions
			this._highlightMeasurement(ray);
		}

		// Draw endpoints
		for ( let p of waypoints ) {
			r.lineStyle(2, 0x000000, 0.5).beginFill(this.color, 0.25).drawCircle(p.x, p.y, 8);
		}

		// Return the measured segments
		return segments;
	}

	/* -------------------------------------------- */

	/**
	 * Get the text label for a segment of the measured path
	 * @param {number} segmentDistance
	 * @param {number} totalDistance
	 * @param {boolean} isTotal
	 * @return {string}
	 * @private
	 */
	_getSegmentLabel(segmentDistance, totalDistance, isTotal) {
		const units = canvas.scene.data.gridUnits;
		let label = `${Math.round(segmentDistance * 100) / 100} ${units}`;
		if ( isTotal ) {
			label += ` [${Math.round(totalDistance * 100) / 100} ${units}]`;
		}
		return label;
	}

	/* -------------------------------------------- */

	/**
	 * Highlight the measurement required to complete the move in the minimum number of discrete spaces
	 * @param {Ray} ray
	 * @private
	 */
	_highlightMeasurement(ray) {
		const spacer = canvas.scene.data.gridType === CONST.GRID_TYPES.SQUARE ? 1.41 : 1;
		const nMax = Math.max(Math.floor(ray.distance / (spacer * Math.min(canvas.grid.w, canvas.grid.h))), 1);
		const tMax = Array.fromRange(nMax+1).map(t => t / nMax);

		// Track prior position
		let prior = null;

		// Iterate over ray portions
		for ( let [i, t] of tMax.entries() ) {
			let {x, y} = ray.project(t);

			// Get grid position
			let [x0, y0] = (i === 0) ? [null, null] : prior;
			let [x1, y1] = canvas.grid.grid.getGridPositionFromPixels(x, y);
			if ( x0 === x1 && y0 === y1 ) continue;

			// Highlight the grid position
			let [xg, yg] = canvas.grid.grid.getPixelsFromGridPosition(x1, y1);
			canvas.grid.highlightPosition(this.name, {x: xg, y: yg, color: this.color});

			// Skip the first one
			prior = [x1, y1];
			if ( i === 0 ) continue;

			// If the positions are not neighbors, also highlight their halfway point
			if ( !canvas.grid.isNeighbor(x0, y0, x1, y1) ) {
				let th = tMax[i - 1] + (0.5 / nMax);
				let {x, y} = ray.project(th);
				let [x1h, y1h] = canvas.grid.grid.getGridPositionFromPixels(x, y);
				let [xgh, ygh] = canvas.grid.grid.getPixelsFromGridPosition(x1h, y1h);
				canvas.grid.highlightPosition(this.name, {x: xgh, y: ygh, color: this.color});
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Determine whether a SPACE keypress event entails a legal token movement along a measured ruler
	 *
	 * @return {Promise<boolean>}    An indicator for whether a token was successfully moved or not. If True the event should be
	 *                               prevented from propagating further, if False it should move on to other handlers.
	 */
	async moveToken() {
		let wasPaused = game.paused;
		if ( wasPaused && !game.user.isGM ) {
			ui.notifications.warn("GAME.PausedWarning", {localize: true});
			return false;
		}
		if ( !this.visible || !this.destination ) return false;
		const token = this._getMovementToken();
		if ( !token ) return false;

		// Determine offset relative to the Token top-left.
		// This is important so we can position the token relative to the ruler origin for non-1x1 tokens.
		const origin = canvas.grid.getTopLeft(this.waypoints[0].x, this.waypoints[0].y);
		const s2 = canvas.dimensions.size / 2;
		const dx = Math.round((token.data.x - origin[0]) / s2) * s2;
		const dy = Math.round((token.data.y - origin[1]) / s2) * s2;

		// Get the movement rays and check collision along each Ray
		// These rays are center-to-center for the purposes of collision checking
		const rays = this._getRaysFromWaypoints(this.waypoints, this.destination);
		let hasCollision = rays.some(r => canvas.walls.checkCollision(r));
		if ( hasCollision ) {
			ui.notifications.error("ERROR.TokenCollide", {localize: true});
			return false;
		}

		// Execute the movement path.
		// Transform each center-to-center ray into a top-left to top-left ray using the prior token offsets.
		this._state = Ruler.STATES.MOVING;
		for ( let r of rays ) {
			if ( !wasPaused && game.paused ) break;
			const dest = canvas.grid.getTopLeft(r.B.x, r.B.y);
			const path = new Ray({x: token.x, y: token.y}, {x: dest[0] + dx, y: dest[1] + dy});

			// Commit the movement
			await token.document.update(path.B);

			// Update the path which may have changed during the update, and animate it
			path.B.x = token.data.x;
			path.B.y = token.data.y;
			await token.animateMovement(path);
		}

		// Once all animations are complete we can clear the ruler
		this._endMeasurement();
	}

	/* -------------------------------------------- */

	/**
	 * Acquire a Token, if any, which is eligible to perform a movement based on the starting point of the Ruler
	 * @return {Token}
	 * @private
	 */
	_getMovementToken() {
		let [x0, y0] = Object.values(this.waypoints[0]);
		let tokens = canvas.tokens.controlled;
		if ( !tokens.length && game.user.character ) tokens = game.user.character.getActiveTokens();
		if ( !tokens.length ) return null;
		return tokens.find(t => {
			let pos = new PIXI.Rectangle(t.x - 1, t.y - 1, t.w + 2, t.h + 2);
			return pos.contains(x0, y0);
		});
	}

	/* -------------------------------------------- */

	/**
	 * A helper method to return an Array of Ray objects constructed from the waypoints of the measurement
	 * @param {PIXI.Point[]} waypoints    An Array of waypoint {x, y} Objects
	 * @param {PIXI.Point} destination    An optional destination point to append to the existing waypoints
	 * @return {Ray[]}                    An Array of Ray objects which represent the segemnts of the waypoint path
	 * @private
	 */
	_getRaysFromWaypoints(waypoints, destination) {
		if ( destination ) waypoints = waypoints.concat([destination]);
		return waypoints.slice(1).map((wp, i) => {
			return new Ray(waypoints[i], wp);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Clear display of the current Ruler
	 */
	clear() {
		this._state = Ruler.STATES.INACTIVE;
		this.waypoints = [];
		if ( this.ruler ) this.ruler.clear();
		this.labels.removeChildren().forEach(c => c.destroy());
		canvas.grid.clearHighlightLayer(this.name);
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */

	/**
	 * Handle the beginning of a new Ruler measurement workflow
	 * @see {Canvas._onDragLeftStart}
	 */
	_onDragStart(event) {
		this.clear();
		this._state = Ruler.STATES.STARTING;
		this._addWaypoint(event.data.origin);
	}

	/* -------------------------------------------- */

	/**
	 * Handle left-click events on the Canvas during Ruler measurement.
	 * @see {Canvas._onClickLeft}
	 */
	_onClickLeft(event) {
		const isCtrl = game.keyboard.isCtrl(event);
		if ( (this._state === 2) && isCtrl ) this._addWaypoint(event.data.origin);
	}

	/* -------------------------------------------- */

	/**
	 * Handle right-click events on the Canvas during Ruler measurement.
	 * @see {Canvas._onClickRight}
	 */
	_onClickRight(event) {
		if ( (this._state === 2) && (this.waypoints.length > 1) ) {
			this._removeWaypoint(event.data.origin, {snap: !event.data.originalEvent.shiftKey});
			return canvas.mouseInteractionManager._dragRight = false;
		}
		else return this._endMeasurement();
	}

	/* -------------------------------------------- */

	/**
	 * Continue a Ruler measurement workflow for left-mouse movements on the Canvas.
	 * @see {Canvas._onDragLeftMove}
	 */
	_onMouseMove(event) {
		if ( this._state === Ruler.STATES.MOVING ) return;

		// Extract event data
		const mt = event._measureTime || 0;
		const {origin, destination, originalEvent} = event.data;

		// Do not begin measuring unless we have moved at least 1/4 of a grid space
		const dx = destination.x - origin.x;
		const dy = destination.y - origin.y;
		const distance = Math.hypot(dy, dx);
		if ( !this.waypoints.length && (distance < (canvas.dimensions.size / 4))) return;

		// Hide any existing Token HUD
		canvas.hud.token.clear();
		delete event.data.hudState;

		// Draw measurement updates
		if ( Date.now() - mt > 50 ) {
			this.measure(destination, {gridSpaces: !originalEvent.shiftKey});
			event._measureTime = Date.now();
			this._state = Ruler.STATES.MEASURING;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Conclude a Ruler measurement workflow by releasing the left-mouse button.
	 * @see {Canvas._onDragLeftDrop}
	 */
	_onMouseUp(event) {
		const oe = event.data.originalEvent;
		const isCtrl = oe.ctrlKey || oe.metaKey;
		if ( !isCtrl ) this._endMeasurement();
	}

	/* -------------------------------------------- */

	/**
	 * Handle the addition of a new waypoint in the Ruler measurement path
	 * @param {PIXI.Point} point
	 * @private
	 */
	_addWaypoint(point) {
		const center = canvas.grid.getCenter(point.x, point.y);
		this.waypoints.push(new PIXI.Point(center[0], center[1]));
		this.labels.addChild(new PreciseText("", CONFIG.canvasTextStyle));
	}

	/* -------------------------------------------- */

	/**
	 * Handle the removal of a waypoint in the Ruler measurement path
	 * @param {PIXI.Point} point      The current cursor position to snap to
	 * @param {boolean} [snap]        Snap exactly to grid spaces?
	 * @private
	 */
	_removeWaypoint(point, {snap=true}={}) {
		this.waypoints.pop();
		this.labels.removeChild(this.labels.children.pop());
		this.measure(point, {gridSpaces: snap});
	}

	/* -------------------------------------------- */

	/**
	 * Handle the conclusion of a Ruler measurement workflow
	 * @private
	 */
	_endMeasurement() {
		this.clear();
		game.user.broadcastActivity({ruler: null});
		canvas.mouseInteractionManager.state = MouseInteractionManager.INTERACTION_STATES.HOVER;
	}

	/* -------------------------------------------- */
	/*  Saving and Loading
	/* -------------------------------------------- */

	toJSON() {
		return {
			class: "Ruler",
			name: `Ruler.${game.user.id}`,
			waypoints: this.waypoints,
			destination: this.destination,
			_state: this._state
		}
	}

	/* -------------------------------------------- */

	/**
	 * Update a Ruler instance using data provided through the cursor activity socket
	 * @param {Object} data   Ruler data with which to update the display
	 */
	update(data) {
		if ( data.class !== "Ruler" ) throw new Error("Unable to recreate Ruler instance from provided data");

		// Populate data
		this.waypoints = data.waypoints;
		this.destination = data.destination;
		this._state = data._state;

		// Ensure labels are created
		for ( let i=0; i<this.waypoints.length - this.labels.children.length; i++) {
			this.labels.addChild(new PreciseText("", CONFIG.canvasTextStyle));
		}

		// Measure current distance
		if ( data.destination ) this.measure(data.destination);
	}
}

/**
 * I don't know what this will do yet
 */
class SpecialEffect {
	constructor(parent, options) {
		this.parent = parent;
		this.options = mergeObject(this.constructor.effectOptions, options, {insertKeys: false});
		this.emitters = this.getParticleEmitters();

		/**
		 * Use this flag as a way to pass a stop signal into the animation frame
		 * @type {boolean}
		 */
		this._stop = null;
	}

	static OPTION_TYPES = {
		VALUE: 1,
		CHECKBOX: 2,
		RANGE: 3,
		SELECT: 4
	};

	static DEFAULT_CONFIG = {
		"maxSpeed": 0,
		"noRotation": false,
		"blendMode": "normal",
		"emitterLifetime": -1,
		"pos": {
			"x": 0,
			"y": 0
		},
		"spawnType": "rect"
	};

	/* -------------------------------------------- */

	static get label() {
		return "Special Effect";
	}

	/* -------------------------------------------- */

	static get effectOptions() {
		return {
			density: {
				label: "Particle Density",
				type: this.OPTION_TYPES.RANGE,
				value: 0.5,
				min: 0.1,
				max: 5,
				step: 0.1
			}
		};
	}

	/* -------------------------------------------- */

	getParticleEmitters() {
		return [];
	}

	/* -------------------------------------------- */

	play(duration) {
		this._stop = null;
		for ( let e of this.emitters ) {
			this._startEmitter(e);
		}
	}

	/* -------------------------------------------- */

	stop() {
		this._stop = true;
		for ( let e of this.emitters ) {
			e.emit = false;
			e.cleanup();
		}
	}

	/* -------------------------------------------- */

	_startEmitter(emitter) {

		// Calculate the current time
		let elapsed = Date.now();

		// Update function every frame
		let update = () => {

			// Maybe stop
			if ( this._stop) return;

			// Update the next frame
			requestAnimationFrame(update);

			// Track the number of elapsed seconds since the previous frame update
			let now = Date.now();
			emitter.update((now - elapsed) * 0.001);
			elapsed = now;
		};

		// Start emitting
		emitter.emit = true;
		update();
	}
}

/**
 * A special full-screen weather effect which uses one Emitters to render gently falling autumn leaves
 * @extends {SpecialEffect}
 */
class AutumnLeavesWeatherEffect extends SpecialEffect {
	static get label() {
		return "Autumn Leaves";
	}

	/**
	 * Configuration for the falling leaves particle effect
	 * @type {Object}
	 */
	static LEAF_CONFIG = foundry.utils.mergeObject(SpecialEffect.DEFAULT_CONFIG, {
		"alpha": {
			"start": 0.9,
			"end": 0.5
		},
		"scale": {
			"start": 0.2,
			"end": 0.4,
			"minimumScaleMultiplier": 0.5
		},
		"speed": {
			"start": 20,
			"end": 60,
			"minimumSpeedMultiplier": 0.6
		},
		"startRotation": {
			"min": 0,
			"max": 365
		},
		"rotation": 180,
		"rotationSpeed": {
			"min": 100,
			"max": 200
		},
		"lifetime": {
			"min": 10,
			"max": 10
		},
	}, {inplace: false});

	/* -------------------------------------------- */

	static get effectOptions() {
		const options = super.effectOptions;
		options.density.min = 0.05;
		options.density.value = 0.25;
		options.density.max = 1;
		options.density.step = 0.05;
		return options;
	}

	/* -------------------------------------------- */

	getParticleEmitters() {
		return [this._getLeafEmitter(this.parent)];
	}

	/* -------------------------------------------- */

	_getLeafEmitter(parent) {
		const d = canvas.dimensions;
		const p = (d.width / d.size) * (d.height / d.size) * this.options.density.value;
		const config = foundry.utils.mergeObject(this.constructor.LEAF_CONFIG, {
			spawnRect: {
				x: d.paddingX,
				y: d.paddingY,
				w: d.sceneWidth,
				h: d.sceneHeight
			},
			maxParticles: p,
			frequency: this.constructor.LEAF_CONFIG.lifetime.min / p
		}, {inplace: false});
		const sprites = Array.fromRange(6).map(n => `ui/particles/leaf${n+1}.png`);
		return new PIXI.particles.Emitter(parent, sprites, config);
	}
}

/**
 * A special full-screen weather effect which uses two Emitters to render drops and splashes
 * @type {SpecialEffect}
 */
class RainWeatherEffect extends SpecialEffect {
	static get label() {
		return "Rain";
	}

	/**
	 * Configuration for the particle emitter for rain
	 * @type {Object}
	 */
	static RAIN_CONFIG = foundry.utils.mergeObject(SpecialEffect.DEFAULT_CONFIG, {
		"alpha": {
			"start": 0.7,
			"end": 0.1
		},
		"scale": {
			"start": 1.0,
			"end": 1.0,
			"minimumScaleMultiplier": 0.8
		},
		"speed": {
			"start": 3500,
			"end": 3500,
			"minimumSpeedMultiplier": 0.8
		},
		"startRotation": {
			"min": 75,
			"max": 75
		},
		"rotation": 90,
		"rotationSpeed": {
			"min": 0,
			"max": 0
		},
		"lifetime": {
			"min": 0.5,
			"max": 0.5
		}
	}, {inplace: false});

	/**
	 * Configuration for the particle emitter for splashes
	 * @type {Object}
	 */
	static SPLASH_CONFIG = foundry.utils.mergeObject(SpecialEffect.DEFAULT_CONFIG, {
		"alpha": {
			"start": 1,
			"end": 1
		},
		"scale": {
			"start": 0.6,
			"end": 0.6,
			"minimumScaleMultiplier": 0.8
		},
		"speed": {
			"start": 0,
			"end": 0
		},
		"startRotation": {
			"min": -90,
			"max": -90
		},
		"noRotation": true,
		"lifetime": {
			"min": 0.5,
			"max": 0.5
		}
	}, {inplace: false});

	/* -------------------------------------------- */

	getParticleEmitters() {
		return [
			this._getRainEmitter(this.parent),
			this._getSplashEmitter(this.parent)
		];
	}

	/* -------------------------------------------- */

	_getRainEmitter(parent) {
		const d = canvas.dimensions;
		const p = (d.width / d.size) * (d.height / d.size) * this.options.density.value;
		const config = foundry.utils.mergeObject(this.constructor.RAIN_CONFIG, {
			spawnRect: {
				x: -0.05 * d.width,
				y: -0.10 * d.height,
				w: d.width,
				h: 0.8 * d.height
			},
			maxParticles: p,
			frequency: 1 / p
		}, {inplace: false});
		return new PIXI.particles.Emitter(parent, ["ui/particles/rain.png"], config);
	}

	/* -------------------------------------------- */

	_getSplashEmitter(parent) {
		const d = canvas.dimensions;
		const p = (d.width / d.size) * (d.height / d.size) * this.options.density.value;
		const config = foundry.utils.mergeObject(this.constructor.SPLASH_CONFIG, {
			spawnRect: {
				x: 0,
				y: 0.25 * d.height,
				w: d.width,
				h: 0.75 * d.height
			},
			maxParticles: 0.5 * p,
			frequency: 2 / p
		}, {inplace: false});
		return new PIXI.particles.Emitter(parent, ["ui/particles/drop.png"], config);
	}
}

/**
 * A special full-screen weather effect which uses one Emitters to render snowflakes
 * @type {SpecialEffect}
 */
class SnowWeatherEffect extends SpecialEffect {
	static get label() {
		return "Snow";
	}

	/**
	 * Configuration of the particle emitter for snowflakes
	 * @type {object}
	 */
	static SNOW_CONFIG = foundry.utils.mergeObject(SpecialEffect.DEFAULT_CONFIG, {
		"alpha": {
			"start": 0.9,
			"end": 0.5
		},
		"scale": {
			"start": 0.2,
			"end": 0.4,
			"minimumScaleMultiplier": 0.5
		},
		"speed": {
			"start": 190,
			"end": 210,
			"minimumSpeedMultiplier": 0.6
		},
		"startRotation": {
			"min": 50,
			"max": 75
		},
		"rotation": 90,
		"rotationSpeed": {
			"min": 0,
			"max": 200
		},
		"lifetime": {
			"min": 4,
			"max": 4
		},
	}, {inplace: false});

	/* -------------------------------------------- */

	getParticleEmitters() {
		return [this._getSnowEmitter(this.parent)];
	}

	/* -------------------------------------------- */

	_getSnowEmitter(parent) {
		const d = canvas.dimensions;
		const p = (d.width / d.size) * (d.height / d.size) * this.options.density.value;
		const config = foundry.utils.mergeObject(this.constructor.SNOW_CONFIG, {
			spawnRect: {
				x: 0,
				y: -0.10 * d.height,
				w: d.width,
				h: d.height
			},
			maxParticles: p,
			frequency: 1 / p
		}, {inplace: false});
		return new PIXI.particles.Emitter(parent, ["ui/particles/snow.png"], config);
	}
}

/**
 * The base grid class.
 * This double-dips to implement the "gridless" option
 */
class BaseGrid extends PIXI.Container {
	constructor(options) {
		super();
		this.options = options;

		/**
		 * Grid Unit Width
		 */
		this.w = options.dimensions.size;

		/**
		 * Grid Unit Height
		 */
		this.h = options.dimensions.size;

		/**
		 * Highlight active grid spaces
		 * @type {Object}
		 */
		this.highlight = this.addChild(new PIXI.Container());
	}

	/* -------------------------------------------- */

	draw() {
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Highlight a grid position for a certain coordinates
	 * @param {GridHighlight} layer The highlight layer to use
	 * @param {number} x            The x-coordinate of the highlighted position
	 * @param {number} y            The y-coordinate of the highlighted position
	 * @param {number} color        The hex fill color of the highlight
	 * @param {number} border       The hex border color of the highlight
	 * @param {number} alpha        The opacity of the highlight
	 * @param {PIXI.Polygon} shape  A predefined shape to highlight
	 */
	highlightGridPosition(layer, {x, y, color=0x33BBFF, border=null, alpha=0.25, shape=null}={}) {
		if ( !shape ) return;
		layer.beginFill(color, alpha);
		if ( border ) layer.lineStyle(2, border, Math.min(alpha*1.5, 1.0));
		layer.drawShape(shape).endFill();
	}

	/* -------------------------------------------- */
	/*  Grid Measurement Methods
	/* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x, y) - return the top-left of the grid square which contains that point
	 * @return {number[]}    An Array [x, y] of the top-left coordinate of the square which contains (x, y)
	 */
	getTopLeft(x, y) {
		let [x0, y0] = this.getGridPositionFromPixels(x,y);
		return this.getPixelsFromGridPosition(x0, y0);
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x, y), return the center of the grid square which contains that point
	 * @param {number} x          The x-coordinate
	 * @param {number} y          The y-coordinate
	 * @return {number[]}         An array [cx, cy] of the central point of the grid space which contains (x, y)
	 */
	getCenter(x, y) {
		return [x, y];
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x1,y1), return the grid coordinates (x2,y2) which represent the snapped position
	 * Under a "gridless" system, every pixel position is a valid snapping position
	 *
	 * @param {number} x          The exact target location x
	 * @param {number} y          The exact target location y
	 * @param {number|null} [interval]  An interval of grid spaces at which to snap.
	 *                                  At interval=1, snapping occurs at pixel intervals defined by the grid size
	 *                                  At interval=2, snapping would occur at the center-points of each grid size
	 *                                  At interval=null, no snapping occurs
	 *
	 * @return {{x, y}}           An object containing the coordinates of the snapped location
	 */
	getSnappedPosition(x, y, interval=null) {
		interval = interval ?? 1;
		return {
			x: x.toNearest(this.w / interval),
			y: y.toNearest(this.h / interval)
		};
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of pixel coordinates, return the grid position as an Array.
	 * Always round down to the nearest grid position so the pixels are within the grid space (from top-left).
	 * @param {number} x    The x-coordinate pixel position
	 * @param {number} y    The y-coordinate pixel position
	 * @return {number[]}   An array representing the position in grid units
	 */
	getGridPositionFromPixels(x, y) {
		return [x, y].map(Math.round);
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of grid coordinates, return the pixel position as an Array.
	 * Always round up to a whole pixel so the pixel is within the grid space (from top-left).
	 * @param {number} x    The x-coordinate grid position
	 * @param {number} y    The y-coordinate grid position
	 * @return {number[]}   An array representing the position in pixels
	 */
	getPixelsFromGridPosition(x, y) {
		return [x, y].map(Math.round);
	}

	/* -------------------------------------------- */

	/**
	 * Shift a pixel position [x,y] by some number of grid units dx and dy
	 * @param {number} x    The starting x-coordinate in pixels
	 * @param {number} y    The starting y-coordinate in pixels
	 * @param {number} dx   The number of grid positions to shift horizontally
	 * @param {number} dy   The number of grid positions to shift vertically
	 */
	shiftPosition(x, y, dx, dy) {
		let s = canvas.dimensions.size;
		return [x + (dx*s), y + (dy*s)];
	}

	/* -------------------------------------------- */

	/**
	 * Measure the distance traversed over an array of measured segments
	 * @param {object[]} segments     An Array of measured movement segments
	 * @param {Options} options       Additional options which modify the measurement
	 * @return {number[]}             An Array of distance measurements for each segment
	 */
	measureDistances(segments, options={}) {
		const d = canvas.dimensions;
		return segments.map(s => {
			return (s.ray.distance / d.size) * d.distance;
		});
	}

	/* -------------------------------------------- */

	/**
	 * Get the grid row and column positions which are neighbors of a certain position
	 * @param {number} row  The grid row coordinate against which to test for neighbors
	 * @param {number} col  The grid column coordinate against which to test for neighbors
	 * @return {number[]}   An array of grid positions which are neighbors of the row and column
	 */
	getNeighbors(row, col) {
		return [];
	}
}
/**
 * Construct a hexagonal grid
 * @extends {BaseGrid}
 */
class HexagonalGrid extends BaseGrid {
	constructor(options) {
		super(options);
		this.columns = !!options.columns;
		this.even = !!options.even;

		// Grid width and height
		let s = options.dimensions.size;
		if ( this.columns ) {
			this.w = s;
			this.h = Math.sqrt(3) * 0.5 * s;
		} else {
			this.w = Math.sqrt(3) * 0.5 * s;
			this.h = s;
		}
	}

	/**
	 * A matrix of x and y offsets which is multiplied by the width/height vector to get pointy-top polygon coordinates
	 * @type {Array<number[]>}
	 */
	static get pointyHexPoints() {
		return [[0, 0.25], [0.5, 0], [1, 0.25], [1, 0.75], [0.5, 1], [0, 0.75]];
	}

	/* -------------------------------------------- */

	/**
	 * A matrix of x and y offsets which is multiplied by the width/height vector to get flat-top polygon coordinates
	 * @type {Array<number[]>}
	 */
	static get flatHexPoints() {
		return [[0, 0.5], [0.25, 0], [0.75, 0], [1, 0.5], [0.75, 1], [0.25, 1]];
	}

	/* -------------------------------------------- */

	/**
	 * An array of the points which define a hexagon for this grid shape
	 * @return {PointArray[]}
	 */
	get hexPoints() {
		return this.options.columns ? this.constructor.flatHexPoints : this.constructor.pointyHexPoints;
	}

	/* -------------------------------------------- */
	/*  Grid Rendering
	/* -------------------------------------------- */

	/** @override */
	draw() {
		if ( this.alpha === 0 ) return this;

		// Set dimensions
		let d = this.options.dimensions;
		this.width = d.width;
		this.height = d.height;

		// Draw grid polygons
		this.addChild(this._drawGrid());
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience method for getting all the polygon points relative to a top-left [x,y] coordinate pair
	 * @param {number} x    The top-left x-coordinate
	 * @param {number} y    The top-right y-coordinate
	 * @param {number} [w]  An optional polygon width
	 * @param {number} [h]  An optional polygon height
	 */
	getPolygon(x, y, w, h) {
		w = w ?? this.w;
		h = h ?? this.h;
		const points = this.hexPoints.concat([this.hexPoints[0]]); // Add the first point back
		return points.reduce((arr, p) => {
			return arr.concat([x + (w * p[0]), y + (h * p[1])]);
		}, []);
	}

	/* -------------------------------------------- */

	_drawGrid() {
		let { color, alpha, columns } = this.options;
		const ncols = Math.ceil(canvas.dimensions.width / this.w);
		const nrows = Math.ceil(canvas.dimensions.height / this.h);

		// Draw Grid graphic
		const grid = new PIXI.Graphics();
		grid.lineStyle(1, color, alpha);

		// Draw hex rows
		if ( columns ) this._drawColumns(grid, nrows, ncols);
		else this._drawRows(grid, nrows, ncols);
		return grid;
	}

	/* -------------------------------------------- */

	_drawRows(grid, nrows, ncols) {
		let shift = this.even ? 0 : 1;
		nrows /= 0.75;
		for ( let r=0; r<nrows; r++ ) {
			let sx = (r % 2) === shift ? 0 : -0.5;
			let y0 = r * this.h * 0.75;
			for ( let c=0; c<ncols; c++ ) {
				let x0 = (c+sx) * this.w;
				grid.drawPolygon(this.getPolygon(x0, y0));
			}
		}
	}

	/* -------------------------------------------- */

	_drawColumns(grid, nrows, ncols) {
		let shift = this.even ? 0 : 1;
		ncols /= 0.75;
		for ( let c=0; c<ncols; c++ ) {
			let sy = (c % 2) === shift ? 0 : -0.5;
			let x0 = c * this.w * 0.75;
			for ( let r=0; r<nrows; r++ ) {
				let y0 = (r+sy) * this.h;
				grid.drawPolygon(this.getPolygon(x0, y0));
			}
		}
	}

	/* -------------------------------------------- */
	/*  Grid Measurement Methods
	/* -------------------------------------------- */

	/** @override */
	getGridPositionFromPixels(x, y) {
		return this._getGridPositionFromPixels(x, y, "floor");
	}

	/* -------------------------------------------- */

	/**
	 * Get the position in grid space from a pixel coordinate.
	 * @param {number} x        The origin x-coordinate
	 * @param {number} y        The origin y-coordinate
	 * @param {string} method   The rounding method applied
	 * @returns {number[]}      The row, column combination
	 * @private
	 */
	_getGridPositionFromPixels(x, y, method="floor") {
		let row, col;
		const fn = Math[method];
		if ( this.options.columns ) {
			col = fn(x / (this.w*0.75));
			const isEven = (col+1) % 2 === 0;
			row = fn((y / this.h) + (this.options.even === isEven ? 0.5 : 0));
		} else {
			row = fn(y / (this.h*0.75));
			const isEven = (row+1) % 2 === 0;
			col = fn((x / this.w) + (this.options.even === isEven ? 0.5 : 0))
		}
		return [row, col];
	}

	/* -------------------------------------------- */

	/** @override */
	getPixelsFromGridPosition(row, col) {
		let x, y;

		// Flat-topped hexes
		if (this.options.columns) {
			x = Math.ceil(col * (this.w * 0.75));
			const isEven = (col + 1) % 2 === 0;
			y = (row - (this.options.even === isEven ? 0.5 : 0)) * this.h;
		}

		// Pointy-topped hexes
		else {
			y = Math.ceil(row * (this.h * 0.75));
			const isEven = (row + 1) % 2 === 0;
			x = (col - (this.options.even === isEven ? 0.5 : 0)) * this.w;
		}
		return [x, y];
	}

	/* -------------------------------------------- */

	/** @override */
	getCenter(x, y) {
		let [x0, y0] = this.getTopLeft(x, y);
		return [x0 + (this.w/2), y0 + (this.h/2)];
	}

	/* -------------------------------------------- */

	/** @override */
	getSnappedPosition(x, y, interval=1) {

		// At precision 5, return the center or nearest vertex
		if ( interval === 5) {
			const w4 = this.w / 4;
			const h4 = this.h / 4;

			// Distance relative to center
			let [xc, yc] = this.getCenter(x, y);
			let dx = x - xc;
			let dy = y - yc;
			let ox = dx.between(-w4, w4) ? 0 : Math.sign(dx);
			let oy = dy.between(-h4, h4) ? 0 : Math.sign(dy);

			// Closest to the center
			if ( (ox === 0) && (oy === 0) ) return {x: xc, y: yc};

			// Closest vertex based on offset
			if ( this.options.columns && (ox === 0) ) ox = Math.sign(dx) ?? -1;
			if ( !this.options.columns && (oy === 0) ) oy = Math.sign(dy) ?? -1;
			return this._getClosestVertex(xc, yc, ox, oy);
		}

		// Start with the closest top-left grid position
		let [r0, c0] = this._getGridPositionFromPixels(x, y, "round");
		let [x0, y0] = this.getPixelsFromGridPosition(r0, c0);
		if ( interval === 1 ) return {x: x0, y: y0};

		// Round the remainder
		const dx = (x - x0).toNearest(this.w / interval);
		const dy = (y - y0).toNearest(this.h / interval);
		return {x: x0 + dx, y: y0 + dy};
	}

	/* -------------------------------------------- */

	_getClosestVertex(xc, yc, ox, oy) {
		const b = ox + (oy << 2); // Bit shift to make a unique reference
		const vertices = this.options.columns ?
			{"-1": 0, "-5": 1, "-3": 2, "1": 3, "5": 4, "3": 5} : // flat hex vertices
			{"-5": 0, "-4": 1, "-3": 2, "5": 3, "4": 4, "3": 5};  // pointy hex vertices
		const idx = vertices[b];
		const pt = this.hexPoints[idx];
		return {
			x: (xc - (this.w/2)) + (pt[0]*this.w),
			y: (yc - (this.h/2)) + (pt[1]*this.h)
		}
	}

	/* -------------------------------------------- */

	/** @override */
	shiftPosition(x, y, dx, dy) {
		let [row, col] = canvas.grid.grid.getGridPositionFromPixels(x, y);

		// Adjust diagonal moves for offset
		let isDiagonal = (dx !== 0) && (dy !== 0);
		if ( isDiagonal ) {

			// Column orientation
			if ( this.options.columns ) {
				let isEven = ((col+1) % 2 === 0) === this.options.even;
				if ( isEven && (dy > 0)) dy--;
				else if ( !isEven && (dy < 0)) dy++;
			}

			// Row orientation
			else {
				let isEven = ((row + 1) % 2 === 0) === this.options.even;
				if ( isEven && (dx > 0) ) dx--;
				else if ( !isEven && (dx < 0 ) ) dx++;
			}
		}
		return canvas.grid.grid.getPixelsFromGridPosition(row+dy, col+dx);
	}

	/* -------------------------------------------- */
	/*  Grid Highlighting
	/* -------------------------------------------- */

	/** @override */
	highlightGridPosition(layer, options={}) {
		const {x, y} = options;
		if ( !layer.highlight(x, y) ) return;
		options.shape = new PIXI.Polygon(this.getPolygon(x, y));
		return super.highlightGridPosition(layer, options);
	}

	/* -------------------------------------------- */

	/** @override */
	getNeighbors(row, col) {
		let offsets;

		// Column orientation
		if ( this.options.columns ) {
			let shift = ((col+1) % 2 === 0) === this.options.even;
			if ( shift ) offsets = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 0], [0, -1]];
			else offsets = [[0, -1], [-1, 0], [0, 1], [1, 1], [1, 0], [1, -1]];
		}

		// Row orientation
		else {
			let shift = ((row+1) % 2 === 0) === this.options.even;
			if ( shift ) offsets = [[0, -1], [-1, -1], [-1, 0], [0, 1], [1, 0], [1, -1]];
			else offsets = [[0, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0]];
		}
		return offsets.map(o => [row+o[0], col+o[1]]);
	}

	/* -------------------------------------------- */

	/** @override */
	measureDistances(segments, options={}) {
		if ( !options.gridSpaces ) return super.measureDistances(segments, options);
		return segments.map(s => {
			let r = s.ray;
			let [r0, c0] = this.getGridPositionFromPixels(r.A.x, r.A.y);
			let [r1, c1] = this.getGridPositionFromPixels(r.B.x, r.B.y);

			// Use cube conversion to measure distance
			let hex0 = this.offsetToCube(r0, c0);
			let hex1 = this.offsetToCube(r1, c1);
			let distance = HexagonalGrid.cubeDistance(hex0, hex1);
			return distance * canvas.dimensions.distance;
		});
	}

	/* -------------------------------------------- */
	/*  Helper Functions
	/* -------------------------------------------- */

	/**
	 * Convert an offset coordinate (row, col) into a cube coordinate (q, r, s).
	 * See https://www.redblobgames.com/grids/hexagons/ for reference
	 * Source code available https://www.redblobgames.com/grids/hexagons/codegen/output/lib-functions.js
	 * @param {number} row      The row number
	 * @param {number} col      The column number
	 * @return {{q: number, r: number, s: number}}
	 */
	offsetToCube(row, col) {
		const offset = this.options.even ? 1 : -1;

		// Column orientation
		if ( this.options.columns ) {
			const q = col;
			const s = row - (col + (offset*(col & 1))) / 2;
			return {q, r: 0 - q - s, s};
		}

		// Row orientation
		else {
			const q = col - (row + (offset*(row & 1))) / 2;
			const s = row;
			return {q, r: 0 - q - s, s};
		}
	}

	/* -------------------------------------------- */

	/**
	 * Convert a cube coordinate (q, r, s) into an offset coordinate (row, col).
	 * See https://www.redblobgames.com/grids/hexagons/ for reference
	 * Source code available https://www.redblobgames.com/grids/hexagons/codegen/output/lib-functions.js
	 * @param {number} q      Cube coordinate 1
	 * @param {number} r      Cube coordinate 2
	 * @param {number} s      Cube coordinate 3
	 * @return {{row: number, col: number}}
	 */
	cubeToOffset(q, r, s) {
		const offset = this.options.even ? 1 : -1;

		// Column orientation
		if ( this.options.columns ) {
			const col = q;
			const row = s + (q - (offset * (q&1))) / 2;
			return {row, col};
		}

		// Row orientation
		else {
			const row = s;
			const col = q + (s - (offset * (s&1))) / 2;
			return {row, col}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Given a cursor position (x, y), obtain the cube coordinate hex (q, r, s) of the hex which contains it
	 * http://justinpombrio.net/programming/2020/04/28/pixel-to-hex.html
	 * @param {number} x    The x-coordinate in pixels
	 * @param {number} y    The y-coordinate in pixels
	 * @private
	 */
	static pixelToCube(x, y) {
		const size = canvas.dimensions.size / 2;
		const cx = x / size;
		const cy = y / size;

		// Fractional hex coordinates, might not satisfy (fx + fy + fz = 0) due to rounding
		const fr = (2/3) * cx;
		const fq = ((-1/3) * cx) + ((1 / Math.sqrt(3)) * cy);
		const fs = ((-1/3) * cx) - ((1 / Math.sqrt(3)) * cy);

		// Convert to integer triangle coordinates
		const a = Math.ceil(fr - fq);
		const b = Math.ceil(fq - fs);
		const c = Math.ceil(fs - fr);

		// Convert back to cube coordinates
		return [
			Math.round((a - c) / 3),
			Math.round((c - b) / 3),
			Math.round((b - a) / 3)
		];
	}

	/* -------------------------------------------- */

	/**
	 * Measure the distance in hexagons between two cube coordinates
	 * @private
	 */
	static cubeDistance(a, b) {
		let diff = {q: a.q - b.q, r: a.r - b.r, s: a.s - b.s};
		return (Math.abs(diff.q) + Math.abs(diff.r) + Math.abs(diff.s)) / 2;
	}
}

/**
 * A special Graphics class which handles Grid layer highlighting
 * @extends {PIXI.Graphics}
 */
class GridHighlight extends PIXI.Graphics {
	constructor(name, ...args) {
		super(...args);

		/**
		 * Track the Grid Highlight name
		 * @type {string}
		 */
		this.name = name;

		/**
		 * Track distinct positions which have already been highlighted
		 * @type {Set}
		 */
		this.positions = new Set();
	}

	/* -------------------------------------------- */

	/**
	 * Record a position that is highlighted and return whether or not it should be rendered
	 * @param {number} x    The x-coordinate to highlight
	 * @param {number} y    The y-coordinate to highlight
	 * @return {boolean}    Whether or not to draw the highlight for this location
	 */
	highlight(x, y) {
		let key = `${x}.${y}`;
		if ( this.positions.has(key) ) return false;
		this.positions.add(key);
		return true;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	clear() {
		this.positions = new Set();
		return super.clear();
	}


	/* -------------------------------------------- */

	/** @inheritdoc */
	destroy(...args) {
		delete canvas.grid.highlightLayers[this.name];
		return super.destroy(...args);
	}
}

/**
 * A CanvasLayer responsible for drawing a square grid
 * @extends {CanvasLayer}
 */
class GridLayer extends CanvasLayer {

	/**
	 * The Grid container
	 * @type {BaseGrid}
	 */
	grid;

	/**
	 * The Grid Highlight container
	 * @type {PIXI.Container}
	 */
	highlight;

	/**
	 * Map named highlight layers
	 * @type {Object<GridHighlight>}
	 */
	highlightLayers = {};

	/* -------------------------------------------- */

	/** @inheritdoc */
	static get layerOptions() {
		return foundry.utils.mergeObject(super.layerOptions, {
			zIndex: 30
		});
	}

	/* -------------------------------------------- */

	/**
	 * The grid type rendered in this Scene
	 * @type {number}
	 */
	get type() {
		return canvas.scene.data.gridType;
	}

	/**
	 * A convenient reference to the pixel grid size used throughout this layer
	 * @type {number}
	 */
	get size() {
		return canvas.dimensions.size;
	}

	/**
	 * Get grid unit width
	 */
	get w() {
		return this.grid.w;
	}

	/**
	 * Get grid unit height
	 */
	get h() {
		return this.grid.h;
	}

	/**
	 * A boolean flag for whether the current grid is hexagonal
	 * @type {boolean}
	 */
	get isHex() {
		const gt = CONST.GRID_TYPES;
		return [gt.HEXODDQ, gt.HEXEVENQ, gt.HEXODDR, gt.HEXEVENR].includes(this.type);
	}

	/* -------------------------------------------- */

	/**
	 * Draw the grid
	 * @param {Object} preview    Override settings used in place of those saved to the Scene data
	 */
	async draw({type=null, dimensions=null, gridColor=null, gridAlpha=null}={}) {
		await super.draw();

		// Get grid data
		const gt = type !== null ? type : this.type;

		// Grid configuration
		let grid;
		let gridOptions = {
			dimensions: dimensions || canvas.dimensions,
			color: gridColor || canvas.scene.data.gridColor.replace("#", "0x") || "0x000000",
			alpha: gridAlpha || canvas.scene.data.gridAlpha,
			columns: [CONST.GRID_TYPES.HEXODDQ, CONST.GRID_TYPES.HEXEVENQ].includes(gt),
			even: [CONST.GRID_TYPES.HEXEVENR, CONST.GRID_TYPES.HEXEVENQ].includes(gt)
		};

		// Gridless
		if ( gt === CONST.GRID_TYPES.GRIDLESS ) grid = new BaseGrid(gridOptions);

		// Square grid
		else if ( gt === CONST.GRID_TYPES.SQUARE ) grid = new SquareGrid(gridOptions);

		// Hexagonal grid
		else grid = new HexagonalGrid(gridOptions);

		// Draw the highlight layer
		this.highlightLayers = {};
		this.highlight = this.addChild(new PIXI.Container());

		// Draw the grid
		this.grid = this.addChild(grid.draw());
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x1,y1), return the grid coordinates (x2,y2) which represent the snapped position
	 * @param {number} x          The exact target location x
	 * @param {number} y          The exact target location y
	 * @param {number} [interval=1]  An interval of grid spaces at which to snap, default is 1. If the interval is zero, no snapping occurs.
	 */
	getSnappedPosition(x, y, interval=1) {
		if ( interval === 0 ) return {x, y};
		return this.grid.getSnappedPosition(x, y, interval);
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x, y) - return the top-left of the grid square which contains that point
	 * @return {number[]}    An Array [x, y] of the top-left coordinate of the square which contains (x, y)
	 */
	getTopLeft(x, y) {
		return this.grid.getTopLeft(x, y);
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x, y), return the center of the grid square which contains that point
	 * @return {number[]}    An Array [x, y] of the central point of the square which contains (x, y)
	 */
	getCenter(x, y) {
		return this.grid.getCenter(x, y);
	}

	/* -------------------------------------------- */

	/**
	 * Measure the grid-wise distance between two point coordinates.
	 * @param {{x: number, y: number}} origin    The origin point
	 * @param {{x: number, y: number}} target    The target point
	 * @return {number}                          The measured distance between these points
	 *
	 * @example
	 * let distance = canvas.grid.measureDistance({x: 1000, y: 1000}, {x: 2000, y: 2000});
	 */
	measureDistance(origin, target) {
		const ray = new Ray(origin, target);
		const segments = [{ray}];
		return this.grid.measureDistances(segments)[0];
	}

	/* -------------------------------------------- */

	/**
	 * Measure the distance traveled over an array of distance segments.
	 * @param {object[]} segments     An array of measured segments
	 * @param {Options} options       Additional options which modify the measurement
	 */
	measureDistances(segments, options={}) {
		return this.grid.measureDistances(segments, options);
	}

	/* -------------------------------------------- */
	/*  Grid Highlighting Methods
	/* -------------------------------------------- */

	/**
	 * Define a new Highlight graphic
	 * @param {string} name     The name for the referenced highlight layer
	 */
	addHighlightLayer(name) {
		const layer = this.highlightLayers[name];
		if ( !layer || layer._destroyed ) {
			this.highlightLayers[name] = this.highlight.addChild(new GridHighlight(name));
		}
		return this.highlightLayers[name];
	}

	/* -------------------------------------------- */

	/**
	 * Clear a specific Highlight graphic
	 * @param {string} name     The name for the referenced highlight layer
	 */
	clearHighlightLayer(name) {
		const layer = this.highlightLayers[name];
		if ( layer ) layer.clear();
	}

	/* -------------------------------------------- */

	/**
	 * Destroy a specific Highlight graphic
	 * @param {string} name     The name for the referenced highlight layer
	 */
	destroyHighlightLayer(name) {
		const layer = this.highlightLayers[name];
		this.highlight.removeChild(layer);
		layer.destroy();
	}

	/* -------------------------------------------- */

	/**
	 * Obtain the highlight layer graphic by name
	 * @param {string} name     The name for the referenced highlight layer
	 */
	getHighlightLayer(name) {
		return this.highlightLayers[name];
	}

	/* -------------------------------------------- */

	/**
	 * Add highlighting for a specific grid position to a named highlight graphic
	 * @param {string} name       The name for the referenced highlight layer
	 * @param {object} options    Options for the grid position that should be highlighted
	 */
	highlightPosition(name, options) {
		const layer = this.highlightLayers[name];
		if ( !layer ) return false;
		this.grid.highlightGridPosition(layer, options);
	}

	/* -------------------------------------------- */

	/**
	 * Test if a specific row and column position is a neighboring location to another row and column coordinate
	 * @param {number} r0     The original row position
	 * @param {number} c0     The original column position
	 * @param {number} r1     The candidate row position
	 * @param {number} c1     The candidate column position
	 */
	isNeighbor(r0, c0, r1, c1) {
		let neighbors = this.grid.getNeighbors(r0, c0);
		return neighbors.some(n => (n[0] === r1) && (n[1] === c1));
	}
}

/**
 * Construct a square grid container
 * @type {BaseGrid}
 */
class SquareGrid extends BaseGrid {

	/** @override */
	draw() {
		let { color, alpha } = this.options;
		if ( alpha === 0 ) return this;

		// Set dimensions
		let d = this.options.dimensions;
		this.width = d.width;
		this.height = d.height;

		// Vertical lines
		let nx = Math.floor(d.width / d.size);
		for (let i = 1; i < nx; i++) {
			let x = i * d.size;
			this.addChild(this._drawLine([x, 0, x, d.height], color , alpha));
		}

		// Horizontal lines
		let ny = Math.ceil(d.height / d.size);
		for (let i = 1; i < ny; i++) {
			let y = i * d.size;
			this.addChild(this._drawLine([0, y, d.width, y], color , alpha));
		}
		return this;
	}

	/* -------------------------------------------- */

	_drawLine(points, lineColor, lineAlpha) {
		let line = new PIXI.Graphics();
		line.lineStyle(1, lineColor, lineAlpha)
				.moveTo(points[0], points[1])
				.lineTo(points[2], points[3]);
		return line;
	}

	/* -------------------------------------------- */
	/*  Grid Measurement Methods
	/* -------------------------------------------- */

	/** @override */
	getCenter(x, y) {
		const gs = canvas.dimensions.size;
		return this.getTopLeft(x, y).map(c => c + (gs / 2));
	}

	/* -------------------------------------------- */

	/** @override */
	getGridPositionFromPixels(x, y) {
		let gs = canvas.dimensions.size;
		return [Math.floor(y / gs), Math.floor(x / gs)];
	}

	/* -------------------------------------------- */

	/** @override */
	getPixelsFromGridPosition(row, col) {
		let gs = canvas.dimensions.size;
		return [col*gs, row*gs];
	}

	/* -------------------------------------------- */

	/** @override */
	getSnappedPosition(x, y, interval=1) {
		let [x0, y0] = this._getNearestVertex(x, y);
		let dx = 0;
		let dy = 0;
		if ( interval !== 1 ) {
			let delta = canvas.dimensions.size / interval;
			dx = Math.round((x - x0) / delta) * delta;
			dy = Math.round((y - y0) / delta) * delta;
		}
		return {
			x: x0 + dx,
			y: y0 + dy
		}
	}

	/* -------------------------------------------- */

	/**
	 * Shift a pixel position [x,y] by some number of grid units dx and dy
	 * @param {number} x    The starting x-coordinate in pixels
	 * @param {number} y    The starting y-coordinate in pixels
	 * @param {number} dx   The number of grid positions to shift horizontally
	 * @param {number} dy   The number of grid positions to shift vertically
	 */
	shiftPosition(x, y, dx, dy) {
		let [row, col] = canvas.grid.grid.getGridPositionFromPixels(x, y);
		return canvas.grid.grid.getPixelsFromGridPosition(row+dy, col+dx);
	}

	/* -------------------------------------------- */

	_getNearestVertex(x, y) {
		const gs = canvas.dimensions.size;
		return [Math.round(x / gs) * gs, Math.round(y / gs) * gs];
	}

	/* -------------------------------------------- */

	/** @override */
	highlightGridPosition(layer , options={}) {
		const {x, y} = options;
		if ( !layer.highlight(x, y) ) return;
		let s = canvas.dimensions.size;
		options.shape = new PIXI.Rectangle(x, y, s, s);
		return super.highlightGridPosition(layer, options);
	}

	/* -------------------------------------------- */

	/** @override */
	measureDistances(segments, options={}) {
		if ( !options.gridSpaces ) return super.measureDistances(segments, options);
		const d = canvas.dimensions;
		return segments.map(s => {
			let r = s.ray;
			let nx = Math.abs(Math.ceil(r.dx / d.size));
			let ny = Math.abs(Math.ceil(r.dy / d.size));

			// Determine the number of straight and diagonal moves
			let nd = Math.min(nx, ny);
			let ns = Math.abs(ny - nx);

			// Linear distance for all moves
			return (nd + ns) * d.distance;
		});
	}

	/* -------------------------------------------- */

	/** @override */
	getNeighbors(row, col) {
		let offsets = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
		return offsets.map(o => [row+o[0], col+o[1]]);
	}
}

/**
 * An implementation interface for an Audio/Video client which is extended to provide broadcasting functionality.
 * @interface
 * @param {AVMaster} master           The master orchestration instance
 * @param {AVSettings} settings       The audio/video settings being used
 */
class AVClient {
	constructor(master, settings) {
		this.master = master;
		this.settings = settings;
	}

	/* -------------------------------------------- */
	/*  Connection                                  */
	/* -------------------------------------------- */

	/**
	 * One-time initialization actions that should be performed for this client implementation.
	 * This will be called only once when the Game object is first set-up.
	 * @return {Promise<void>}
	 */
	async initialize() {
		throw Error("The initialize() method must be defined by an AVClient subclass.");
	}

	/* -------------------------------------------- */

	/**
	 * Connect to any servers or services needed in order to provide audio/video functionality.
	 * Any parameters needed in order to establish the connection should be drawn from the settings object.
	 * This function should return a boolean for whether the connection attempt was successful.
	 * @return {Promise<boolean>}   Was the connection attempt successful?
	 */
	async connect() {
		throw Error("The connect() method must be defined by an AVClient subclass.");
	}

	/* -------------------------------------------- */

	/**
	 * Disconnect from any servers or services which are used to provide audio/video functionality.
	 * This function should return a boolean for whether a valid disconnection occurred.
	 * @return {Promise<boolean>}   Did a disconnection occur?
	 */
	async disconnect() {
		throw Error("The disconnect() method must be defined by an AVClient subclass.");
	}

	/* -------------------------------------------- */
	/*  Device Discovery                            */
	/* -------------------------------------------- */

	/**
	 * Provide an Object of available audio sources which can be used by this implementation.
	 * Each object key should be a device id and the key should be a human-readable label.
	 * @return {Promise<{string: string}>}
	 */
	async getAudioSinks() {
		throw Error("The getAudioSinks() method must be defined by an AVClient subclass.");
	}

	/* -------------------------------------------- */

	/**
	 * Provide an Object of available audio sources which can be used by this implementation.
	 * Each object key should be a device id and the key should be a human-readable label.
	 * @return {Promise<{string: string}>}
	 */
	async getAudioSources() {
		throw Error("The getAudioSources() method must be defined by an AVClient subclass.");
	}

	/* -------------------------------------------- */

	/**
	 * Provide an Object of available video sources which can be used by this implementation.
	 * Each object key should be a device id and the key should be a human-readable label.
	 * @return {Promise<{string: string}>}
	 */
	async getVideoSources() {
		throw Error("The getVideoSources() method must be defined by an AVClient subclass.");
	}

	/* -------------------------------------------- */
	/*  Track Manipulation                          */
	/* -------------------------------------------- */

	/**
	 * Return an array of Foundry User IDs which are currently connected to A/V.
	 * The current user should also be included as a connected user in addition to all peers.
	 * @return {string[]}           The connected User IDs
	 */
	getConnectedUsers() {
		throw Error("The getConnectedUsers() method must be defined by an AVClient subclass.");
	}

	/* -------------------------------------------- */

	/**
	 * Provide a MediaStream instance for a given user ID
	 * @param {string} userId        The User id
	 * @return {MediaStream|null}    The MediaStream for the user, or null if the user does not have one
	 */
	getMediaStreamForUser(userId) {
		throw Error("The getMediaStreamForUser() method must be defined by an AVClient subclass.");
	}

	/* -------------------------------------------- */

	/**
	 * Is outbound audio enabled for the current user?
	 * @return {boolean}
	 */
	isAudioEnabled() {
		throw Error("The isAudioEnabled() method must be defined by an AVClient subclass.");
	}

	/* -------------------------------------------- */

	/**
	 * Is outbound video enabled for the current user?
	 * @return {boolean}
	 */
	isVideoEnabled() {
		throw Error("The isVideoEnabled() method must be defined by an AVClient subclass.");
	}

	/* -------------------------------------------- */

	/**
	 * Set whether the outbound audio feed for the current game user is enabled.
	 * This method should be used when the user marks themselves as muted or if the gamemaster globally mutes them.
	 * @param {boolean} enable        Whether the outbound audio track should be enabled (true) or disabled (false)
	 */
	toggleAudio(enable) {
		throw Error("The toggleAudio() method must be defined by an AVClient subclass.");
	}

	/* -------------------------------------------- */

	/**
	 * Set whether the outbound audio feed for the current game user is actively broadcasting.
	 * This can only be true if audio is enabled, but may be false if using push-to-talk or voice activation modes.
	 * @param {boolean} broadcast      Whether outbound audio should be sent to connected peers or not?
	 */
	toggleBroadcast(broadcast) {
		throw Error("The toggleBroadcast() method must be defined by an AVClient subclass.");
	}

	/* -------------------------------------------- */

	/**
	 * Set whether the outbound video feed for the current game user is enabled.
	 * This method should be used when the user marks themselves as hidden or if the gamemaster globally hides them.
	 * @param {boolean} enable        Whether the outbound video track should be enabled (true) or disabled (false)
	 */
	toggleVideo(enable) {
		throw Error("The toggleVideo() method must be defined by an AVClient subclass.");
	}

	/* -------------------------------------------- */

	/**
	 * Set the Video Track for a given User ID to a provided VideoElement
	 * @param {string} userId                   The User ID to set to the element
	 * @param {HTMLVideoElement} videoElement   The HTMLVideoElement to which the video should be set
	 */
	async setUserVideo(userId, videoElement) {
		throw Error("The setUserVideo() method must be defined by an AVClient subclass.");
	}

	/* -------------------------------------------- */
	/*  Settings and Configuration                  */
	/* -------------------------------------------- */

	/**
	 * Handle changes to A/V configuration settings.
	 * @param {object} changed      The settings which have changed
	 */
	onSettingsChanged(changed) {}
}

/**
 * The master Audio/Video controller instance.
 * This is available as the singleton game.webrtc
 *
 * @param {AVSettings} settings     The Audio/Video settings to use
 */
class AVMaster {
	constructor() {
		this.settings = new AVSettings();
		this.config = new AVConfig(this);

		/**
		 * The Audio/Video client class
		 * @type {AVClient}
		 */
		this.client = new CONFIG.WebRTC.clientClass(this, this.settings);

		/**
		 * A flag to track whether the current user is actively broadcasting their microphone.
		 * @type {boolean}
		 */
		this.broadcasting = false;

		/**
		 * Flag to determine if we are connected to the signalling server or not.
		 * This is required for synchronization between connection and reconnection attempts.
		 * @type {boolean}
		 */
		this._connected = false;

		/**
		 * A flag to track whether the A/V system is currently in the process of reconnecting.
		 * This occurs if the connection is lost or interrupted.
		 * @type {boolean}
		 * @private
		 */
		this._reconnecting = false;

		// Other internal flags
		this._speakingData = {};
		this._pttHandlers = {};
		this._pttMuteTimeout = 0;
	}

	/* -------------------------------------------- */

	get mode() {
		return this.settings.world.mode;
	}

	/* -------------------------------------------- */
	/*  Initialization                              */
	/* -------------------------------------------- */

	/**
	 * Connect to the Audio/Video client.
	 * @return {Promise<boolean>}     Was the connection attempt successful?
	 */
	async connect() {

		// Initialize Client state
		await this.client.initialize();

		// Disconnect from any existing session
		await this.disconnect();

		// Activate the connection
		if ( this.mode === AVSettings.AV_MODES.DISABLED ) return false;

		// Connect to the client
		const connected = await this.client.connect();
		if ( !connected ) return false;
		console.log(`Connected to the ${this.client.constructor.name} Audio/Video client.`);

		// Initialize local broadcasting
		this._initialize();
		return this._connected = connected;
	}

	/* -------------------------------------------- */

	/**
	 * Disconnect from the Audio/Video client.
	 * @return {Promise<boolean>}     Whether an existing connection was terminated?
	 */
	async disconnect() {
		if ( !this._connected ) return false;
		this._connected = this._reconnecting = false;
		await this.client.disconnect();
		console.log(`Disconnected from the ${this.client.constructor.name} Audio/Video client.`);
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Callback actions to take when the user becomes disconnected from the server.
	 * @return {Promise<void>}
	 */
	async reestablish() {
		if ( !this._connected ) return;
		ui.notifications.warn("WEBRTC.ConnectionLostWarning", {localize: true});
		await this.disconnect();

		// Attempt to reconnect
		while ( this._reconnecting ) {
			await this.connect();
			if ( this._connected ) {
				this._reconnecting = true;
				break;
			}
			await new Promise(resolve => setTimeout(resolve, this._reconnectPeriodMS));
		}
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the local broadcast state.
	 * @private
	 */
	_initialize() {
		const client = this.settings.client;
		const voiceMode = client.voice.mode;

		// Initialize voice detection
		this._initializeUserVoiceDetection(voiceMode);

		// Initialize push-to-talk
		this._initializePushToTalk();

		// Reset the speaking history for the user
		this._resetSpeakingHistory(game.user.id);

		// Set the initial state of outbound audio and video streams
		const isAlways = voiceMode === "always";
		this.client.toggleAudio(isAlways && client.audioSrc && this.canUserShareAudio(game.user.id));
		this.client.toggleVideo(client.videoSrc && this.canUserShareVideo(game.user.id));
		this.broadcast(isAlways);

		// Update the display of connected A/V
		ui.webrtc.render();
	}

	/* -------------------------------------------- */
	/*  Permissions                                 */
	/* -------------------------------------------- */

	/**
	 * A user can broadcast audio if the AV mode is compatible and if they are allowed to broadcast.
	 * @param {string} userId
	 * @return {boolean}
	 */
	canUserBroadcastAudio(userId) {
		if ( [AVSettings.AV_MODES.DISABLED, AVSettings.AV_MODES.VIDEO].includes(this.mode) ) return false;
		const user = this.settings.getUser(userId);
		return user && user.canBroadcastAudio;
	}

	/* -------------------------------------------- */

	/**
	 * A user can share audio if they are allowed to broadcast and if they have not muted themselves or been blocked.
	 * @param {string} userId
	 * @return {boolean}
	 */
	canUserShareAudio(userId) {
		if ( [AVSettings.AV_MODES.DISABLED, AVSettings.AV_MODES.VIDEO].includes(this.mode) ) return false;
		const user = this.settings.getUser(userId);
		return user && user.canBroadcastAudio && !(user.muted || user.blocked);
	}

	/* -------------------------------------------- */

	/**
	 * A user can broadcast video if the AV mode is compatible and if they are allowed to broadcast.
	 * @param {string} userId
	 * @return {boolean}
	 */
	canUserBroadcastVideo(userId) {
		if ( [AVSettings.AV_MODES.DISABLED, AVSettings.AV_MODES.AUDIO].includes(this.mode) ) return false;
		const user = this.settings.getUser(userId);
		return user && user.canBroadcastVideo;
	}

	/* -------------------------------------------- */

	/**
	 * A user can share video if they are allowed to broadcast and if they have not hidden themselves or been blocked.
	 * @param {string} userId
	 * @return {boolean}
	 */
	canUserShareVideo(userId) {
		if ( [AVSettings.AV_MODES.DISABLED, AVSettings.AV_MODES.AUDIO].includes(this.mode) ) return false;
		const user = this.settings.getUser(userId);
		return user && user.canBroadcastVideo && !(user.hidden || user.blocked);
	}

	/* -------------------------------------------- */
	/*  Broadcasting                                */
	/* -------------------------------------------- */

	/**
	 * Trigger a change in the audio broadcasting state when using a push-to-talk workflow.
	 * @param {boolean} intent        The user's intent to broadcast. Whether an actual broadcast occurs will depend
	 *                                on whether or not the user has muted their audio feed.
	 */
	broadcast(intent) {
		this.broadcasting = intent && this.canUserShareAudio(game.user.id);
		this.client.toggleBroadcast(this.broadcasting);
		ui.webrtc.setUserIsSpeaking(game.user.id, this.broadcasting);
	}

	/* -------------------------------------------- */

	/**
	 * Set up audio level listeners to handle voice activation detection workflow.
	 * @param {string} mode           The currently selected voice broadcasting mode
	 * @private
	 */
	_initializeUserVoiceDetection(mode) {

		// Deactivate prior detection
		game.audio.stopLevelReports(game.user.id);
		if ( !["always", "activity"].includes(mode) ) return;

		// Activate voice level detection for always-on and activity-based broadcasting
		const stream = this.client.getMediaStreamForUser(game.user.id);
		const ms = mode === "activity" ? CONFIG.WebRTC.detectSelfVolumeInterval : CONFIG.WebRTC.detectPeerVolumeInterval;
		this.activateVoiceDetection(game.user.id, stream, ms);
	}

	/* -------------------------------------------- */

	/**
	 * Activate voice detection tracking for a userId on a provided MediaStream.
	 * Currently only a MediaStream is supported because MediaStreamTrack processing is not yet supported cross-browser.
	 * @param {string} userId         The Foundry User ID whose voice is being processed
	 * @param {MediaStream} stream    The MediaStream which corresponds to that User
	 * @param {number} [ms]           A number of milliseconds which represents the voice activation volume interval
	 */
	activateVoiceDetection(userId, stream, ms) {
		this.deactivateVoiceDetection(userId);
		if ( !stream || !stream.getAudioTracks().some(t => t.enabled) ) return;
		ms = ms || CONFIG.WebRTC.detectPeerVolumeInterval;
		const handler = this._onAudioLevel.bind(this, userId);
		game.audio.startLevelReports(userId, stream, handler, ms);
	}

	/* -------------------------------------------- */

	/**
	 * Actions which the orchestration layer should take when a peer user disconnects from the audio/video service.
	 * @param {string} userId   The id of the disconnecting User
	 */
	deactivateVoiceDetection(userId) {
		this._resetSpeakingHistory(userId);
		game.audio.stopLevelReports(userId);
	}

	/* -------------------------------------------- */

	/**
	 * Periodic notification of user audio level
	 *
	 * This function uses the audio level (in dB) of each stream it's listening to to determine if a user
	 * is speaking or not and notifies the UI of such changes.
	 *
	 * The User is considered speaking if they are above the decibel threshold in any of the history values.
	 * This marks them as speaking as soon as they have a high enough volume, and marks them as not speaking only after
	 * they drop below the threshold in all histories (last 4 volumes = for 200 ms).
	 *
	 * There can be more optimal ways to do this and which uses whether the user was already considered speaking before
	 * or not, in order to eliminate short bursts of audio (coughing for example).
	 *
	 * @param {string} userId          The user ID of the user whose audio levels are being reported
	 * @param {number} dbLevel         The audio level in decibels of the user within the last 50ms
	 * @private
	 */
	_onAudioLevel(userId, dbLevel) {
		const voice = this.settings.client.voice;

		// Get speaking data for the user
		if ( !this._speakingData.hasOwnProperty(userId) ) {
			this._speakingData[userId] = { speaking: false, volumeHistories: [] };
		}
		const speakingData = this._speakingData[userId];

		// Add the current volume to the history of the user and keep the list below the history length config.
		if (speakingData.volumeHistories.push(dbLevel) > CONFIG.WebRTC.speakingHistoryLength) {
			speakingData.volumeHistories.shift();
		}

		// Count the number and total decibels of speaking events which exceed an activity threshold
		const [count, max, total] = speakingData.volumeHistories.reduce((totals, vol) => {
			if ( vol >= voice.activityThreshold )  {
				totals[0] += 1;
				totals[1] = Math.min(totals[1], vol);
				totals[2] += vol;
			}
			return totals;
		}, [0, 0, 0]);

		// Determine whether a change in the speaking state has occurred
		const wasSpeaking = speakingData.speaking;
		const isSpeaking = wasSpeaking ? (count > 0) : (count >= CONFIG.WebRTC.speakingThresholdEvents);
		speakingData.speaking = isSpeaking;
		if ( isSpeaking === wasSpeaking ) return;

		// Enable or disable voice activity based broadcasting
		const isSelf = userId === game.user.id;
		if ( isSelf ) {
			if ( voice.mode === "activity" ) return this.broadcast(isSpeaking);
		}
		else ui.webrtc.setUserIsSpeaking(userId, isSpeaking);
	}

	/* -------------------------------------------- */
	/*  Push-To-Talk Controls                       */
	/* -------------------------------------------- */

	/**
	 * Set up interactivity and handling of push-to-talk broadcasting workflow.
	 * @private
	 */
	_initializePushToTalk() {

		// Deactivate prior broadcasting
		for (let [event, handler] of Object.entries(this._pttHandlers)) {
			window.removeEventListener(event, handler, {capture: true});
		}

		// Configure handling
		const start = this._onPTTStart.bind(this);
		const end = this._onPTTEnd.bind(this);
		this._pttHandlers = this.settings.client.voice.pttMouse ? {
			mousedown: start,
			mouseup: end
		} : {
			keydown: start,
			keyup: end
		};

		// Activate push-to-talk handlers
		for (let [event, handler] of Object.entries(this._pttHandlers)) {
			window.addEventListener(event, handler, {capture: true});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Resets the speaking history of a user
	 * If the user was considered speaking, then mark them as not speaking
	 * @param {string} userId         The ID of the user
	 */
	_resetSpeakingHistory(userId) {
		if ( ui.webrtc ) ui.webrtc.setUserIsSpeaking(userId, false);
		delete this._speakingData[userId];
	}

	/* -------------------------------------------- */

	/**
	 * Handle activation of a push-to-talk key or button.
	 * @param {KeyboardEvent|MouseEvent} event   The original keydown event
	 */
	_onPTTStart(event) {
		const voice = this.settings.client.voice;
		const pressed = voice.pttMouse ? event.button : event.keyCode;
		if (pressed !== voice.pttKey) return;
		event.preventDefault();
		if ( event.repeat ) return;

		// Case 1: Push-to-Talk (begin broadcasting immediately)
		if ( voice.mode === "ptt" ) {
			if (this._pttMuteTimeout > 0) clearTimeout(this._pttMuteTimeout);
			this._pttMuteTimeout = 0;
			this.broadcast(true);
		}

		// Case 2: Push-to-Mute (disable broadcasting on a timeout)
		else this._pttMuteTimeout = setTimeout(() => this.broadcast(false), voice.pttDelay);
	}

	/* -------------------------------------------- */

	/**
	 * Handle deactivation of a push-to-talk key or button.
	 * @param {KeyboardEvent|MouseEvent} event   The original keyup event
	 */
	_onPTTEnd(event) {
		const voice = this.settings.client.voice;
		const pressed = voice.pttMouse ? event.button : event.keyCode;
		if (pressed !== voice.pttKey) return;
		event.preventDefault();
		if ( event.repeat ) return;

		// Case 1: Push-to-Talk (disable broadcasting on a timeout)
		if ( voice.mode === "ptt" ) {
			this._pttMuteTimeout = setTimeout(() => this.broadcast(false), voice.pttDelay);
		}

		// Case 2: Push-to-Mute (re-enable broadcasting immediately)
		else {
			if (this._pttMuteTimeout > 0) clearTimeout(this._pttMuteTimeout);
			this._pttMuteTimeout = 0;
			this.broadcast(true);
		}
	}

	/* -------------------------------------------- */
	/*  User Interface Controls                     */
	/* -------------------------------------------- */

	render() {
		return ui.webrtc.render();
	}

	/* -------------------------------------------- */

	/**
	 * Render the audio/video streams to the CameraViews UI.
	 * Assign each connected user to the correct video frame element.
	 */
	onRender() {
		const users = this.client.getConnectedUsers();
		for ( let u of users ) {
			const videoElement = ui.webrtc.getUserVideoElement(u);
			if ( !videoElement ) continue;
			const isSpeaking = this._speakingData?.[u]?.speaking || false;
			this.client.setUserVideo(u, videoElement);
			ui.webrtc.setUserIsSpeaking(u, isSpeaking);
		}
	}

	/* -------------------------------------------- */
	/*  Events Handlers and Callbacks               */
	/* -------------------------------------------- */

	/**
	 * Respond to changes which occur to AV Settings.
	 * Changes are handled in descending order of impact.
	 * @param {Object} changed       The object of changed AV settings
	 */
	onSettingsChanged(changed) {
		const keys = Object.keys(flattenObject(changed));

		// Change the server mode (full reload)
		if (keys.includes('world.mode')) return window.location.reload();

		// Change the server configuration (full AV re-connection)
		if (["world.server", "world.turn"].some(k => hasProperty(changed, k))) return this.connect();

		// Change audio and video visibility at a user level
		const users = getProperty(changed, "client.users") || {};
		for ( let [userId, user] of Object.entries(users) ) {
			const changed = new Set(Object.keys(user));
			if ( ["hidden", "blocked"].some(k => changed.has(k)) ) {
				this.client.toggleVideo(this.canUserShareVideo(userId));
			}
			if ( ["muted", "blocked"].some(k => changed.has(k)) ) {
				this.client.toggleAudio(this.canUserShareAudio(userId));
			}
		}

		// Call client specific setting handling
		this.client.onSettingsChanged(changed);
	}

	/* -------------------------------------------- */

	debug(message) {
		if ( this.settings.debug ) console.debug(message);
	}
}

class AVSettings {
	constructor() {
		this.initialize();
		this._set = debounce((key, value) => game.settings.set("core", key, value), 100);
		this._change = debounce(this._onSettingsChanged.bind(this), 100);
	}

	/**
	 * WebRTC Mode, Disabled, Audio only, Video only, Audio & Video
	 * @type {Object}
	 */
	static AV_MODES = {
		DISABLED: 0,
		AUDIO: 1,
		VIDEO: 2,
		AUDIO_VIDEO: 3
	};

	static VOICE_MODES = {
		ALWAYS: "always",
		ACTIVITY: "activity",
		PTT: "ptt"
	};

	static DEFAULT_CLIENT_SETTINGS = {
		videoSrc: "default",
		audioSrc: "default",
		audioSink: "default",
		dockSize: "medium",
		dockPosition: "bottom",
		hidePlayerList: false,
		muteAll: false,
		voice: {
			mode: AVSettings.VOICE_MODES.PTT,
			pttKey: 192, // Tilde
			pttName: "`",
			pttMouse: false,
			pttDelay: 100,
			activityThreshold: -45
		},
		users: {}
	};

	static DEFAULT_WORLD_SETTINGS = {
		mode: AVSettings.AV_MODES.DISABLED,
		server: {
			type: "FVTT",
			url: "",
			room: "",
			username: "",
			password: ""
		},
		turn: {
			type: "server",
			url: "",
			username: "",
			password: "",
		}
	};

	static DEFAULT_USER_SETTINGS = {
		popout: false,
		x: 100,
		y: 100,
		z: 0,
		width: 320,
		volume: 1.0,
		muted: false,
		hidden: false,
		blocked: false
	};

	/* -------------------------------------------- */

	initialize() {
		this.client = game.settings.get("core", "rtcClientSettings");
		this.world = game.settings.get("core", "rtcWorldSettings");
		this._original = duplicate({client: this.client, world: this.world});
	}

	/* -------------------------------------------- */

	changed(settings) {
		return this._change(settings);
	}

	/* -------------------------------------------- */

	get(scope, setting) {
		return getProperty(this[scope], setting);
	}

	/* -------------------------------------------- */

	getUser(userId) {
		const user = game.users.get(userId);
		if ( !user ) return null;
		return this._getUserSettings(user);
	}

	/* -------------------------------------------- */

	set(scope, setting, value) {
		setProperty(this[scope], setting, value);
		this._set(`rtc${scope.titleCase()}Settings`, this[scope]);
	}

	/* -------------------------------------------- */

	/**
	 * Return a mapping of AV settings for each game User.
	 * @type {object}
	 */
	get users() {
		const users = {};
		for ( let u of game.users ) {
			users[u.id] = this._getUserSettings(u);
		}
		return users;
	}

	/* -------------------------------------------- */

	/**
	 * Prepare a standardized object of user settings data for a single User
	 * @private
	 */
	_getUserSettings(user) {
		const clientSettings = this.client.users[user.id] || {};
		const settings = mergeObject(AVSettings.DEFAULT_USER_SETTINGS, clientSettings, {inplace: false});
		settings.canBroadcastAudio = user.can('BROADCAST_AUDIO');
		settings.canBroadcastVideo = user.can('BROADCAST_VIDEO');
		if ( !user.isSelf ) {
			settings.muted = !settings.canBroadcastAudio;
			settings.hidden = !settings.canBroadcastVideo;
		}
		return settings;
	}

	/* -------------------------------------------- */

	/**
	 * Handle setting changes to either rctClientSettings or rtcWorldSettings.
	 * @private
	 */
	_onSettingsChanged() {
		const original = this._original;
		this.initialize();
		const changed = diffObject(original, this._original);
		game.webrtc.onSettingsChanged(changed);
		Hooks.callAll("rtcSettingsChanged", this, changed);
	}
}

/**
 * An AVClient implementation that uses WebRTC and the EasyRTC library.
 * @extends {AVClient}
 * @param {AVMaster} master           The master orchestration instance
 * @param {AVSettings} settings       The audio/video settings being used
 */
class EasyRTCClient extends AVClient {
	constructor(master, settings) {
		super(master, settings);

		/**
		 * Store the name of the joined EasyRTC room
		 * @type {string|null}
		 * @private
		 */
		this._room = null;

		/**
		 * A mapping of easyRtcId peer ids to Foundry User ids
		 * @type {{string: string}}
		 * @private
		 */
		this._usernameCache = {};

		/**
		 * An array of easyRtcId peers that rejected our call. Avoid continually trying to call the same peer.
		 * @type {object[]}
		 * @private
		 */
		this._callRejections = [];

		// Set some one-time configuration data
		easyrtc.setUsername(game.user.id);
		easyrtc.setAutoInitUserMedia(false);
		easyrtc.setVideoDims(320, 240, undefined);
		easyrtc.enableDebug(CONFIG.debug.av);
	}

	/* -------------------------------------------- */

	/** @override */
	async initialize() {
		easyrtc.setRoomOccupantListener(this._onRoomOccupantsChange.bind(this));
		easyrtc.setOnError(this._onError.bind(this));
		easyrtc.setAcceptChecker(this._answerIncomingCall.bind(this));
		easyrtc.setPeerOpenListener(this._onPeerOpen.bind(this));
		easyrtc.setStreamAcceptor(this._onPeerConnect.bind(this));
		easyrtc.setOnStreamClosed(this._onPeerDisconnect.bind(this));
		easyrtc.setPeerClosedListener(this._onPeerClosed.bind(this));
	}

	/* -------------------------------------------- */

	/** @override */
	async connect() {
		await this.disconnect();  // Disconnect first, just in case
		await this._connectServer(this.settings.world.server);
		await this._initializeLocal(this.settings.client);
		return true;
	}

	/* -------------------------------------------- */

	/** @override */
	async disconnect() {
		if ( !easyrtc.webSocketConnected ) return true;
		await new Promise(resolve => {
			easyrtc.setDisconnectListener(resolve);
			easyrtc.hangupAll();
			easyrtc.disconnect();
		});
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Connect to the WebRTC server and configure ICE/TURN servers
	 * @return {Promise<boolean>}   Was the server connected?
	 * @private
	 */
	async _connectServer({type, room, url, username, password}={}) {
		easyrtc.setDisconnectListener(this._onConnectionLost.bind(this));
		return new Promise(resolve => {

			// Configure custom server
			let host = url;
			let credential = {username, password};
			let socketPath = getRoute("easyrtc");

			// Fall-back to default server
			const isCustom = ( type === "custom" ) && ( url !== '' );
			if ( !isCustom ) {
				host = window.location.origin;
				credential = {sessionId: game.sessionId };
			}

			// Configure EasyRTC socket and credentials
			easyrtc.setSocketUrl(host, {
				path: socketPath,
				reconnectionAttempts: 2,
				timeout: 10000,
				forceNew: true
			});
			easyrtc.setCredential(credential);

			// Choose the room to join
			this._room = isCustom ? room : "default";
			Object.keys(easyrtc.getRoomsJoined()).forEach(easyrtc.leaveRoom);
			easyrtc.joinRoom(this._room, null, null, null);

			// Connect to the server
			const onSuccess = easyRtcId => {
				game.webrtc.debug("EasyRTCClient | Login successful, I am " + easyrtc.cleanId(easyRtcId));
				this._setupCustomTURN();
				resolve(true);
			};
			const onFailure = (errorCode, message) => {
				game.webrtc.debug("EasyRTCClient | Login error: ", errorCode, message);
				console.error(game.i18n.localize("WEBRTC.GenericError") + message);
				if (errorCode !== easyrtc.errCodes.ICECANDIDATE_ERR) this.webrtc.onError(errorText);
				resolve(false);
			};
			easyrtc.connect("FoundryVTT", onSuccess, onFailure);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Setup the custom TURN relay to be used in subsequent calls if there is one configured
	 * If configured, setup custom TURN configuration for future calls. Turn credentials are mandatory in WebRTC.
	 * @private
	 */
	_setupCustomTURN() {
		const {type, url, username, password} = this.settings.world.turn;
		const isCustom = (type === "custom") && !!url && !!username && !!password;
		const config = duplicate(easyrtc.getServerIce());

		// Create a custom TURN configuration, replacing the default server-provided one
		if ( isCustom ) {
			config.iceServers = config.iceServers.filter(ice => !(ice.url || ice.urls[0]).startsWith('turn'));
			config.iceServers.push({
				urls: ["turn:" + url],
				url: "turn:" + url,
				username: username,
				credential: password
			});
		}
		easyrtc.setIceUsedInCalls(config);
	}

	/* -------------------------------------------- */

	/**
	 * Initialize a local media stream
	 * Capture the local audio and video and returns the stream associated with them.
	 *
	 * If @temporary is false (default), then this will initialize the master stream, not the actual
	 * streams being sent to individual users. However, if a master stream was already created, it
	 * will automatically get closed and every individual streams derived from it that are being sent
	 * to connected users will be removed from the calls.
	 * Each established or subsequent calls will receive a copy of the created stream (A/V depending on user permissions)
	 *
	 * If @temporary is true then this only applies to a temporary stream and does not affect
	 * the master stream or any streams in existing calls.
	 * Note that this assumes only one temporary stream can be created at a time.
	 *
	 * @param {string|null} audioSrc       ID of the audio source to capture from or null to disable Audio
	 * @param {string|null} videoSrc       ID of the video source to capture from or null to disable Video
	 * @param {boolean} temporary          Whether to create a temporary stream or the master stream
	 * @return {Promise.MediaStream}       Returns the local stream or `null` if none could be created
	 */
	async _initializeLocal({audioSrc, videoSrc, temporary=false}={}) {
		this._closeLocalStream(temporary);
		return this._openLocalStream(audioSrc, videoSrc, temporary);
	}

	/* -------------------------------------------- */

	/**
	 * Create an open a local stream when initially connecting to the server.
	 * This local stream becomes the "master" stream which tracks your own device inputs.
	 * The master stream is cloned to provide a stream to every connected peer.
	 * @private
	 */
	async _openLocalStream(audioSrc, videoSrc, temporary=false) {

		// Close an already opened stream
		const streamName = temporary ? "temporary" : null;
		this._closeLocalStream(temporary);
		const settings = this.settings.getUser(game.user.id);

		// Configure data channels
		easyrtc.enableDataChannels(false);
		easyrtc.enableAudio(audioSrc != null);
		easyrtc.enableVideo(videoSrc != null);

		// Assign media sources, or return early if none are applied
		if (!audioSrc && !videoSrc) return null;
		easyrtc.setVideoSource(videoSrc);
		easyrtc.setAudioSource(audioSrc);

		// Wrap the initialization in a Promise
		return new Promise(resolve => {

			// Define success handler
			const onSuccess = () => {

				// Get the users own stream
				const stream = easyrtc.getLocalStream(streamName);
				if (temporary) return resolve(stream);

				// Set initial camera and microphone state
				easyrtc.enableCamera(!settings.hidden, streamName);
				easyrtc.enableMicrophone(!settings.muted, streamName);

				// Define preferred media constraints
				easyrtc._presetMediaConstraints = this._getStreamMediaConstraints(videoSrc, audioSrc);

				// Add the stream to each peer
				const peers = easyrtc.getRoomOccupantsAsArray(this._room) || [];
				for (let peer of peers) {
					if (easyrtc.getConnectStatus(peer) === easyrtc.NOT_CONNECTED) continue;
					let peerStream = this._createStreamForPeer(peer);
					if (peerStream) {
						easyrtc.addStreamToCall(peer, peerStream.streamName, null);
						// addStreamToCall should cause a renegotiation but it won't happen if we just closed our stream which
						// means we removed it from the call then we add a similar one to it right away. The problem is that the
						// other side risks not seeing the change in the stream if that happens so we force a renegotiation with
						// the other peer.
						easyrtc.renegotiate(peer);
					}
				}
				return resolve(stream);
			};

			// Define failure handler
			const onFailure = (errorCode, errorText) => {
				game.webrtc.debug("Error capturing media ", errorCode, errorText);
				if (temporary) return resolve(null);
				else ui.notifications.warn("WEBRTC.DeviceUnavailableWarning", {localize: true, permanent: true});

				// Attempt to renegotiate with failed peers
				const peers = easyrtc.getRoomOccupantsAsArray(this._room) || [];
				for (let peer of peers) {
					if (easyrtc.getConnectStatus(peer) !== easyrtc.NOT_CONNECTED) easyrtc.renegotiate(peer);
				}
				return resolve(null);
			};

			// Initialize the media source with an appropriate stream name
			easyrtc.initMediaSource(onSuccess, onFailure, streamName);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Close the local stream
	 * @private
	 */
	_closeLocalStream(temporary=false) {

		// Close the temporary master stream
		const streamName = temporary ? "temporary" : null;
		easyrtc.closeLocalStream(streamName);
		if ( temporary ) return;

		// Close other local media streams
		const streamNames = easyrtc.getLocalMediaIds();
		for (let streamName of streamNames) {
			if (streamName === "temporary")  continue;
			easyrtc.closeLocalStream(streamName);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Define media constraints to control the resolution and devices used.
	 * We need to set our own constraints so we can specify a min/max range of resolutions.
	 * @return {{video: *, audio: *}}
	 * @private
	 */
	_getStreamMediaConstraints(videoSrc, audioSrc) {
		return {
			video: !!videoSrc ? {
				aspectRatio: 4/3,
				width: {
						ideal: 320,
						max: 640,
						min: 160
				},
				height: {
						ideal: 240,
						max: 480,
						min: 120
				},
				frameRate: {
						ideal: 15,
						max: 30
				},
				deviceId: videoSrc
			} : false,
			audio: !!audioSrc ? {
				deviceId: audioSrc
			} : false
		};
	}

	/* -------------------------------------------- */

	/**
	 * Call a peer and establish a connection with them
	 * @param {string} easyRtcId      The peer ID to call
	 * @return {Promise.<boolean>}    Returns false if no call was made or true if the call is successful.
	 *                                raises an Exception in case of failure to establish the call.
	 * @private
	 */
	async _performCall(easyRtcId) {
		return new Promise((resolve, reject) => {

			// Determine whether to make the call (if it has not already been rejected)
			let makeCall = !this._callRejections.includes(easyRtcId) &&
				(easyrtc.getConnectStatus(easyRtcId) === easyrtc.NOT_CONNECTED);

			// Get the peers to call
			const userId = easyrtc.idToName(easyRtcId);
			const allPeers = makeCall ? easyrtc.usernameToIds(userId, null) : [];

			// Make sure we don't already have an existing connection with the same user
			for (let peer of allPeers) {
				if (easyrtc.getConnectStatus(peer.easyrtcid) !== easyrtc.NOT_CONNECTED) {
					game.webrtc.debug(`EasyRTCClient | Not making the call to ${easyRtcId}, already in a call with same user.`);
					makeCall = false;
					break;
				}
			}
			if (!makeCall) return resolve(false);

			// Important: create a clone of the local stream to send to the peer
			const stream = this._createStreamForPeer(easyrtc.idToName(easyRtcId));

			// Define success, failure, and acceptance callbacks
			const onSuccess = () => {
				game.webrtc.debug("EasyRTCClient | Successfully established call ", arguments);
				resolve(true);
			};
			const onFailure = (errorCode, errorText) => {
				game.webrtc.debug("EasyRTCClient | Failed to establish call ", errorCode, errorText);
				if (stream) easyrtc.closeLocalStream(stream.streamName);
				reject(errorText);
			};
			const onAccept = (accepted) => {
				game.webrtc.debug("EasyRTCClient | The call was ", accepted ? "accepted" : "rejected", arguments);
				if (!accepted) this._callRejections.push(easyRtcId)
			};

			// Perform the call
			game.webrtc.debug("EasyRTCClient | Calling user ", easyRtcId);
			easyrtc.call(easyRtcId, onSuccess, onFailure, onAccept, stream ? [stream.streamName] : null);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Create a MediaStream to be sent to a specific peer.
	 * This stream should control whether outbound video and audio is transmitted.
	 * Create the stream as a clone of the current master stream for configuration on a peer-to-peer basis.
	 * @private
	 */
	_createStreamForPeer(peer) {
		const master = easyrtc.getLocalStream();
		if ( !master ) return null;

		// Use the user's ID as the stream name to create the local named stream
		const userId = this._usernameCache[peer] || easyrtc.idToName(peer);
		const createTracks = {
			audioTracks: master.getAudioTracks(),
			videoTracks: master.getVideoTracks()
		};
		const streamName = userId;
		easyrtc.closeLocalStream(streamName);

		// Close the stream in case it's been opened already.
		game.webrtc.debug("EasyRTCClient | Creating new stream for user ", userId);
		const stream = easyrtc.buildLocalMediaStream(streamName, createTracks.audioTracks, createTracks.videoTracks);

		// Set the initial audio broadcast state
		easyrtc.enableMicrophone(this.master.broadcasting, streamName);
		return stream;
	}

	/* -------------------------------------------- */
	/*  Device Discovery                            */
	/* -------------------------------------------- */

	/** @override */
	async getAudioSinks() {
		return new Promise(resolve => {
			try {
				easyrtc.getAudioSinkList(list => resolve(this._deviceInfoToObject(list)));
			} catch (err) {
				resolve({})
			}
		});
	}

	/* -------------------------------------------- */

	/** @override */
	async getAudioSources() {
		return new Promise(resolve => {
			try {
				easyrtc.getAudioSourceList(list => resolve(this._deviceInfoToObject(list)));
			} catch (err) {
				resolve({})
			}
		});
	}

	/* -------------------------------------------- */

	/** @override */
	async getVideoSources() {
		return new Promise(resolve => {
			try {
				easyrtc.getVideoSourceList(list => resolve(this._deviceInfoToObject(list)));
			} catch (err) {
				resolve({})
			}
		});
	}

	/* -------------------------------------------- */

	/**
	 * Transform the device info array from easyrtc into an object with {id: label} keys
	 * @param {Object[]} list    The list of devices
	 * @private
	 */
	_deviceInfoToObject(list) {
		return list.reduce((obj, device) => {
			obj[device.id] = device.label || game.i18n.localize("WEBRTC.UnknownDevice");
			return obj;
		}, {});
	}

	/* -------------------------------------------- */

	/**
	 * Obtain the EasyRTC user ID of a user based on their Foundry VTT user ID
	 * @param {string} userId     The ID of the user
	 * @return {string|null}      The EasyRtcId of the peer
	 */
	_userIdToEasyRtcId(userId) {
		const ids = easyrtc.usernameToIds(userId, null);
		if (ids && ids.length > 0)
			return ids[0].easyrtcid;
		return null;
	}

	/* -------------------------------------------- */
	/*  Track Manipulation                          */
	/* -------------------------------------------- */

	/** @override */
	getConnectedUsers() {
		const connected = [];

		// The current user
		if ( easyrtc.getLocalStream() ) connected.push(game.user.id);

		// Connected peers
		for ( let [easyRtcId, userId] of Object.entries(this._usernameCache ) ) {
			const peer = easyrtc.getPeerConnectionByUserId(easyRtcId);
			if ( !peer ) continue;
			else connected.push(userId);
		}
		return connected;
	}

	/* -------------------------------------------- */

	/**
	 * Get MediaStream instances for every connected peer in the room.
	 * @return {object[]}   An array of stream information for each peer
	 */
	getConnectedStreams() {
		const peers = easyrtc.getRoomOccupantsAsArray(this._room) || [];
		return peers.reduce((streams, peer) => {
			const pc = easyrtc.getPeerConnectionByUserId(peer);
			if ( !pc ) return streams;
			const stream = {
				id: easyrtc.idToName(peer),
				connection: pc,
				local: null,
				remote: null
			};
			const remote = pc.getRemoteStreams();
			if ( remote?.length ) stream.remote = remote[0];
			const local = pc.getLocalStreams();
			if ( local?.length ) stream.local = local[0];
			streams.push(stream);
			return streams;
		}, []);
	}

	/* -------------------------------------------- */

	/** @override */
	getMediaStreamForUser(userId) {
		if (userId === game.userId) return easyrtc.getLocalStream();
		const easyRtcId = this._userIdToEasyRtcId(userId);
		const pc = easyrtc.getPeerConnectionByUserId(easyRtcId);
		if ( !pc ) return null;
		const remote = pc.getRemoteStreams();
		return remote?.length ? remote[0] : null;
	}

	/* -------------------------------------------- */

	/** @override */
	isAudioEnabled() {
		const stream = easyrtc.getLocalStream();
		return stream && stream.getAudioTracks().some(t => t.enabled);
	}

	/* -------------------------------------------- */

	/** @override */
	isVideoEnabled() {
		const stream = easyrtc.getLocalStream();
		return stream && stream.getVideoTracks().some(t => t.enabled);
	}

	/* -------------------------------------------- */

	/**
	 * Handle a request to enable or disable the outbound audio feed for the current game user.
	 * @param {boolean} enable        Whether the outbound audio track should be enabled (true) or disabled (false)
	 */
	toggleAudio(enable) {
		const stream = easyrtc.getLocalStream();
		if ( !stream ) return;
		for ( let s of this.getConnectedStreams() ) {   // Toggle outbound streams to connected peers
			this.enableStreamAudio(s.local, enable);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Set whether the outbound audio feed for the current game user is actively broadcasting.
	 * This can only be true if audio is enabled, but may be false if using push-to-talk or voice activation modes.
	 * @param {boolean} broadcast      Whether outbound audio should be sent to connected peers or not?
	 */
	toggleBroadcast(broadcast) {
		const stream = easyrtc.getLocalStream();
		if ( !stream ) return;
		if ( !this.isAudioEnabled() ) broadcast = false;
		for ( let s of this.getConnectedStreams() ) {
			easyrtc.enableMicrophone(broadcast, s.id);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle a request to enable or disable the outbound video feed for the current game user.
	 * @param {boolean} enable        Whether the outbound audio track should be enabled (true) or disabled (false)
	 */
	toggleVideo(enable) {
		const stream = easyrtc.getLocalStream();
		if ( !stream ) return;
		this.enableStreamVideo(stream, enable);       // Toggle your own local stream
		for ( let s of this.getConnectedStreams() ) {   // Also toggle outbound streams to connected peers
			this.enableStreamVideo(s.local, enable);
		}
	}

	/* -------------------------------------------- */

	/** @override */
	async setUserVideo(userId, videoElement) {
		const stream = this.getMediaStreamForUser(userId);
		easyrtc.setVideoObjectSrc(videoElement, stream);
		easyrtc.muteVideoObject(videoElement, game.user.id === userId);
		easyrtc.setAudioOutput(videoElement, this.settings.client.audioSink);
		const event = new CustomEvent('webrtcVideoSet', { detail: { stream, userId } });
		videoElement.dispatchEvent(event);
	}

	/* -------------------------------------------- */

	/**
	 * Enable or disable the audio tracks in a stream
	 *
	 * Disabling a track represents what a typical user would consider muting it.
	 * We use the term 'enable' here instead of 'mute' to match the MediaStreamTrack
	 * field name and to avoid confusion with the 'muted' read-only field of the MediaStreamTrack
	 * as well as the video element's `muted` field which only stops playing the audio.
	 * Muting by definition stops rendering any of the data, while a disabled track in this case
	 * is still rendering its data, but is simply generating disabled content (silence and black frames)
	 * See https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack/enabled
	 *
	 * @param {MediaStream} stream    The stream to modify
	 * @param {boolean} enable        (optional) Whether to enable or disable the tracks
	 */
	enableStreamAudio(stream, enable=true) {
		if (stream) this._enableMediaTracks(stream.getAudioTracks(), enable);
	}

	/* -------------------------------------------- */

	/**
	 * Enable or disable the video tracks in a stream
	 *
	 * Disabling a track represents what a typical user would consider muting it. We use the term 'enable' here instead
	 * of 'mute' to match the MediaStreamTrack field name and to avoid confusion with the 'muted' read-only field of the
	 * MediaStreamTrack as well as the video element's `muted` field which only stops playing the audio.
	 *
	 * Muting by definition stops rendering any of the data, while a disabled track in this case is still rendering its
	 * data, but is simply generating disabled content (silence and black frames).
	 *
	 * See https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack/enabled
	 *
	 * @param {MediaStream} stream    The stream to modify
	 * @param {boolean} enable        (optional) Whether to enable or disable the tracks
	 */
	enableStreamVideo(stream, enable = true) {
		if (stream) this._enableMediaTracks(stream.getVideoTracks(), enable);
	}

	/* -------------------------------------------- */

	/**
	 * Enables or disables media tracks
	 * See https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack/enabled
	 * @param {object[]} tracks       The tracks to enable/disable
	 * @param {boolean} enable        Whether to enable or disable the tracks
	 */
	_enableMediaTracks(tracks, enable) {
		for (let track of tracks || []) {
			track.enabled = enable;
		}
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/**
	 * Callback used to check if an incoming call should be accepted or not
	 * @param {string} easyRtcId     The peer ID of the caller
	 * @param {Function} acceptor    Function to call with whether or not to accept the call and the media streams to use
	 * @private
	 */
	_answerIncomingCall(easyRtcId , acceptor) {
		const userId = easyrtc.idToName(easyRtcId);
		const user = game.users.get(userId);
		const settings = this.settings.getUser(userId);
		let accept = (user !== undefined) && !settings.blocked;

		// Verify that we don't already have an existing call with someone else using the same user ID
		const allPeers = accept ? easyrtc.usernameToIds(userId, null) : [];
		if (allPeers.some(peer => easyrtc.getConnectStatus(peer.easyrtcid) !== easyrtc.NOT_CONNECTED)) {
			accept = false;
		}

		// Create the stream for an accepted call
		const stream = accept ? this._createStreamForPeer(easyrtc.idToName(easyRtcId)) : null;

		// Call any provided callback function
		game.webrtc.debug("EasyRTCClient |", (accept ? "Accepting" : "Rejecting") + " call from ", arguments);
		acceptor(accept, stream ? [stream.streamName] : null);
	}

	/* -------------------------------------------- */

	/**
	 * Called when the connection to the signaling server is lost (unintentionally).
	 * This handles the case of when connectivity is interrupted non-deliberately.
	 * @private
	 */
	_onConnectionLost() {
		return this.master.reestablish();
	}

	/* -------------------------------------------- */

	/**
	 * Called when an error occurs
	 * @private
	 */
	_onError({errorCode, errorText}) {
		console.error(`EasyRTCClient | `, ...arguments);
	}

	/* -------------------------------------------- */

	/**
	 * Called whenever there is a change in the list of occupants in a room.
	 * It can also be called if a peer's state changes, such as when a call is established or ended.
	 * For each other peer in the room, record their user ID and establish a call with them.
	 * Record the username associated with each peer.
	 *
	 * Important: We need to make sure that only user initiates a call, instead of both trying to call each other.
	 * Resolve this by having the alphabetically greater ID call the other peer.
	 *
	 * @param {string} roomName       The room name where occupants have changed
	 * @param {object[]} otherPeople  An array of other peers in the room
	 * @param {object} myInfo         My own connection info
	 * @private
	 */
	async _onRoomOccupantsChange(roomName, otherPeople, myInfo) {
		game.webrtc.debug("EasyRTCClient | Room occupancy changed : ", otherPeople, myInfo);
		this._usernameCache[myInfo.easyrtcid] = game.user.id;
		const users = this.settings.users;
		for ( let easyRtcId of Object.keys(otherPeople) ) {

			// Verify the Foundry user ID
			const userId = easyrtc.idToName(easyRtcId);
			const user = game.users.get(userId);
			if ( !user ) continue;
			this._usernameCache[easyRtcId] = userId;

			// Create a call for any non-blocked users other than ourselves
			if ( (userId.localeCompare(game.user.id) === 1) && !users[userId].blocked ) {
				this._performCall(easyRtcId).catch(()=>{});
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Called when the connection with a peer has been established
	 * @private
	 */
	_onPeerOpen(easyRtcId) {
		let userId = this._usernameCache[easyRtcId] || easyrtc.idToName(easyRtcId);
		game.webrtc.debug(`EasyRTCClient | Connection established with peer ${userId}`);
	}

	/* -------------------------------------------- */

	/**
	 * Called when the connection with a peer has been lost and the ICE machine was unable to re-establish it.
	 * In case of irrecoverable connection loss with the peer, hanging up the call will cause a roomOccupantListener
	 * signal to be sent and we will automatically try to reconnect to the user.
	 * First make sure that they are still in the room so we don't try to hangup with an easyRtcId that is invalid.
	 * @private
	 */
	_onPeerClosed(easyRtcId) {
		let userId = this._usernameCache[easyRtcId] || easyrtc.idToName(easyRtcId);
		game.webrtc.debug(`EasyRTCClient | Connection lost with peer ${userId}`);
		if ( (easyrtc.getRoomOccupantsAsArray(this._room) || []).includes(easyRtcId) )
			easyrtc.hangup(easyRtcId);
	}

	/* -------------------------------------------- */

	/**
	 * Called when a remote stream is added to an existing call
	 * @private
	 */
	_onPeerConnect(easyRtcId, stream) {
		const userId = this._usernameCache[easyRtcId] || easyrtc.idToName(easyRtcId);
		game.webrtc.debug(`EasyRTCClient | Stream opened from ${easyRtcId} for user ${userId}`);

		// Remove tracks from the stream which the user does not have permission to be sharing
		const user = this.settings.getUser(userId);
		if ( !user.canBroadcastAudio ) stream.getAudioTracks().forEach(t => stream.removeTrack(t));
		if ( !user.canBroadcastVideo ) stream.getVideoTracks().forEach(t => stream.removeTrack(t));

		// Disable tracks based on the user's broadcast state
		if ( user.muted ) this.enableStreamAudio(stream, false);
		if ( user.hidden ) this.enableStreamVideo(stream, false);

		// Activate voice detection for the audio channel
		this.master.activateVoiceDetection(userId, stream);

		// Update the video element in the Camera Views UI
		this.master.render();
	}

	/* -------------------------------------------- */

	/**
	 * Called when a remote stream is removed from an existing call
	 * @private
	 */
	_onPeerDisconnect(easyRtcId, stream, streamName) {
		const userId = this._usernameCache[easyRtcId] || easyrtc.idToName(easyRtcId);
		game.webrtc.debug(`EasyRTCClient | Stream closed from ${easyRtcId} for user ${userId}`);
		this.master.deactivateVoiceDetection(userId);
	}

	/* -------------------------------------------- */
	/*  DEPRECATED OR NEEDS REFACTOR                */
	/* -------------------------------------------- */

	getStreamForUser(userId) {
		console.warn("You are calling getStreamForUser() which is DEPRECATED in favor of getMediaStreamForUser()");
		return this.getMediaStreamForUser(userId)
	}
}
/**
 * Runtime configuration settings for Foundry VTT which exposes a large number of variables which determine how
 * aspects of the software behaves.
 *
 * Unlike the CONST analog which is frozen and immutable, the CONFIG object may be updated during the course of a
 * session or modified by system and module developers to adjust how the application behaves.
 *
 * @type {Object}
 */
const CONFIG = window.CONFIG = {

	/**
	 * Configure debugging flags to display additional information
	 */
	debug: {
		dice: false,
		documents: false,
		fog: false,
		hooks: false,
		sight: false,
		sightRays: false,
		av: false,
		avclient: false,
		mouseInteraction: false,
		time: false
	},

	/**
	 * Configure the DatabaseBackend used to perform Document operations
	 * @type {ClientDatabaseBackend}
	 */
	DatabaseBackend: new ClientDatabaseBackend(),

	/**
	 * Configuration for the Actor document
	 */
	Actor: {
		documentClass: Actor,
		collection: Actors,
		sheetClasses: {},
		sidebarIcon: "fas fa-user",
		typeLabels: {}
	},

	/**
	 * Configuration for the ChatMessage document
	 */
	ChatMessage: {
		documentClass: ChatMessage,
		collection: Messages,
		template: "templates/sidebar/chat-message.html",
		sidebarIcon: "fas fa-comments",
		batchSize: 100
	},

	/**
	 * Configuration for the Combat document
	 */
	Combat: {
		documentClass: Combat,
		collection: CombatEncounters,
		defeatedStatusId: "dead",
		sidebarIcon: "fas fa-fist-raised",
		initiative: {
			formula: null,
			decimals: 2
		}
	},

	/**
	 * Configuration for dice rolling behaviors in the Foundry VTT client
	 * @type {Object}
	 */
	Dice: {
		types: [Die, FateDie],
		rollModes: Object.entries(CONST.DICE_ROLL_MODES).reduce((obj, e) => {
			let [k, v] = e;
			obj[v] = `CHAT.Roll${k.titleCase()}`;
			return obj;
		}, {}),
		rolls: [Roll],
		termTypes: {DiceTerm, MathTerm, NumericTerm, OperatorTerm, ParentheticalTerm, PoolTerm, StringTerm},
		terms: {
			"c": Coin,
			"d": Die,
			"f": FateDie
		},
		randomUniform: MersenneTwister.random
	},

	/**
	 * Configuration for the FogExploration document
	 */
	FogExploration: {
		documentClass: FogExploration,
		collection: FogExplorations
	},

	/**
	 * Configuration for the Folder document
	 */
	Folder: {
		documentClass: Folder,
		collection: Folders,
		sheetClass: FolderConfig
	},

	/**
	 * Configuration for Item document
	 */
	Item: {
		documentClass: Item,
		collection: Items,
		sheetClasses: {},
		sidebarIcon: "fas fa-suitcase",
		typeLabels: {}
	},

	/**
	 * Configuration for the JournalEntry document
	 */
	JournalEntry: {
		documentClass: JournalEntry,
		collection: Journal,
		sheetClass: JournalSheet,
		noteIcons: {
			"Anchor": "icons/svg/anchor.svg",
			"Barrel": "icons/svg/barrel.svg",
			"Book": "icons/svg/book.svg",
			"Bridge": "icons/svg/bridge.svg",
			"Cave": "icons/svg/cave.svg",
			"Castle": "icons/svg/castle.svg",
			"Chest": "icons/svg/chest.svg",
			"City": "icons/svg/city.svg",
			"Coins": "icons/svg/coins.svg",
			"Fire": "icons/svg/fire.svg",
			"Hanging Sign": "icons/svg/hanging-sign.svg",
			"House": "icons/svg/house.svg",
			"Mountain": "icons/svg/mountain.svg",
			"Oak Tree": "icons/svg/oak.svg",
			"Obelisk": "icons/svg/obelisk.svg",
			"Pawprint": "icons/svg/pawprint.svg",
			"Ruins": "icons/svg/ruins.svg",
			"Tankard": "icons/svg/tankard.svg",
			"Temple": "icons/svg/temple.svg",
			"Tower": "icons/svg/tower.svg",
			"Trap": "icons/svg/trap.svg",
			"Skull": "icons/svg/skull.svg",
			"Statue": "icons/svg/statue.svg",
			"Sword": "icons/svg/sword.svg",
			"Village": "icons/svg/village.svg",
			"Waterfall": "icons/svg/waterfall.svg",
			"Windmill": "icons/svg/windmill.svg"
		},
		sidebarIcon: "fas fa-book-open"
	},

	/**
	 * Configuration for the Macro document
	 */
	Macro: {
		documentClass: Macro,
		collection: Macros,
		sheetClass: MacroConfig,
		sidebarIcon: "fas fa-terminal"
	},

	/**
	 * Configuration for the Playlist document
	 */
	Playlist: {
		documentClass: Playlist,
		collection: Playlists,
		sheetClass: PlaylistConfig,
		sidebarIcon: "fas fa-music",
		autoPreloadSeconds: 20
	},

	/**
	 * Configuration for RollTable random draws
	 */
	RollTable: {
		documentClass: RollTable,
		collection: RollTables,
		sheetClass: RollTableConfig,
		sidebarIcon: "fas fa-th-list",
		resultIcon: "icons/svg/d20-black.svg",
		resultTemplate: "templates/dice/table-result.html"
	},

	/**
	 * Configuration for the Scene document
	 */
	Scene: {
		documentClass: Scene,
		collection: Scenes,
		sheetClass: SceneConfig,
		sidebarIcon: "fas fa-map"
	},

	Setting: {
		documentClass: Setting,
		collection: WorldSettings,
	},

	/**
	 * Configuration for the User document
	 */
	User: {
		documentClass: User,
		collection: Users,
		sheetClass: UserConfig,
		permissions: Users.permissions
	},

	/* -------------------------------------------- */
	/*  Canvas                                      */
	/* -------------------------------------------- */

	/**
	 * Configuration settings for the Canvas and its contained layers and objects
	 * @type {Object}
	 */
	Canvas: {
		blurStrength: 8,
		darknessColor: 0x242448,
		darknessLightPenalty: 0.4,
		daylightColor: 0xEEEEEE,
		dispositionColors: {
			HOSTILE: 0xE72124,
			NEUTRAL: 0xF1D836,
			FRIENDLY: 0x43DFDF,
			INACTIVE: 0x555555,
			PARTY: 0x33BC4E,
			CONTROLLED: 0xFF9829
		},
		exploredColor: 0x7f7f7f,
		unexploredColor: 0x000000,
		layers: {
			background: BackgroundLayer,  // 0
			drawings: DrawingsLayer,      // 20
			grid: GridLayer,              // 30
			walls: WallsLayer,            // 40
			templates: TemplateLayer,     // 50
			notes: NotesLayer,            // 60
			tokens: TokenLayer,           // 100
			foreground: ForegroundLayer,  // 200
			sounds: SoundsLayer,          // 300
			lighting: LightingLayer,      // 300
			sight: SightLayer,            // 400
			effects: EffectsLayer,        // 500
			controls: ControlsLayer       // 1000
		},
		lightLevels: {
			dark: 0,
			dim: 0.5,
			bright: 1.0
		},
		normalLightColor: 0xb86200,
		maxZoom: 3.0,
		objectBorderThickness: 4,
		lightAnimations: {
			"torch": {
				label: "LIGHT.AnimationTorch",
				animation: PointSource.prototype.animateTorch,
				illuminationShader: TorchIlluminationShader,
				colorationShader: TorchColorationShader
			},
			"pulse": {
				label: "LIGHT.AnimationPulse",
				animation: PointSource.prototype.animatePulse,
				illuminationShader: PulseIlluminationShader,
				colorationShader: PulseColorationShader
			},
			"chroma": {
				label: "LIGHT.AnimationChroma",
				animation: PointSource.prototype.animateTime,
				colorationShader: ChromaColorationShader
			},
			"wave": {
				label: "LIGHT.AnimationWave",
				animation: PointSource.prototype.animateTime,
				illuminationShader: WaveIlluminationShader,
				colorationShader: WaveColorationShader
			},
			"fog": {
				label: "LIGHT.AnimationFog",
				animation: PointSource.prototype.animateTime,
				colorationShader: FogColorationShader
			},
			"sunburst": {
				label: "LIGHT.AnimationSunburst",
				animation: PointSource.prototype.animateTime,
				illuminationShader: SunburstIlluminationShader,
				colorationShader: SunburstColorationShader
			},
			"dome": {
				label: "LIGHT.AnimationLightDome",
				animation: PointSource.prototype.animateTime,
				colorationShader: LightDomeColorationShader
			},
			"emanation": {
				label: "LIGHT.AnimationEmanation",
				animation: PointSource.prototype.animateTime,
				colorationShader: EmanationColorationShader
			},
			"hexa": {
				label: "LIGHT.AnimationHexaDome",
				animation: PointSource.prototype.animateTime,
				colorationShader: HexaDomeColorationShader
			},
			"ghost": {
				label: "LIGHT.AnimationGhostLight",
				animation: PointSource.prototype.animateTime,
				illuminationShader: GhostLightIlluminationShader,
				colorationShader: GhostLightColorationShader
			},
			"energy": {
				label: "LIGHT.AnimationEnergyField",
				animation: PointSource.prototype.animateTime,
				colorationShader: EnergyFieldColorationShader
			},
			"roiling": {
				label: "LIGHT.AnimationRoilingMass",
				animation: PointSource.prototype.animateTime,
				illuminationShader: RoilingIlluminationShader
			},
			"hole": {
				label: "LIGHT.AnimationBlackHole",
				animation: PointSource.prototype.animateTime,
				illuminationShader: BlackHoleIlluminationShader
			}
		}
	},

	/**
	 * Configure the default Token text style so that it may be reused and overridden by modules
	 * @type {PIXI.TextStyle}
	 */
	canvasTextStyle: new PIXI.TextStyle({
		fontFamily: "Signika",
		fontSize: 36,
		fill: "#FFFFFF",
		stroke: '#111111',
		strokeThickness: 1,
		dropShadow: true,
		dropShadowColor: "#000000",
		dropShadowBlur: 4,
		dropShadowAngle: 0,
		dropShadowDistance: 0,
		align: "center",
		wordWrap: false,
		padding: 1
	}),

	/**
	 * Available Weather Effects implementations
	 * @type {Object}
	 */
	weatherEffects: {
		leaves: AutumnLeavesWeatherEffect,
		rain: RainWeatherEffect,
		snow: SnowWeatherEffect
	},


	/**
	 * The control icons used for rendering common HUD operations
	 * @type {Object}
	 */
	controlIcons: {
		combat: "icons/svg/combat.svg",
		visibility: "icons/svg/cowled.svg",
		effects: "icons/svg/aura.svg",
		lock: "icons/svg/padlock.svg",
		up: "icons/svg/up.svg",
		down: "icons/svg/down.svg",
		defeated: "icons/svg/skull.svg",
		light: "icons/svg/light.svg",
		lightOff: "icons/svg/light-off.svg",
		template: "icons/svg/explosion.svg",
		sound: "icons/svg/sound.svg",
		soundOff: "icons/svg/sound-off.svg",
		doorClosed: "icons/svg/door-closed-outline.svg",
		doorOpen: "icons/svg/door-open-outline.svg",
		doorSecret: "icons/svg/door-secret-outline.svg",
		doorLocked: "icons/svg/door-locked-outline.svg"
	},

	/**
	 * Suggested font families that are displayed wherever a choice is presented
	 * @type {string[]}
	 */
	fontFamilies: [
		"Arial",
		"Arial Black",
		"Comic Sans MS",
		"Courier New",
		"Times New Roman",
		"Signika",
		"Modesto Condensed"
	],

	/**
	 * The default font family used for text labels on the PIXI Canvas
	 * @type {string}
	 */
	defaultFontFamily: "Signika",

	/**
	 * An array of status effects which can be applied to a TokenDocument.
	 * Each effect can either be a string for an icon path, or an object representing an Active Effect data.
	 * @type {Array<string|foundry.data.ActiveEffectData>}
	 */
	statusEffects: [
		{
			id: "dead",
			label: "EFFECT.StatusDead",
			icon: "icons/svg/skull.svg"
		},
		{
			id: "unconscious",
			label: "EFFECT.StatusUnconscious",
			icon: "icons/svg/unconscious.svg"
		},
		{
			id: "sleep",
			label: "EFFECT.StatusAsleep",
			icon: "icons/svg/sleep.svg"
		},
		{
			id: "stun",
			label: "EFFECT.StatusStunned",
			icon: "icons/svg/daze.svg"
		},
		{
			id: "prone",
			label: "EFFECT.StatusProne",
			icon: "icons/svg/falling.svg"
		},
		{
			id: "restrain",
			label: "EFFECT.StatusRestrained",
			icon: "icons/svg/net.svg",
		},
		{
			id: "paralysis",
			label: "EFFECT.StatusParalysis",
			icon: "icons/svg/paralysis.svg",
		},
		{
			id: "fly",
			label: "EFFECT.StatusFlying",
			icon: "icons/svg/wing.svg",
		},
		{
			id: "blind",
			label: "EFFECT.StatusBlind",
			icon: "icons/svg/blind.svg"
		},
		{
			id: "deaf",
			label: "EFFECT.StatusDeaf",
			icon: "icons/svg/deaf.svg"
		},
		{
			id: "silence",
			label: "EFFECT.StatusSilenced",
			icon: "icons/svg/silenced.svg"
		},
		{
			id: "fear",
			label: "EFFECT.StatusFear",
			icon: "icons/svg/terror.svg"
		},
		{
			id: "burning",
			label: "EFFECT.StatusBurning",
			icon: "icons/svg/fire.svg"
		},
		{
			id: "frozen",
			label: "EFFECT.StatusFrozen",
			icon: "icons/svg/frozen.svg"
		},
		{
			id: "shock",
			label: "EFFECT.StatusShocked",
			icon: "icons/svg/lightning.svg"
		},
		{
			id: "corrode",
			label: "EFFECT.StatusCorrode",
			icon: "icons/svg/acid.svg"
		},
		{
			id: "bleeding",
			label: "EFFECT.StatusBleeding",
			icon: "icons/svg/blood.svg"
		},
		{
			id: "disease",
			label: "EFFECT.StatusDisease",
			icon: "icons/svg/biohazard.svg"
		},
		{
			id: "poison",
			label: "EFFECT.StatusPoison",
			icon: "icons/svg/poison.svg"
		},
		{
			id: "radiation",
			label: "EFFECT.StatusRadiation",
			icon: "icons/svg/radiation.svg"
		},
		{
			id: "regen",
			label: "EFFECT.StatusRegen",
			icon: "icons/svg/regen.svg"
		},
		{
			id: "degen",
			label: "EFFECT.StatusDegen",
			icon: "icons/svg/degen.svg"
		},
		{
			id: "upgrade",
			label: "EFFECT.StatusUpgrade",
			icon: "icons/svg/upgrade.svg"
		},
		{
			id: "downgrade",
			label: "EFFECT.StatusDowngrade",
			icon: "icons/svg/downgrade.svg"
		},
		{
			id: "target",
			label: "EFFECT.StatusTarget",
			icon: "icons/svg/target.svg"
		},
		{
			id: "eye",
			label: "EFFECT.StatusMarked",
			icon: "icons/svg/eye.svg"
		},
		{
			id: "curse",
			label: "EFFECT.StatusCursed",
			icon: "icons/svg/sun.svg"
		},
		{
			id: "bless",
			label: "EFFECT.StatusBlessed",
			icon: "icons/svg/angel.svg"
		},
		{
			id: "fireShield",
			label: "EFFECT.StatusFireShield",
			icon: "icons/svg/fire-shield.svg"
		},
		{
			id: "coldShield",
			label: "EFFECT.StatusIceShield",
			icon: "icons/svg/ice-shield.svg"
		},
		{
			id: "magicShield",
			label: "EFFECT.StatusMagicShield",
			icon: "icons/svg/mage-shield.svg"
		},
		{
			id: "holyShield",
			label: "EFFECT.StatusHolyShield",
			icon: "icons/svg/holy-shield.svg"
		},
	],

	/**
	 * A mapping of core audio effects used which can be replaced by systems or mods
	 * @type {Object}
	 */
	sounds: {
		dice: "sounds/dice.wav",
		lock: "sounds/lock.wav",
		notification: "sounds/notify.wav",
		combat: "sounds/drums.wav"
	},

	/**
	 * Define the set of supported languages for localization
	 * @type {{string, string}}
	 */
	supportedLanguages: {
		en: "English"
	},

	/**
	 * Configuration for time tracking
	 * @type {{turnTime: number}}
	 */
	time: {
		turnTime: 0,
		roundTime: 0
	},

	/* -------------------------------------------- */
	/*  Embedded Documents                          */
	/* -------------------------------------------- */

	/**
	 * Configuration for the ActiveEffect embedded document type
	 */
	ActiveEffect: {
		documentClass: ActiveEffect,
		sheetClass: ActiveEffectConfig
	},

	/**
	 * Configuration for the TableResult embedded document type
	 */
	TableResult: {
		documentClass: TableResult
	},

	/**
	 * Configuration for the PlaylistSound embedded document type
	 */
	PlaylistSound: {
		documentClass: PlaylistSound,
		sheetClass: PlaylistSoundConfig
	},

	/**
	 * Configuration for the AmbientLight embedded document type and its representation on the game Canvas
	 * @enum {Function}
	 */
	AmbientLight: {
		documentClass: AmbientLightDocument,
		objectClass: AmbientLight,
		layerClass: LightingLayer,
		sheetClass: LightConfig
	},

	/**
	 * Configuration for the AmbientSound embedded document type and its representation on the game Canvas
	 * @enum {Function}
	 */
	AmbientSound: {
		documentClass: AmbientSoundDocument,
		objectClass: AmbientSound,
		layerClass: SoundsLayer,
		sheetClass: AmbientSoundConfig
	},

	/**
	 * Configuration for the Combatant embedded document type within a Combat document
	 * @enum {Function}
	 */
	Combatant: {
		documentClass: Combatant,
		sheetClass: CombatantConfig
	},

	/**
	 * Configuration for the Drawing embedded document type and its representation on the game Canvas
	 * @enum {Function}
	 */
	Drawing: {
		documentClass: DrawingDocument,
		objectClass: Drawing,
		layerClass: DrawingsLayer,
		sheetClass: DrawingConfig
	},

	/**
	 * Configuration for the MeasuredTemplate embedded document type and its representation on the game Canvas
	 * @enum {Function}
	 */
	MeasuredTemplate: {
		defaults: {
			angle: 53.13,
			width: 1
		},
		types: {
			"circle": "Circle",
			"cone": "Cone",
			"rect": "Rectangle",
			"ray": "Ray"
		},
		documentClass: MeasuredTemplateDocument,
		objectClass: MeasuredTemplate,
		layerClass: TemplateLayer,
		sheetClass: MeasuredTemplateConfig
	},

	/**
	 * Configuration for the Note embedded document type and its representation on the game Canvas
	 * @enum {Function}
	 */
	Note: {
		documentClass: NoteDocument,
		objectClass: Note,
		layerClass: NotesLayer,
		sheetClass: NoteConfig
	},

	/**
	 * Configuration for the Tile embedded document type and its representation on the game Canvas
	 * @enum {Function}
	 */
	Tile: {
		documentClass: TileDocument,
		objectClass: Tile,
		layerClass: BackgroundLayer,
		sheetClass: TileConfig
	},

	/**
	 * Configuration for the Token embedded document type and its representation on the game Canvas
	 * @enum {Function}
	 */
	Token: {
		documentClass: TokenDocument,
		objectClass: Token,
		layerClass: TokenLayer,
		sheetClass: TokenConfig
	},

	/**
	 * Configuration for the Wall embedded document type and its representation on the game Canvas
	 * @enum {Function}
	 */
	Wall: {
		documentClass: WallDocument,
		objectClass: Wall,
		layerClass: WallsLayer,
		sheetClass: WallConfig
	},

	/* -------------------------------------------- */
	/*  Integrations                                */
	/* -------------------------------------------- */

	/**
	 * Default configuration options for TinyMCE editors
	 * @type {object}
	 */
	TinyMCE: {
		branding: false,
		menubar: false,
		statusbar: false,
		content_css: ["/css/mce.css"],
		plugins: "lists image table hr code save link",
		toolbar: "styleselect bullist numlist image table hr link removeformat code save",
		save_enablewhendirty: true,
		table_default_styles: {},
		style_formats: [
			{
				title: "Custom",
				items: [
					{
						title: "Secret",
						block: 'section',
						classes: 'secret',
						wrapper: true
					}
				]
			}
		],
		style_formats_merge: true,
	},

	/**
	 * Configuration for the WebRTC implementation class
	 * @type {Object}
	 */
	WebRTC: {
		clientClass: EasyRTCClient,
		detectPeerVolumeInterval: 50,
		detectSelfVolumeInterval: 20,
		emitVolumeInterval: 25,
		speakingThresholdEvents: 2,
		speakingHistoryLength: 10
	},

	/* -------------------------------------------- */
	/*  Interface                                   */
	/* -------------------------------------------- */

	/**
	 * Configure the Application classes used to render various core UI elements in the application.
	 * The order of this object is relevant, as certain classes need to be constructed and referenced before others.
	 * @type {Object<Application>}
	 */
	ui: {
		menu: MainMenu,
		sidebar: Sidebar,
		pause: Pause,
		nav: SceneNavigation,
		notifications: Notifications,
		actors: ActorDirectory,
		chat: ChatLog,
		combat: CombatTracker,
		compendium: CompendiumDirectory,
		controls: SceneControls,
		hotbar: Hotbar,
		items: ItemDirectory,
		journal: JournalDirectory,
		macros: MacroDirectory,
		players: PlayerList,
		playlists: PlaylistDirectory,
		scenes: SceneDirectory,
		settings: Settings,
		tables: RollTableDirectory,
		webrtc: CameraViews
	}
};

/* -------------------------------------------- */
/*  Deprecations                                */
/* -------------------------------------------- */

for ( let documentName of CONST.ENTITY_TYPES.concat(["ActiveEffect"]) ) {
	if ( !CONFIG[documentName] ) continue;

	/**
	 * @deprecated since 0.8.0
	 * @ignore
	 */
	Object.defineProperty(CONFIG[documentName], "entityClass", {
		get: () => {
			console.warn(`You are retrieving the value of CONFIG.${documentName}.entityClass which has been renamed to CONFIG.${documentName}.documentClass. Support for the old configuration value will be removed in 0.9.0`);
			return CONFIG[documentName].documentClass;
		},
		set: value => {
			console.warn(`You have assigned a value to CONFIG.${documentName}.entityClass which should now be assigned to CONFIG.${documentName}.documentClass. Support for the old configuration value will be removed in 0.9.0`);
			CONFIG[documentName].documentClass = value;
		}
	})
}


// Helper classes
globalThis.Hooks = Hooks;
globalThis.TextEditor = TextEditor;
globalThis.SortingHelpers = SortingHelpers;

// Default Entity sheet registrations
Actors.registerSheet("core", ActorSheet, {label: "Default Actor Sheet"});
Items.registerSheet("core", ItemSheet, {label: "Default Item Sheet"});

/**
 * Once the Window has loaded, created and initialize the Game object
 */
window.addEventListener("DOMContentLoaded", async function() {

	// Log ASCII welcome message
	console.log(CONST.ASCII);

	// Get the current URL
	const url = new URL(window.location.href);
	const view = url.pathname.split("/").pop();

	// Establish a session
	const cookies = Game.getCookies();
	const sessionId = cookies.session ?? null;
	if ( !sessionId ) return window.location.href = getRoute("join");
	console.log(`${vtt} | Reestablishing existing session ${sessionId}`);

	// Create the master Game controller
	if ( CONST.SETUP_VIEWS.includes(view) ) game = globalThis.game = await Setup.create(view, sessionId);
	else if ( CONST.GAME_VIEWS.includes(view) ) game = globalThis.game = await Game.create(view, sessionId);
	game.initialize();
}, {once: true, passive: true});

/**
 * A helper class to provide common functionality for working with the Web Audio API.
 * https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API
 * A singleton instance of this class is available as game#audio.
 * @see Game#audio
 */
class AudioHelper {
	constructor() {
		if ( game.audio instanceof this.constructor ) {
			throw new Error("You may not re-initialize the singleton AudioHelper. Use game.audio instead.");
		}

		/**
		 * The primary Audio Context used to play client-facing sounds.
		 * The context is undefined until the user's first gesture is observed.
		 * @type {AudioContext}
		 */
		this.context = undefined;

		/**
		 * The set of AudioBuffer objects which are cached for different audio paths
		 * @type {Map<string,AudioBuffer>}
		 */
		this.buffers = new Map();

		/**
		 * The set of singleton Sound instances which are cached for different audio paths
		 * @type {Map<string,Sound>}
		 */
		this.sounds = new Map();

		/**
		 * Get an array of the Sound objects which are currently playing.
		 * @type {Map<number,Sound>}
		 */
		this.playing = new Map();

		/**
		 * A user gesture must be registered before audio can be played.
		 * This Array contains the Howl instances which are requested for playback prior to a gesture.
		 * Once a gesture is observed, we begin playing all elements of this Array.
		 * @type {Function[]}
		 */
		this.pending = [];

		/**
		 * A flag for whether video playback is currently locked by awaiting a user gesture
		 * @type {boolean}
		 */
		this.locked = true;

		/**
		 * Audio Context singleton used for analysing audio levels of each stream
		 * Only created if necessary to listen to audio streams.
		 *
		 * @type {AudioContext}
		 */
		this._audioContext = null;

		/**
		 * Map of all streams that we listen to for determining the decibel levels.
		 * Used for analyzing audio levels of each stream.
		 * Format of the object stored is :
		 * {id:
		 *   {
		 *     stream: MediaStream,
		 *     analyser: AudioAnalyser,
		 *     interval: Number,
		 *     callback: Function
		 *   }
		 * }
		 *
		 * @type {Object}
		 * @private
		 */
		this._analyserStreams = {};

		/**
		 * Interval ID as returned by setInterval for analysing the volume of streams
		 * When set to 0, means no timer is set.
		 * @type {number}
		 * @private
		 */
		this._analyserInterval = 0;

		/**
		 * Fast Fourier Transform Array.
		 * Used for analysing the decibel level of streams. The array is allocated only once
		 * then filled by the analyser repeatedly. We only generate it when we need to listen to
		 * a stream's level, so we initialize it to null.
		 * @type {Float32Array}
		 * @private
		 */
		this._fftArray = null;
	}

	/**
	 * The Native interval for the AudioHelper to analyse audio levels from streams
	 * Any interval passed to startLevelReports() would need to be a multiple of this value.
	 * @type {number}
	 */
	static levelAnalyserNativeInterval = 50;

	/* -------------------------------------------- */

	/**
	 * Register client-level settings for global volume overrides
	 */
	static registerSettings() {

		// Playlist Volume
		game.settings.register("core", "globalPlaylistVolume", {
			name: "Global Playlist Volume",
			hint: "Define a global playlist volume modifier",
			scope: "client",
			config: false,
			default: 1.0,
			type: Number,
			onChange: v => {
				for ( let p of game.playlists ) {
					for ( let s of p.sounds ) {
						if ( s.playing ) s.sync();
					}
				}
				game.audio._onChangeGlobalVolume("globalPlaylistVolume",  v);
			}
		});

		// Ambient Volume
		game.settings.register("core", "globalAmbientVolume", {
			name: "Global Ambient Volume",
			hint: "Define a global ambient volume modifier",
			scope: "client",
			config: false,
			default: 1.0,
			type: Number,
			onChange: v => {
				if ( canvas.ready ) {
					if ( canvas.background.isVideo ) canvas.background.bgSource.volume = v;
					if ( canvas.foreground.isVideo ) canvas.foreground.bgSource.volume = v;
					canvas.sounds.refresh({fade: 0});
				}
				game.audio._onChangeGlobalVolume("globalAmbientVolume",  v);
			}
		});

		// Interface Volume
		game.settings.register("core", "globalInterfaceVolume", {
			name: "Global Interface Volume",
			hint: "Define a global interface volume modifier",
			scope: "client",
			config: false,
			default: 0.5,
			type: Number,
			onChange: v => game.audio._onChangeGlobalVolume("globalInterfaceVolume",  v)
		});
	}

	/* -------------------------------------------- */

	/**
	 * Create a Sound instance for a given audio source URL
	 * @param {object} options      Audio creation options
	 * @param {string} options.src                  The source URL for the audio file
	 * @param {boolean} [options.singleton=true]    Reuse an existing Sound for this source?
	 * @param {boolean} [options.preload=false]     Begin loading the audio immediately?
	 * @param {boolean} [options.autoplay=false]    Begin playing the audio as soon as it is ready?
	 * @param {object} [options.autoplayOptions={}] Additional options passed to the play method if autoplay is true
	 * @return {Sound}
	 */
	create({src, singleton=true, preload=false, autoplay=false, autoplayOptions={}} = {}) {
		let sound;
		if ( singleton ) {
			if ( this.sounds.has(src) ) sound = this.sounds.get(src);
			else {
				sound = new Sound(src);
				this.sounds.set(src, sound);
			}
		} else {
			sound = new Sound(src);
		}
		if ( preload ) sound.load({autoplay, autoplayOptions});
		return sound;
	}

	/* -------------------------------------------- */

	/**
	 * Test whether a source file has a supported audio extension type
	 * @param {string} src      A requested audio source path
	 * @return {boolean}        Does the filename end with a valid audio extension?
	 */
	static hasAudioExtension(src) {
		let rgx = new RegExp("(\\."+CONST.AUDIO_FILE_EXTENSIONS.join("|\\.")+")(\\?.*)?", "i");
		return rgx.test(src);
	}

	/* -------------------------------------------- */

	/**
	 * Given an input file path, determine a default name for the sound based on the filename
	 * @param {string} src      An input file path
	 * @returns {string}        A default sound name for the path
	 */
	static getDefaultSoundName(src) {
		const parts = src.split("/").pop().split(".");
		parts.pop();
		let name = decodeURIComponent(parts.join("."));
		return name.replace(/[-_.]/g, " ").titleCase();
	}

	/* -------------------------------------------- */

	/**
	 * Play a single Sound by providing its source.
	 * @param {string} src            The file path to the audio source being played
	 * @param {object} options]       Additional options passed to Sound#play
	 * @returns {Promise<Sound>}      The created Sound which is now playing
	 */
	async play(src, options) {
		const sound = new Sound(src);
		await sound.load();
		sound.play(options);
		return sound;
	}

	/* -------------------------------------------- */

	/**
	 * Register an event listener to await the first mousemove gesture and begin playback once observed
	 */
	awaitFirstGesture() {
		if ( !this.locked ) return;
		for ( let eventName of ['contextmenu', 'auxclick', 'mousedown', 'mouseup', 'keydown'] ) {
			document.addEventListener(eventName, this._onFirstGesture.bind(this), {once: true});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Request that other connected clients begin preloading a certain sound path.
	 * @param {string} src          The source file path requested for preload
	 * @returns {Promise<Sound>}    A Promise which resolves once the preload is complete
	 */
	preload(src) {
		if ( typeof src === "object" ) {
			src = src.path;
			console.warn(`You are passing an object to the AudioHelper#preload method which now only requires a source URL`);
		}
		if ( !src || !AudioHelper.hasAudioExtension(src) ) {
			throw new Error(`Invalid audio source path ${src} provided for preload request`);
		}
		game.socket.emit("preloadAudio", src);
		return this.constructor.preloadSound(src);
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/**
	 * Open socket listeners which transact ChatMessage data
	 */
	static _activateSocketListeners(socket) {
		socket.on('playAudio', this.play);
		socket.on('preloadAudio', src => this.preloadSound(src));
	}

	/* -------------------------------------------- */

	/**
	 * Play a one-off sound effect which is not part of a Playlist
	 *
	 * @param {Object} data           An object configuring the audio data to play
	 * @param {string} data.src       The audio source file path, either a public URL or a local path relative to the public directory
	 * @param {number} data.volume    The volume level at which to play the audio, between 0 and 1.
	 * @param {boolean} data.autoplay Begin playback of the audio effect immediately once it is loaded.
	 * @param {boolean} data.loop     Loop the audio effect and continue playing it until it is manually stopped.
	 * @param {boolean} [push]        Push the audio sound effect to other connected clients?
	 *
	 * @return {Object}               A Howl instance which controls audio playback.
	 *
	 * @example
	 * // Play the sound of a locked door for all players
	 * AudioHelper.play({src: "sounds/lock.wav", volume: 0.8, loop: false}, true);
	 */
	static play(data, push=false) {
		const audioData = foundry.utils.mergeObject({
			src: null,
			volume: 1.0,
			loop: false
		}, data, {insertKeys: true});

		// Push the sound to other clients
		if ( push ) game.socket.emit("playAudio", audioData);

		// Backwards compatibility, if autoplay was passed as false take no further action
		if ( audioData.autoplay === false ) {
			return console.warn("You are using the autoplay option of AudioHelper.play which is no longer supported in 0.8.0");
		}

		// Play the sound locally
		return game.audio.play(audioData.src, {
			volume: (audioData.volume ?? 1) * game.settings.get("core", "globalInterfaceVolume"),
			loop: audioData.loop
		});
	}

	/* -------------------------------------------- */

	/**
	 * Begin loading the sound for a provided source URL adding its
	 * @param {string} src            The audio source path to preload
	 * @returns {Promise<Sound>}      The created and loaded Sound ready for playback
	 */
	static async preloadSound(src) {
		const sound = game.audio.create({
			src: src,
			preload: true,
			singleton: true
		});
		return sound.load();
	}

	/* -------------------------------------------- */

	/**
	 * Returns the volume value based on a range input volume control's position.
	 * This is using an exponential approximation of the logarithmic nature of audio level perception
	 * @param {number|string} value   Value between [0, 1] of the range input
	 * @param {number} [order=1.5]    The exponent of the curve
	 * @return {number}
	 */
	static inputToVolume(value, order=1.5) {
		return Math.pow(parseFloat(value), order);
	}

	/* -------------------------------------------- */

	/**
	 * Counterpart to inputToVolume()
	 * Returns the input range value based on a volume
	 * @param {number} volume         Value between [0, 1] of the volume level
	 * @param {number} [order=1.5]    The exponent of the curve
	 * @return {number}
	 */
	static volumeToInput(volume, order=1.5) {
		return Math.pow(volume, 1 / order);
	}

	/* -------------------------------------------- */
	/*  Audio Stream Analysis                       */
	/* -------------------------------------------- */

	/**
	 * Returns a singleton AudioContext if one can be created.
	 * An audio context may not be available due to limited resources or browser compatibility
	 * in which case null will be returned
	 *
	 * @return {AudioContext}   A singleton AudioContext or null if one is not available
	 */
	getAudioContext() {
		if ( this._audioContext )
			return this._audioContext;
		try {
			// Use one Audio Context for all the analysers.
			return new (AudioContext || webkitAudioContext)();
		} catch (err) {
			console.log("Could not create AudioContext. Will not be able to analyse stream volumes.");
		}
		return null;
	}

	/* -------------------------------------------- */

	/**
	 * Registers a stream for periodic reports of audio levels.
	 * Once added, the callback will be called with the maximum decibel level of
	 * the audio tracks in that stream since the last time the event was fired.
	 * The interval needs to be a multiple of AudioHelper.levelAnalyserNativeInterval which defaults at 50ms
	 *
	 * @param {string} id             An id to assign to this report. Can be used to stop reports
	 * @param {MediaStream} stream    The MediaStream instance to report activity on.
	 * @param {Function} callback     The callback function to call with the decibel level. `callback(dbLevel)`
	 * @param {number} interval       (optional) The interval at which to produce reports.
	 * @param {number} smoothing      (optional) The smoothingTimeConstant to set on the audio analyser. Refer to AudioAnalyser API docs.
	 * @return {boolean}              Returns whether or not listening to the stream was successful
	 */
	startLevelReports(id, stream, callback, interval = 50, smoothing = 0.1) {
		if ( !stream || !id ) return;
		let audioContext = this.getAudioContext();
		if (audioContext === null) return false;

		// Clean up any existing report with the same ID
		this.stopLevelReports(id);

		// Make sure this stream has audio tracks, otherwise we can't connect the analyser to it
		if (stream.getAudioTracks().length === 0)
			return false;

		// Create the analyser
		let analyser = audioContext.createAnalyser();
		analyser.fftSize = 512;
		analyser.smoothingTimeConstant = smoothing;

		// Connect the analyser to the MediaStreamSource
		audioContext.createMediaStreamSource(stream).connect(analyser);
		this._analyserStreams[id] = {
			stream,
			analyser,
			interval,
			callback,
			// Used as a counter of 50ms increments in case the interval is more than 50
			_lastEmit: 0
		};

		// Ensure the analyser timer is started as we have at least one valid stream to listen to
		this._ensureAnalyserTimer();
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Stop sending audio level reports
	 * This stops listening to a stream and stops sending reports.
	 * If we aren't listening to any more streams, cancel the global analyser timer.
	 * @param {string} id      The id of the reports that passed to startLevelReports.
	 */
	stopLevelReports(id) {
		delete this._analyserStreams[id];
		if (isObjectEmpty(this._analyserStreams)) this._cancelAnalyserTimer();
	}

	/* -------------------------------------------- */

	/**
	 * Ensures the global analyser timer is started
	 * 
	 * We create only one timer that runs every 50ms and only create it if needed, this is meant to optimize things
	 * and avoid having multiple timers running if we want to analyse multiple streams at the same time.
	 * I don't know if it actually helps much with performance but it's expected that limiting the number of timers
	 * running at the same time is good practice and with JS itself, there's a potential for a timer congestion
	 * phenomenon if too many are created.
	 * @private
	 */
	_ensureAnalyserTimer() {
		if (this._analyserInterval === 0) {
			this._analyserInterval = setInterval(this._emitVolumes.bind(this), AudioHelper.levelAnalyserNativeInterval);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Cancel the global analyser timer
	 * If the timer is running and has become unnecessary, stops it.
	 * @private
	 */
	_cancelAnalyserTimer() {
		if (this._analyserInterval !== 0) {
			clearInterval(this._analyserInterval);
			this._analyserInterval = 0;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Capture audio level for all speakers and emit a webrtcVolumes custom event with all the volume levels
	 * detected since the last emit.
	 * The event's detail is in the form of {userId: decibelLevel}
	 * @private
	 */
	_emitVolumes() {
		for (let id in this._analyserStreams) {
			const analyserStream = this._analyserStreams[id];
			if (++analyserStream._lastEmit < analyserStream.interval / AudioHelper.levelAnalyserNativeInterval)
				continue;

			// Create the Fast Fourier Transform Array only once. Assume all analysers use the same fftSize
			if (this._fftArray === null) this._fftArray = new Float32Array(analyserStream.analyser.frequencyBinCount);

			// Fill the array
			analyserStream.analyser.getFloatFrequencyData(this._fftArray);
			let maxDecibel = Math.max(...this._fftArray);
			analyserStream.callback(maxDecibel, this._fftArray);
			analyserStream._lastEmit = 0;
		}
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/**
	 * Handle the first observed user gesture
	 * @param {Event} event   The mouse-move event which enables playback
	 */
	_onFirstGesture(event) {
		if ( this.locked === false ) return;
		this.context = new AudioContext();
		this.locked = false;
		if ( !this.pending.length ) return;
		console.log(`${vtt} | Activating pending audio playback with user gesture.`);
		this.pending.forEach(fn => fn());
		this.pending = [];
	}

	/* -------------------------------------------- */

	/**
	 * Additional standard callback events that occur whenever a global volume slider is adjusted
	 * @param {string} key        The setting key
	 * @param {number} volume     The new volume level
	 * @private
	 */
	_onChangeGlobalVolume(key, volume) {
		/**
		 * A hook event that fires when the user modifies a global volume slider.
		 * The hook name needs to be customized to include the type of global volume being changed, one of:
		 * `globalPlaylistVolumeChanged`, `globalAmbientVolumeChanged`, or `globalInterfaceVolumeChanged`.
		 * @function globalVolumeChanged
		 * @memberof hookEvents
		 * @param {number} volume     The new volume level
		 */
		Hooks.callAll(`${key}Changed`, volume);
	}
}

/**
 * An AudioSourceNode container which handles the strategy of node type to use for playback.
 * Used by the Sound interface which controls playback.
 * This class is for internal use only and should not be used by external callers.
 * @private
 */
class AudioContainer {
	constructor(src) {

		/**
		 * The audio source path
		 * @type {string}
		 */
		this.src = src;
	}

	/**
	 * The Audio Node used to control this sound
	 * @type {AudioBufferSourceNode|MediaElementAudioSourceNode}
	 */
	sourceNode = undefined;

	/**
	 * The GainNode used to control volume
	 * @type {GainNode}
	 */
	gainNode = undefined;

	/**
	 * Is this container using an AudioBuffer?
	 * @type {boolean}
	 */
	isBuffer = false;

	/**
	 * Has the source for this audio container been loaded to a point that playback can begin?
	 * @type {boolean}
	 */
	loaded = false;

	/**
	 * Is the audio source currently playing?
	 * @type {boolean}
	 */
	playing = false;

	/**
	 * The maximum duration, in seconds, for which an AudioBuffer will be used.
	 * Otherwise a streaming media element will be used.
	 * @type {number}
	 */
	static MAX_BUFFER_DURATION = 10 * 60;  // 10 Minutes

	/* -------------------------------------------- */
	/*  Container Attributes                        */
	/* -------------------------------------------- */

	/**
	 * A reference to the AudioBuffer if the sourceNode is a AudioBufferSourceNode.
	 * @returns {AudioBuffer}
	 */
	get buffer() {
		return this.sourceNode.buffer;
	}

	/* -------------------------------------------- */

	/**
	 * The game audio context used throughout the application.
	 * @returns {AudioContext}
	 */
	get context() {
		return game.audio.context;
	}

	/* -------------------------------------------- */

	/**
	 * The total duration of the audio source in seconds
	 * @type {number}
	 */
	get duration() {
		if ( !this.loaded ) return undefined;
		if ( this.isBuffer ) return this.buffer.duration;
		else return this.element.duration;
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the HTMLMediaElement, if the sourceNode is a MediaElementAudioSourceNode.
	 * @returns {HTMLMediaElement}
	 */
	get element() {
		return this.sourceNode.mediaElement;
	}

	/* -------------------------------------------- */
	/*  Constructor Methods                         */
	/* -------------------------------------------- */

	/**
	 * Load the source node required for playback of this audio source
	 * @returns {Promise<void>}
	 */
	async load() {
		this.sourceNode = await this._createNode();
		this.gainNode = this.context.createGain();
		this.gainNode.connect(this.context.destination);
		this.loaded = true;
	}

	/* -------------------------------------------- */

	/**
	 * Create the initial audio node used for playback.
	 * Determine the node type to use based on cached state and sound duration.
	 * @returns {AudioBufferSourceNode|MediaElementAudioSourceNode}
	 * @private
	 */
	async _createNode() {

		// If an audio buffer is cached, use an AudioBufferSourceNode
		let buffer = game.audio.buffers.get(this.src);
		if (buffer) return this._createAudioBufferSourceNode(buffer);

		// Otherwise check the element duration using HTML5 audio
		const element = await this._createAudioElement();
		const isShort = element.duration && (element.duration <= this.constructor.MAX_BUFFER_DURATION);

		// For short sounds create and cache the audio buffer and use an AudioBufferSourceNode
		if ( isShort ) {
			const buffer = await this._createAudioBuffer();
			console.debug(`${vtt} | Constructing audio buffer source node - ${this.src}`);
			return this._createAudioBufferSourceNode(buffer);
		}

		// For long or streamed sounds, use a MediaElementAudioSourceNode
		console.debug(`${vtt} | Constructing audio element source node - ${this.src}`);
		return this._createMediaElementAudioSourceNode(element);
	}

	/* -------------------------------------------- */

	/**
	 * Create an Audio source node using a buffered array.
	 * @returns {Promise<AudioBuffer>}
	 * @private
	 */
	async _createAudioBuffer() {
		console.debug(`${vtt} | Loading audio buffer - ${this.src}`);
		const response = await fetch(this.src);
		const arrayBuffer = await response.arrayBuffer();
		return this.context.decodeAudioData(arrayBuffer);
	}

	/* -------------------------------------------- */

	/**
	 * Create a AudioBufferSourceNode using a provided AudioBuffer
	 * @private
	 */
	_createAudioBufferSourceNode(buffer) {
		game.audio.buffers.set(this.src, buffer);
		this.isBuffer = true;
		return new AudioBufferSourceNode(this.context, {buffer});
	}

	/* -------------------------------------------- */

	/**
	 * Create an HTML5 Audio element which has loaded the metadata for the provided source.
	 * @returns {Promise<HTMLAudioElement>}
	 * @private
	 */
	async _createAudioElement() {
		console.debug(`${vtt} | Loading audio element - ${this.src}`);
		return new Promise((resolve, reject) => {
			const element = new Audio();
			element.autoplay = false;
			element.crossOrigin = "anonymous";
			element.onloadedmetadata = () => resolve(element);
			element.onload = () => resolve(element);
			element.onerror = reject;
			element.src = this.src;
		});
	}

	/* -------------------------------------------- */

	/**
	 * Create a MediaElementAudioSourceNode using a provided HTMLAudioElement
	 * @private
	 */
	_createMediaElementAudioSourceNode(element) {
		this.isBuffer = false;
		return new MediaElementAudioSourceNode(this.context, {mediaElement: element});
	}

	/* -------------------------------------------- */
	/*  Playback Methods                            */
	/* -------------------------------------------- */

	/**
	 * Begin playback for the source node.
	 * @param {number} offset         The desired start time
	 * @param {Function} onended      A callback function for when playback concludes naturally
	 */
	play(offset=0, onended) {
		this._configureNode();
		if ( this.isBuffer ) {
			this.sourceNode.onended = onended;
			this.sourceNode.start(0, offset);
		}
		else {
			this.element.currentTime = offset;
			this.element.onended = onended;
			this.element.play();
		}
		this.playing = true;
	}

	/* -------------------------------------------- */

	/**
	 * Pre-playback actions that are needed depending on the node type
	 * @private
	 */
	_configureNode() {
		if ( this.isBuffer ) this.sourceNode = this._createAudioBufferSourceNode(this.buffer);
		this.sourceNode.connect(this.gainNode);
	}

	/* -------------------------------------------- */

	/**
	 * Terminate playback for the source node.
	 */
	stop() {
		this.playing = false;
		if ( this.isBuffer ) {
			this.sourceNode.onended = undefined;
			this.sourceNode.stop(0);
		}
		else {
			this.element.onended = undefined;
			this.element.pause();
		}
	}
}
/**
 * The Sound class is used to control the playback of audio sources using the Web Audio API.
 */
class Sound {
	constructor(src) {

		/**
		 * The numeric identifier for accessing this node
		 * @type {number}
		 */
		this.id = ++Sound._nodeId;

		/**
		 * The audio source path
		 * @type {string}
		 */
		this.src = src;

		/**
		 * The AudioContainer which controls playback
		 * @type {AudioContainer}
		 */
		this.container = new AudioContainer(this.src);
	}

	/* -------------------------------------------- */

	/**
	 * The time in seconds at which playback was started
	 * @type {number}
	 */
	startTime = undefined;

	/**
	 * The time in seconds at which playback was paused
	 * @type {number}
	 */
	pausedTime = undefined;

	/**
	 * Registered event callbacks
	 * @type {{stop: {}, start: {}, end: {}, pause: {}, load: {}}}
	 */
	events = {
		end: {},
		pause: {},
		start: {},
		stop: {},
		load: {}
	}

	/**
	 * The registered event handler id for this Sound.
	 * Incremented each time a callback is registered.
	 * @type {number}
	 * @private
	 */
	_eventHandlerId = 1;

	/**
	 * If this Sound source is currently in the process of loading, this attribute contains a Promise that will resolve
	 * when the loading process completes.
	 * @type {Promise}
	 */
	loading = undefined;

	/**
	 * A collection of scheduled events recorded as window timeout IDs
	 * @type {Set<number>}
	 */
	_scheduledEvents = new Set();

	/**
	 * A global audio node ID used to quickly reference a specific audio node
	 * @type {number}
	 * @private
	 */
	static _nodeId = 0;

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * A convenience reference to the sound context used by the application
	 * @returns {AudioContext}
	 */
	get context() {
		return game.audio.context;
	}

	/**
	 * A reference to the audio source node being used by the AudioContainer
	 * @returns {AudioBufferSourceNode|MediaElementAudioSourceNode}
	 */
	get node() {
		return this.container.sourceNode;
	}

	/**
	 * A reference to the GainNode parameter which controls volume
	 * @type {AudioParam}
	 */
	get gain() {
		return this.container.gainNode?.gain;
	}

	/**
	 * The current playback time of the sound
	 * @returns {number}
	 */
	get currentTime() {
		if ( !this.playing ) return undefined;
		if ( this.pausedTime ) return this.pausedTime;
		return (this.context.currentTime - this.startTime) % this.duration;
	}

	/**
	 * The total sound duration, in seconds
	 * @type {number}
	 */
	get duration() {
		return this.container.duration;
	}

	/**
	 * Is the contained audio node loaded and ready for playback?
	 * @returns {boolean}
	 */
	get loaded() {
		return this.container.loaded;
	}

	/**
	 * Is the audio source currently playing?
	 * @type {boolean}
	 */
	get playing() {
		return this.container.playing;
	}

	/**
	 * Is the Sound current looping?
	 * @type {boolean}
	 */
	get loop() {
		return this.node?.loop || false;
	}
	set loop(looping) {
		if ( !this.node ) return;
		this.node.loop = looping;
	}

	/**
	 * The volume at which the Sound is playing
	 * @returns {number}
	 */
	get volume() {
		return this.gain?.value;
	}
	set volume(value) {
		if ( !this.node || !Number.isNumeric(value) ) return;
		const ct = this.context.currentTime;
		this.gain.cancelScheduledValues(ct);
		this.gain.setValueAtTime(this.gain.value = value, ct); // Important - immediately "schedule" the current value
	}

	/* -------------------------------------------- */
	/*  Control Methods                             */
	/* -------------------------------------------- */

	/**
	 * Fade the volume for this sound between its current level and a desired target volume
	 * @param {number} volume                     The desired target volume level between 0 and 1
	 * @param {object} [options={}]               Additional options that configure the fade operation
	 * @param {number} [options.duration=1000]      The duration of the fade effect in milliseconds
	 * @param {number} [options.from]               A volume level to start from, the current volume by default
	 * @param {string} [options.type=linear]        The type of fade easing, "linear" or "exponential"
	 * @returns {Promise<void>}                   A Promise that resolves after the requested fade duration
	 */
	async fade(volume, {duration=1000, from, type="linear"}={}) {
		if ( !this.gain ) return;
		const ramp = this.gain[`${type}RampToValueAtTime`];
		if ( !ramp ) throw new Error(`Invalid fade type ${type} requested`);
		const ct = this.context.currentTime;

		// Schedule the fade
		this.gain.cancelScheduledValues(ct); // Cancel any existing transition
		this.gain.setValueAtTime(from ?? this.gain.value, ct); // Important - immediately "schedule" the current value
		ramp.call(this.gain, volume, ct + (duration / 1000));
		return new Promise(resolve => window.setTimeout(resolve, duration));
	}

	/* -------------------------------------------- */

	/**
	 * Load the audio source, creating an AudioBuffer.
	 * Audio loading is idempotent, it can be requested multiple times but only the first load request will be honored.
	 * @param {object} [options={}]   Additional options which affect resource loading
	 * @param {boolean} [options.autoplay=false]  Automatically begin playback of the audio source once loaded
	 * @param {object} [options.autoplayOptions]  Additional options passed to the play method when loading is complete
	 * @returns {Promise<Sound>}      The Sound once its source audio buffer is loaded
	 */
	async load({autoplay=false, autoplayOptions={}}={}) {

		// Delay audio loading until after an observed user gesture
		if ( game.audio.locked ) {
			console.log(`${vtt} | Delaying load of sound ${this.src} until after first user gesture`);
			await new Promise(resolve => game.audio.pending.push(resolve));
		}

		// Currently loading
		if (this.loading instanceof Promise) await this.loading;

		// If loading is required, cache the promise for idempotency
		if ( !this.container?.loaded ) {
			this.loading = this.container.load();
			await this.loading;
			this.loading = undefined;
		}

		// Trigger automatic playback actions
		if ( autoplay ) this.play(autoplayOptions);
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Begin playback for the sound node
	 * @param {object} [options={}]   Options which configure playback
	 * @param {boolean} [options.loop=false]    Whether to loop the audio automatically
	 * @param {number} [options.offset]         A specific offset in seconds at which to begin playback
	 * @param {number} [options.volume]         The desired volume at which to begin playback
	 * @param {number} [options.fade=0]         Fade volume changes over a desired duration in milliseconds
	 */
	play({loop=false, offset, volume, fade=0}={}) {
		if ( !this.loaded ) {
			return console.warn(`You cannot play Sound ${this.src} before it has loaded`);
		}

		// If we are still awaiting the first user interaction, add this playback to a pending queue
		if ( game.audio.locked ) {
			console.log(`${vtt} | Delaying playback of sound ${this.src} until after first user gesture`);
			return game.audio.pending.push(() => this.play({loop, offset, volume}));
		}

		// Adjust volume and looping
		const adjust = () => {
			this.loop = loop;
			if ( (volume !== undefined) && (volume !== this.volume) ) {
				if ( fade ) return this.fade(volume, {duration: fade});
				else this.volume = volume;
			}
		}

		// If the sound is already playing, and a specific offset is not provided, do nothing
		if ( this.playing ) {
			if ( offset === undefined ) return adjust();
			this.stop();
		}

		// Configure playback
		offset = (offset ?? this.pausedTime ?? 0) % this.duration;
		this.startTime = this.context.currentTime - offset;
		this.pausedTime = undefined;

		// Start playback
		this.volume = 0; // Start volume at 0
		this.container.play(offset, this._onEnd.bind(this));
		adjust(); // Adjust to the desired volume
		this._onStart();
	}

	/* -------------------------------------------- */

	/**
	 * Pause playback, remembering the playback position in order to resume later.
	 */
	pause() {
		this.pausedTime = this.currentTime;
		this.startTime = undefined;
		this.container.stop();
		this._onPause();
	}

	/* -------------------------------------------- */

	/**
	 * Stop playback, fully resetting the Sound to a non-playing state.
	 */
	stop() {
		if ( this.playing === false ) return;
		this.pausedTime = undefined;
		this.startTime = undefined;
		this.container.stop();
		this._onStop();
	}

	/* -------------------------------------------- */

	/**
	 * Schedule a function to occur at the next occurrence of a specific playbackTime for this Sound.
	 * @param {Function} fn           A function that will be called with this Sound as its single argument
	 * @param {number} playbackTime   The desired playback time at which the function should be called
	 * @returns {Promise<null>}       A Promise which resolves once the scheduled function has been called
	 *
	 * @example
	 * sound.schedule(() => console.log("Do something exactly 30 seconds into the track"), 30);
	 * sound.schedule(() => console.log("Do something next time the track loops back to the beginning"), 0);
	 * sound.schedule(() => console.log("Do something 5 seconds before the end of the track"), sound.duration - 5);
	 */
	schedule(fn, playbackTime) {
		const now = this.currentTime;
		playbackTime = Math.clamped(playbackTime, 0, this.duration);
		if ( playbackTime < now ) playbackTime += this.duration;
		const deltaMS = (playbackTime - now) * 1000;
		return new Promise(resolve => {
			const timeoutId = setTimeout(() => {
				this._scheduledEvents.delete(timeoutId);
				fn(this);
				return resolve();
			}, deltaMS);
			this._scheduledEvents.add(timeoutId);
		});
	}

	/* -------------------------------------------- */
	/*  Event Emitter                               */
	/* -------------------------------------------- */

	/**
	 * Trigger registered callback functions for a specific event name.
	 * @param {string} eventName      The event name being emitted
	 */
	emit(eventName) {
		const events = this.events[eventName]
		if ( !events ) return;
		for ( let [fnId, callback] of Object.entries(events) ) {
			callback.fn(this);
			if ( callback.once ) delete events[fnId];
		}
	}

	/* -------------------------------------------- */

	/**
	 * Deactivate an event handler which was previously registered for a specific event
	 * @param {string} eventName      The event name being deactivated
	 * @param {number|Function} fn    The callback ID or callback function being un-registered
	 */
	off(eventName, fn) {
		const events = this.events[eventName];
		if ( !events ) return;
		if ( Number.isNumeric(fn) ) delete events[fn];
		for ( let [id, f] of Object.entries(events) ) {
			if ( f === fn ) {
				delete events[id];
				break;
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Register an event handler to take actions for a certain Sound event.
	 * @param {string} eventName      The event name being deactivated
	 * @param {Function} fn           The callback function to trigger when the event occurs
	 * @param {object} [options={}]   Additional options that affect callback registration
	 * @param {boolean} [options.once=false]  Trigger the callback once only and automatically un-register it
	 */
	on(eventName, fn, {once=false}={}) {
		return this._registerForEvent(eventName, {fn, once});
	}

	/* -------------------------------------------- */

	/**
	 * Register a new callback function for a certain event. For internal use only.
	 * @private
	 */
	_registerForEvent(eventName, callback) {
		const events = this.events[eventName];
		if ( !events ) return;
		const fnId = this._eventHandlerId++;
		events[fnId] = callback;
		return fnId;
	}

	/* -------------------------------------------- */

	/**
	 * Cancel all pending scheduled events.
	 * @private
	 */
	_clearEvents() {
		for ( let timeoutId of this._scheduledEvents ) {
			window.clearTimeout(timeoutId)
		}
		this._scheduledEvents.clear();
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/**
	 * Called when playback concludes naturally
	 * @protected
	 */
	_onEnd() {
		this._clearEvents();
		game.audio.playing.delete(this.id);
		this.emit("end");
	}

	/**
	 * Called when the audio buffer is first loaded
	 * @protected
	 */
	_onLoad() {
		this.emit("load");
	}

	/**
	 * Called when playback is paused
	 * @protected
	 */
	_onPause() {
		this._clearEvents();
		this.emit("pause");
	}

	/**
	 * Called when the sound begins playing
	 * @protected
	 */
	_onStart() {
		game.audio.playing.set(this.id, this);
		this.emit("start");
	}

	/**
	 * Called when playback is stopped (prior to naturally reaching the end)
	 * @protected
	 */
	_onStop() {
		this._clearEvents();
		game.audio.playing.delete(this.id);
		this.emit("stop");
	}
}