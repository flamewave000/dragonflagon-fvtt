class Keys {
	constructor() {
		this._data = {
			KeyA: { key: 'KeyA', label: 'DF_HOTKEYS.KeyA' },
			KeyB: { key: 'KeyB', label: 'DF_HOTKEYS.KeyB' },
			KeyC: { key: 'KeyC', label: 'DF_HOTKEYS.KeyC' },
			KeyD: { key: 'KeyD', label: 'DF_HOTKEYS.KeyD' },
			KeyE: { key: 'KeyE', label: 'DF_HOTKEYS.KeyE' },
			KeyF: { key: 'KeyF', label: 'DF_HOTKEYS.KeyF' },
			KeyG: { key: 'KeyG', label: 'DF_HOTKEYS.KeyG' },
			KeyH: { key: 'KeyH', label: 'DF_HOTKEYS.KeyH' },
			KeyI: { key: 'KeyI', label: 'DF_HOTKEYS.KeyI' },
			KeyJ: { key: 'KeyJ', label: 'DF_HOTKEYS.KeyJ' },
			KeyK: { key: 'KeyK', label: 'DF_HOTKEYS.KeyK' },
			KeyL: { key: 'KeyL', label: 'DF_HOTKEYS.KeyL' },
			KeyM: { key: 'KeyM', label: 'DF_HOTKEYS.KeyM' },
			KeyN: { key: 'KeyN', label: 'DF_HOTKEYS.KeyN' },
			KeyO: { key: 'KeyO', label: 'DF_HOTKEYS.KeyO' },
			KeyP: { key: 'KeyP', label: 'DF_HOTKEYS.KeyP' },
			KeyQ: { key: 'KeyQ', label: 'DF_HOTKEYS.KeyQ' },
			KeyR: { key: 'KeyR', label: 'DF_HOTKEYS.KeyR' },
			KeyS: { key: 'KeyS', label: 'DF_HOTKEYS.KeyS' },
			KeyT: { key: 'KeyT', label: 'DF_HOTKEYS.KeyT' },
			KeyU: { key: 'KeyU', label: 'DF_HOTKEYS.KeyU' },
			KeyV: { key: 'KeyV', label: 'DF_HOTKEYS.KeyV' },
			KeyW: { key: 'KeyW', label: 'DF_HOTKEYS.KeyW' },
			KeyX: { key: 'KeyX', label: 'DF_HOTKEYS.KeyX' },
			KeyY: { key: 'KeyY', label: 'DF_HOTKEYS.KeyY' },
			KeyZ: { key: 'KeyZ', label: 'DF_HOTKEYS.KeyZ' },
			Digit1: { key: 'Digit1', label: 'DF_HOTKEYS.Digit1' },
			Digit2: { key: 'Digit2', label: 'DF_HOTKEYS.Digit2' },
			Digit3: { key: 'Digit3', label: 'DF_HOTKEYS.Digit3' },
			Digit4: { key: 'Digit4', label: 'DF_HOTKEYS.Digit4' },
			Digit5: { key: 'Digit5', label: 'DF_HOTKEYS.Digit5' },
			Digit6: { key: 'Digit6', label: 'DF_HOTKEYS.Digit6' },
			Digit7: { key: 'Digit7', label: 'DF_HOTKEYS.Digit7' },
			Digit8: { key: 'Digit8', label: 'DF_HOTKEYS.Digit8' },
			Digit9: { key: 'Digit9', label: 'DF_HOTKEYS.Digit9' },
			Digit0: { key: 'Digit0', label: 'DF_HOTKEYS.Digit0' },
			Numpad1: { key: 'Numpad1', label: 'DF_HOTKEYS.Numpad1' },
			Numpad2: { key: 'Numpad2', label: 'DF_HOTKEYS.Numpad2' },
			Numpad3: { key: 'Numpad3', label: 'DF_HOTKEYS.Numpad3' },
			Numpad4: { key: 'Numpad4', label: 'DF_HOTKEYS.Numpad4' },
			Numpad5: { key: 'Numpad5', label: 'DF_HOTKEYS.Numpad5' },
			Numpad6: { key: 'Numpad6', label: 'DF_HOTKEYS.Numpad6' },
			Numpad7: { key: 'Numpad7', label: 'DF_HOTKEYS.Numpad7' },
			Numpad8: { key: 'Numpad8', label: 'DF_HOTKEYS.Numpad8' },
			Numpad9: { key: 'Numpad9', label: 'DF_HOTKEYS.Numpad9' },
			Numpad0: { key: 'Numpad0', label: 'DF_HOTKEYS.Numpad0' },
			NumpadDecimal: { key: 'NumpadDecimal', label: 'DF_HOTKEYS.NumpadDecimal' },
			NumpadDivide: { key: 'NumpadDivide', label: 'DF_HOTKEYS.NumpadDivide' },
			NumpadMultiply: { key: 'NumpadMultiply', label: 'DF_HOTKEYS.NumpadMultiply' },
			NumpadSubtract: { key: 'NumpadSubtract', label: 'DF_HOTKEYS.NumpadSubtract' },
			NumpadAdd: { key: 'NumpadAdd', label: 'DF_HOTKEYS.NumpadAdd' },
			NumpadEnter: { key: 'NumpadEnter', label: 'DF_HOTKEYS.NumpadEnter' },
			Backspace: { key: 'Backspace', label: 'DF_HOTKEYS.Backspace' },
			Enter: { key: 'Enter', label: 'DF_HOTKEYS.Enter' },
			// ShiftRight: { key: 'ShiftRight', label: 'DF_HOTKEYS.ShiftRight' },
			// ShiftLeft: { key: 'ShiftLeft', label: 'DF_HOTKEYS.ShiftLeft' },
			// ControlLeft: { key: 'ControlLeft', label: 'DF_HOTKEYS.ControlLeft' },
			// ControlRight: { key: 'ControlRight', label: 'DF_HOTKEYS.ControlRight' },
			// AltRight: { key: 'AltRight', label: 'DF_HOTKEYS.AltRight' },
			// AltLeft: { key: 'AltLeft', label: 'DF_HOTKEYS.AltLeft' },
			Insert: { key: 'Insert', label: 'DF_HOTKEYS.Insert' },
			Delete: { key: 'Delete', label: 'DF_HOTKEYS.Delete' },
			PageUp: { key: 'PageUp', label: 'DF_HOTKEYS.PageUp' },
			PageDown: { key: 'PageDown', label: 'DF_HOTKEYS.PageDown' },
			Home: { key: 'Home', label: 'DF_HOTKEYS.Home' },
			End: { key: 'End', label: 'DF_HOTKEYS.End' },
			BracketLeft: { key: 'BracketLeft', label: 'DF_HOTKEYS.BracketLeft' },
			BracketRight: { key: 'BracketRight', label: 'DF_HOTKEYS.BracketRight' },
			Slash: { key: 'Slash', label: 'DF_HOTKEYS.Slash' },
			Backslash: { key: 'Backslash', label: 'DF_HOTKEYS.Backslash' },
			Minus: { key: 'Minus', label: 'DF_HOTKEYS.Minus' },
			Equal: { key: 'Equal', label: 'DF_HOTKEYS.Equal' },
			Semicolon: { key: 'Semicolon', label: 'DF_HOTKEYS.Semicolon' },
			Quote: { key: 'Quote', label: 'DF_HOTKEYS.Quote' },
			Comma: { key: 'Comma', label: 'DF_HOTKEYS.Comma' },
			Period: { key: 'Period', label: 'DF_HOTKEYS.Period' },
			Backquote: { key: 'Backquote', label: 'DF_HOTKEYS.Backquote' }
		};
	}
	get(key) { return this._data[key]; }
	get keys() { return Object.values(this._data).map(x => x.key); }
	get labels() { return Object.values(this._data).map(x => x.label); }
	get entries() { return Object.values(this._data); }
	get KeyA() { return this._data.KeyA.key; }
	get KeyB() { return this._data.KeyB.key; }
	get KeyC() { return this._data.KeyC.key; }
	get KeyD() { return this._data.KeyD.key; }
	get KeyE() { return this._data.KeyE.key; }
	get KeyF() { return this._data.KeyF.key; }
	get KeyG() { return this._data.KeyG.key; }
	get KeyH() { return this._data.KeyH.key; }
	get KeyI() { return this._data.KeyI.key; }
	get KeyJ() { return this._data.KeyJ.key; }
	get KeyK() { return this._data.KeyK.key; }
	get KeyL() { return this._data.KeyL.key; }
	get KeyM() { return this._data.KeyM.key; }
	get KeyN() { return this._data.KeyN.key; }
	get KeyO() { return this._data.KeyO.key; }
	get KeyP() { return this._data.KeyP.key; }
	get KeyQ() { return this._data.KeyQ.key; }
	get KeyR() { return this._data.KeyR.key; }
	get KeyS() { return this._data.KeyS.key; }
	get KeyT() { return this._data.KeyT.key; }
	get KeyU() { return this._data.KeyU.key; }
	get KeyV() { return this._data.KeyV.key; }
	get KeyW() { return this._data.KeyW.key; }
	get KeyX() { return this._data.KeyX.key; }
	get KeyY() { return this._data.KeyY.key; }
	get KeyZ() { return this._data.KeyZ.key; }
	get Digit1() { return this._data.Digit1.key; }
	get Digit2() { return this._data.Digit2.key; }
	get Digit3() { return this._data.Digit3.key; }
	get Digit4() { return this._data.Digit4.key; }
	get Digit5() { return this._data.Digit5.key; }
	get Digit6() { return this._data.Digit6.key; }
	get Digit7() { return this._data.Digit7.key; }
	get Digit8() { return this._data.Digit8.key; }
	get Digit9() { return this._data.Digit9.key; }
	get Digit0() { return this._data.Digit0.key; }
	get Numpad1() { return this._data.Numpad1.key; }
	get Numpad2() { return this._data.Numpad2.key; }
	get Numpad3() { return this._data.Numpad3.key; }
	get Numpad4() { return this._data.Numpad4.key; }
	get Numpad5() { return this._data.Numpad5.key; }
	get Numpad6() { return this._data.Numpad6.key; }
	get Numpad7() { return this._data.Numpad7.key; }
	get Numpad8() { return this._data.Numpad8.key; }
	get Numpad9() { return this._data.Numpad9.key; }
	get Numpad0() { return this._data.Numpad0.key; }
	get NumpadDecimal() { return this._data.NumpadDecimal.key; }
	get NumpadDivide() { return this._data.NumpadDivide.key; }
	get NumpadMultiply() { return this._data.NumpadMultiply.key; }
	get NumpadSubtract() { return this._data.NumpadSubtract.key; }
	get NumpadAdd() { return this._data.NumpadAdd.key; }
	get NumpadEnter() { return this._data.NumpadEnter.key; }
	get Backspace() { return this._data.Backspace.key; }
	get Enter() { return this._data.Enter.key; }
	// get ShiftRight() { return this._data.ShiftRight.key; }
	// get ShiftLeft() { return this._data.ShiftLeft.key; }
	// get ControlLeft() { return this._data.ControlLeft.key; }
	// get ControlRight() { return this._data.ControlRight.key; }
	// get AltRight() { return this._data.AltRight.key; }
	// get AltLeft() { return this._data.AltLeft.key; }
	get Insert() { return this._data.Insert.key; }
	get Delete() { return this._data.Delete.key; }
	get PageUp() { return this._data.PageUp.key; }
	get PageDown() { return this._data.PageDown.key; }
	get Home() { return this._data.Home.key; }
	get End() { return this._data.End.key; }
	get BracketLeft() { return this._data.BracketLeft.key; }
	get BracketRight() { return this._data.BracketRight.key; }
	get Slash() { return this._data.Slash.key; }
	get Backslash() { return this._data.Backslash.key; }
	get Minus() { return this._data.Minus.key; }
	get Equal() { return this._data.Equal.key; }
	get Semicolon() { return this._data.Semicolon.key; }
	get Quote() { return this._data.Quote.key; }
	get Comma() { return this._data.Comma.key; }
	get Period() { return this._data.Period.key; }
	get Backquote() { return this._data.Backquote.key; }
}

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
	function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	return new (P || (P = Promise))(function (resolve, reject) {
		function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
};
class SETTINGS {
	static get MOD_NAME() { return this._MOD_NAME; }
	static init(modName) {
		this._MOD_NAME = modName;
	}
	static register(key, config) { game.settings.register(SETTINGS._MOD_NAME, key, config); }
	static get(key) { return game.settings.get(SETTINGS._MOD_NAME, key); }
	static set(key, value) {
		return __awaiter(this, void 0, void 0, function* () { return yield game.settings.set(SETTINGS._MOD_NAME, key, value); });
	}
	static default(key) { return game.settings.settings.get(`${SETTINGS._MOD_NAME}.${key}`).default; }
	static typeOf() { return Object; }
}

/** This is just a helper for printing the list of errors with a call stack */
function printErrors(errors) {
	console.error(errors.join(',\n') + '\n' + (new Error().stack));
}
class Hotkeys {
	static _metaKey(event) {
		return (event.altKey ? 0x1 : 0) | (event.ctrlKey ? 0x2 : 0) | (event.shiftKey ? 0x4 : 0);
	}
	static _isMeta(event) {
		return event.key === 'Shift' || event.key === 'Ctrl' || event.key === 'Alt';
	}
	static _handleKeyDown(event) {
		// Ignore the regular meta keys Shift, Ctrl, and Alt
		if (this._isMeta(event))
			return;
		// Verify we are not focused on an input or text field, or an editable element
		if (document.activeElement instanceof HTMLInputElement)
			return;
		if (document.activeElement instanceof HTMLTextAreaElement)
			return;
		if (document.activeElement.getAttribute('contenteditable') === 'true')
			return;
		// generate the meta key bit flag
		const metaKey = this._metaKey(event);
		// Get the hotkeys that use the meta key combination
		const metaHandlers = this._handlers.get(metaKey);
		// If there are no hotkeys in this meta-group, return
		if (!metaHandlers || metaHandlers.size == 0)
			return;
		// Get the event handlers for the given key press
		const eventHandlers = metaHandlers.get(event.code);
		// If there are no handlers for this key, return
		if (!eventHandlers || eventHandlers.length == 0)
			return;
		// Prevent propagation of the event to other handlers
		event.preventDefault();
		// Make a note that this key has been processed
		this._handled.add(event.code);
		// Notify the event handlers of the key press
		for (let handler of eventHandlers) {
			if (!handler.onKeyDown)
				continue;
			if (event.repeat && !handler.repeat)
				continue;
			handler.onKeyDown(handler, event, event.repeat);
		}
	}
	static _handleKeyUp(event) {
		// If we don't have a Down event for this key, ignore it
		if (!this._handled.has(event.code))
			return;
		// Remove the down event from the handled list
		this._handled.delete(event.code);
		// generate the meta key bit flag
		const metaKey = this._metaKey(event);
		// Get the hotkeys that use the meta key combination
		const metaHandlers = this._handlers.get(metaKey);
		// If there are no hotkeys in this meta-group, return
		if (!metaHandlers || metaHandlers.size == 0)
			return;
		// Get the event handlers for the given key release
		const eventHandlers = metaHandlers.get(event.code);
		// If there are no handlers for this key, return
		if (!eventHandlers || eventHandlers.length == 0)
			return;
		// Prevent propagation of the event to other handlers
		event.preventDefault();
		// Make a note that this key has been processed
		this._handled.add(event.code);
		// Notify the event handlers of the key release
		for (let handler of eventHandlers) {
			if (!handler.onKeyUp)
				continue;
			handler.onKeyUp(handler, event);
		}
	}
	static _init() {
		window.addEventListener("keydown", this._handleKeyDown.bind(this));
		window.addEventListener("keyup", this._handleKeyUp.bind(this));
		this._settings.set(Hotkeys.GENERAL, {
			name: Hotkeys.GENERAL,
			label: 'DF_HOTKEYS.GeneralGroup_Label',
			description: '',
			items: []
		});
	}
	static _getOrDefault(map, key, defValue) {
		if (map.has(key))
			return map.get(key);
		map.set(key, defValue());
		return map.get(key);
	}
	/**
	* Registers a new hotkey configuration.
	* @param config Hotkey configuration.
	* @param throwOnFail	If true, will throw an error if a config with that name already exists, or
	*						an explicit group was given but does not exist; default true.
	* @throws Error if the hotkey already exists, or the config is malformed.
	* @returns The ID for the registration, used for De-Registration, or null if it failed to be registered.
	*/
	static registerShortcut(config, throwOnFail = true) {
		const errors = [];
		// Validate our data structure
		if (typeof (config.name) !== 'string' && !(config.name instanceof String))
			errors.push('Hotkeys.registerShortcut(): config.name must be a string!');
		if (typeof (config.label) !== 'string' && !(config.label instanceof String))
			errors.push('Hotkeys.registerShortcut(): config.label must be a string!');
		if (config.group !== undefined && config.group !== null && typeof (config.group) !== 'string' && !(config.group instanceof String))
			errors.push('Hotkeys.registerShortcut(): config.group must be null, undefined, or a string!');
		if (!!config.get && !(config.get instanceof Function))
			errors.push('Hotkeys.registerShortcut(): config.get must be a Function!');
		if (!!config.set && !(config.set instanceof Function))
			errors.push('Hotkeys.registerShortcut(): config.set must be a Function!');
		if (!config.set !== !config.get)
			errors.push('Hotkeys.registerShortcut(): If either `get` or `set` is defined, both must be defined!');
		if (!(config.default instanceof Function) && (config.default.key === undefined || config.default.alt === undefined || config.default.ctrl === undefined || config.default.shift === undefined))
			errors.push('Hotkeys.registerShortcut(): config.default must be either a Function or a KeyMap!');
		if (!!config.handle && !(config.handle instanceof Function))
			errors.push('Hotkeys.registerShortcut(): DEPRECATED! config.handle must be a Function!');
		if (!!config.onKeyDown && !(config.onKeyDown instanceof Function))
			errors.push('Hotkeys.registerShortcut(): config.onKeyDown must be a Function!');
		if (!!config.onKeyUp && !(config.onKeyUp instanceof Function))
			errors.push('Hotkeys.registerShortcut(): config.onKeyUp must be a Function!');
		if (this._settingsNames.has(config.name))
			errors.push(`Hotkeys.registerShortcut(): '${config.name}' hotkey has already been registered!`);
		// If there were errors report them
		if (errors.length > 0) {
			if (throwOnFail)
				throw Error(errors.join(',\n'));
			printErrors(errors);
			return false;
		}
		// Post a warning in the console that the `handle` function is deprecated
		if (!!config.handle) {
			console.warn(`Hotkeys: The configuration "${config.name}" is using the deprecated 'handle()' function. Please use 'onKeyDown' and/or 'onKeyUp' instead.\nThis function will still work for now, but will be removed in a later update.`);
		}
		// If there is no `get` function defined, host the hotkey setting
		if (!config.get) {
			// Register a setting for the hotkey
			SETTINGS.register('KEYMAP.' + config.name, {
				scope: 'world',
				config: false,
				type: SETTINGS.typeOf(),
				default: config.default instanceof Function ? config.default() : config.default
			});
			// Bind the `get` and `set` to the new setting
			config.get = () => SETTINGS.get('KEYMAP.' + config.name);
			config.set = value => SETTINGS.set('KEYMAP.' + config.name, value);
		}
		// Add the new configuration name to the Quick Lookup Table
		this._settingsNames.add(config.name);
		// If there is no group defined, add it to the general group
		if (!config.group)
			config.group = Hotkeys.GENERAL;
		// Otherwise, if a custom group is added, verify that it exists
		else if (!this._settings.has(config.group)) {
			if (throwOnFail)
				throw Error(`Hotkeys.registerShortcut(): '${config.group}' group does not exist. Please make sure you call Hotkeys.registerGroup() before adding hotkeys for a custom group.`);
			else
				return false;
		}
		// Add the configuration to the assigned group
		this._settings.get(config.group).items.push(config);
		// Add the configuration to the event handlers registry
		const keyMap = config.get();
		const metaKey = (keyMap.alt ? 0x1 : 0) | (keyMap.ctrl ? 0x2 : 0) | (keyMap.shift ? 0x4 : 0);
		const metaHandlers = this._getOrDefault(this._handlers, metaKey, () => new Map());
		const eventHandlers = this._getOrDefault(metaHandlers, keyMap.key, () => []);
		eventHandlers.push(config);
		return true;
	}
	/**
	* De-registers the keyboard shortcut previously registered via the ID number returned by the `Hotkeys.registerShortcut` function.
	* @param id ID of the Hotkey to be de-registered.
	* @returns true if a handler was found and removed; false if no handler was found for the given key.
	*/
	static deregisterShortcut(name) {
		var found = false;
		// Remove the configuration from the groups
		for (let group of this._settings.values()) {
			const idx = group.items.findIndex(x => x.name === name);
			if (idx < 0)
				continue;
			group.items.splice(idx, 1);
			found = true;
			break;
		}
		// If a config with the given name could not be found in the groups, return failure
		if (!found)
			return false;
		// Remove the configuration from the Meta Key list
		for (let meta of this._handlers.values()) {
			for (let handlers of meta.values()) {
				const idx = handlers.findIndex(x => x.name === name);
				if (idx < 0)
					continue;
				handlers.splice(idx, 1);
			}
		}
		// Return success
		return true;
	}
	/**
	* Registers a new Settings Group for hotkeys.
	* @param group Group settings, requiring the name and label. Description is optional.
	* @param throwOnFail If true, will throw an error if a group already exists for the given name; default true.
	* @throws Error if the group already exists, or the config is malformed.
	* @returns true if the group has been registered; otherwise false if the group already exists.
	*/
	static registerGroup(group, throwOnFail = true) {
		var _a;
		// Validate HotkeyGroup data structure
		const errors = [];
		if (typeof (group.name) !== 'string' && !(group.name instanceof String))
			errors.push('Hotkeys.registerGroup(): group.name must be a string!');
		if (typeof (group.label) !== 'string' && !(group.label instanceof String))
			errors.push('Hotkeys.registerGroup(): group.label must be a string!');
		if (group.description !== undefined && group.description !== null && typeof (group.description) !== 'string' && !(group.description instanceof String))
			errors.push('Hotkeys.registerGroup(): group.description must be null, undefined, or a string!');
		if (this._settings.has(group.name))
			errors.push(`Hotkeys.registerGroup(): '${group.name}' group has already been registered!`);
		// If there were errors report them
		if (errors.length > 0) {
			if (throwOnFail)
				throw Error(errors.join(',\n'));
			printErrors(errors);
			return false;
		}
		// Register the new group
		this._settings.set(group.name, {
			name: group.name,
			label: group.label,
			description: (_a = group.description) !== null && _a !== void 0 ? _a : '',
			items: []
		});
		return true;
	}
}
Hotkeys.GENERAL = 'general';
Hotkeys._handlers = new Map();
Hotkeys._handled = new Set();
Hotkeys._settings = new Map();
Hotkeys._settingsNames = new Set();
Hotkeys.keys = new Keys();

let hotkeys = undefined;
Hooks.once('init', function () {
	// If the Hotkeys library is present and activated
	// @ts-expect-error
	if (window.Hotkeys) {
		// Just grab a reference to the global Hotkeys library and return
		hotkeys =
			// @ts-expect-error
			window.Hotkeys;
		return;
	}
	// There is no global definition of the Hotkeys Library
	// Generate the Shim and initialize it
	SETTINGS.init('lib-df-hotkeys');
	hotkeys = Hotkeys;
	// @ts-expect-error
	hotkeys._init();
});

export { hotkeys };
